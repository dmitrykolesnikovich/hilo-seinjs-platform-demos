(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["seinjs"],{

/***/ "./node_modules/_seinjs@1.5.10@seinjs/lib/seinjs.js":
/*!**********************************************************!*\
  !*** ./node_modules/_seinjs@1.5.10@seinjs/lib/seinjs.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {/*! 
 * @license Sein.js v1.5.10
 * Copyright (c) 2018-present SeinJS Group.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


Object.defineProperty(exports, '__esModule', { value: true });

/**
 * @hidden
 */
(function (ESpace) {
    ESpace[ESpace["BONE"] = 0] = "BONE";
    ESpace[ESpace["LOCAL"] = 1] = "LOCAL";
    ESpace[ESpace["WORLD"] = 2] = "WORLD";
    ESpace[ESpace["VIEW"] = 3] = "VIEW";
    ESpace[ESpace["NDC"] = 4] = "NDC";
    ESpace[ESpace["SCREEN"] = 5] = "SCREEN";
})(exports.ESpace || (exports.ESpace = {}));

/**
 * 支持的碰撞体类型枚举。
 */
(function (EColliderType) {
    /**
     * 没有碰撞体。
     */
    EColliderType[EColliderType["Null"] = 0] = "Null";
    /**
     * 球碰撞体。
     */
    EColliderType[EColliderType["Sphere"] = 1] = "Sphere";
    /**
     * 盒碰撞体。
     */
    EColliderType[EColliderType["Box"] = 2] = "Box";
    /**
     * 平面碰撞体。
     */
    EColliderType[EColliderType["Plane"] = 3] = "Plane";
    /**
     * 柱状碰撞体。
     */
    EColliderType[EColliderType["Cylinder"] = 4] = "Cylinder";
    // todo: support terrain
    // Terrain = 5,
    // Particle = 6,
    // Mesh = 7
})(exports.EColliderType || (exports.EColliderType = {}));
(function (ERigidBodyType) {
    /**
     * 动态的，等同于`physicStatic = false`。
     */
    ERigidBodyType[ERigidBodyType["Dynamic"] = 1] = "Dynamic";
    /**
     * 静态的，等同于`physicStatic = true`。
     */
    ERigidBodyType[ERigidBodyType["Static"] = 2] = "Static";
})(exports.ERigidBodyType || (exports.ERigidBodyType = {}));
(function (EJointType) {
    /**
     * 点对点约束。
     */
    EJointType[EJointType["PointToPoint"] = 0] = "PointToPoint";
    /**
     * 铰链约束。
     */
    EJointType[EJointType["Hinge"] = 1] = "Hinge";
    /**
     * 距离约束。
     */
    EJointType[EJointType["Distance"] = 2] = "Distance";
    /**
     * 弹簧约束。
     */
    EJointType[EJointType["Spring"] = 3] = "Spring";
    /**
     * 锁定约束。
     */
    EJointType[EJointType["Lock"] = 4] = "Lock";
})(exports.EJointType || (exports.EJointType = {}));
(function (EPickMode) {
    /**
     * 只拾取距离摄像机最近的刚体，性能最佳。
     *
     * @deprecated
     */
    EPickMode[EPickMode["CLOSEST"] = 1] = "CLOSEST";
    /**
     * 只拾取距离摄像机最近的刚体，性能最佳。
     */
    EPickMode[EPickMode["Closest"] = 1] = "Closest";
    /**
     * 拾取任意的刚体。
     */
    EPickMode[EPickMode["Any"] = 2] = "Any";
    /**
     * 拾取所有的刚体。
     */
    EPickMode[EPickMode["All"] = 4] = "All";
})(exports.EPickMode || (exports.EPickMode = {}));

/**
 * **GlTFLoader的扩展相关，不要自己使用。**
 *
 * @hidden
 */
(function (ESeinNodeType) {
    ESeinNodeType[ESeinNodeType["Component"] = 1] = "Component";
    ESeinNodeType[ESeinNodeType["Actor"] = 2] = "Actor";
})(exports.ESeinNodeType || (exports.ESeinNodeType = {}));

/**
 * @File   : SName.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 2018/10/8 上午11:13:40
 * @Description:
 */
/**
 * 判断一个实例是否为`isSName`。
 */
function isSName(value) {
    return value.isSName;
}
/**
 * 一个字符串池，用于构建名字，后续可以快速拿来进行对比。
 */
var SName = /** @class */ (function () {
    /**
     * 通过字符串创建一个实例。
     */
    function SName(name) {
        this.isSName = true;
        this._value = '';
        this._index = 0;
        this._value = name;
        if (!SName.TABLE[name]) {
            SName.INDEX += 1;
            SName.TABLE[name] = SName.INDEX;
        }
        this._index = SName.TABLE[name];
    }
    Object.defineProperty(SName.prototype, "value", {
        /**
         * 获取实例的字符串值。
         */
        get: function () {
            return this._value;
        },
        enumerable: false,
        configurable: true
    });
    SName.prototype.equalsTo = function (name) {
        if (isSName(name)) {
            return this._index === name._index;
        }
        if (!SName.TABLE[name]) {
            return false;
        }
        return SName.TABLE[name] === this._index;
    };
    /**
     * @hidden
     */
    SName.prototype.toString = function () {
        return this._value;
    };
    SName.INDEX = 0;
    SName.TABLE = {};
    return SName;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/**
 * @File   : index.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 10/24/2018, 4:04:57 PM
 * @Description:
 */
/**
 * 当前环境，一般为`development`或`production`。
 */
var env = 'production';
if (typeof process !== 'undefined') {
    env = "development";
}
/**
 * 是否是开发模式。
 */
var devMode = env !== 'production';
/**
 * 调试用，仅在开发环境会做出的警告。
 */
function warn() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (devMode) {
        console.warn.apply(console, args);
    }
}
/**
 * 调试用，将一个Canvas渲染到控制台。
 */
function logCanvas(canvas, width) {
    var height = width * canvas.height / canvas.width;
    var url = canvas.toDataURL();
    /*tslint:disable-next-line */
    console.log('%c+', "font-size: 1px; padding: " + height / 2 + "px " + width / 2 + "px; line-height: " + height + "px; background: url(" + url + "); background-size: " + width + "px " + height + "px; background-repeat: no-repeat; color: transparent;");
}
var Debug = { devMode: devMode, warn: warn, logCanvas: logCanvas, env: env };

/**
 * 判断一个实例是否为`BaseException`。
 */
function isBaseException(value) {
    return value.isBaseException;
}
/**
 * Sein中的异常基类，用于封装特定异常，同时也作为异常边界系统的基础。
 *
 * @noInheritDoc
 */
var BaseException = /** @class */ (function (_super) {
    __extends(BaseException, _super);
    /**
     * 构建异常。
     *
     * @param object 触发异常的实例。
     * @param message 追加信息。
     */
    function BaseException(name, object, message) {
        if (message === void 0) { message = ''; }
        var _this = _super.call(this, message) || this;
        _this.isBaseException = true;
        /**
         * 异常涉及到的SObject堆栈，生产环境无效。
         *
         * @hidden
         */
        _this.objectStack = [];
        _this.__proto__ = BaseException.prototype;
        _this.name = name;
        _this.object = object;
        _this.type = new SName(_this.name || 'Unknown');
        if (Debug.devMode) {
            _this.objectStack = _this.initObjectStack();
        }
        return _this;
    }
    /**
     * 从一个普通错误转换为异常。
     */
    BaseException.FROM_NATIVE_JS_ERROR = function (error, object) {
        var err = new BaseException(error.name, object, error.message);
        err.stack = error.stack;
        return err;
    };
    /**
     * 手动获取错误对象栈，在错误上报时可能有用。
     */
    BaseException.prototype.initObjectStack = function () {
        var currentObj = this.object;
        var stack = [];
        while (currentObj) {
            stack.push(currentObj.constructor.CLASS_NAME.value + "(" + currentObj.name.value + ")");
            currentObj = currentObj.parent;
        }
        return stack;
    };
    return BaseException;
}(Error));

/**
 * @File   : throwException.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 10/17/2018, 5:24:42 PM
 * @Description:
 */
function isBaseException$1(error) {
    return error.isBaseException;
}
function isFunction(value) {
    return !!value.call;
}
/**
 * 抛出异常函数。作为错误边界系统最重要的方法，此函数允许你抛出异常或错误，并给出错误对象的栈，进行错误边界处理。
 * 详见[Exception](../guide/exception)。
 *
 * @param error 异常实例。
 * @param errorObject 触发异常的实例。
 * @param errorDetails 异常的细节。
 * @noInheritDoc
 */
function throwException(error, errorObject, errorDetails) {
    if (errorDetails === void 0) { errorDetails = null; }
    var err = error;
    if (!isBaseException$1(error)) {
        err = BaseException.FROM_NATIVE_JS_ERROR(error, errorObject);
    }
    if (Debug.devMode) {
        console.error(err);
        /* tslint:disable-next-line */
        console.log("%cStack: " + err.objectStack.join(' -> '), 'color: #ff0000; background: rgba(255, 0, 0, .1); padding: 16px');
    }
    var currentObj = errorObject;
    while (currentObj) {
        if (currentObj.onError && isFunction(currentObj.onError)) {
            if (currentObj.onError(err, errorDetails) === true) {
                return;
            }
        }
        currentObj = currentObj.parent;
    }
    throw err;
}

/**
 * @File   : SObject.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 2018/9/25 下午5:22:43
 * @Description:
 */
/**
 * 判断一个实例是否为`SObject`。
 */
function isSObject(value) {
    return value.isSObject;
}
/**
 * Sein.js的基础类，除了单纯存在于渲染引擎的实例，比如材质、几何体等，所有类都继承自`SObject`。
 * 此基类提供了基础的`uuid`计算、序列化与反序列化等标注接口。
 */
var SObject = /** @class */ (function () {
    function SObject(name) {
        if (name === void 0) { name = ''; }
        // for serialize and deserialize
        // user can not modify
        // public _serializableMembers: (keyof IStateTypes)[] = [];
        /**
         * 一个实例是否为SObject的判据。
         */
        this.isSObject = true;
        /**
         * 预留给编辑器（有的话）。
         *
         * @hidden
         */
        this.editable = true;
        SObject.UUID += 1;
        this._uuid = SObject.UUID;
        this.name = new SName(name || this.constructor.CLASS_NAME.value + "-" + this._uuid);
    }
    Object.defineProperty(SObject.prototype, "uuid", {
        /**
         * 所有继承自`SObject`的类的实例的唯一ID。
         */
        get: function () {
            return this._uuid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SObject.prototype, "className", {
        /**
         * 实例的类名，代理到类的静态属性`CLASS_NAME`。
         */
        get: function () {
            return this.constructor.CLASS_NAME;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SObject.prototype, "classType", {
        /**
         * 实例的类型，代理到类的静态属性`CLASS_NAME`。
         * 预留，暂时没啥用。
         */
        get: function () {
            return this.constructor.CLASS_TYPE;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 通过字符串修改实例名字。
     */
    SObject.prototype.rename = function (name) {
        this.name = new SName(name);
    };
    /**
     * 克隆一个实例，交由子类实现。
     */
    SObject.prototype.clone = function (object) {
        throw new Error('Not implement.');
    };
    /**
     * 实例序列化，交由子类实现。
     *
     * @todo: 暂未实现，预留。
     */
    SObject.prototype.serialize = function () {
        throw new Error('Not implement.');
    };
    /**
     * 从一个json序列反序列化，交由子类实现。
     *
     * @todo: 暂未实现，预留。
     */
    SObject.prototype.deserialize = function (json) {
        throw new Error('Not implement.');
    };
    /**
     * 生命周期之一，会在实例将要销毁时被触发。
     */
    SObject.prototype.onDestroy = function () {
    };
    /**
     * @hidden
     */
    SObject.prototype.destroy = function () {
        try {
            this.onDestroy();
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * 实例的类名，用于反射，在类被实例化后有`object.className`作为代理。
     */
    SObject.CLASS_NAME = new SName('SObject');
    /**
     * 实例的类型用于反射，在类被实例化后有`object.classType`作为代理。
     * 预留，暂时没用。
     */
    SObject.CLASS_TYPE = new SName('SObject');
    /**
     * 存储着所有监视器装饰器`SInspect`的类与属性表。配合`inspectable`装饰器使用。
     *
     * 每一个属性有`type`确定检视类型，不传则按照实际数据类型自动反射。
     * 而`options`则是一个在特定`type`下一个的参数。
     *
     * 注意引擎本身不会对这个元信息做任何操作，只有引入了`seinjs-inspector`才会有效。
     */
    SObject.INSPECTABLE_PROPERTIES = {};
    SObject.UUID = 0;
    return SObject;
}());

/**
 * 全局单例，存储着所有`SClass`的键(`className`)和类的对应表。
 */
var MetaSClasses = {};
/**
 * 全局单例，存储着所有`SMaterial`的键(`className`)和类的对应表。
 */
var MetaSMaterials = {};

/* tslint:disable */
/**
 * 装饰器，用于指定一个继承自`SObject`的类的类名和类型，并将其添加到全局的元信息中。
 */
function SClass(options) {
    return function Decorator(constructor) {
        var Class = constructor;
        Class.CLASS_NAME = new SName(options.className);
        if (options.classType) {
            Class.CLASS_TYPE = new SName(options.classType);
        }
        return MetaSClasses[options.className] = Class;
    };
}
/**
 * 装饰器，用于指定一个继承自`RawShaderMaterial`的类的类名，并将其添加到全局的元信息中。
 */
function SMaterial(options) {
    return function Decorator(constructor) {
        constructor.CLASS_NAME = new SName(options.className);
        MetaSMaterials[options.className] = constructor;
        return constructor;
    };
}
/* tslint:enable */
/**
 * @hidden
 */
function serialize(target, key) {
    // target._serializableMembers[key] = true;
}
/**
 * @hidden
 */
function deprecated(target, key) {
}
/**
 * 装饰器，用于指定在`seinjs-inspector`中可检视的属性。
 *
 * @param type 检视属性的类型，若不指定则会根据类型自动判断。
 * @param options 检视属性的配置，用于比如`range`这种类型指定边界。
 */
function inspectable(type, options) {
    return function Decorator(target, key, descriptor) {
        var clz = target.constructor;
        if (!clz.CLASS_NAME) {
            Debug.warn("'inspectable' decorator must be applied to property in 'SObject' with 'SClass' decorator!");
            return;
        }
        var obj = clz.INSPECTABLE_PROPERTIES = clz.INSPECTABLE_PROPERTIES || {};
        obj[key] = {};
        if (type) {
            obj[key].type = type;
        }
        if (options) {
            obj[key].options = options;
        }
        if (descriptor && !descriptor.writable) {
            obj[key].readonly = true;
        }
    };
}

/**
 * 判断一个实例是否为`Observable`。
 */
function isObservable(value) {
    return value.isObservable;
}
/**
 * 可观察对象，事件机制的底层基础，维护一个观察回调队列。
 *
 * @template 队列中回调的参数类型。
 */
var Observable = /** @class */ (function (_super) {
    __extends(Observable, _super);
    /**
     * @param parent 可选，用于构造异常链。
     * @param name 可选，用于指定名字。
     */
    function Observable(parent, name) {
        var _this = _super.call(this, name) || this;
        _this.isObservable = true;
        /**
         * 当队列从非空变为空时将会被触发的回调。
         */
        _this.onEmpty = function () { };
        /**
         * 父级SObject实例。
         */
        _this.parent = null;
        _this._index = 0;
        _this._length = 0;
        _this._queue = [];
        _this.parent = parent;
        return _this;
    }
    Object.defineProperty(Observable.prototype, "count", {
        /**
         * 拥有的监听者数量。
         */
        get: function () {
            return this._queue.length;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 添加一个回调到队列中。
     */
    Observable.prototype.add = function (callback, priority) {
        if (priority !== undefined) {
            this._queue.splice(priority, 0, { callback: callback, isOnce: false });
        }
        else {
            this._queue.push({ callback: callback, isOnce: false });
        }
        return this;
    };
    /**
     * 添加一个回调到队列中，并再被触发执行一次后自动移除。
     */
    Observable.prototype.addOnce = function (callback, priority) {
        if (priority !== undefined) {
            this._queue.splice(priority, 0, { callback: callback, isOnce: true });
        }
        else {
            this._queue.push({ callback: callback, isOnce: true });
        }
        return this;
    };
    /**
     * 清空队列。
     */
    Observable.prototype.clear = function () {
        this._queue = [];
        this.onEmpty();
        return this;
    };
    /**
     * 从队列中移除一个回调。
     */
    Observable.prototype.remove = function (callback) {
        var length = this._queue.length;
        var index = -1;
        for (var i = 0; i < length; i += 1) {
            if (this._queue[i].callback === callback) {
                index = i;
            }
        }
        if (index < 0) {
            return;
        }
        this._queue.splice(index, 1);
        // Guard: If remove a handler while notify
        this._index -= 1;
        this._length -= 1;
        if (length === 1) {
            this.onEmpty();
        }
        return this;
    };
    /**
     * 通过一个参数触发一次广播，调用所有回调。
     */
    Observable.prototype.notify = function (params) {
        this._index = 0;
        this._length = this._queue.length;
        while (this._index < this._length) {
            var _a = this._queue[this._index], callback = _a.callback, isOnce = _a.isOnce;
            if (isOnce) {
                this._queue.splice(this._index, 1);
                this._length -= 1;
            }
            else {
                this._index += 1;
            }
            try {
                if (callback(params) === true) {
                    return this;
                }
            }
            catch (error) {
                throwException(error, this);
            }
        }
        return this;
    };
    Observable = __decorate([
        SClass({ className: 'Observable' })
    ], Observable);
    return Observable;
}(SObject));

/**
 * 判断一个实例是否为`MissingMemberException`。
 */
function isMissingMemberException(value) {
    return value.isMissingMemberException;
}
/**
 * 成员缺失异常。
 *
 * @noInheritDoc
 */
var MissingMemberException = /** @class */ (function (_super) {
    __extends(MissingMemberException, _super);
    /**
     * 构建异常。
     *
     * @param parent 成员父级实例。
     * @param memberType 成员类型。
     * @param memberName 成员名称。
     * @param object 触发异常的实例。
     * @param message 追加信息。
     */
    function MissingMemberException(parent, memberType, memberName, object, message) {
        if (message === void 0) { message = ''; }
        var _this = _super.call(this, 'MissingMember', object, parent.className + " \"" + parent.name + "\" does not have " + memberType + " \"" + memberName + "\". " + message) || this;
        _this.isMissingMemberException = true;
        return _this;
    }
    return MissingMemberException;
}(BaseException));

/**
 * 判断一个实例是否为`EventManager`。
 */
function isEventManager(value) {
    return value.isEventManager;
}
/**
 * 事件管理器类。作为事件的集中管理容器，承担着引擎绝大多数部分的事件注册、分发。
 *
 * @template IDefaultEvents 用于标注所有事件的名称以及对应的事件参数类型。
 * @noInheritDoc
 */
var EventManager = /** @class */ (function (_super) {
    __extends(EventManager, _super);
    /**
     * @param objHasGame 拥有`getGame()`方法和`onError`方法的对象。
     */
    function EventManager(objHasGame) {
        if (objHasGame === void 0) { objHasGame = null; }
        var _this = _super.call(this, objHasGame.name.value) || this;
        _this.isEventManager = true;
        _this._observables = {};
        _this._triggers = {};
        _this._caches = {};
        _this._objHasGame = null;
        _this._objHasGame = objHasGame;
        return _this;
    }
    Object.defineProperty(EventManager.prototype, "parent", {
        /**
         * 获取自身的父级实例引用，一般不需要自己使用。
         */
        get: function () {
            return this._objHasGame;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    EventManager.prototype.getGame = function () {
        return this._objHasGame.getGame();
    };
    /**
     * 生命周期，用于错误边界处理。将在游戏中大部分可预知错误发生时被调用（通常是生命周期中的非异步错误）。
     * 错误将会根据一定的路径向上传递，一直到`Engine`的层次，你可以在确保完美处理了问题后返回`true`来通知引擎不再向上传递。
     * 当然你也可以将自定义的一些错误加入错误边界机制中，详见[Exception](../../guide/exception)。
     */
    EventManager.prototype.onError = function () {
    };
    EventManager.prototype.register = function (type, TriggerClass) {
        var _this = this;
        if (this._observables[type]) {
            Debug.warn("Event " + type + " is already registered, before re-register, please unregister it at first !");
            return this;
        }
        this._observables[type] = new Observable(this, type);
        this._observables[type].onEmpty = function () {
            if (_this._triggers[type] && !_this._triggers[type].paused) {
                _this._triggers[type].pause();
            }
        };
        if (TriggerClass) {
            this._triggers[type] = new TriggerClass(type, this, this.getGame());
        }
        return this;
    };
    EventManager.prototype.unregister = function (type) {
        if (!this._observables[type]) {
            return this;
        }
        delete this._observables[type];
        if (this._triggers[type]) {
            this._triggers[type].destroy();
            delete this._triggers[type];
        }
        return this;
    };
    EventManager.prototype.add = function (type, callback, priority) {
        if (!this._observables[type]) {
            this.register(type);
        }
        this._observables[type].add(callback, priority);
        if (this._triggers[type] && this._triggers[type].paused) {
            this._triggers[type].begin();
        }
        return this;
    };
    EventManager.prototype.addOnce = function (type, callback, priority) {
        if (!this._observables[type]) {
            this.register(type);
        }
        this._observables[type].addOnce(callback, priority);
        if (this._triggers[type] && this._triggers[type].paused) {
            this._triggers[type].begin();
        }
        return this;
    };
    EventManager.prototype.remove = function (type, callback) {
        if (!this._observables[type]) {
            return this;
        }
        this._observables[type].remove(callback);
        return this;
    };
    /**
     * 判断一个事件是否被注册。
     */
    EventManager.prototype.has = function (type) {
        return !!this._observables[type];
    };
    /**
     * 判断一个时间的监听者数量。
     */
    EventManager.prototype.getCount = function (type) {
        if (!this.has(type)) {
            return 0;
        }
        return this._observables[type].count;
    };
    EventManager.prototype.clear = function (type) {
        if (!this._observables[type]) {
            throwException(new MissingMemberException(this, 'Event', type, this), this);
        }
        this._observables[type].clear();
        return this;
    };
    EventManager.prototype.trigger = function (type, event, immediately) {
        if (immediately === void 0) { immediately = true; }
        if (!this._observables[type]) {
            throwException(new MissingMemberException(this, 'Event', type, this, 'Register it before trigger !'), this);
        }
        if (immediately || this.getGame().paused) {
            this._observables[type].notify(event);
            return this;
        }
        this._caches[type] = event;
        return this;
    };
    EventManager.prototype.flush = function (type) {
        if (!this._observables[type]) {
            throw new MissingMemberException(this, 'Event', type, this, 'Register it before flush !');
        }
        var event = this._caches[type];
        if (event) {
            delete this._caches[type];
            this._observables[type].notify(event);
        }
        return this;
    };
    /**
     * 分发所有缓存的事件，一般不需要自行触发。
     */
    EventManager.prototype.flushAll = function () {
        for (var type in this._caches) {
            this.flush(type);
        }
        return this;
    };
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    EventManager.prototype.onDestroy = function () {
        for (var type in this._triggers) {
            this._triggers[type].destroy();
        }
    };
    EventManager = __decorate([
        SClass({ className: 'EventManager', classType: 'EventManager' })
    ], EventManager);
    return EventManager;
}(SObject));

/**
 * 判断一个实例是否为`Component`。
 */
function isComponent(value) {
    return value.isComponent;
}
/**
 * 游戏实体的功能的最小抽象，是Actor实际功能的体现。
 *
 * @template IStateTypes 初始化参数类型，一般交由由继承的类定义实现多态。
 * @noInheritDoc
 */
var Component = /** @class */ (function (_super) {
    __extends(Component, _super);
    /**
     * 构造Component，**不可自行构造！！！**请参见`actor.addComponent`方法。
     */
    function Component(name, actor, initState) {
        var _this = _super.call(this, name) || this;
        _this.isComponent = true;
        /**
         * 自身是否为根组件。
         */
        _this.isRoot = false;
        /**
         * Component是否需要在每一帧进行进行`update`调用，如果为`false`，则将不会触发`onUpdate`生命周期（包括挂载在其下的所有Component）。
         * 用于性能优化。
         */
        _this.updateOnEverTick = true;
        /**
         * 是否要将自身加入其挂载的Actor的更新队列中，同时决定自身是否要跟随Actor销毁。
         * 如果为`false`，则说明此Component是一个纯静态组件（比如单纯的图元组件，没有逻辑）。
         * 用于性能优化。
         */
        _this.needUpdateAndDestroy = true;
        /**
         * 是否允许自身在运行时被动态移除，用于保护某些特殊Component，比如根组件默认不可移除。
         */
        _this.canBeRemoved = true;
        _this._owner = null;
        _this._event = null;
        _this._initState = initState || {};
        _this._owner = actor;
        _this._event = new EventManager(_this);
        return _this;
    }
    Object.defineProperty(Component.prototype, "parent", {
        /**
         * 获取自身的父级实例，根据情况不同可能有不同的类型，一般不需要自己使用。
         */
        get: function () {
            return this._owner;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "event", {
        /**
         * 获取自身的事件系统管理器。
         */
        get: function () {
            return this._event;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 用于验证一个该组件在当前状态是否可被添加，一般用于防止重复添加不可重复的组件。
     * 你可以重写此方法来达成验证，如果验证不通过请抛出异常。
     * 注意，此验证仅会在`development`环境下被执行！
     */
    Component.prototype.verifyAdding = function (initState) { };
    /**
     * 用于验证一个该组件在当前状态是否可被移除。
     * 你可以重写此方法来达成验证，如果验证不通过请抛出异常。
     * 注意，此验证仅会在`development`环境下被执行！
     */
    Component.prototype.verifyRemoving = function () { };
    /**
     * 生命周期，将在Component被创建后调用。
     */
    Component.prototype.onInit = function (initState) {
    };
    /**
     * 生命周期，将在加入了Actor并且父级Actor被正式添加到了游戏中后调用。
     */
    Component.prototype.onAdd = function (initState) {
    };
    /**
     * 生命周期，将在正式加入游戏后，并且`updateOnEverTick`与`needUpdateAndDestroy`均为`true`时在每一帧被调用。
     */
    Component.prototype.onUpdate = function (delta) {
    };
    /**
     * 生命周期，用于错误边界处理。将在游戏中大部分可预知错误发生时被调用（通常是生命周期中的非异步错误）。
     * 错误将会根据一定的路径向上传递，一直到`Engine`的层次，你可以在确保完美处理了问题后返回`true`来通知引擎不再向上传递。
     * 当然你也可以将自定义的一些错误加入错误边界机制中，详见[Exception](../../guide/exception)。
     */
    Component.prototype.onError = function (error, details) {
    };
    /**
     * 当父级Actor被`unLink`时触发，详见[actor.unLink](../classes/actor#unlink).
     */
    Component.prototype.onUnLink = function () {
    };
    /**
     * 当父级Actor被`reLink`时触发，详见[actor.reLink](../classes/actor#relink).
     */
    Component.prototype.onReLink = function () {
    };
    /**
     * 生命周期，将在Component被销毁时触发。
     */
    Component.prototype.onDestroy = function () {
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Component.prototype.initialized = function () {
        try {
            this.onInit(this._initState);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Component.prototype.added = function () {
        try {
            this.onAdd(this._initState);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Component.prototype.update = function (delta) {
        if (!this.updateOnEverTick || !this.parent) {
            return;
        }
        try {
            this.onUpdate(delta);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Component.prototype.unLink = function () {
        try {
            this.onUnLink();
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Component.prototype.reLink = function () {
        try {
            this.onReLink();
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Component.prototype.destroy = function () {
        if (!this._owner) {
            return;
        }
        this._event.destroy();
        _super.prototype.destroy.call(this);
        this._owner = null;
    };
    /**
     * 获取当前`Game`实例。
     *
     * @template IGameState 当前游戏状态管理器的类型。
     */
    Component.prototype.getGame = function () {
        return this._owner.getGame();
    };
    /**
     * 获取当前`World`实例。
     *
     * @template IWorldState 当前世界状态管理器的类型。
     */
    Component.prototype.getWorld = function () {
        return this._owner.getWorld();
    };
    /**
     * 获取当前`Level`实例。
     *
     * @template ILevelState 当前关卡状态管理器的类型。
     */
    Component.prototype.getLevel = function () {
        return this._owner.getLevel();
    };
    /**
     * 仅在初始化了物理引擎之后，用于获取当前物理世界`PhysicWorld`实例。
     * 如何使用物理引擎请见**Guide**和**Demo**。
     */
    Component.prototype.getPhysicWorld = function () {
        return this._owner.getPhysicWorld();
    };
    /**
     * 获取当前拥有自己的`Actor`。
     *
     * @template TOwner Actor的类型。
     */
    Component.prototype.getOwner = function () {
        return this._owner;
    };
    /**
     * 获取当前拥有自己的`Actor`的根组件。
     *
     * @template TRoot 根组件的类型。
     */
    Component.prototype.getRoot = function () {
        return this._owner.root;
    };
    /**
     * 将自己从父级移除，基本等同于`destroy`方法，从Owner中销毁自身。
     */
    Component.prototype.removeFromParent = function () {
        this._owner.removeComponent(this);
    };
    Component = __decorate([
        SClass({ className: 'Component', classType: 'Component' })
    ], Component);
    return Component;
}(SObject));

function isT(item) {
    return item.isSObject;
}
/**
 * 可迭代对象基类，Sein.js封装的用于存储`SObject`实例的特殊容器。
 * 一般使用此基类的子类，不直接使用自身。
 *
 * @template T 存储的实例的类型。
 */
var SIterable = /** @class */ (function () {
    function SIterable() {
        this._array = [];
    }
    Object.defineProperty(SIterable.prototype, "length", {
        /**
         * 存储实例的个数。
         */
        get: function () {
            return this._array.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SIterable.prototype, "empty", {
        /**
         * 是否为空。
         */
        get: function () {
            return this._array.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 从一个基本的数组实例初始化SIterable。
     */
    SIterable.prototype.fromArray = function (array) {
        throw new Error('Not implemented');
    };
    /**
     * 对存储的所有实例进行迭代。
     * 通过回调的返回值设`true`，你可以终止迭代，这用于性能优化。
     */
    SIterable.prototype.forEach = function (func) {
        var length = this.length;
        for (var index = 0; index < length; index += 1) {
            if (func(this._array[index])) {
                return this;
            }
        }
        return this;
    };
    /**
     * 清空所有存储的实例。
     */
    SIterable.prototype.clear = function () {
        this._array = [];
        return this;
    };
    SIterable.prototype.addItem = function (item) {
        this._array.push(item);
    };
    SIterable.prototype.removeItem = function (item) {
        var index;
        if (isT(item)) {
            index = this._array.indexOf(item);
            if (index < 0) {
                return;
            }
        }
        else {
            index = item;
            item = this._array[index];
            if (!item) {
                return;
            }
        }
        this._array.splice(index, 1);
    };
    /**
     * 根据类来查找第一个实例。
     */
    SIterable.prototype.findByClass = function (Class) {
        return this.findByFilter(function (item) { return item.className.equalsTo(Class.CLASS_NAME); });
    };
    /**
     * 根据类来查找所有实例。
     *
     * @param stopFinding 通过当前实例判断是否要继续搜索，返回`true`则停止搜索，用于性能优化。
     */
    SIterable.prototype.findAllByClass = function (Class, stopFinding) {
        return this.findAllByFilter(function (item) { return item.className.equalsTo(Class.CLASS_NAME); }, stopFinding);
    };
    /**
     * 根据类型来查找第一个实例。
     */
    SIterable.prototype.findByClassType = function (classType) {
        return this.findByFilter(function (item) { return item.classType.equalsTo(classType); });
    };
    /**
     * 根据类型来查找所有实例。
     *
     * @param stopFinding 通过当前实例判断是否要继续搜索，返回`true`则停止搜索，用于性能优化。
     */
    SIterable.prototype.findAllByClassType = function (classType, stopFinding) {
        return this.findAllByFilter(function (item) { return item.classType.equalsTo(classType); }, stopFinding);
    };
    /**
     * 通过名字查找第一个实例。
     */
    SIterable.prototype.findByName = function (name) {
        return this.findByFilter(function (item) { return item.name.equalsTo(name); });
    };
    /**
     * 通过名字查找所有实例。
     *
     * @param stopFinding 通过当前实例判断是否要继续搜索，返回`true`则停止搜索，用于性能优化。
     */
    SIterable.prototype.findAllByName = function (name, stopFinding) {
        return this.findAllByFilter(function (item) { return item.name.equalsTo(name); }, stopFinding);
    };
    /**
     * 根据给定的filter函数来查找第一个实例。
     */
    SIterable.prototype.findByFilter = function (filter) {
        var element = null;
        this.forEach(function (ele) {
            if (filter(ele)) {
                element = ele;
                return true;
            }
        });
        return element;
    };
    /**
     * 根据给定的filter函数来查找所有实例。
     *
     * @param stopFinding 通过当前实例判断是否要继续搜索，返回`true`则停止搜索，用于性能优化。
     */
    SIterable.prototype.findAllByFilter = function (filter, stopFinding) {
        var result = [];
        this.forEach(function (ele) {
            if (filter(ele)) {
                result.push(ele);
                if (stopFinding && stopFinding(ele, result)) {
                    return true;
                }
            }
        });
        return result;
    };
    /**
     * 序列化，尚未实现。
     *
     * @hidden
     */
    SIterable.prototype.serialize = function () {
        throw new Error('Not implemented');
    };
    /**
     * 反序列化，尚未实现。
     *
     * @hidden
     */
    SIterable.prototype.deserialize = function (json) {
        throw new Error('Not implemented');
    };
    return SIterable;
}());

/**
 * Sein.js封装的用于存储`SObject`实例的特殊数组容器。
 *
 * @template T 存储的实例的类型。
 */
var SArray = /** @class */ (function (_super) {
    __extends(SArray, _super);
    function SArray() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(SArray.prototype, "array", {
        /**
         * 原始基础数组。
         */
        get: function () {
            return this._array;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 添加一个实例到容器中。
     */
    SArray.prototype.add = function (item) {
        this.addItem(item);
        return this;
    };
    /**
     * 从容器中移除一个实例。
     */
    SArray.prototype.remove = function (item) {
        this.removeItem(item);
        return this;
    };
    /**
     * 修改`index`索引处的实例。
     */
    SArray.prototype.set = function (index, value) {
        this._array[index] = value;
        return this;
    };
    /**
     * 在`index`索引处后方插入一个实例。
     */
    SArray.prototype.insert = function (index, value) {
        this._array.splice(index, 0, value);
        return this;
    };
    /**
     * 获取`index`索引处的实例引用。
     */
    SArray.prototype.get = function (index) {
        return this._array[index];
    };
    /**
     * 释放容器队列中的最后一个实例。
     */
    SArray.prototype.pop = function () {
        var length = this.length;
        var item = this._array[length];
        this.removeItem(length);
        return item;
    };
    /**
     * 查找实例在容器中的索引。
     */
    SArray.prototype.indexOf = function (item) {
        return this._array.indexOf(item);
    };
    /**
     * 合并当前和另一个容器。
     */
    SArray.prototype.merge = function (array) {
        Array.prototype.push.apply(this._array, array._array);
        return this;
    };
    /**
     * 从另一个容器复制数据。
     */
    SArray.prototype.copy = function (array) {
        this._array = array.array.slice();
        return this;
    };
    /**
     * 从一个基本的数组实例初始化SIterable。
     */
    SArray.prototype.fromArray = function (array) {
        this._array = array.slice();
        return this;
    };
    return SArray;
}(SIterable));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var Hilo3d = createCommonjsModule(function (module, exports) {
/*!
 * Hilo3d 1.15.2
 * Copyright (c) 2017-present Alibaba Group Holding Ltd.
 * @license MIT
 */
window["Hilo3d"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/_amc@1.0.6@amc/build/amd.js":
/*!**************************************************!*\
  !*** ./node_modules/_amc@1.0.6@amc/build/amd.js ***!
  \**************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = function (e) {
  var t = {};

  function n(r) {
    if (t[r]) return t[r].exports;
    var i = t[r] = {
      i: r,
      l: !1,
      exports: {}
    };
    return e[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports;
  }

  return n.m = e, n.c = t, n.d = function (e, t, r) {
    n.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: r
    });
  }, n.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    });
  }, n.t = function (e, t) {
    if (1 & t && (e = n(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var r = Object.create(null);
    if (n.r(r), Object.defineProperty(r, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e) for (var i in e) {
      n.d(r, i, function (t) {
        return e[t];
      }.bind(null, i));
    }
    return r;
  }, n.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e["default"];
    } : function () {
      return e;
    };
    return n.d(t, "a", t), t;
  }, n.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }, n.p = "", n(n.s = 2);
}([function (e, t, n) {
  function r(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
    }
  }

  function i(e, t, n) {
    return t && r(e.prototype, t), n && r(e, n), e;
  }

  var a = n(1),
      o = {
    POSITION: "POSITION",
    NORMAL: "NORMAL",
    COLOR: "COLOR",
    COLOR_0: "COLOR",
    COLOR_1: "COLOR_1",
    TEXCOORD: "TEXCOORD",
    TEXCOORD_0: "TEXCOORD",
    TEXCOORD_1: "TEXCOORD_1",
    TEXCOORD_2: "TEXCOORD_2",
    TANGENT: "TANGENT",
    JOINT: "JOINT",
    JOINTS_0: "JOINT",
    WEIGHT: "WEIGHT",
    WEIGHTS_0: "WEIGHT"
  },
      s = ["POSITION", "NORMAL", "COLOR", "TEXCOORD", "TANGENT", "JOINT", "WEIGHT", "OTHER", "TEXCOORD_1", "TEXCOORD_2", "COLOR_1"],
      u = {
    POSITION: 0,
    NORMAL: 1,
    COLOR: 2,
    TEXCOORD: 3,
    TANGENT: 4,
    JOINT: 5,
    WEIGHT: 6,
    OTHER: 7,
    TEXCOORD_1: 8,
    TEXCOORD_2: 9,
    COLOR_1: 10
  },
      c = {
    POSITION: "vertices",
    NORMAL: "normals",
    COLOR: "colors",
    TEXCOORD: "uvs",
    TEXCOORD_1: "uvs1",
    TEXCOORD_2: "uvs2",
    TANGENT: "tangents",
    JOINT: "skinIndices",
    WEIGHT: "skinWeights"
  },
      h = {
    vertices: "POSITION",
    _normals: "NORMAL",
    colors: "COLOR",
    uvs: "TEXCOORD",
    uvs1: "TEXCOORD_1",
    uvs2: "TEXCOORD_2",
    _tangents: "TANGENT",
    skinIndices: "JOINT",
    skinWeights: "WEIGHT"
  },
      l = {
    POSITION: 3,
    NORMAL: 3,
    COLOR: 3,
    COLOR_1: 3,
    TEXCOORD: 2,
    TEXCOORD_1: 2,
    TEXCOORD_2: 2,
    TANGENT: 4,
    JOINT: 4,
    WEIGHT: 4
  },
      f = function () {
    function e(t) {
      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4;
      !function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }(this, e), this.indices = t, this.mode = n, this.attrs = [], this.attrIndexMap = {};
    }

    return i(e, null, [{
      key: "cp",
      value: function value(e) {
        return e;
      }
    }, {
      key: "minus",
      value: function value(e, t) {
        return e - t;
      }
    }, {
      key: "plus",
      value: function value(e, t) {
        return e + t;
      }
    }, {
      key: "pp",
      value: function value(e, t, n, r) {
        return r - t - n + e;
      }
    }, {
      key: "depp",
      value: function value(e, t, n, r) {
        return t + n - e + r;
      }
    }, {
      key: "ATTR",
      get: function get() {
        return o;
      }
    }, {
      key: "ATTR_NAME_ID",
      get: function get() {
        return u;
      }
    }]), i(e, [{
      key: "getAttrLength",
      value: function value() {
        return this.attrs[0].data.length / this.attrs[0].itemCount;
      }
    }, {
      key: "attrIdToName",
      value: function value(e) {
        return s[e] || "OTHER";
      }
    }, {
      key: "addAttr",
      value: function value(e, t, n) {
        o[e] ? (this.attrIndexMap[e] = this.attrs.length, n || (n = l[e])) : n || (n = 1), this.attrs.push({
          name: e,
          itemCount: n,
          data: t
        });
      }
    }, {
      key: "getAttr",
      value: function value(e) {
        if (this.attrIndexMap[e]) return this.attrs[this.attrIndexMap[e]];

        for (var t = this.attrs.length - 1; t >= 0; t--) {
          var n = this.attrs[t];
          if (n.name === e) return n;
        }
      }
    }, {
      key: "cal",
      value: function value(e, t, n) {
        for (var r = arguments.length, i = new Array(r > 3 ? r - 3 : 0), a = 3; a < r; a++) {
          i[a - 3] = arguments[a];
        }

        this.attrs.forEach(function (r, a) {
          for (var o = r.data, s = e.attrs[a].data, u = t * r.itemCount, c = r.itemCount - 1; c >= 0; c--) {
            s[u + c] = n.apply(null, i.map(function (e) {
              return o[e * r.itemCount + c];
            }));
          }
        });
      }
    }, {
      key: "quantize",
      value: function value() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        this.attrs.forEach(function (t) {
          if ("JOINT" !== t.name && 0 != e[t.name]) {
            var n = a.encode(t.data, e[t.name] || 12);
            t.quantizationBit = n.quantizationBit, t.min = n.min, t.max = n.max, t.data = n.data;
          }
        });
      }
    }, {
      key: "dequantize",
      value: function value() {
        this.attrs.forEach(function (e) {
          e.quantizationBit && (e.data = a.decode(e.data, e.quantizationBit, e.min, e.max));
        });
      }
    }, {
      key: "convertTypedArray",
      value: function value() {
        !this.indices || this.indices instanceof Array || (this.indices = Array.from(this.indices)), this.attrs.forEach(function (e) {
          e.data instanceof Array || e.data instanceof Float32Array || (e.data = Array.from(e.data));
        });
      }
    }, {
      key: "clearEBAttrs",
      value: function value() {
        delete this.clers, delete this.holes, delete this.handles;
      }
    }, {
      key: "convertToTypedArray",
      value: function value() {
        this.indices instanceof Array && (this.getAttrLength() > 65535 ? this.indices = new Uint32Array(this.indices) : this.indices = new Uint16Array(this.indices)), this.attrs.forEach(function (e) {
          e.data instanceof Array && (e.data = new Float32Array(e.data));
        });
      }
    }, {
      key: "prepareToWorkerSend",
      value: function value() {
        return this.clearEBAttrs(), this.convertToTypedArray(), this.getAllBuffers();
      }
    }, {
      key: "clone",
      value: function value() {
        var t = new e(Array.from(this.indices), this.mode);
        return Object.assign(t.attrIndexMap, this.attrIndexMap), t.attrs = this.attrs.map(function (e) {
          var t = Object.assign({}, e);
          return t.data = Array.from(t.data), t;
        }), t;
      }
    }, {
      key: "cloneStruct",
      value: function value() {
        var t = new e();
        return t.mode = this.mode, this.indices && (t.indices = []), Object.assign(t.attrIndexMap, this.attrIndexMap), t.attrs = this.attrs.map(function (e) {
          var t = Object.assign({}, e);
          return t.data = [], t;
        }), t;
      }
    }, {
      key: "toHilo3dGeometry",
      value: function value(e, t) {
        var n = t || new e.Geometry();
        return this.indices && (this.indices.BYTES_PER_ELEMENT ? n.indices = new e.GeometryData(this.indices, 1) : this.getAttrLength() > 65535 ? n.indices = new e.GeometryData(new Uint32Array(this.indices), 1) : n.indices = new e.GeometryData(new Uint16Array(this.indices), 1)), this.attrs.forEach(function (t) {
          var r = c[t.name];
          r && (t.data.BYTES_PER_ELEMENT ? n[r] = new e.GeometryData(t.data, t.itemCount) : n[r] = new e.GeometryData(new Float32Array(t.data), t.itemCount));
        }), n;
      }
    }, {
      key: "getAllBuffers",
      value: function value() {
        var e = [];
        return this.indices.BYTES_PER_ELEMENT && e.push(this.indices.buffer), this.attrs.forEach(function (t) {
          t.data && t.data.BYTES_PER_ELEMENT && e.push(t.data.buffer);
        }), e;
      }
    }], [{
      key: "fromGLTFPrimitive",
      value: function value(t) {
        var n = new e(t.indices, t.mode),
            r = t.attributes,
            i = 0;

        for (var a in r.POSITION && (i = r.POSITION.length / 3), r) {
          if (o[a]) {
            var s = l[o[a]];
            i && (s = r[a].length / i), n.addAttr(o[a], r[a], s);
          } else console.warn("Dont support attribute", a);
        }

        return n;
      }
    }, {
      key: "fromHilo3dGeometry",
      value: function value(t) {
        var n = new e(t.indices.data, t.mode);

        for (var r in h) {
          t[r] && n.addAttr(h[r], t[r].data, t[r].size);
        }

        return n;
      }
    }]), e;
  }();

  e.exports = f;
}, function (e, t) {
  var n = {};

  function r(e) {
    return n[e] || (n[e] = Math.pow(2, e) - 1), n[e];
  }

  e.exports = {
    cal: function cal(e, t, n, i) {
      var a = r(i),
          o = n - t;
      return Math.round((e - t) / o * a);
    },
    encode: function encode(e) {
      for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8, n = e.length, i = r(t), a = 1 / 0, o = -1 / 0, s = 0; s < n; s++) {
        a = Math.min(a, e[s]), o = Math.max(o, e[s]);
      }

      var u = o - a || 1,
          c = [];

      for (s = 0; s < n; s++) {
        c[s] = Math.round((e[s] - a) / u * i);
      }

      return {
        min: a,
        max: o,
        quantizationBit: t,
        data: c
      };
    },
    encodeWithMinAndMax: function encodeWithMinAndMax(e) {
      for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 8, o = e.length, s = r(a), u = i - n || 1, c = 0; c < o; c++) {
        t[c] = Math.round((e[c] - n) / u * s);
      }

      return t;
    },
    decode: function decode(e) {
      for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8, n = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0, a = e.length, o = r(t), s = i - n, u = new Float32Array(a), c = 0; c < a; c++) {
        u[c] = n + s * (e[c] / o);
      }

      return u;
    },
    normalize: function normalize(e) {
      for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 3, r = e.length, i = 0; i < r; i += n) {
        for (var a = 0, o = 0; o < n; o++) {
          a += e[i + o] * e[i + o];
        }

        a = Math.sqrt(a);

        for (o = 0; o < n; o++) {
          t[i + o] = e[i + o] / a;
        }
      }

      return t;
    }
  };
}, function (e, t, n) {
  e.exports = n(3);
}, function (e, t, n) {
  var r = n(4);
  r.Geometry = n(0), e.exports = r;
}, function (e, t, n) {
  var r = n(0),
      i = n(5),
      a = n(7),
      o = n(8),
      s = n(9),
      u = [i],
      c = [a];

  function h(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return e instanceof Uint8Array && (t = e.byteOffset, e = e.buffer), function (e) {
      return new u[e.type](e).decompress();
    }(function (e, t) {
      var n = new Uint8Array(e, t, 4);
      if (65 !== n[0] || 77 !== n[1] || 67 !== n[2]) throw new Error("The file is not AMC format!");
      var r = c[n[3]].read(e, t + 4);
      return r.geometry.type = n[3], r.geometry;
    }(e, t));
  }

  var l,
      f = null,
      d = null;

  function v(e, t) {
    return !f && s() ? (f = new o({
      wasmURL: e,
      memPages: t
    }), d = f.init()) : d || Promise.resolve();
  }

  function p(e, t, n) {
    if (f || v(t, n), !f || !f.isReady) return h(e);

    try {
      return f.decompress(e);
    } catch (t) {
      return console.warn("wasm decompress error", t), h(e);
    }
  }

  var y = null;

  function m(e) {
    return e = e || "https://g.alicdn.com/hilo/amc/0.1.27/worker.js", y || (!1 === l || "undefined" == typeof Worker ? Promise.reject("dont support web worker") : y = /^(?:http|blob|data:|\/\/)/.test(e) ? new Promise(function (t, n) {
      var r = new XMLHttpRequest();
      r.addEventListener("load", function () {
        if ("undefined" == typeof URL || "undefined" == typeof Blob) l = new Worker("data:application/javascript, ".concat(this.responseText));else {
          var e = URL.createObjectURL(new Blob([this.responseText]));
          l = new Worker(e);
        }
        l.onerror = function (e) {
          console.log("web worker error", e), l = !1, n(e);
        }, t(l);
      }), r.addEventListener("error", function (e) {
        return n(e);
      }), r.open("get", e, !0), r.send();
    }) : new Promise(function (t, n) {
      (l = new Worker(e)).onerror = function (e) {
        console.log("web worker init error", e), l = !1, n(e);
      }, t(l);
    }));
  }

  var g = 0;

  function O(e, t, n, i) {
    return t = t && s(), e = new Uint8Array(e), m(i).then(function (i) {
      return new Promise(function (a, o) {
        var s = g++,
            _u = function u(t) {
          if (t.data.id === s) if (i.removeEventListener("message", _u), _u = null, t.data.data) {
            var n = t.data.data;
            n.constructor = r, n.__proto__ = r.prototype, a(n);
          } else a(h(e));
        };

        i.addEventListener("message", _u), i.postMessage({
          id: s,
          data: e,
          useWASM: t,
          wasmURL: n
        }, [e.buffer]);
      });
    })["catch"](function (r) {
      return t ? p(e, n) : h(e);
    });
  }

  e.exports = {
    initWASM: v,
    initWorker: m,
    decompress: function decompress(e, t, n) {
      var r = s();
      return !r || e.byteLength > 1048576 ? O(e, r, t, n) : r ? Promise.resolve(p(e, t)) : Promise.resolve(h(e));
    },
    decompressWithJS: h,
    decompressWithWASM: p,
    decompressWithWorker: O,
    destory: function destory() {
      l && (l.terminate(), l = null, y = null), f && (f = null, d = null);
    }
  };
}, function (e, t, n) {
  function r(e) {
    return function (e) {
      if (Array.isArray(e)) {
        for (var t = 0, n = new Array(e.length); t < e.length; t++) {
          n[t] = e[t];
        }

        return n;
      }
    }(e) || function (e) {
      if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e);
    }(e) || function () {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }();
  }

  function i(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
    }
  }

  var a = n(0),
      o = (n(1), n(6)),
      u = o.map,
      c = function () {
    function e(t) {
      !function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }(this, e), this.geometry = t, this.faceCount = t.clers.length, this.clers = t.clers, this.holes = t.holes, this.handles = t.handles, this.createHandleMap(this.handles), this.vertexCount = t.getAttrLength(), this.noParallelogramPrediction = !!t.noParallelogramPrediction;
    }

    var t, n;
    return t = e, (n = [{
      key: "nextCorner",
      value: function value(e) {
        return e < 0 ? -1 : e + (e % 3 == 2 ? -2 : 1);
      }
    }, {
      key: "prevCorner",
      value: function value(e) {
        return e < 0 ? -1 : e + (e % 3 ? -1 : 2);
      }
    }, {
      key: "createHandleMap",
      value: function value(e) {
        var t = this.handlesMap = {};
        if (e) for (var n = e.length - 1; n >= 0; n -= 2) {
          t[e[n]] = e[n - 1];
        }
      }
    }, {
      key: "mapBoundary",
      value: function value(e) {
        for (var t = this.indices, n = e.length, r = this.currentVertex, i = this.currentVertex - n + 1, a = n - 1; a >= 0; a--) {
          t[this.nextCorner(e[a])] = r, r = i, t[this.prevCorner(e[a])] = i++;
        }

        this.currentVertex -= n;
      }
    }, {
      key: "mapHoleBoundary",
      value: function value(e) {
        for (var t = this.indices, n = e.length, r = this.currentVertex - n + 1, i = r, a = n - 1; a >= 0; a--) {
          t[this.nextCorner(e[a])] = r++, t[this.prevCorner(e[a])] = a ? r : i;
        }

        this.currentVertex -= n;
      }
    }, {
      key: "fixNegativeIndex",
      value: function value(e) {
        for (var t = e, n = this.indices; n[e] < 0;) {
          if (t === -n[-n[e]] || n[e] === n[-n[e]]) {
            console.warn("dead loop bug!!"), n[s] = 0;
            break;
          }

          n[e] = n[-n[e]];
        }
      }
    }, {
      key: "fixIndicesAndReadVertice",
      value: function value() {
        for (var e, t = this.indices, n = this.handlesMap, r = this.clers, i = r.length, a = -1, s = [], u = 0, c = 0; u < i; u++, c += 3) {
          -1 === a ? (this.fixNegativeIndex(c + 1), this.fixNegativeIndex(c + 2)) : (t[c + 1] = t[this.prevCorner(a)], t[c + 2] = t[this.nextCorner(a)]), this.fixNegativeIndex(c), -1 === a ? (this.readVertex(t[c + 2]), this.readVertex(t[c + 1]), this.readVertex(t[c])) : this.readVertex(t[c], a), a = c + 1, (e = r[u]) !== o.S || n[u] ? e === o.E || e === o.F ? a = s.pop() : e === o.R && (a = c + 2) : s.push(c + 2), e === o.F && (a = -1, delete this.lastReadVertexIndex), this._onDecompressFace(u, e);
        }
      }
    }, {
      key: "readVertex",
      value: function value(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;

        if (!this.readedVertexMap[e] && (this.readedVertexMap[e] = 1, !this.noParallelogramPrediction)) {
          var n = this.indices,
              r = this.geometry;
          -1 === t ? void 0 !== this.lastReadVertexIndex && r.cal(r, e, a.plus, this.lastReadVertexIndex, e) : r.cal(r, e, a.depp, n[t], n[this.prevCorner(t)], n[this.nextCorner(t)], e), this.lastReadVertexIndex = e;
        }
      }
    }, {
      key: "markCorner",
      value: function value(e, t) {
        var n = this.indices;
        void 0 === n[this.nextCorner(e)] && (n[this.nextCorner(e)] = -this.prevCorner(t[0])), void 0 === n[this.prevCorner(e)] && (n[this.prevCorner(e)] = -this.nextCorner(t[t.length - 1]));
      }
    }, {
      key: "onFaceC",
      value: function value(e) {
        var t = this.indices,
            n = 3 * this.currentFace,
            r = this.currentVertex--;
        t[n] = r;
        var i = e.pop();
        return t[this.nextCorner(i)] = r, t[this.prevCorner(i)] = -this.nextCorner(e[e.length - 1]), i = e.shift(), t[this.prevCorner(i)] = r, t[this.nextCorner(i)] = -this.prevCorner(e[0]), e.push(n), e;
      }
    }, {
      key: "onFaceL",
      value: function value(e) {
        var t = 3 * this.currentFace;
        return this.markCorner(e.pop(), e), e.unshift(t + 2), e.push(t), e;
      }
    }, {
      key: "onFaceF",
      value: function value(e, t) {
        return e && this.mapBoundary(e), this.onFaceE(null, t);
      }
    }, {
      key: "onFaceE",
      value: function value(e, t) {
        var n = 3 * this.currentFace;
        return e && t.push(e), [n + 2, n + 1, n];
      }
    }, {
      key: "onFaceR",
      value: function value(e) {
        var t = 3 * this.currentFace;
        return this.markCorner(e.pop(), e), e.push(t + 1, t), e;
      }
    }, {
      key: "onHandleEnd",
      value: function value(e, t, n) {
        var r = this.indices,
            i = 3 * this.currentFace,
            a = this.handlesMap[this.currentFace],
            o = t.splice(0, e);
        return t.shift(), n.push(o), r[this.nextCorner(a)] = -(i + 1), r[this.prevCorner(a)] = -this.nextCorner(o[o.length - 1]), r[i] = -this.prevCorner(o[0]), t.push(i), t;
      }
    }, {
      key: "onHandleStart",
      value: function value(e, t) {
        for (var n, i = this.indices, a = 3 * this.currentFace, o = this.handlesMap[this.currentFace], s = t.length - 1; s >= 0; s--) {
          var u = t[s].indexOf(o);

          if (u >= 0) {
            var c,
                h = (n = t.splice(s, 1)[0]).splice(0, u);
            n.shift(), (c = n).push.apply(c, r(h));
            break;
          }
        }

        return i[this.nextCorner(o)] = -(a + 1), i[this.prevCorner(o)] = -this.nextCorner(n[n.length - 1]), i[a] = -this.prevCorner(e[0]), (e = n.concat(e)).push(a), e;
      }
    }, {
      key: "onFaceS",
      value: function value(e, t, n) {
        var r = this.handlesMap,
            i = this.indices,
            a = 3 * this.currentFace;

        if (r[this.currentFace]) {
          this.markCorner(e.pop(), e);
          var o = e.indexOf(r[this.currentFace]);
          e = o >= 0 ? this.onHandleEnd(o, e, n) : this.onHandleStart(e, n);
        } else {
          var s = e.pop();
          this.markCorner(s, e), i[a] = -this.nextCorner(s);
          var u = t.pop();
          this.markCorner(u.pop(), u), (e = u.concat(e)).push(a);
        }

        return e;
      }
    }, {
      key: "onFaceM",
      value: function value(e, t, n) {
        var r = this.indices,
            i = 3 * this.currentFace,
            a = e.splice(0, this.holes[this.currentHole--]);
        this.mapHoleBoundary(a);
        var o = r[this.prevCorner(a[0])];
        r[i] = o;
        var s = e.pop();
        return r[this.prevCorner(s)] = -this.nextCorner(e[e.length - 1]), r[this.nextCorner(s)] = o, s = e.shift(), r[this.prevCorner(s)] = o, r[this.nextCorner(s)] = -this.prevCorner(e[0]), e.push(i), e;
      }
    }, {
      key: "decompress",
      value: function value() {
        this.readedVertexMap = new Uint8Array(this.vertexCount);
        var e = this.faceCount,
            t = this.indices = new Array(3 * e);
        this.currentFace = e - 1, this.currentVertex = this.vertexCount - 1, this.currentHole = this.holes.length - 1;

        for (var n, r = this.clers, i = [], a = []; this.currentFace >= 0;) {
          var o = "onFace" + u[r[this.currentFace]];
          this[o] ? n = this[o](n, i, a) : console.warn("has no ".concat(o)), this.currentFace--;
        }

        return this.mapBoundary(n), this.fixIndicesAndReadVertice(this.indices), this.geometry.indices = t, this.geometry.dequantize(), this.geometry;
      }
    }, {
      key: "_onDecompressFace",
      value: function value(e, t) {
        this.onDecompressFace && this.onDecompressFace(e, t);
      }
    }]) && i(t.prototype, n), e;
  }();

  e.exports = c;
}, function (e, t) {
  var n = {
    C: 0,
    R: 1,
    L: 2,
    S: 3,
    E: 4,
    M: 5,
    F: 6
  },
      r = [];

  for (var i in n) {
    r[n[i]] = i;
  }

  n.map = r, e.exports = n;
}, function (e, t, n) {
  var r = n(0);

  function i(e, t, n, r) {
    return new e(t.slice(n, n + r * e.BYTES_PER_ELEMENT));
  }

  e.exports = {
    read: function read(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          n = new DataView(e),
          a = new r(),
          o = function (e, t) {
        var n = {};
        return n.version = e.getUint8(t++), n.faceCount = e.getUint32(t, !0), t += 4, n.vertexCount = e.getUint32(t, !0), t += 4, n.attrCount = e.getUint8(t++), n.noParallelogramPrediction = e.getUint8(t++), n.holesCount = e.getUint16(t, !0), t += 2, n.handlesCount = e.getUint16(t, !0), t += 2, n.headerBytes = 15, n;
      }(n, t);

      return t += o.headerBytes, a.mode = "CLERS", t = function (e, t, n, r) {
        return r.holesCount ? (e.holes = i(Uint16Array, t.buffer, n, r.holesCount), n + 2 * r.holesCount) : (e.holes = [], n);
      }(a, n, t, o), t = function (e, t, n, r) {
        return r.handlesCount ? (e.handles = i(Uint32Array, t.buffer, n, 2 * r.handlesCount), n + 8 * r.handlesCount) : (e.handles = [], n);
      }(a, n, t, o), t = function (e, t, n, r) {
        return e.clers = new Uint8Array(t.buffer, n, r.faceCount), n + r.faceCount;
      }(a, n, t, o), t = function (e, t, n, r) {
        for (var a = 0; a < r.attrCount; a++) {
          var o = {},
              s = t.getUint16(n, !0);
          n += 2, o.name = e.attrIdToName(s), o.itemCount = t.getUint8(n++), o.quantizationBit = t.getUint8(n++), o.min = t.getFloat32(n, !0), n += 4, o.max = t.getFloat32(n, !0), n += 4, o.data = i(Int16Array, t.buffer, n, o.itemCount * r.vertexCount), n += o.itemCount * r.vertexCount * 2, e.attrs.push(o);
        }

        return n;
      }(a, n, t, o), {
        header: o,
        geometry: a,
        offset: t
      };
    }
  };
}, function (e, t, n) {
  function r(e, t) {
    return function (e) {
      if (Array.isArray(e)) return e;
    }(e) || function (e, t) {
      var n = [],
          r = !0,
          i = !1,
          a = void 0;

      try {
        for (var o, s = e[Symbol.iterator](); !(r = (o = s.next()).done) && (n.push(o.value), !t || n.length !== t); r = !0) {
          ;
        }
      } catch (e) {
        i = !0, a = e;
      } finally {
        try {
          r || null == s["return"] || s["return"]();
        } finally {
          if (i) throw a;
        }
      }

      return n;
    }(e, t) || function () {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }();
  }

  function i(e) {
    return function (e) {
      if (Array.isArray(e)) {
        for (var t = 0, n = new Array(e.length); t < e.length; t++) {
          n[t] = e[t];
        }

        return n;
      }
    }(e) || function (e) {
      if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e);
    }(e) || function () {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }();
  }

  function a(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
    }
  }

  var o = n(0),
      s = function () {
    function e() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      !function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }(this, e), this.wasmURL = t.wasmURL || "https://ossgw.alicdn.com/tmall-c3/tmx/70b8d82ccf33e97a124e54c2d6a3e0c7.wasm", this.memPages = t.memPages || 256, this.memPages < 256 && (this.memPages = 256), this.isReady = !1;
    }

    var t, n;
    return t = e, (n = [{
      key: "initASMJS",
      value: function value() {
        this.isReady = !0, this.dv = new DataView(HEAP8.buffer), this.heap8 = HEAP8, this.ins = {
          exports: {
            __Z7AMCinitj: Module.__Z7AMCinitj,
            __Z12AMDecompressv: Module.__Z12AMDecompressv
          }
        };
      }
    }, {
      key: "init",
      value: function value() {
        var e = this,
            t = this.memory = new WebAssembly.Memory({
          initial: this.memPages
        });
        this.dv = new DataView(t.buffer);
        var n = this.heap8 = new Uint8Array(t.buffer),
            r = {
          global: {
            NaN: 5,
            Infinity: 6
          },
          env: {
            memoryBase: 0,
            memory: t,
            _malloc: function _malloc() {
              return 2097152;
            },
            _memset: function _memset(e, t, r) {
              return n.fill(t, e, e + r), e;
            },
            _printf: function _printf(e, t) {
              for (var r = e; n[r];) {
                r++;
              }

              var a = String.fromCharCode.apply(String, i(n.slice(e, r))),
                  o = 0;
              a = a.replace(/%([duf])/g, function (e, n) {
                return "d" === n || "u" === n ? dv.getInt32(t + 4 * o++, !0) : "f" === n ? dv.getFloat32(t + 4 * o++, !0) : void 0;
              }), console.log(a);
            }
          }
        };
        return fetch(this.wasmURL).then(function (e) {
          return e.arrayBuffer();
        }).then(function (e) {
          return WebAssembly.instantiate(e, r);
        }).then(function (t) {
          e.module = t, e.ins = t.instance, e.isReady = !0;
        })["catch"](function (e) {
          return console.log("wasm load error, use js ver");
        });
      }
    }, {
      key: "getDataAddr",
      value: function value(e) {
        return this.ins.exports.__Z7AMCinitj(e);
      }
    }, {
      key: "decompress",
      value: function value(e) {
        e instanceof ArrayBuffer && (e = new Uint8Array(e));
        var t = this.dv,
            n = this.heap8,
            i = this.getDataAddr(e.length);
        n.set(e, i);

        var a = this.ins.exports.__Z12AMDecompressv();

        if (a <= 0) throw console.error("decompression error code: " + a), new Error("decompression error code: " + a);

        for (var s = t.getUint32(a, !0), u = t.getUint32(a + 4, !0), c = t.getUint32(a + 8, !0), h = t.getUint32(a + 12, !0), l = [], f = 0; f < h; f++) {
          var d = a + 16 + 12 * f;
          l.push([t.getUint32(d, !0), t.getUint32(d + 4, !0), t.getUint32(d + 8, !0)]);
        }

        var v = new Uint32Array(t.buffer, u, 3 * s);
        v = c > 65536 ? new Uint32Array(v) : new Uint16Array(v);
        var p = new o(v);
        return l.forEach(function (e) {
          var n = r(e, 3),
              i = n[0],
              a = n[1],
              o = n[2],
              s = new Float32Array(t.buffer.slice(o, o + c * a * 4));
          p.addAttr(p.attrIdToName(i), s, a);
        }), p;
      }
    }]) && a(t.prototype, n), e;
  }();

  e.exports = s;
}, function (e, t) {
  function n() {
    if ("undefined" == typeof WebAssembly || "undefined" == typeof fetch || function () {
      if (!/iPad|iPhone|iPod/i.test(navigator.userAgent)) return !1;

      if (/OS (\d+)_(\d+)_?(\d+)?/i.test(navigator.userAgent)) {
        var e = Number(RegExp.$1),
            t = Number(RegExp.$2);
        if (11 === e && t >= 3 || e > 11) return !1;
      }

      return !0;
    }()) return !1;

    try {
      var e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11]),
          t = new WebAssembly.Module(e);
      return 0 !== new WebAssembly.Instance(t, {}).exports.test(4);
    } catch (e) {
      return console.log("err while check WebAssembly", e), !1;
    }
  }

  var r;

  e.exports = function () {
    return void 0 === r && (r = n()), r;
  };
}]);

/***/ }),

/***/ "./node_modules/_gl-constants@1.0.0@gl-constants/1.0/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/_gl-constants@1.0.0@gl-constants/1.0/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = {
  ACTIVE_ATTRIBUTES: 35721,
  ACTIVE_ATTRIBUTE_MAX_LENGTH: 35722,
  ACTIVE_TEXTURE: 34016,
  ACTIVE_UNIFORMS: 35718,
  ACTIVE_UNIFORM_MAX_LENGTH: 35719,
  ALIASED_LINE_WIDTH_RANGE: 33902,
  ALIASED_POINT_SIZE_RANGE: 33901,
  ALPHA: 6406,
  ALPHA_BITS: 3413,
  ALWAYS: 519,
  ARRAY_BUFFER: 34962,
  ARRAY_BUFFER_BINDING: 34964,
  ATTACHED_SHADERS: 35717,
  BACK: 1029,
  BLEND: 3042,
  BLEND_COLOR: 32773,
  BLEND_DST_ALPHA: 32970,
  BLEND_DST_RGB: 32968,
  BLEND_EQUATION: 32777,
  BLEND_EQUATION_ALPHA: 34877,
  BLEND_EQUATION_RGB: 32777,
  BLEND_SRC_ALPHA: 32971,
  BLEND_SRC_RGB: 32969,
  BLUE_BITS: 3412,
  BOOL: 35670,
  BOOL_VEC2: 35671,
  BOOL_VEC3: 35672,
  BOOL_VEC4: 35673,
  BROWSER_DEFAULT_WEBGL: 37444,
  BUFFER_SIZE: 34660,
  BUFFER_USAGE: 34661,
  BYTE: 5120,
  CCW: 2305,
  CLAMP_TO_EDGE: 33071,
  COLOR_ATTACHMENT0: 36064,
  COLOR_BUFFER_BIT: 16384,
  COLOR_CLEAR_VALUE: 3106,
  COLOR_WRITEMASK: 3107,
  COMPILE_STATUS: 35713,
  COMPRESSED_TEXTURE_FORMATS: 34467,
  CONSTANT_ALPHA: 32771,
  CONSTANT_COLOR: 32769,
  CONTEXT_LOST_WEBGL: 37442,
  CULL_FACE: 2884,
  CULL_FACE_MODE: 2885,
  CURRENT_PROGRAM: 35725,
  CURRENT_VERTEX_ATTRIB: 34342,
  CW: 2304,
  DECR: 7683,
  DECR_WRAP: 34056,
  DELETE_STATUS: 35712,
  DEPTH_ATTACHMENT: 36096,
  DEPTH_BITS: 3414,
  DEPTH_BUFFER_BIT: 256,
  DEPTH_CLEAR_VALUE: 2931,
  DEPTH_COMPONENT: 6402,
  DEPTH_COMPONENT16: 33189,
  DEPTH_FUNC: 2932,
  DEPTH_RANGE: 2928,
  DEPTH_STENCIL: 34041,
  DEPTH_STENCIL_ATTACHMENT: 33306,
  DEPTH_TEST: 2929,
  DEPTH_WRITEMASK: 2930,
  DITHER: 3024,
  DONT_CARE: 4352,
  DST_ALPHA: 772,
  DST_COLOR: 774,
  DYNAMIC_DRAW: 35048,
  ELEMENT_ARRAY_BUFFER: 34963,
  ELEMENT_ARRAY_BUFFER_BINDING: 34965,
  EQUAL: 514,
  FASTEST: 4353,
  FLOAT: 5126,
  FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  FRAGMENT_SHADER: 35632,
  FRAMEBUFFER: 36160,
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
  FRAMEBUFFER_BINDING: 36006,
  FRAMEBUFFER_COMPLETE: 36053,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
  FRAMEBUFFER_UNSUPPORTED: 36061,
  FRONT: 1028,
  FRONT_AND_BACK: 1032,
  FRONT_FACE: 2886,
  FUNC_ADD: 32774,
  FUNC_REVERSE_SUBTRACT: 32779,
  FUNC_SUBTRACT: 32778,
  GENERATE_MIPMAP_HINT: 33170,
  GEQUAL: 518,
  GREATER: 516,
  GREEN_BITS: 3411,
  HIGH_FLOAT: 36338,
  HIGH_INT: 36341,
  INCR: 7682,
  INCR_WRAP: 34055,
  INFO_LOG_LENGTH: 35716,
  INT: 5124,
  INT_VEC2: 35667,
  INT_VEC3: 35668,
  INT_VEC4: 35669,
  INVALID_ENUM: 1280,
  INVALID_FRAMEBUFFER_OPERATION: 1286,
  INVALID_OPERATION: 1282,
  INVALID_VALUE: 1281,
  INVERT: 5386,
  KEEP: 7680,
  LEQUAL: 515,
  LESS: 513,
  LINEAR: 9729,
  LINEAR_MIPMAP_LINEAR: 9987,
  LINEAR_MIPMAP_NEAREST: 9985,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  LINE_WIDTH: 2849,
  LINK_STATUS: 35714,
  LOW_FLOAT: 36336,
  LOW_INT: 36339,
  LUMINANCE: 6409,
  LUMINANCE_ALPHA: 6410,
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
  MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
  MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
  MAX_RENDERBUFFER_SIZE: 34024,
  MAX_TEXTURE_IMAGE_UNITS: 34930,
  MAX_TEXTURE_SIZE: 3379,
  MAX_VARYING_VECTORS: 36348,
  MAX_VERTEX_ATTRIBS: 34921,
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
  MAX_VERTEX_UNIFORM_VECTORS: 36347,
  MAX_VIEWPORT_DIMS: 3386,
  MEDIUM_FLOAT: 36337,
  MEDIUM_INT: 36340,
  MIRRORED_REPEAT: 33648,
  NEAREST: 9728,
  NEAREST_MIPMAP_LINEAR: 9986,
  NEAREST_MIPMAP_NEAREST: 9984,
  NEVER: 512,
  NICEST: 4354,
  NONE: 0,
  NOTEQUAL: 517,
  NO_ERROR: 0,
  NUM_COMPRESSED_TEXTURE_FORMATS: 34466,
  ONE: 1,
  ONE_MINUS_CONSTANT_ALPHA: 32772,
  ONE_MINUS_CONSTANT_COLOR: 32770,
  ONE_MINUS_DST_ALPHA: 773,
  ONE_MINUS_DST_COLOR: 775,
  ONE_MINUS_SRC_ALPHA: 771,
  ONE_MINUS_SRC_COLOR: 769,
  OUT_OF_MEMORY: 1285,
  PACK_ALIGNMENT: 3333,
  POINTS: 0,
  POLYGON_OFFSET_FACTOR: 32824,
  POLYGON_OFFSET_FILL: 32823,
  POLYGON_OFFSET_UNITS: 10752,
  RED_BITS: 3410,
  RENDERBUFFER: 36161,
  RENDERBUFFER_ALPHA_SIZE: 36179,
  RENDERBUFFER_BINDING: 36007,
  RENDERBUFFER_BLUE_SIZE: 36178,
  RENDERBUFFER_DEPTH_SIZE: 36180,
  RENDERBUFFER_GREEN_SIZE: 36177,
  RENDERBUFFER_HEIGHT: 36163,
  RENDERBUFFER_INTERNAL_FORMAT: 36164,
  RENDERBUFFER_RED_SIZE: 36176,
  RENDERBUFFER_STENCIL_SIZE: 36181,
  RENDERBUFFER_WIDTH: 36162,
  RENDERER: 7937,
  REPEAT: 10497,
  REPLACE: 7681,
  RGB: 6407,
  RGB5_A1: 32855,
  RGB565: 36194,
  RGBA: 6408,
  RGBA4: 32854,
  SAMPLER_2D: 35678,
  SAMPLER_CUBE: 35680,
  SAMPLES: 32937,
  SAMPLE_ALPHA_TO_COVERAGE: 32926,
  SAMPLE_BUFFERS: 32936,
  SAMPLE_COVERAGE: 32928,
  SAMPLE_COVERAGE_INVERT: 32939,
  SAMPLE_COVERAGE_VALUE: 32938,
  SCISSOR_BOX: 3088,
  SCISSOR_TEST: 3089,
  SHADER_COMPILER: 36346,
  SHADER_SOURCE_LENGTH: 35720,
  SHADER_TYPE: 35663,
  SHADING_LANGUAGE_VERSION: 35724,
  SHORT: 5122,
  SRC_ALPHA: 770,
  SRC_ALPHA_SATURATE: 776,
  SRC_COLOR: 768,
  STATIC_DRAW: 35044,
  STENCIL_ATTACHMENT: 36128,
  STENCIL_BACK_FAIL: 34817,
  STENCIL_BACK_FUNC: 34816,
  STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
  STENCIL_BACK_PASS_DEPTH_PASS: 34819,
  STENCIL_BACK_REF: 36003,
  STENCIL_BACK_VALUE_MASK: 36004,
  STENCIL_BACK_WRITEMASK: 36005,
  STENCIL_BITS: 3415,
  STENCIL_BUFFER_BIT: 1024,
  STENCIL_CLEAR_VALUE: 2961,
  STENCIL_FAIL: 2964,
  STENCIL_FUNC: 2962,
  STENCIL_INDEX: 6401,
  STENCIL_INDEX8: 36168,
  STENCIL_PASS_DEPTH_FAIL: 2965,
  STENCIL_PASS_DEPTH_PASS: 2966,
  STENCIL_REF: 2967,
  STENCIL_TEST: 2960,
  STENCIL_VALUE_MASK: 2963,
  STENCIL_WRITEMASK: 2968,
  STREAM_DRAW: 35040,
  SUBPIXEL_BITS: 3408,
  TEXTURE: 5890,
  TEXTURE0: 33984,
  TEXTURE1: 33985,
  TEXTURE2: 33986,
  TEXTURE3: 33987,
  TEXTURE4: 33988,
  TEXTURE5: 33989,
  TEXTURE6: 33990,
  TEXTURE7: 33991,
  TEXTURE8: 33992,
  TEXTURE9: 33993,
  TEXTURE10: 33994,
  TEXTURE11: 33995,
  TEXTURE12: 33996,
  TEXTURE13: 33997,
  TEXTURE14: 33998,
  TEXTURE15: 33999,
  TEXTURE16: 34000,
  TEXTURE17: 34001,
  TEXTURE18: 34002,
  TEXTURE19: 34003,
  TEXTURE20: 34004,
  TEXTURE21: 34005,
  TEXTURE22: 34006,
  TEXTURE23: 34007,
  TEXTURE24: 34008,
  TEXTURE25: 34009,
  TEXTURE26: 34010,
  TEXTURE27: 34011,
  TEXTURE28: 34012,
  TEXTURE29: 34013,
  TEXTURE30: 34014,
  TEXTURE31: 34015,
  TEXTURE_2D: 3553,
  TEXTURE_BINDING_2D: 32873,
  TEXTURE_BINDING_CUBE_MAP: 34068,
  TEXTURE_CUBE_MAP: 34067,
  TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
  TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
  TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
  TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  TRIANGLES: 4,
  TRIANGLE_FAN: 6,
  TRIANGLE_STRIP: 5,
  UNPACK_ALIGNMENT: 3317,
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
  UNPACK_FLIP_Y_WEBGL: 37440,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_INT: 5125,
  UNSIGNED_SHORT: 5123,
  UNSIGNED_SHORT_4_4_4_4: 32819,
  UNSIGNED_SHORT_5_5_5_1: 32820,
  UNSIGNED_SHORT_5_6_5: 33635,
  VALIDATE_STATUS: 35715,
  VENDOR: 7936,
  VERSION: 7938,
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
  VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
  VERTEX_ATTRIB_ARRAY_POINTER: 34373,
  VERTEX_ATTRIB_ARRAY_SIZE: 34339,
  VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
  VERTEX_ATTRIB_ARRAY_TYPE: 34341,
  VERTEX_SHADER: 35633,
  VIEWPORT: 2978,
  ZERO: 0
};

/***/ }),

/***/ "./node_modules/_gl-extensions-constants@1.0.0@gl-extensions-constants/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/_gl-extensions-constants@1.0.0@gl-extensions-constants/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

var extensionsConstants = {
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88FE,
  //  Describes the frequency divisor used for instanced rendering.
  UNMASKED_VENDOR_WEBGL: 0x9245,
  //  Passed to getParameter to get the vendor string of the graphics driver.
  UNMASKED_RENDERER_WEBGL: 0x9246,
  //  Passed to getParameter to get the renderer string of the graphics driver.
  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF,
  //  Returns the maximum available anisotropy.
  TEXTURE_MAX_ANISOTROPY_EXT: 0x84FE,
  //  Passed to texParameter to set the desired maximum anisotropy for a texture.
  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0,
  //  A DXT1-compressed image in an RGB image format.
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1,
  //  A DXT1-compressed image in an RGB image format with a simple on/off alpha value.
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2,
  //  A DXT3-compressed image in an RGBA image format. Compared to a 32-bit RGBA texture, it offers 4:1 compression.
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3,
  //  A DXT5-compressed image in an RGBA image format. It also provides a 4:1 compression, but differs to the DXT3 compression in how the alpha compression is done.
  COMPRESSED_R11_EAC: 0x9270,
  //  One-channel (red) unsigned format compression.
  COMPRESSED_SIGNED_R11_EAC: 0x9271,
  //  One-channel (red) signed format compression.
  COMPRESSED_RG11_EAC: 0x9272,
  //  Two-channel (red and green) unsigned format compression.
  COMPRESSED_SIGNED_RG11_EAC: 0x9273,
  //  Two-channel (red and green) signed format compression.
  COMPRESSED_RGB8_ETC2: 0x9274,
  //  Compresses RBG8 data with no alpha channel.
  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,
  //  Compresses RGBA8 data. The RGB part is encoded the same as RGB_ETC2, but the alpha part is encoded separately.
  COMPRESSED_SRGB8_ETC2: 0x9276,
  //  Compresses sRBG8 data with no alpha channel.
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,
  //  Compresses sRGBA8 data. The sRGB part is encoded the same as SRGB_ETC2, but the alpha part is encoded separately.
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,
  //  Similar to RGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent.
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,
  //  Similar to SRGB8_ETC, but with ability to punch through the alpha channel, which means to make it completely opaque or transparent.
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00,
  //  RGB compression in 4-bit mode. One block for each 4×4 pixels.
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02,
  //  RGBA compression in 4-bit mode. One block for each 4×4 pixels.
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01,
  //  RGB compression in 2-bit mode. One block for each 8×4 pixels.
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03,
  //  RGBA compression in 2-bit mode. One block for each 8×4 pixe
  COMPRESSED_RGB_ETC1_WEBGL: 0x8D64,
  //  Compresses 24-bit RGB data with no alpha channel.
  COMPRESSED_RGB_ATC_WEBGL: 0x8C92,
  //  Compresses RGB textures with no alpha channel.
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8C92,
  //  Compresses RGBA textures using explicit alpha encoding (useful when alpha transitions are sharp).
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87EE,
  //  Compresses RGBA textures using interpolated alpha encoding (useful when alpha transitions are gradient).
  UNSIGNED_INT_24_8_WEBGL: 0x84FA,
  //  Unsigned integer type for 24-bit depth texture data.
  HALF_FLOAT_OES: 0x8D61,
  //  Half floating-point type (16-bit).
  RGBA32F_EXT: 0x8814,
  //  RGBA 32-bit floating-point color-renderable format.
  RGB32F_EXT: 0x8815,
  //  RGB 32-bit floating-point color-renderable format.
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
  //   
  UNSIGNED_NORMALIZED_EXT: 0x8C17,
  //   
  MIN_EXT: 0x8007,
  //  Produces the minimum color components of the source and destination colors.
  MAX_EXT: 0x8008,
  //  Produces the maximum color components of the source and destination colors.
  SRGB_EXT: 0x8C40,
  //  Unsized sRGB format that leaves the precision up to the driver.
  SRGB_ALPHA_EXT: 0x8C42,
  //  Unsized sRGB format with unsized alpha component.
  SRGB8_ALPHA8_EXT: 0x8C43,
  //  Sized (8-bit) sRGB and alpha formats.
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210,
  //  Returns the framebuffer color encoding.
  FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8B8B,
  //  Indicates the accuracy of the derivative calculation for the GLSL built-in functions: dFdx, dFdy, and fwidth.
  COLOR_ATTACHMENT0_WEBGL: 0x8CE0,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT1_WEBGL: 0x8CE1,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT2_WEBGL: 0x8CE2,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT3_WEBGL: 0x8CE3,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT4_WEBGL: 0x8CE4,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT5_WEBGL: 0x8CE5,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT6_WEBGL: 0x8CE6,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT7_WEBGL: 0x8CE7,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT8_WEBGL: 0x8CE8,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT9_WEBGL: 0x8CE9,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT10_WEBGL: 0x8CEA,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT11_WEBGL: 0x8CEB,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT12_WEBGL: 0x8CEC,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT13_WEBGL: 0x8CED,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT14_WEBGL: 0x8CEE,
  //  Framebuffer color attachment point
  COLOR_ATTACHMENT15_WEBGL: 0x8CEF,
  //  Framebuffer color attachment point
  DRAW_BUFFER0_WEBGL: 0x8825,
  //  Draw buffer
  DRAW_BUFFER1_WEBGL: 0x8826,
  //  Draw buffer
  DRAW_BUFFER2_WEBGL: 0x8827,
  //  Draw buffer
  DRAW_BUFFER3_WEBGL: 0x8828,
  //  Draw buffer
  DRAW_BUFFER4_WEBGL: 0x8829,
  //  Draw buffer
  DRAW_BUFFER5_WEBGL: 0x882A,
  //  Draw buffer
  DRAW_BUFFER6_WEBGL: 0x882B,
  //  Draw buffer
  DRAW_BUFFER7_WEBGL: 0x882C,
  //  Draw buffer
  DRAW_BUFFER8_WEBGL: 0x882D,
  //  Draw buffer
  DRAW_BUFFER9_WEBGL: 0x882E,
  //  Draw buffer
  DRAW_BUFFER10_WEBGL: 0x882F,
  //  Draw buffer
  DRAW_BUFFER11_WEBGL: 0x8830,
  //  Draw buffer
  DRAW_BUFFER12_WEBGL: 0x8831,
  //  Draw buffer
  DRAW_BUFFER13_WEBGL: 0x8832,
  //  Draw buffer
  DRAW_BUFFER14_WEBGL: 0x8833,
  //  Draw buffer
  DRAW_BUFFER15_WEBGL: 0x8834,
  //  Draw buffer
  MAX_COLOR_ATTACHMENTS_WEBGL: 0x8CDF,
  //  Maximum number of framebuffer color attachment points
  MAX_DRAW_BUFFERS_WEBGL: 0x8824,
  //  Maximum number of draw buffers
  VERTEX_ARRAY_BINDING_OES: 0x85B5,
  //  The bound vertex array object (VAO).
  QUERY_COUNTER_BITS_EXT: 0x8864,
  //  The number of bits used to hold the query result for the given target.
  CURRENT_QUERY_EXT: 0x8865,
  //  The currently active query.
  QUERY_RESULT_EXT: 0x8866,
  //  The query result.
  QUERY_RESULT_AVAILABLE_EXT: 0x8867,
  //  A Boolean indicating whether or not a query result is available.
  TIME_ELAPSED_EXT: 0x88BF,
  //  Elapsed time (in nanoseconds).
  TIMESTAMP_EXT: 0x8E28,
  //  The current time.
  GPU_DISJOINT_EXT: 0x8FBB //  A Boolean indicating whether or not the GPU performed any disjoint operation.

};

{
  module.exports = extensionsConstants;
}

/***/ }),

/***/ "./node_modules/_gl-matrix@2.8.1@gl-matrix/dist/gl-matrix-min.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_gl-matrix@2.8.1@gl-matrix/dist/gl-matrix-min.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

/*!
@fileoverview gl-matrix - High performance matrix and vector operations
@author Brandon Jones
@author Colin MacKenzie IV
@version 2.7.0

Copyright (c) 2015-2018, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
!function (t, n) {
  module.exports = n();
}("undefined" != typeof self ? self : this, function () {
  return function (t) {
    var n = {};

    function r(a) {
      if (n[a]) return n[a].exports;
      var e = n[a] = {
        i: a,
        l: !1,
        exports: {}
      };
      return t[a].call(e.exports, e, e.exports, r), e.l = !0, e.exports;
    }

    return r.m = t, r.c = n, r.d = function (t, n, a) {
      r.o(t, n) || Object.defineProperty(t, n, {
        enumerable: !0,
        get: a
      });
    }, r.r = function (t) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(t, "__esModule", {
        value: !0
      });
    }, r.t = function (t, n) {
      if (1 & n && (t = r(t)), 8 & n) return t;
      if (4 & n && "object" == typeof t && t && t.__esModule) return t;
      var a = Object.create(null);
      if (r.r(a), Object.defineProperty(a, "default", {
        enumerable: !0,
        value: t
      }), 2 & n && "string" != typeof t) for (var e in t) {
        r.d(a, e, function (n) {
          return t[n];
        }.bind(null, e));
      }
      return a;
    }, r.n = function (t) {
      var n = t && t.__esModule ? function () {
        return t["default"];
      } : function () {
        return t;
      };
      return r.d(n, "a", n), n;
    }, r.o = function (t, n) {
      return Object.prototype.hasOwnProperty.call(t, n);
    }, r.p = "", r(r.s = 10);
  }([function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.setMatrixArrayType = function (t) {
      n.ARRAY_TYPE = t;
    }, n.toRadian = function (t) {
      return t * e;
    }, n.equals = function (t, n) {
      return Math.abs(t - n) <= a * Math.max(1, Math.abs(t), Math.abs(n));
    };
    var a = n.EPSILON = 1e-6;
    n.ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, n.RANDOM = Math.random;
    var e = Math.PI / 180;
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.forEach = n.sqrLen = n.len = n.sqrDist = n.dist = n.div = n.mul = n.sub = void 0, n.create = e, n.clone = function (t) {
      var n = new a.ARRAY_TYPE(4);
      return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n;
    }, n.fromValues = function (t, n, r, e) {
      var u = new a.ARRAY_TYPE(4);
      return u[0] = t, u[1] = n, u[2] = r, u[3] = e, u;
    }, n.copy = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t;
    }, n.set = function (t, n, r, a, e) {
      return t[0] = n, t[1] = r, t[2] = a, t[3] = e, t;
    }, n.add = function (t, n, r) {
      return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t[3] = n[3] + r[3], t;
    }, n.subtract = u, n.multiply = o, n.divide = i, n.ceil = function (t, n) {
      return t[0] = Math.ceil(n[0]), t[1] = Math.ceil(n[1]), t[2] = Math.ceil(n[2]), t[3] = Math.ceil(n[3]), t;
    }, n.floor = function (t, n) {
      return t[0] = Math.floor(n[0]), t[1] = Math.floor(n[1]), t[2] = Math.floor(n[2]), t[3] = Math.floor(n[3]), t;
    }, n.min = function (t, n, r) {
      return t[0] = Math.min(n[0], r[0]), t[1] = Math.min(n[1], r[1]), t[2] = Math.min(n[2], r[2]), t[3] = Math.min(n[3], r[3]), t;
    }, n.max = function (t, n, r) {
      return t[0] = Math.max(n[0], r[0]), t[1] = Math.max(n[1], r[1]), t[2] = Math.max(n[2], r[2]), t[3] = Math.max(n[3], r[3]), t;
    }, n.round = function (t, n) {
      return t[0] = Math.round(n[0]), t[1] = Math.round(n[1]), t[2] = Math.round(n[2]), t[3] = Math.round(n[3]), t;
    }, n.scale = function (t, n, r) {
      return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = n[3] * r, t;
    }, n.scaleAndAdd = function (t, n, r, a) {
      return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t[2] = n[2] + r[2] * a, t[3] = n[3] + r[3] * a, t;
    }, n.distance = s, n.squaredDistance = c, n.length = f, n.squaredLength = M, n.negate = function (t, n) {
      return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t[3] = -n[3], t;
    }, n.inverse = function (t, n) {
      return t[0] = 1 / n[0], t[1] = 1 / n[1], t[2] = 1 / n[2], t[3] = 1 / n[3], t;
    }, n.normalize = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = r * r + a * a + e * e + u * u;
      o > 0 && (o = 1 / Math.sqrt(o), t[0] = r * o, t[1] = a * o, t[2] = e * o, t[3] = u * o);
      return t;
    }, n.dot = function (t, n) {
      return t[0] * n[0] + t[1] * n[1] + t[2] * n[2] + t[3] * n[3];
    }, n.lerp = function (t, n, r, a) {
      var e = n[0],
          u = n[1],
          o = n[2],
          i = n[3];
      return t[0] = e + a * (r[0] - e), t[1] = u + a * (r[1] - u), t[2] = o + a * (r[2] - o), t[3] = i + a * (r[3] - i), t;
    }, n.random = function (t, n) {
      var r, e, u, o, i, s;
      n = n || 1;

      do {
        r = 2 * a.RANDOM() - 1, e = 2 * a.RANDOM() - 1, i = r * r + e * e;
      } while (i >= 1);

      do {
        u = 2 * a.RANDOM() - 1, o = 2 * a.RANDOM() - 1, s = u * u + o * o;
      } while (s >= 1);

      var c = Math.sqrt((1 - i) / s);
      return t[0] = n * r, t[1] = n * e, t[2] = n * u * c, t[3] = n * o * c, t;
    }, n.transformMat4 = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3];
      return t[0] = r[0] * a + r[4] * e + r[8] * u + r[12] * o, t[1] = r[1] * a + r[5] * e + r[9] * u + r[13] * o, t[2] = r[2] * a + r[6] * e + r[10] * u + r[14] * o, t[3] = r[3] * a + r[7] * e + r[11] * u + r[15] * o, t;
    }, n.transformQuat = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = r[0],
          i = r[1],
          s = r[2],
          c = r[3],
          f = c * a + i * u - s * e,
          M = c * e + s * a - o * u,
          h = c * u + o * e - i * a,
          l = -o * a - i * e - s * u;
      return t[0] = f * c + l * -o + M * -s - h * -i, t[1] = M * c + l * -i + h * -o - f * -s, t[2] = h * c + l * -s + f * -i - M * -o, t[3] = n[3], t;
    }, n.str = function (t) {
      return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    }, n.exactEquals = function (t, n) {
      return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3];
    }, n.equals = function (t, n) {
      var r = t[0],
          e = t[1],
          u = t[2],
          o = t[3],
          i = n[0],
          s = n[1],
          c = n[2],
          f = n[3];
      return Math.abs(r - i) <= a.EPSILON * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(e - s) <= a.EPSILON * Math.max(1, Math.abs(e), Math.abs(s)) && Math.abs(u - c) <= a.EPSILON * Math.max(1, Math.abs(u), Math.abs(c)) && Math.abs(o - f) <= a.EPSILON * Math.max(1, Math.abs(o), Math.abs(f));
    };

    var a = function (t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }(r(0));

    function e() {
      var t = new a.ARRAY_TYPE(4);
      return a.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
    }

    function u(t, n, r) {
      return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t[2] = n[2] - r[2], t[3] = n[3] - r[3], t;
    }

    function o(t, n, r) {
      return t[0] = n[0] * r[0], t[1] = n[1] * r[1], t[2] = n[2] * r[2], t[3] = n[3] * r[3], t;
    }

    function i(t, n, r) {
      return t[0] = n[0] / r[0], t[1] = n[1] / r[1], t[2] = n[2] / r[2], t[3] = n[3] / r[3], t;
    }

    function s(t, n) {
      var r = n[0] - t[0],
          a = n[1] - t[1],
          e = n[2] - t[2],
          u = n[3] - t[3];
      return Math.sqrt(r * r + a * a + e * e + u * u);
    }

    function c(t, n) {
      var r = n[0] - t[0],
          a = n[1] - t[1],
          e = n[2] - t[2],
          u = n[3] - t[3];
      return r * r + a * a + e * e + u * u;
    }

    function f(t) {
      var n = t[0],
          r = t[1],
          a = t[2],
          e = t[3];
      return Math.sqrt(n * n + r * r + a * a + e * e);
    }

    function M(t) {
      var n = t[0],
          r = t[1],
          a = t[2],
          e = t[3];
      return n * n + r * r + a * a + e * e;
    }

    n.sub = u, n.mul = o, n.div = i, n.dist = s, n.sqrDist = c, n.len = f, n.sqrLen = M, n.forEach = function () {
      var t = e();
      return function (n, r, a, e, u, o) {
        var i = void 0,
            s = void 0;

        for (r || (r = 4), a || (a = 0), s = e ? Math.min(e * r + a, n.length) : n.length, i = a; i < s; i += r) {
          t[0] = n[i], t[1] = n[i + 1], t[2] = n[i + 2], t[3] = n[i + 3], u(t, t, o), n[i] = t[0], n[i + 1] = t[1], n[i + 2] = t[2], n[i + 3] = t[3];
        }

        return n;
      };
    }();
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.forEach = n.sqrLen = n.len = n.sqrDist = n.dist = n.div = n.mul = n.sub = void 0, n.create = e, n.clone = function (t) {
      var n = new a.ARRAY_TYPE(3);
      return n[0] = t[0], n[1] = t[1], n[2] = t[2], n;
    }, n.length = u, n.fromValues = o, n.copy = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t;
    }, n.set = function (t, n, r, a) {
      return t[0] = n, t[1] = r, t[2] = a, t;
    }, n.add = function (t, n, r) {
      return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t;
    }, n.subtract = i, n.multiply = s, n.divide = c, n.ceil = function (t, n) {
      return t[0] = Math.ceil(n[0]), t[1] = Math.ceil(n[1]), t[2] = Math.ceil(n[2]), t;
    }, n.floor = function (t, n) {
      return t[0] = Math.floor(n[0]), t[1] = Math.floor(n[1]), t[2] = Math.floor(n[2]), t;
    }, n.min = function (t, n, r) {
      return t[0] = Math.min(n[0], r[0]), t[1] = Math.min(n[1], r[1]), t[2] = Math.min(n[2], r[2]), t;
    }, n.max = function (t, n, r) {
      return t[0] = Math.max(n[0], r[0]), t[1] = Math.max(n[1], r[1]), t[2] = Math.max(n[2], r[2]), t;
    }, n.round = function (t, n) {
      return t[0] = Math.round(n[0]), t[1] = Math.round(n[1]), t[2] = Math.round(n[2]), t;
    }, n.scale = function (t, n, r) {
      return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t;
    }, n.scaleAndAdd = function (t, n, r, a) {
      return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t[2] = n[2] + r[2] * a, t;
    }, n.distance = f, n.squaredDistance = M, n.squaredLength = h, n.negate = function (t, n) {
      return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t;
    }, n.inverse = function (t, n) {
      return t[0] = 1 / n[0], t[1] = 1 / n[1], t[2] = 1 / n[2], t;
    }, n.normalize = l, n.dot = v, n.cross = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = r[0],
          i = r[1],
          s = r[2];
      return t[0] = e * s - u * i, t[1] = u * o - a * s, t[2] = a * i - e * o, t;
    }, n.lerp = function (t, n, r, a) {
      var e = n[0],
          u = n[1],
          o = n[2];
      return t[0] = e + a * (r[0] - e), t[1] = u + a * (r[1] - u), t[2] = o + a * (r[2] - o), t;
    }, n.hermite = function (t, n, r, a, e, u) {
      var o = u * u,
          i = o * (2 * u - 3) + 1,
          s = o * (u - 2) + u,
          c = o * (u - 1),
          f = o * (3 - 2 * u);
      return t[0] = n[0] * i + r[0] * s + a[0] * c + e[0] * f, t[1] = n[1] * i + r[1] * s + a[1] * c + e[1] * f, t[2] = n[2] * i + r[2] * s + a[2] * c + e[2] * f, t;
    }, n.bezier = function (t, n, r, a, e, u) {
      var o = 1 - u,
          i = o * o,
          s = u * u,
          c = i * o,
          f = 3 * u * i,
          M = 3 * s * o,
          h = s * u;
      return t[0] = n[0] * c + r[0] * f + a[0] * M + e[0] * h, t[1] = n[1] * c + r[1] * f + a[1] * M + e[1] * h, t[2] = n[2] * c + r[2] * f + a[2] * M + e[2] * h, t;
    }, n.random = function (t, n) {
      n = n || 1;
      var r = 2 * a.RANDOM() * Math.PI,
          e = 2 * a.RANDOM() - 1,
          u = Math.sqrt(1 - e * e) * n;
      return t[0] = Math.cos(r) * u, t[1] = Math.sin(r) * u, t[2] = e * n, t;
    }, n.transformMat4 = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = r[3] * a + r[7] * e + r[11] * u + r[15];
      return o = o || 1, t[0] = (r[0] * a + r[4] * e + r[8] * u + r[12]) / o, t[1] = (r[1] * a + r[5] * e + r[9] * u + r[13]) / o, t[2] = (r[2] * a + r[6] * e + r[10] * u + r[14]) / o, t;
    }, n.transformMat3 = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2];
      return t[0] = a * r[0] + e * r[3] + u * r[6], t[1] = a * r[1] + e * r[4] + u * r[7], t[2] = a * r[2] + e * r[5] + u * r[8], t;
    }, n.transformQuat = function (t, n, r) {
      var a = r[0],
          e = r[1],
          u = r[2],
          o = r[3],
          i = n[0],
          s = n[1],
          c = n[2],
          f = e * c - u * s,
          M = u * i - a * c,
          h = a * s - e * i,
          l = e * h - u * M,
          v = u * f - a * h,
          d = a * M - e * f,
          b = 2 * o;
      return f *= b, M *= b, h *= b, l *= 2, v *= 2, d *= 2, t[0] = i + f + l, t[1] = s + M + v, t[2] = c + h + d, t;
    }, n.rotateX = function (t, n, r, a) {
      var e = [],
          u = [];
      return e[0] = n[0] - r[0], e[1] = n[1] - r[1], e[2] = n[2] - r[2], u[0] = e[0], u[1] = e[1] * Math.cos(a) - e[2] * Math.sin(a), u[2] = e[1] * Math.sin(a) + e[2] * Math.cos(a), t[0] = u[0] + r[0], t[1] = u[1] + r[1], t[2] = u[2] + r[2], t;
    }, n.rotateY = function (t, n, r, a) {
      var e = [],
          u = [];
      return e[0] = n[0] - r[0], e[1] = n[1] - r[1], e[2] = n[2] - r[2], u[0] = e[2] * Math.sin(a) + e[0] * Math.cos(a), u[1] = e[1], u[2] = e[2] * Math.cos(a) - e[0] * Math.sin(a), t[0] = u[0] + r[0], t[1] = u[1] + r[1], t[2] = u[2] + r[2], t;
    }, n.rotateZ = function (t, n, r, a) {
      var e = [],
          u = [];
      return e[0] = n[0] - r[0], e[1] = n[1] - r[1], e[2] = n[2] - r[2], u[0] = e[0] * Math.cos(a) - e[1] * Math.sin(a), u[1] = e[0] * Math.sin(a) + e[1] * Math.cos(a), u[2] = e[2], t[0] = u[0] + r[0], t[1] = u[1] + r[1], t[2] = u[2] + r[2], t;
    }, n.angle = function (t, n) {
      var r = o(t[0], t[1], t[2]),
          a = o(n[0], n[1], n[2]);
      l(r, r), l(a, a);
      var e = v(r, a);
      return e > 1 ? 0 : e < -1 ? Math.PI : Math.acos(e);
    }, n.str = function (t) {
      return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
    }, n.exactEquals = function (t, n) {
      return t[0] === n[0] && t[1] === n[1] && t[2] === n[2];
    }, n.equals = function (t, n) {
      var r = t[0],
          e = t[1],
          u = t[2],
          o = n[0],
          i = n[1],
          s = n[2];
      return Math.abs(r - o) <= a.EPSILON * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(e - i) <= a.EPSILON * Math.max(1, Math.abs(e), Math.abs(i)) && Math.abs(u - s) <= a.EPSILON * Math.max(1, Math.abs(u), Math.abs(s));
    };

    var a = function (t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }(r(0));

    function e() {
      var t = new a.ARRAY_TYPE(3);
      return a.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
    }

    function u(t) {
      var n = t[0],
          r = t[1],
          a = t[2];
      return Math.sqrt(n * n + r * r + a * a);
    }

    function o(t, n, r) {
      var e = new a.ARRAY_TYPE(3);
      return e[0] = t, e[1] = n, e[2] = r, e;
    }

    function i(t, n, r) {
      return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t[2] = n[2] - r[2], t;
    }

    function s(t, n, r) {
      return t[0] = n[0] * r[0], t[1] = n[1] * r[1], t[2] = n[2] * r[2], t;
    }

    function c(t, n, r) {
      return t[0] = n[0] / r[0], t[1] = n[1] / r[1], t[2] = n[2] / r[2], t;
    }

    function f(t, n) {
      var r = n[0] - t[0],
          a = n[1] - t[1],
          e = n[2] - t[2];
      return Math.sqrt(r * r + a * a + e * e);
    }

    function M(t, n) {
      var r = n[0] - t[0],
          a = n[1] - t[1],
          e = n[2] - t[2];
      return r * r + a * a + e * e;
    }

    function h(t) {
      var n = t[0],
          r = t[1],
          a = t[2];
      return n * n + r * r + a * a;
    }

    function l(t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = r * r + a * a + e * e;
      return u > 0 && (u = 1 / Math.sqrt(u), t[0] = n[0] * u, t[1] = n[1] * u, t[2] = n[2] * u), t;
    }

    function v(t, n) {
      return t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
    }

    n.sub = i, n.mul = s, n.div = c, n.dist = f, n.sqrDist = M, n.len = u, n.sqrLen = h, n.forEach = function () {
      var t = e();
      return function (n, r, a, e, u, o) {
        var i = void 0,
            s = void 0;

        for (r || (r = 3), a || (a = 0), s = e ? Math.min(e * r + a, n.length) : n.length, i = a; i < s; i += r) {
          t[0] = n[i], t[1] = n[i + 1], t[2] = n[i + 2], u(t, t, o), n[i] = t[0], n[i + 1] = t[1], n[i + 2] = t[2];
        }

        return n;
      };
    }();
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.setAxes = n.sqlerp = n.rotationTo = n.equals = n.exactEquals = n.normalize = n.sqrLen = n.squaredLength = n.len = n.length = n.lerp = n.dot = n.scale = n.mul = n.add = n.set = n.copy = n.fromValues = n.clone = void 0, n.create = s, n.identity = function (t) {
      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }, n.setAxisAngle = c, n.getAxisAngle = function (t, n) {
      var r = 2 * Math.acos(n[3]),
          e = Math.sin(r / 2);
      e > a.EPSILON ? (t[0] = n[0] / e, t[1] = n[1] / e, t[2] = n[2] / e) : (t[0] = 1, t[1] = 0, t[2] = 0);
      return r;
    }, n.multiply = f, n.rotateX = function (t, n, r) {
      r *= .5;
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = Math.sin(r),
          s = Math.cos(r);
      return t[0] = a * s + o * i, t[1] = e * s + u * i, t[2] = u * s - e * i, t[3] = o * s - a * i, t;
    }, n.rotateY = function (t, n, r) {
      r *= .5;
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = Math.sin(r),
          s = Math.cos(r);
      return t[0] = a * s - u * i, t[1] = e * s + o * i, t[2] = u * s + a * i, t[3] = o * s - e * i, t;
    }, n.rotateZ = function (t, n, r) {
      r *= .5;
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = Math.sin(r),
          s = Math.cos(r);
      return t[0] = a * s + e * i, t[1] = e * s - a * i, t[2] = u * s + o * i, t[3] = o * s - u * i, t;
    }, n.calculateW = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2];
      return t[0] = r, t[1] = a, t[2] = e, t[3] = Math.sqrt(Math.abs(1 - r * r - a * a - e * e)), t;
    }, n.slerp = M, n.random = function (t) {
      var n = a.RANDOM(),
          r = a.RANDOM(),
          e = a.RANDOM(),
          u = Math.sqrt(1 - n),
          o = Math.sqrt(n);
      return t[0] = u * Math.sin(2 * Math.PI * r), t[1] = u * Math.cos(2 * Math.PI * r), t[2] = o * Math.sin(2 * Math.PI * e), t[3] = o * Math.cos(2 * Math.PI * e), t;
    }, n.invert = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = r * r + a * a + e * e + u * u,
          i = o ? 1 / o : 0;
      return t[0] = -r * i, t[1] = -a * i, t[2] = -e * i, t[3] = u * i, t;
    }, n.conjugate = function (t, n) {
      return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t[3] = n[3], t;
    }, n.fromMat3 = h, n.fromEuler = function (t, n, r, a) {
      var e = .5 * Math.PI / 180;
      n *= e, r *= e, a *= e;
      var u = Math.sin(n),
          o = Math.cos(n),
          i = Math.sin(r),
          s = Math.cos(r),
          c = Math.sin(a),
          f = Math.cos(a);
      return t[0] = u * s * f - o * i * c, t[1] = o * i * f + u * s * c, t[2] = o * s * c - u * i * f, t[3] = o * s * f + u * i * c, t;
    }, n.str = function (t) {
      return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    };
    var a = i(r(0)),
        e = i(r(5)),
        u = i(r(2)),
        o = i(r(1));

    function i(t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }

    function s() {
      var t = new a.ARRAY_TYPE(4);
      return a.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
    }

    function c(t, n, r) {
      r *= .5;
      var a = Math.sin(r);
      return t[0] = a * n[0], t[1] = a * n[1], t[2] = a * n[2], t[3] = Math.cos(r), t;
    }

    function f(t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = r[0],
          s = r[1],
          c = r[2],
          f = r[3];
      return t[0] = a * f + o * i + e * c - u * s, t[1] = e * f + o * s + u * i - a * c, t[2] = u * f + o * c + a * s - e * i, t[3] = o * f - a * i - e * s - u * c, t;
    }

    function M(t, n, r, e) {
      var u = n[0],
          o = n[1],
          i = n[2],
          s = n[3],
          c = r[0],
          f = r[1],
          M = r[2],
          h = r[3],
          l = void 0,
          v = void 0,
          d = void 0,
          b = void 0,
          m = void 0;
      return (v = u * c + o * f + i * M + s * h) < 0 && (v = -v, c = -c, f = -f, M = -M, h = -h), 1 - v > a.EPSILON ? (l = Math.acos(v), d = Math.sin(l), b = Math.sin((1 - e) * l) / d, m = Math.sin(e * l) / d) : (b = 1 - e, m = e), t[0] = b * u + m * c, t[1] = b * o + m * f, t[2] = b * i + m * M, t[3] = b * s + m * h, t;
    }

    function h(t, n) {
      var r = n[0] + n[4] + n[8],
          a = void 0;
      if (r > 0) a = Math.sqrt(r + 1), t[3] = .5 * a, a = .5 / a, t[0] = (n[5] - n[7]) * a, t[1] = (n[6] - n[2]) * a, t[2] = (n[1] - n[3]) * a;else {
        var e = 0;
        n[4] > n[0] && (e = 1), n[8] > n[3 * e + e] && (e = 2);
        var u = (e + 1) % 3,
            o = (e + 2) % 3;
        a = Math.sqrt(n[3 * e + e] - n[3 * u + u] - n[3 * o + o] + 1), t[e] = .5 * a, a = .5 / a, t[3] = (n[3 * u + o] - n[3 * o + u]) * a, t[u] = (n[3 * u + e] + n[3 * e + u]) * a, t[o] = (n[3 * o + e] + n[3 * e + o]) * a;
      }
      return t;
    }

    n.clone = o.clone, n.fromValues = o.fromValues, n.copy = o.copy, n.set = o.set, n.add = o.add, n.mul = f, n.scale = o.scale, n.dot = o.dot, n.lerp = o.lerp;
    var l = n.length = o.length,
        v = (n.len = l, n.squaredLength = o.squaredLength),
        d = (n.sqrLen = v, n.normalize = o.normalize);
    n.exactEquals = o.exactEquals, n.equals = o.equals, n.rotationTo = function () {
      var t = u.create(),
          n = u.fromValues(1, 0, 0),
          r = u.fromValues(0, 1, 0);
      return function (a, e, o) {
        var i = u.dot(e, o);
        return i < -.999999 ? (u.cross(t, n, e), u.len(t) < 1e-6 && u.cross(t, r, e), u.normalize(t, t), c(a, t, Math.PI), a) : i > .999999 ? (a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1, a) : (u.cross(t, e, o), a[0] = t[0], a[1] = t[1], a[2] = t[2], a[3] = 1 + i, d(a, a));
      };
    }(), n.sqlerp = function () {
      var t = s(),
          n = s();
      return function (r, a, e, u, o, i) {
        return M(t, a, o, i), M(n, e, u, i), M(r, t, n, 2 * i * (1 - i)), r;
      };
    }(), n.setAxes = function () {
      var t = e.create();
      return function (n, r, a, e) {
        return t[0] = a[0], t[3] = a[1], t[6] = a[2], t[1] = e[0], t[4] = e[1], t[7] = e[2], t[2] = -r[0], t[5] = -r[1], t[8] = -r[2], d(n, h(n, t));
      };
    }();
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.sub = n.mul = void 0, n.create = function () {
      var t = new a.ARRAY_TYPE(16);
      a.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0);
      return t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
    }, n.clone = function (t) {
      var n = new a.ARRAY_TYPE(16);
      return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n[9] = t[9], n[10] = t[10], n[11] = t[11], n[12] = t[12], n[13] = t[13], n[14] = t[14], n[15] = t[15], n;
    }, n.copy = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t;
    }, n.fromValues = function (t, n, r, e, u, o, i, s, c, f, M, h, l, v, d, b) {
      var m = new a.ARRAY_TYPE(16);
      return m[0] = t, m[1] = n, m[2] = r, m[3] = e, m[4] = u, m[5] = o, m[6] = i, m[7] = s, m[8] = c, m[9] = f, m[10] = M, m[11] = h, m[12] = l, m[13] = v, m[14] = d, m[15] = b, m;
    }, n.set = function (t, n, r, a, e, u, o, i, s, c, f, M, h, l, v, d, b) {
      return t[0] = n, t[1] = r, t[2] = a, t[3] = e, t[4] = u, t[5] = o, t[6] = i, t[7] = s, t[8] = c, t[9] = f, t[10] = M, t[11] = h, t[12] = l, t[13] = v, t[14] = d, t[15] = b, t;
    }, n.identity = e, n.transpose = function (t, n) {
      if (t === n) {
        var r = n[1],
            a = n[2],
            e = n[3],
            u = n[6],
            o = n[7],
            i = n[11];
        t[1] = n[4], t[2] = n[8], t[3] = n[12], t[4] = r, t[6] = n[9], t[7] = n[13], t[8] = a, t[9] = u, t[11] = n[14], t[12] = e, t[13] = o, t[14] = i;
      } else t[0] = n[0], t[1] = n[4], t[2] = n[8], t[3] = n[12], t[4] = n[1], t[5] = n[5], t[6] = n[9], t[7] = n[13], t[8] = n[2], t[9] = n[6], t[10] = n[10], t[11] = n[14], t[12] = n[3], t[13] = n[7], t[14] = n[11], t[15] = n[15];

      return t;
    }, n.invert = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = n[4],
          i = n[5],
          s = n[6],
          c = n[7],
          f = n[8],
          M = n[9],
          h = n[10],
          l = n[11],
          v = n[12],
          d = n[13],
          b = n[14],
          m = n[15],
          p = r * i - a * o,
          P = r * s - e * o,
          A = r * c - u * o,
          E = a * s - e * i,
          O = a * c - u * i,
          R = e * c - u * s,
          y = f * d - M * v,
          q = f * b - h * v,
          x = f * m - l * v,
          _ = M * b - h * d,
          Y = M * m - l * d,
          L = h * m - l * b,
          S = p * L - P * Y + A * _ + E * x - O * q + R * y;

      if (!S) return null;
      return S = 1 / S, t[0] = (i * L - s * Y + c * _) * S, t[1] = (e * Y - a * L - u * _) * S, t[2] = (d * R - b * O + m * E) * S, t[3] = (h * O - M * R - l * E) * S, t[4] = (s * x - o * L - c * q) * S, t[5] = (r * L - e * x + u * q) * S, t[6] = (b * A - v * R - m * P) * S, t[7] = (f * R - h * A + l * P) * S, t[8] = (o * Y - i * x + c * y) * S, t[9] = (a * x - r * Y - u * y) * S, t[10] = (v * O - d * A + m * p) * S, t[11] = (M * A - f * O - l * p) * S, t[12] = (i * q - o * _ - s * y) * S, t[13] = (r * _ - a * q + e * y) * S, t[14] = (d * P - v * E - b * p) * S, t[15] = (f * E - M * P + h * p) * S, t;
    }, n.adjoint = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = n[4],
          i = n[5],
          s = n[6],
          c = n[7],
          f = n[8],
          M = n[9],
          h = n[10],
          l = n[11],
          v = n[12],
          d = n[13],
          b = n[14],
          m = n[15];
      return t[0] = i * (h * m - l * b) - M * (s * m - c * b) + d * (s * l - c * h), t[1] = -(a * (h * m - l * b) - M * (e * m - u * b) + d * (e * l - u * h)), t[2] = a * (s * m - c * b) - i * (e * m - u * b) + d * (e * c - u * s), t[3] = -(a * (s * l - c * h) - i * (e * l - u * h) + M * (e * c - u * s)), t[4] = -(o * (h * m - l * b) - f * (s * m - c * b) + v * (s * l - c * h)), t[5] = r * (h * m - l * b) - f * (e * m - u * b) + v * (e * l - u * h), t[6] = -(r * (s * m - c * b) - o * (e * m - u * b) + v * (e * c - u * s)), t[7] = r * (s * l - c * h) - o * (e * l - u * h) + f * (e * c - u * s), t[8] = o * (M * m - l * d) - f * (i * m - c * d) + v * (i * l - c * M), t[9] = -(r * (M * m - l * d) - f * (a * m - u * d) + v * (a * l - u * M)), t[10] = r * (i * m - c * d) - o * (a * m - u * d) + v * (a * c - u * i), t[11] = -(r * (i * l - c * M) - o * (a * l - u * M) + f * (a * c - u * i)), t[12] = -(o * (M * b - h * d) - f * (i * b - s * d) + v * (i * h - s * M)), t[13] = r * (M * b - h * d) - f * (a * b - e * d) + v * (a * h - e * M), t[14] = -(r * (i * b - s * d) - o * (a * b - e * d) + v * (a * s - e * i)), t[15] = r * (i * h - s * M) - o * (a * h - e * M) + f * (a * s - e * i), t;
    }, n.determinant = function (t) {
      var n = t[0],
          r = t[1],
          a = t[2],
          e = t[3],
          u = t[4],
          o = t[5],
          i = t[6],
          s = t[7],
          c = t[8],
          f = t[9],
          M = t[10],
          h = t[11],
          l = t[12],
          v = t[13],
          d = t[14],
          b = t[15];
      return (n * o - r * u) * (M * b - h * d) - (n * i - a * u) * (f * b - h * v) + (n * s - e * u) * (f * d - M * v) + (r * i - a * o) * (c * b - h * l) - (r * s - e * o) * (c * d - M * l) + (a * s - e * i) * (c * v - f * l);
    }, n.multiply = u, n.translate = function (t, n, r) {
      var a = r[0],
          e = r[1],
          u = r[2],
          o = void 0,
          i = void 0,
          s = void 0,
          c = void 0,
          f = void 0,
          M = void 0,
          h = void 0,
          l = void 0,
          v = void 0,
          d = void 0,
          b = void 0,
          m = void 0;
      n === t ? (t[12] = n[0] * a + n[4] * e + n[8] * u + n[12], t[13] = n[1] * a + n[5] * e + n[9] * u + n[13], t[14] = n[2] * a + n[6] * e + n[10] * u + n[14], t[15] = n[3] * a + n[7] * e + n[11] * u + n[15]) : (o = n[0], i = n[1], s = n[2], c = n[3], f = n[4], M = n[5], h = n[6], l = n[7], v = n[8], d = n[9], b = n[10], m = n[11], t[0] = o, t[1] = i, t[2] = s, t[3] = c, t[4] = f, t[5] = M, t[6] = h, t[7] = l, t[8] = v, t[9] = d, t[10] = b, t[11] = m, t[12] = o * a + f * e + v * u + n[12], t[13] = i * a + M * e + d * u + n[13], t[14] = s * a + h * e + b * u + n[14], t[15] = c * a + l * e + m * u + n[15]);
      return t;
    }, n.scale = function (t, n, r) {
      var a = r[0],
          e = r[1],
          u = r[2];
      return t[0] = n[0] * a, t[1] = n[1] * a, t[2] = n[2] * a, t[3] = n[3] * a, t[4] = n[4] * e, t[5] = n[5] * e, t[6] = n[6] * e, t[7] = n[7] * e, t[8] = n[8] * u, t[9] = n[9] * u, t[10] = n[10] * u, t[11] = n[11] * u, t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], t;
    }, n.rotate = function (t, n, r, e) {
      var u = e[0],
          o = e[1],
          i = e[2],
          s = Math.sqrt(u * u + o * o + i * i),
          c = void 0,
          f = void 0,
          M = void 0,
          h = void 0,
          l = void 0,
          v = void 0,
          d = void 0,
          b = void 0,
          m = void 0,
          p = void 0,
          P = void 0,
          A = void 0,
          E = void 0,
          O = void 0,
          R = void 0,
          y = void 0,
          q = void 0,
          x = void 0,
          _ = void 0,
          Y = void 0,
          L = void 0,
          S = void 0,
          w = void 0,
          I = void 0;

      if (s < a.EPSILON) return null;
      u *= s = 1 / s, o *= s, i *= s, c = Math.sin(r), f = Math.cos(r), M = 1 - f, h = n[0], l = n[1], v = n[2], d = n[3], b = n[4], m = n[5], p = n[6], P = n[7], A = n[8], E = n[9], O = n[10], R = n[11], y = u * u * M + f, q = o * u * M + i * c, x = i * u * M - o * c, _ = u * o * M - i * c, Y = o * o * M + f, L = i * o * M + u * c, S = u * i * M + o * c, w = o * i * M - u * c, I = i * i * M + f, t[0] = h * y + b * q + A * x, t[1] = l * y + m * q + E * x, t[2] = v * y + p * q + O * x, t[3] = d * y + P * q + R * x, t[4] = h * _ + b * Y + A * L, t[5] = l * _ + m * Y + E * L, t[6] = v * _ + p * Y + O * L, t[7] = d * _ + P * Y + R * L, t[8] = h * S + b * w + A * I, t[9] = l * S + m * w + E * I, t[10] = v * S + p * w + O * I, t[11] = d * S + P * w + R * I, n !== t && (t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]);
      return t;
    }, n.rotateX = function (t, n, r) {
      var a = Math.sin(r),
          e = Math.cos(r),
          u = n[4],
          o = n[5],
          i = n[6],
          s = n[7],
          c = n[8],
          f = n[9],
          M = n[10],
          h = n[11];
      n !== t && (t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]);
      return t[4] = u * e + c * a, t[5] = o * e + f * a, t[6] = i * e + M * a, t[7] = s * e + h * a, t[8] = c * e - u * a, t[9] = f * e - o * a, t[10] = M * e - i * a, t[11] = h * e - s * a, t;
    }, n.rotateY = function (t, n, r) {
      var a = Math.sin(r),
          e = Math.cos(r),
          u = n[0],
          o = n[1],
          i = n[2],
          s = n[3],
          c = n[8],
          f = n[9],
          M = n[10],
          h = n[11];
      n !== t && (t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]);
      return t[0] = u * e - c * a, t[1] = o * e - f * a, t[2] = i * e - M * a, t[3] = s * e - h * a, t[8] = u * a + c * e, t[9] = o * a + f * e, t[10] = i * a + M * e, t[11] = s * a + h * e, t;
    }, n.rotateZ = function (t, n, r) {
      var a = Math.sin(r),
          e = Math.cos(r),
          u = n[0],
          o = n[1],
          i = n[2],
          s = n[3],
          c = n[4],
          f = n[5],
          M = n[6],
          h = n[7];
      n !== t && (t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15]);
      return t[0] = u * e + c * a, t[1] = o * e + f * a, t[2] = i * e + M * a, t[3] = s * e + h * a, t[4] = c * e - u * a, t[5] = f * e - o * a, t[6] = M * e - i * a, t[7] = h * e - s * a, t;
    }, n.fromTranslation = function (t, n) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t;
    }, n.fromScaling = function (t, n) {
      return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = n[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, n.fromRotation = function (t, n, r) {
      var e = r[0],
          u = r[1],
          o = r[2],
          i = Math.sqrt(e * e + u * u + o * o),
          s = void 0,
          c = void 0,
          f = void 0;
      if (i < a.EPSILON) return null;
      return e *= i = 1 / i, u *= i, o *= i, s = Math.sin(n), c = Math.cos(n), f = 1 - c, t[0] = e * e * f + c, t[1] = u * e * f + o * s, t[2] = o * e * f - u * s, t[3] = 0, t[4] = e * u * f - o * s, t[5] = u * u * f + c, t[6] = o * u * f + e * s, t[7] = 0, t[8] = e * o * f + u * s, t[9] = u * o * f - e * s, t[10] = o * o * f + c, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, n.fromXRotation = function (t, n) {
      var r = Math.sin(n),
          a = Math.cos(n);
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = r, t[7] = 0, t[8] = 0, t[9] = -r, t[10] = a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, n.fromYRotation = function (t, n) {
      var r = Math.sin(n),
          a = Math.cos(n);
      return t[0] = a, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r, t[9] = 0, t[10] = a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, n.fromZRotation = function (t, n) {
      var r = Math.sin(n),
          a = Math.cos(n);
      return t[0] = a, t[1] = r, t[2] = 0, t[3] = 0, t[4] = -r, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, n.fromRotationTranslation = o, n.fromQuat2 = function (t, n) {
      var r = new a.ARRAY_TYPE(3),
          e = -n[0],
          u = -n[1],
          i = -n[2],
          s = n[3],
          c = n[4],
          f = n[5],
          M = n[6],
          h = n[7],
          l = e * e + u * u + i * i + s * s;
      l > 0 ? (r[0] = 2 * (c * s + h * e + f * i - M * u) / l, r[1] = 2 * (f * s + h * u + M * e - c * i) / l, r[2] = 2 * (M * s + h * i + c * u - f * e) / l) : (r[0] = 2 * (c * s + h * e + f * i - M * u), r[1] = 2 * (f * s + h * u + M * e - c * i), r[2] = 2 * (M * s + h * i + c * u - f * e));
      return o(t, n, r), t;
    }, n.getTranslation = function (t, n) {
      return t[0] = n[12], t[1] = n[13], t[2] = n[14], t;
    }, n.getScaling = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[4],
          o = n[5],
          i = n[6],
          s = n[8],
          c = n[9],
          f = n[10];
      return t[0] = Math.sqrt(r * r + a * a + e * e), t[1] = Math.sqrt(u * u + o * o + i * i), t[2] = Math.sqrt(s * s + c * c + f * f), t;
    }, n.getRotation = function (t, n) {
      var r = n[0] + n[5] + n[10],
          a = 0;
      r > 0 ? (a = 2 * Math.sqrt(r + 1), t[3] = .25 * a, t[0] = (n[6] - n[9]) / a, t[1] = (n[8] - n[2]) / a, t[2] = (n[1] - n[4]) / a) : n[0] > n[5] && n[0] > n[10] ? (a = 2 * Math.sqrt(1 + n[0] - n[5] - n[10]), t[3] = (n[6] - n[9]) / a, t[0] = .25 * a, t[1] = (n[1] + n[4]) / a, t[2] = (n[8] + n[2]) / a) : n[5] > n[10] ? (a = 2 * Math.sqrt(1 + n[5] - n[0] - n[10]), t[3] = (n[8] - n[2]) / a, t[0] = (n[1] + n[4]) / a, t[1] = .25 * a, t[2] = (n[6] + n[9]) / a) : (a = 2 * Math.sqrt(1 + n[10] - n[0] - n[5]), t[3] = (n[1] - n[4]) / a, t[0] = (n[8] + n[2]) / a, t[1] = (n[6] + n[9]) / a, t[2] = .25 * a);
      return t;
    }, n.fromRotationTranslationScale = function (t, n, r, a) {
      var e = n[0],
          u = n[1],
          o = n[2],
          i = n[3],
          s = e + e,
          c = u + u,
          f = o + o,
          M = e * s,
          h = e * c,
          l = e * f,
          v = u * c,
          d = u * f,
          b = o * f,
          m = i * s,
          p = i * c,
          P = i * f,
          A = a[0],
          E = a[1],
          O = a[2];
      return t[0] = (1 - (v + b)) * A, t[1] = (h + P) * A, t[2] = (l - p) * A, t[3] = 0, t[4] = (h - P) * E, t[5] = (1 - (M + b)) * E, t[6] = (d + m) * E, t[7] = 0, t[8] = (l + p) * O, t[9] = (d - m) * O, t[10] = (1 - (M + v)) * O, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;
    }, n.fromRotationTranslationScaleOrigin = function (t, n, r, a, e) {
      var u = n[0],
          o = n[1],
          i = n[2],
          s = n[3],
          c = u + u,
          f = o + o,
          M = i + i,
          h = u * c,
          l = u * f,
          v = u * M,
          d = o * f,
          b = o * M,
          m = i * M,
          p = s * c,
          P = s * f,
          A = s * M,
          E = a[0],
          O = a[1],
          R = a[2],
          y = e[0],
          q = e[1],
          x = e[2],
          _ = (1 - (d + m)) * E,
          Y = (l + A) * E,
          L = (v - P) * E,
          S = (l - A) * O,
          w = (1 - (h + m)) * O,
          I = (b + p) * O,
          N = (v + P) * R,
          g = (b - p) * R,
          T = (1 - (h + d)) * R;

      return t[0] = _, t[1] = Y, t[2] = L, t[3] = 0, t[4] = S, t[5] = w, t[6] = I, t[7] = 0, t[8] = N, t[9] = g, t[10] = T, t[11] = 0, t[12] = r[0] + y - (_ * y + S * q + N * x), t[13] = r[1] + q - (Y * y + w * q + g * x), t[14] = r[2] + x - (L * y + I * q + T * x), t[15] = 1, t;
    }, n.fromQuat = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = r + r,
          i = a + a,
          s = e + e,
          c = r * o,
          f = a * o,
          M = a * i,
          h = e * o,
          l = e * i,
          v = e * s,
          d = u * o,
          b = u * i,
          m = u * s;
      return t[0] = 1 - M - v, t[1] = f + m, t[2] = h - b, t[3] = 0, t[4] = f - m, t[5] = 1 - c - v, t[6] = l + d, t[7] = 0, t[8] = h + b, t[9] = l - d, t[10] = 1 - c - M, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }, n.frustum = function (t, n, r, a, e, u, o) {
      var i = 1 / (r - n),
          s = 1 / (e - a),
          c = 1 / (u - o);
      return t[0] = 2 * u * i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * u * s, t[6] = 0, t[7] = 0, t[8] = (r + n) * i, t[9] = (e + a) * s, t[10] = (o + u) * c, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = o * u * 2 * c, t[15] = 0, t;
    }, n.perspective = function (t, n, r, a, e) {
      var u = 1 / Math.tan(n / 2),
          o = void 0;
      t[0] = u / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = u, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != e && e !== 1 / 0 ? (o = 1 / (a - e), t[10] = (e + a) * o, t[14] = 2 * e * a * o) : (t[10] = -1, t[14] = -2 * a);
      return t;
    }, n.perspectiveFromFieldOfView = function (t, n, r, a) {
      var e = Math.tan(n.upDegrees * Math.PI / 180),
          u = Math.tan(n.downDegrees * Math.PI / 180),
          o = Math.tan(n.leftDegrees * Math.PI / 180),
          i = Math.tan(n.rightDegrees * Math.PI / 180),
          s = 2 / (o + i),
          c = 2 / (e + u);
      return t[0] = s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = c, t[6] = 0, t[7] = 0, t[8] = -(o - i) * s * .5, t[9] = (e - u) * c * .5, t[10] = a / (r - a), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = a * r / (r - a), t[15] = 0, t;
    }, n.ortho = function (t, n, r, a, e, u, o) {
      var i = 1 / (n - r),
          s = 1 / (a - e),
          c = 1 / (u - o);
      return t[0] = -2 * i, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * s, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * c, t[11] = 0, t[12] = (n + r) * i, t[13] = (e + a) * s, t[14] = (o + u) * c, t[15] = 1, t;
    }, n.lookAt = function (t, n, r, u) {
      var o = void 0,
          i = void 0,
          s = void 0,
          c = void 0,
          f = void 0,
          M = void 0,
          h = void 0,
          l = void 0,
          v = void 0,
          d = void 0,
          b = n[0],
          m = n[1],
          p = n[2],
          P = u[0],
          A = u[1],
          E = u[2],
          O = r[0],
          R = r[1],
          y = r[2];
      if (Math.abs(b - O) < a.EPSILON && Math.abs(m - R) < a.EPSILON && Math.abs(p - y) < a.EPSILON) return e(t);
      h = b - O, l = m - R, v = p - y, d = 1 / Math.sqrt(h * h + l * l + v * v), o = A * (v *= d) - E * (l *= d), i = E * (h *= d) - P * v, s = P * l - A * h, (d = Math.sqrt(o * o + i * i + s * s)) ? (o *= d = 1 / d, i *= d, s *= d) : (o = 0, i = 0, s = 0);
      c = l * s - v * i, f = v * o - h * s, M = h * i - l * o, (d = Math.sqrt(c * c + f * f + M * M)) ? (c *= d = 1 / d, f *= d, M *= d) : (c = 0, f = 0, M = 0);
      return t[0] = o, t[1] = c, t[2] = h, t[3] = 0, t[4] = i, t[5] = f, t[6] = l, t[7] = 0, t[8] = s, t[9] = M, t[10] = v, t[11] = 0, t[12] = -(o * b + i * m + s * p), t[13] = -(c * b + f * m + M * p), t[14] = -(h * b + l * m + v * p), t[15] = 1, t;
    }, n.targetTo = function (t, n, r, a) {
      var e = n[0],
          u = n[1],
          o = n[2],
          i = a[0],
          s = a[1],
          c = a[2],
          f = e - r[0],
          M = u - r[1],
          h = o - r[2],
          l = f * f + M * M + h * h;
      l > 0 && (l = 1 / Math.sqrt(l), f *= l, M *= l, h *= l);
      var v = s * h - c * M,
          d = c * f - i * h,
          b = i * M - s * f;
      (l = v * v + d * d + b * b) > 0 && (l = 1 / Math.sqrt(l), v *= l, d *= l, b *= l);
      return t[0] = v, t[1] = d, t[2] = b, t[3] = 0, t[4] = M * b - h * d, t[5] = h * v - f * b, t[6] = f * d - M * v, t[7] = 0, t[8] = f, t[9] = M, t[10] = h, t[11] = 0, t[12] = e, t[13] = u, t[14] = o, t[15] = 1, t;
    }, n.str = function (t) {
      return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
    }, n.frob = function (t) {
      return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2) + Math.pow(t[9], 2) + Math.pow(t[10], 2) + Math.pow(t[11], 2) + Math.pow(t[12], 2) + Math.pow(t[13], 2) + Math.pow(t[14], 2) + Math.pow(t[15], 2));
    }, n.add = function (t, n, r) {
      return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t[3] = n[3] + r[3], t[4] = n[4] + r[4], t[5] = n[5] + r[5], t[6] = n[6] + r[6], t[7] = n[7] + r[7], t[8] = n[8] + r[8], t[9] = n[9] + r[9], t[10] = n[10] + r[10], t[11] = n[11] + r[11], t[12] = n[12] + r[12], t[13] = n[13] + r[13], t[14] = n[14] + r[14], t[15] = n[15] + r[15], t;
    }, n.subtract = i, n.multiplyScalar = function (t, n, r) {
      return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = n[3] * r, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = n[7] * r, t[8] = n[8] * r, t[9] = n[9] * r, t[10] = n[10] * r, t[11] = n[11] * r, t[12] = n[12] * r, t[13] = n[13] * r, t[14] = n[14] * r, t[15] = n[15] * r, t;
    }, n.multiplyScalarAndAdd = function (t, n, r, a) {
      return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t[2] = n[2] + r[2] * a, t[3] = n[3] + r[3] * a, t[4] = n[4] + r[4] * a, t[5] = n[5] + r[5] * a, t[6] = n[6] + r[6] * a, t[7] = n[7] + r[7] * a, t[8] = n[8] + r[8] * a, t[9] = n[9] + r[9] * a, t[10] = n[10] + r[10] * a, t[11] = n[11] + r[11] * a, t[12] = n[12] + r[12] * a, t[13] = n[13] + r[13] * a, t[14] = n[14] + r[14] * a, t[15] = n[15] + r[15] * a, t;
    }, n.exactEquals = function (t, n) {
      return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3] && t[4] === n[4] && t[5] === n[5] && t[6] === n[6] && t[7] === n[7] && t[8] === n[8] && t[9] === n[9] && t[10] === n[10] && t[11] === n[11] && t[12] === n[12] && t[13] === n[13] && t[14] === n[14] && t[15] === n[15];
    }, n.equals = function (t, n) {
      var r = t[0],
          e = t[1],
          u = t[2],
          o = t[3],
          i = t[4],
          s = t[5],
          c = t[6],
          f = t[7],
          M = t[8],
          h = t[9],
          l = t[10],
          v = t[11],
          d = t[12],
          b = t[13],
          m = t[14],
          p = t[15],
          P = n[0],
          A = n[1],
          E = n[2],
          O = n[3],
          R = n[4],
          y = n[5],
          q = n[6],
          x = n[7],
          _ = n[8],
          Y = n[9],
          L = n[10],
          S = n[11],
          w = n[12],
          I = n[13],
          N = n[14],
          g = n[15];
      return Math.abs(r - P) <= a.EPSILON * Math.max(1, Math.abs(r), Math.abs(P)) && Math.abs(e - A) <= a.EPSILON * Math.max(1, Math.abs(e), Math.abs(A)) && Math.abs(u - E) <= a.EPSILON * Math.max(1, Math.abs(u), Math.abs(E)) && Math.abs(o - O) <= a.EPSILON * Math.max(1, Math.abs(o), Math.abs(O)) && Math.abs(i - R) <= a.EPSILON * Math.max(1, Math.abs(i), Math.abs(R)) && Math.abs(s - y) <= a.EPSILON * Math.max(1, Math.abs(s), Math.abs(y)) && Math.abs(c - q) <= a.EPSILON * Math.max(1, Math.abs(c), Math.abs(q)) && Math.abs(f - x) <= a.EPSILON * Math.max(1, Math.abs(f), Math.abs(x)) && Math.abs(M - _) <= a.EPSILON * Math.max(1, Math.abs(M), Math.abs(_)) && Math.abs(h - Y) <= a.EPSILON * Math.max(1, Math.abs(h), Math.abs(Y)) && Math.abs(l - L) <= a.EPSILON * Math.max(1, Math.abs(l), Math.abs(L)) && Math.abs(v - S) <= a.EPSILON * Math.max(1, Math.abs(v), Math.abs(S)) && Math.abs(d - w) <= a.EPSILON * Math.max(1, Math.abs(d), Math.abs(w)) && Math.abs(b - I) <= a.EPSILON * Math.max(1, Math.abs(b), Math.abs(I)) && Math.abs(m - N) <= a.EPSILON * Math.max(1, Math.abs(m), Math.abs(N)) && Math.abs(p - g) <= a.EPSILON * Math.max(1, Math.abs(p), Math.abs(g));
    };

    var a = function (t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }(r(0));

    function e(t) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }

    function u(t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = n[4],
          s = n[5],
          c = n[6],
          f = n[7],
          M = n[8],
          h = n[9],
          l = n[10],
          v = n[11],
          d = n[12],
          b = n[13],
          m = n[14],
          p = n[15],
          P = r[0],
          A = r[1],
          E = r[2],
          O = r[3];
      return t[0] = P * a + A * i + E * M + O * d, t[1] = P * e + A * s + E * h + O * b, t[2] = P * u + A * c + E * l + O * m, t[3] = P * o + A * f + E * v + O * p, P = r[4], A = r[5], E = r[6], O = r[7], t[4] = P * a + A * i + E * M + O * d, t[5] = P * e + A * s + E * h + O * b, t[6] = P * u + A * c + E * l + O * m, t[7] = P * o + A * f + E * v + O * p, P = r[8], A = r[9], E = r[10], O = r[11], t[8] = P * a + A * i + E * M + O * d, t[9] = P * e + A * s + E * h + O * b, t[10] = P * u + A * c + E * l + O * m, t[11] = P * o + A * f + E * v + O * p, P = r[12], A = r[13], E = r[14], O = r[15], t[12] = P * a + A * i + E * M + O * d, t[13] = P * e + A * s + E * h + O * b, t[14] = P * u + A * c + E * l + O * m, t[15] = P * o + A * f + E * v + O * p, t;
    }

    function o(t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = a + a,
          s = e + e,
          c = u + u,
          f = a * i,
          M = a * s,
          h = a * c,
          l = e * s,
          v = e * c,
          d = u * c,
          b = o * i,
          m = o * s,
          p = o * c;
      return t[0] = 1 - (l + d), t[1] = M + p, t[2] = h - m, t[3] = 0, t[4] = M - p, t[5] = 1 - (f + d), t[6] = v + b, t[7] = 0, t[8] = h + m, t[9] = v - b, t[10] = 1 - (f + l), t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;
    }

    function i(t, n, r) {
      return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t[2] = n[2] - r[2], t[3] = n[3] - r[3], t[4] = n[4] - r[4], t[5] = n[5] - r[5], t[6] = n[6] - r[6], t[7] = n[7] - r[7], t[8] = n[8] - r[8], t[9] = n[9] - r[9], t[10] = n[10] - r[10], t[11] = n[11] - r[11], t[12] = n[12] - r[12], t[13] = n[13] - r[13], t[14] = n[14] - r[14], t[15] = n[15] - r[15], t;
    }

    n.mul = u, n.sub = i;
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.sub = n.mul = void 0, n.create = function () {
      var t = new a.ARRAY_TYPE(9);
      a.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0);
      return t[0] = 1, t[4] = 1, t[8] = 1, t;
    }, n.fromMat4 = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[4], t[4] = n[5], t[5] = n[6], t[6] = n[8], t[7] = n[9], t[8] = n[10], t;
    }, n.clone = function (t) {
      var n = new a.ARRAY_TYPE(9);
      return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n[8] = t[8], n;
    }, n.copy = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t;
    }, n.fromValues = function (t, n, r, e, u, o, i, s, c) {
      var f = new a.ARRAY_TYPE(9);
      return f[0] = t, f[1] = n, f[2] = r, f[3] = e, f[4] = u, f[5] = o, f[6] = i, f[7] = s, f[8] = c, f;
    }, n.set = function (t, n, r, a, e, u, o, i, s, c) {
      return t[0] = n, t[1] = r, t[2] = a, t[3] = e, t[4] = u, t[5] = o, t[6] = i, t[7] = s, t[8] = c, t;
    }, n.identity = function (t) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }, n.transpose = function (t, n) {
      if (t === n) {
        var r = n[1],
            a = n[2],
            e = n[5];
        t[1] = n[3], t[2] = n[6], t[3] = r, t[5] = n[7], t[6] = a, t[7] = e;
      } else t[0] = n[0], t[1] = n[3], t[2] = n[6], t[3] = n[1], t[4] = n[4], t[5] = n[7], t[6] = n[2], t[7] = n[5], t[8] = n[8];

      return t;
    }, n.invert = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = n[4],
          i = n[5],
          s = n[6],
          c = n[7],
          f = n[8],
          M = f * o - i * c,
          h = -f * u + i * s,
          l = c * u - o * s,
          v = r * M + a * h + e * l;
      if (!v) return null;
      return v = 1 / v, t[0] = M * v, t[1] = (-f * a + e * c) * v, t[2] = (i * a - e * o) * v, t[3] = h * v, t[4] = (f * r - e * s) * v, t[5] = (-i * r + e * u) * v, t[6] = l * v, t[7] = (-c * r + a * s) * v, t[8] = (o * r - a * u) * v, t;
    }, n.adjoint = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = n[4],
          i = n[5],
          s = n[6],
          c = n[7],
          f = n[8];
      return t[0] = o * f - i * c, t[1] = e * c - a * f, t[2] = a * i - e * o, t[3] = i * s - u * f, t[4] = r * f - e * s, t[5] = e * u - r * i, t[6] = u * c - o * s, t[7] = a * s - r * c, t[8] = r * o - a * u, t;
    }, n.determinant = function (t) {
      var n = t[0],
          r = t[1],
          a = t[2],
          e = t[3],
          u = t[4],
          o = t[5],
          i = t[6],
          s = t[7],
          c = t[8];
      return n * (c * u - o * s) + r * (-c * e + o * i) + a * (s * e - u * i);
    }, n.multiply = e, n.translate = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = n[4],
          s = n[5],
          c = n[6],
          f = n[7],
          M = n[8],
          h = r[0],
          l = r[1];
      return t[0] = a, t[1] = e, t[2] = u, t[3] = o, t[4] = i, t[5] = s, t[6] = h * a + l * o + c, t[7] = h * e + l * i + f, t[8] = h * u + l * s + M, t;
    }, n.rotate = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = n[4],
          s = n[5],
          c = n[6],
          f = n[7],
          M = n[8],
          h = Math.sin(r),
          l = Math.cos(r);
      return t[0] = l * a + h * o, t[1] = l * e + h * i, t[2] = l * u + h * s, t[3] = l * o - h * a, t[4] = l * i - h * e, t[5] = l * s - h * u, t[6] = c, t[7] = f, t[8] = M, t;
    }, n.scale = function (t, n, r) {
      var a = r[0],
          e = r[1];
      return t[0] = a * n[0], t[1] = a * n[1], t[2] = a * n[2], t[3] = e * n[3], t[4] = e * n[4], t[5] = e * n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t;
    }, n.fromTranslation = function (t, n) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = n[0], t[7] = n[1], t[8] = 1, t;
    }, n.fromRotation = function (t, n) {
      var r = Math.sin(n),
          a = Math.cos(n);
      return t[0] = a, t[1] = r, t[2] = 0, t[3] = -r, t[4] = a, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }, n.fromScaling = function (t, n) {
      return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = n[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }, n.fromMat2d = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = 0, t[3] = n[2], t[4] = n[3], t[5] = 0, t[6] = n[4], t[7] = n[5], t[8] = 1, t;
    }, n.fromQuat = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = r + r,
          i = a + a,
          s = e + e,
          c = r * o,
          f = a * o,
          M = a * i,
          h = e * o,
          l = e * i,
          v = e * s,
          d = u * o,
          b = u * i,
          m = u * s;
      return t[0] = 1 - M - v, t[3] = f - m, t[6] = h + b, t[1] = f + m, t[4] = 1 - c - v, t[7] = l - d, t[2] = h - b, t[5] = l + d, t[8] = 1 - c - M, t;
    }, n.normalFromMat4 = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = n[4],
          i = n[5],
          s = n[6],
          c = n[7],
          f = n[8],
          M = n[9],
          h = n[10],
          l = n[11],
          v = n[12],
          d = n[13],
          b = n[14],
          m = n[15],
          p = r * i - a * o,
          P = r * s - e * o,
          A = r * c - u * o,
          E = a * s - e * i,
          O = a * c - u * i,
          R = e * c - u * s,
          y = f * d - M * v,
          q = f * b - h * v,
          x = f * m - l * v,
          _ = M * b - h * d,
          Y = M * m - l * d,
          L = h * m - l * b,
          S = p * L - P * Y + A * _ + E * x - O * q + R * y;

      if (!S) return null;
      return S = 1 / S, t[0] = (i * L - s * Y + c * _) * S, t[1] = (s * x - o * L - c * q) * S, t[2] = (o * Y - i * x + c * y) * S, t[3] = (e * Y - a * L - u * _) * S, t[4] = (r * L - e * x + u * q) * S, t[5] = (a * x - r * Y - u * y) * S, t[6] = (d * R - b * O + m * E) * S, t[7] = (b * A - v * R - m * P) * S, t[8] = (v * O - d * A + m * p) * S, t;
    }, n.projection = function (t, n, r) {
      return t[0] = 2 / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
    }, n.str = function (t) {
      return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
    }, n.frob = function (t) {
      return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + Math.pow(t[6], 2) + Math.pow(t[7], 2) + Math.pow(t[8], 2));
    }, n.add = function (t, n, r) {
      return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t[3] = n[3] + r[3], t[4] = n[4] + r[4], t[5] = n[5] + r[5], t[6] = n[6] + r[6], t[7] = n[7] + r[7], t[8] = n[8] + r[8], t;
    }, n.subtract = u, n.multiplyScalar = function (t, n, r) {
      return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = n[3] * r, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = n[7] * r, t[8] = n[8] * r, t;
    }, n.multiplyScalarAndAdd = function (t, n, r, a) {
      return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t[2] = n[2] + r[2] * a, t[3] = n[3] + r[3] * a, t[4] = n[4] + r[4] * a, t[5] = n[5] + r[5] * a, t[6] = n[6] + r[6] * a, t[7] = n[7] + r[7] * a, t[8] = n[8] + r[8] * a, t;
    }, n.exactEquals = function (t, n) {
      return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3] && t[4] === n[4] && t[5] === n[5] && t[6] === n[6] && t[7] === n[7] && t[8] === n[8];
    }, n.equals = function (t, n) {
      var r = t[0],
          e = t[1],
          u = t[2],
          o = t[3],
          i = t[4],
          s = t[5],
          c = t[6],
          f = t[7],
          M = t[8],
          h = n[0],
          l = n[1],
          v = n[2],
          d = n[3],
          b = n[4],
          m = n[5],
          p = n[6],
          P = n[7],
          A = n[8];
      return Math.abs(r - h) <= a.EPSILON * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(e - l) <= a.EPSILON * Math.max(1, Math.abs(e), Math.abs(l)) && Math.abs(u - v) <= a.EPSILON * Math.max(1, Math.abs(u), Math.abs(v)) && Math.abs(o - d) <= a.EPSILON * Math.max(1, Math.abs(o), Math.abs(d)) && Math.abs(i - b) <= a.EPSILON * Math.max(1, Math.abs(i), Math.abs(b)) && Math.abs(s - m) <= a.EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(c - p) <= a.EPSILON * Math.max(1, Math.abs(c), Math.abs(p)) && Math.abs(f - P) <= a.EPSILON * Math.max(1, Math.abs(f), Math.abs(P)) && Math.abs(M - A) <= a.EPSILON * Math.max(1, Math.abs(M), Math.abs(A));
    };

    var a = function (t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }(r(0));

    function e(t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = n[4],
          s = n[5],
          c = n[6],
          f = n[7],
          M = n[8],
          h = r[0],
          l = r[1],
          v = r[2],
          d = r[3],
          b = r[4],
          m = r[5],
          p = r[6],
          P = r[7],
          A = r[8];
      return t[0] = h * a + l * o + v * c, t[1] = h * e + l * i + v * f, t[2] = h * u + l * s + v * M, t[3] = d * a + b * o + m * c, t[4] = d * e + b * i + m * f, t[5] = d * u + b * s + m * M, t[6] = p * a + P * o + A * c, t[7] = p * e + P * i + A * f, t[8] = p * u + P * s + A * M, t;
    }

    function u(t, n, r) {
      return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t[2] = n[2] - r[2], t[3] = n[3] - r[3], t[4] = n[4] - r[4], t[5] = n[5] - r[5], t[6] = n[6] - r[6], t[7] = n[7] - r[7], t[8] = n[8] - r[8], t;
    }

    n.mul = e, n.sub = u;
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.forEach = n.sqrLen = n.sqrDist = n.dist = n.div = n.mul = n.sub = n.len = void 0, n.create = e, n.clone = function (t) {
      var n = new a.ARRAY_TYPE(2);
      return n[0] = t[0], n[1] = t[1], n;
    }, n.fromValues = function (t, n) {
      var r = new a.ARRAY_TYPE(2);
      return r[0] = t, r[1] = n, r;
    }, n.copy = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t;
    }, n.set = function (t, n, r) {
      return t[0] = n, t[1] = r, t;
    }, n.add = function (t, n, r) {
      return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t;
    }, n.subtract = u, n.multiply = o, n.divide = i, n.ceil = function (t, n) {
      return t[0] = Math.ceil(n[0]), t[1] = Math.ceil(n[1]), t;
    }, n.floor = function (t, n) {
      return t[0] = Math.floor(n[0]), t[1] = Math.floor(n[1]), t;
    }, n.min = function (t, n, r) {
      return t[0] = Math.min(n[0], r[0]), t[1] = Math.min(n[1], r[1]), t;
    }, n.max = function (t, n, r) {
      return t[0] = Math.max(n[0], r[0]), t[1] = Math.max(n[1], r[1]), t;
    }, n.round = function (t, n) {
      return t[0] = Math.round(n[0]), t[1] = Math.round(n[1]), t;
    }, n.scale = function (t, n, r) {
      return t[0] = n[0] * r, t[1] = n[1] * r, t;
    }, n.scaleAndAdd = function (t, n, r, a) {
      return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t;
    }, n.distance = s, n.squaredDistance = c, n.length = f, n.squaredLength = M, n.negate = function (t, n) {
      return t[0] = -n[0], t[1] = -n[1], t;
    }, n.inverse = function (t, n) {
      return t[0] = 1 / n[0], t[1] = 1 / n[1], t;
    }, n.normalize = function (t, n) {
      var r = n[0],
          a = n[1],
          e = r * r + a * a;
      e > 0 && (e = 1 / Math.sqrt(e), t[0] = n[0] * e, t[1] = n[1] * e);
      return t;
    }, n.dot = function (t, n) {
      return t[0] * n[0] + t[1] * n[1];
    }, n.cross = function (t, n, r) {
      var a = n[0] * r[1] - n[1] * r[0];
      return t[0] = t[1] = 0, t[2] = a, t;
    }, n.lerp = function (t, n, r, a) {
      var e = n[0],
          u = n[1];
      return t[0] = e + a * (r[0] - e), t[1] = u + a * (r[1] - u), t;
    }, n.random = function (t, n) {
      n = n || 1;
      var r = 2 * a.RANDOM() * Math.PI;
      return t[0] = Math.cos(r) * n, t[1] = Math.sin(r) * n, t;
    }, n.transformMat2 = function (t, n, r) {
      var a = n[0],
          e = n[1];
      return t[0] = r[0] * a + r[2] * e, t[1] = r[1] * a + r[3] * e, t;
    }, n.transformMat2d = function (t, n, r) {
      var a = n[0],
          e = n[1];
      return t[0] = r[0] * a + r[2] * e + r[4], t[1] = r[1] * a + r[3] * e + r[5], t;
    }, n.transformMat3 = function (t, n, r) {
      var a = n[0],
          e = n[1];
      return t[0] = r[0] * a + r[3] * e + r[6], t[1] = r[1] * a + r[4] * e + r[7], t;
    }, n.transformMat4 = function (t, n, r) {
      var a = n[0],
          e = n[1];
      return t[0] = r[0] * a + r[4] * e + r[12], t[1] = r[1] * a + r[5] * e + r[13], t;
    }, n.rotate = function (t, n, r, a) {
      var e = n[0] - r[0],
          u = n[1] - r[1],
          o = Math.sin(a),
          i = Math.cos(a);
      return t[0] = e * i - u * o + r[0], t[1] = e * o + u * i + r[1], t;
    }, n.angle = function (t, n) {
      var r = t[0],
          a = t[1],
          e = n[0],
          u = n[1],
          o = r * r + a * a;
      o > 0 && (o = 1 / Math.sqrt(o));
      var i = e * e + u * u;
      i > 0 && (i = 1 / Math.sqrt(i));
      var s = (r * e + a * u) * o * i;
      return s > 1 ? 0 : s < -1 ? Math.PI : Math.acos(s);
    }, n.str = function (t) {
      return "vec2(" + t[0] + ", " + t[1] + ")";
    }, n.exactEquals = function (t, n) {
      return t[0] === n[0] && t[1] === n[1];
    }, n.equals = function (t, n) {
      var r = t[0],
          e = t[1],
          u = n[0],
          o = n[1];
      return Math.abs(r - u) <= a.EPSILON * Math.max(1, Math.abs(r), Math.abs(u)) && Math.abs(e - o) <= a.EPSILON * Math.max(1, Math.abs(e), Math.abs(o));
    };

    var a = function (t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }(r(0));

    function e() {
      var t = new a.ARRAY_TYPE(2);
      return a.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;
    }

    function u(t, n, r) {
      return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t;
    }

    function o(t, n, r) {
      return t[0] = n[0] * r[0], t[1] = n[1] * r[1], t;
    }

    function i(t, n, r) {
      return t[0] = n[0] / r[0], t[1] = n[1] / r[1], t;
    }

    function s(t, n) {
      var r = n[0] - t[0],
          a = n[1] - t[1];
      return Math.sqrt(r * r + a * a);
    }

    function c(t, n) {
      var r = n[0] - t[0],
          a = n[1] - t[1];
      return r * r + a * a;
    }

    function f(t) {
      var n = t[0],
          r = t[1];
      return Math.sqrt(n * n + r * r);
    }

    function M(t) {
      var n = t[0],
          r = t[1];
      return n * n + r * r;
    }

    n.len = f, n.sub = u, n.mul = o, n.div = i, n.dist = s, n.sqrDist = c, n.sqrLen = M, n.forEach = function () {
      var t = e();
      return function (n, r, a, e, u, o) {
        var i = void 0,
            s = void 0;

        for (r || (r = 2), a || (a = 0), s = e ? Math.min(e * r + a, n.length) : n.length, i = a; i < s; i += r) {
          t[0] = n[i], t[1] = n[i + 1], u(t, t, o), n[i] = t[0], n[i + 1] = t[1];
        }

        return n;
      };
    }();
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.sqrLen = n.squaredLength = n.len = n.length = n.dot = n.mul = n.setReal = n.getReal = void 0, n.create = function () {
      var t = new a.ARRAY_TYPE(8);
      a.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0);
      return t[3] = 1, t;
    }, n.clone = function (t) {
      var n = new a.ARRAY_TYPE(8);
      return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n[6] = t[6], n[7] = t[7], n;
    }, n.fromValues = function (t, n, r, e, u, o, i, s) {
      var c = new a.ARRAY_TYPE(8);
      return c[0] = t, c[1] = n, c[2] = r, c[3] = e, c[4] = u, c[5] = o, c[6] = i, c[7] = s, c;
    }, n.fromRotationTranslationValues = function (t, n, r, e, u, o, i) {
      var s = new a.ARRAY_TYPE(8);
      s[0] = t, s[1] = n, s[2] = r, s[3] = e;
      var c = .5 * u,
          f = .5 * o,
          M = .5 * i;
      return s[4] = c * e + f * r - M * n, s[5] = f * e + M * t - c * r, s[6] = M * e + c * n - f * t, s[7] = -c * t - f * n - M * r, s;
    }, n.fromRotationTranslation = i, n.fromTranslation = function (t, n) {
      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = .5 * n[0], t[5] = .5 * n[1], t[6] = .5 * n[2], t[7] = 0, t;
    }, n.fromRotation = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;
    }, n.fromMat4 = function (t, n) {
      var r = e.create();
      u.getRotation(r, n);
      var o = new a.ARRAY_TYPE(3);
      return u.getTranslation(o, n), i(t, r, o), t;
    }, n.copy = s, n.identity = function (t) {
      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;
    }, n.set = function (t, n, r, a, e, u, o, i, s) {
      return t[0] = n, t[1] = r, t[2] = a, t[3] = e, t[4] = u, t[5] = o, t[6] = i, t[7] = s, t;
    }, n.getDual = function (t, n) {
      return t[0] = n[4], t[1] = n[5], t[2] = n[6], t[3] = n[7], t;
    }, n.setDual = function (t, n) {
      return t[4] = n[0], t[5] = n[1], t[6] = n[2], t[7] = n[3], t;
    }, n.getTranslation = function (t, n) {
      var r = n[4],
          a = n[5],
          e = n[6],
          u = n[7],
          o = -n[0],
          i = -n[1],
          s = -n[2],
          c = n[3];
      return t[0] = 2 * (r * c + u * o + a * s - e * i), t[1] = 2 * (a * c + u * i + e * o - r * s), t[2] = 2 * (e * c + u * s + r * i - a * o), t;
    }, n.translate = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = .5 * r[0],
          s = .5 * r[1],
          c = .5 * r[2],
          f = n[4],
          M = n[5],
          h = n[6],
          l = n[7];
      return t[0] = a, t[1] = e, t[2] = u, t[3] = o, t[4] = o * i + e * c - u * s + f, t[5] = o * s + u * i - a * c + M, t[6] = o * c + a * s - e * i + h, t[7] = -a * i - e * s - u * c + l, t;
    }, n.rotateX = function (t, n, r) {
      var a = -n[0],
          u = -n[1],
          o = -n[2],
          i = n[3],
          s = n[4],
          c = n[5],
          f = n[6],
          M = n[7],
          h = s * i + M * a + c * o - f * u,
          l = c * i + M * u + f * a - s * o,
          v = f * i + M * o + s * u - c * a,
          d = M * i - s * a - c * u - f * o;
      return e.rotateX(t, n, r), a = t[0], u = t[1], o = t[2], i = t[3], t[4] = h * i + d * a + l * o - v * u, t[5] = l * i + d * u + v * a - h * o, t[6] = v * i + d * o + h * u - l * a, t[7] = d * i - h * a - l * u - v * o, t;
    }, n.rotateY = function (t, n, r) {
      var a = -n[0],
          u = -n[1],
          o = -n[2],
          i = n[3],
          s = n[4],
          c = n[5],
          f = n[6],
          M = n[7],
          h = s * i + M * a + c * o - f * u,
          l = c * i + M * u + f * a - s * o,
          v = f * i + M * o + s * u - c * a,
          d = M * i - s * a - c * u - f * o;
      return e.rotateY(t, n, r), a = t[0], u = t[1], o = t[2], i = t[3], t[4] = h * i + d * a + l * o - v * u, t[5] = l * i + d * u + v * a - h * o, t[6] = v * i + d * o + h * u - l * a, t[7] = d * i - h * a - l * u - v * o, t;
    }, n.rotateZ = function (t, n, r) {
      var a = -n[0],
          u = -n[1],
          o = -n[2],
          i = n[3],
          s = n[4],
          c = n[5],
          f = n[6],
          M = n[7],
          h = s * i + M * a + c * o - f * u,
          l = c * i + M * u + f * a - s * o,
          v = f * i + M * o + s * u - c * a,
          d = M * i - s * a - c * u - f * o;
      return e.rotateZ(t, n, r), a = t[0], u = t[1], o = t[2], i = t[3], t[4] = h * i + d * a + l * o - v * u, t[5] = l * i + d * u + v * a - h * o, t[6] = v * i + d * o + h * u - l * a, t[7] = d * i - h * a - l * u - v * o, t;
    }, n.rotateByQuatAppend = function (t, n, r) {
      var a = r[0],
          e = r[1],
          u = r[2],
          o = r[3],
          i = n[0],
          s = n[1],
          c = n[2],
          f = n[3];
      return t[0] = i * o + f * a + s * u - c * e, t[1] = s * o + f * e + c * a - i * u, t[2] = c * o + f * u + i * e - s * a, t[3] = f * o - i * a - s * e - c * u, i = n[4], s = n[5], c = n[6], f = n[7], t[4] = i * o + f * a + s * u - c * e, t[5] = s * o + f * e + c * a - i * u, t[6] = c * o + f * u + i * e - s * a, t[7] = f * o - i * a - s * e - c * u, t;
    }, n.rotateByQuatPrepend = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = r[0],
          s = r[1],
          c = r[2],
          f = r[3];
      return t[0] = a * f + o * i + e * c - u * s, t[1] = e * f + o * s + u * i - a * c, t[2] = u * f + o * c + a * s - e * i, t[3] = o * f - a * i - e * s - u * c, i = r[4], s = r[5], c = r[6], f = r[7], t[4] = a * f + o * i + e * c - u * s, t[5] = e * f + o * s + u * i - a * c, t[6] = u * f + o * c + a * s - e * i, t[7] = o * f - a * i - e * s - u * c, t;
    }, n.rotateAroundAxis = function (t, n, r, e) {
      if (Math.abs(e) < a.EPSILON) return s(t, n);
      var u = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
      e *= .5;
      var o = Math.sin(e),
          i = o * r[0] / u,
          c = o * r[1] / u,
          f = o * r[2] / u,
          M = Math.cos(e),
          h = n[0],
          l = n[1],
          v = n[2],
          d = n[3];
      t[0] = h * M + d * i + l * f - v * c, t[1] = l * M + d * c + v * i - h * f, t[2] = v * M + d * f + h * c - l * i, t[3] = d * M - h * i - l * c - v * f;
      var b = n[4],
          m = n[5],
          p = n[6],
          P = n[7];
      return t[4] = b * M + P * i + m * f - p * c, t[5] = m * M + P * c + p * i - b * f, t[6] = p * M + P * f + b * c - m * i, t[7] = P * M - b * i - m * c - p * f, t;
    }, n.add = function (t, n, r) {
      return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t[3] = n[3] + r[3], t[4] = n[4] + r[4], t[5] = n[5] + r[5], t[6] = n[6] + r[6], t[7] = n[7] + r[7], t;
    }, n.multiply = c, n.scale = function (t, n, r) {
      return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = n[3] * r, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = n[7] * r, t;
    }, n.lerp = function (t, n, r, a) {
      var e = 1 - a;
      f(n, r) < 0 && (a = -a);
      return t[0] = n[0] * e + r[0] * a, t[1] = n[1] * e + r[1] * a, t[2] = n[2] * e + r[2] * a, t[3] = n[3] * e + r[3] * a, t[4] = n[4] * e + r[4] * a, t[5] = n[5] * e + r[5] * a, t[6] = n[6] * e + r[6] * a, t[7] = n[7] * e + r[7] * a, t;
    }, n.invert = function (t, n) {
      var r = h(n);
      return t[0] = -n[0] / r, t[1] = -n[1] / r, t[2] = -n[2] / r, t[3] = n[3] / r, t[4] = -n[4] / r, t[5] = -n[5] / r, t[6] = -n[6] / r, t[7] = n[7] / r, t;
    }, n.conjugate = function (t, n) {
      return t[0] = -n[0], t[1] = -n[1], t[2] = -n[2], t[3] = n[3], t[4] = -n[4], t[5] = -n[5], t[6] = -n[6], t[7] = n[7], t;
    }, n.normalize = function (t, n) {
      var r = h(n);

      if (r > 0) {
        r = Math.sqrt(r);
        var a = n[0] / r,
            e = n[1] / r,
            u = n[2] / r,
            o = n[3] / r,
            i = n[4],
            s = n[5],
            c = n[6],
            f = n[7],
            M = a * i + e * s + u * c + o * f;
        t[0] = a, t[1] = e, t[2] = u, t[3] = o, t[4] = (i - a * M) / r, t[5] = (s - e * M) / r, t[6] = (c - u * M) / r, t[7] = (f - o * M) / r;
      }

      return t;
    }, n.str = function (t) {
      return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")";
    }, n.exactEquals = function (t, n) {
      return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3] && t[4] === n[4] && t[5] === n[5] && t[6] === n[6] && t[7] === n[7];
    }, n.equals = function (t, n) {
      var r = t[0],
          e = t[1],
          u = t[2],
          o = t[3],
          i = t[4],
          s = t[5],
          c = t[6],
          f = t[7],
          M = n[0],
          h = n[1],
          l = n[2],
          v = n[3],
          d = n[4],
          b = n[5],
          m = n[6],
          p = n[7];
      return Math.abs(r - M) <= a.EPSILON * Math.max(1, Math.abs(r), Math.abs(M)) && Math.abs(e - h) <= a.EPSILON * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(u - l) <= a.EPSILON * Math.max(1, Math.abs(u), Math.abs(l)) && Math.abs(o - v) <= a.EPSILON * Math.max(1, Math.abs(o), Math.abs(v)) && Math.abs(i - d) <= a.EPSILON * Math.max(1, Math.abs(i), Math.abs(d)) && Math.abs(s - b) <= a.EPSILON * Math.max(1, Math.abs(s), Math.abs(b)) && Math.abs(c - m) <= a.EPSILON * Math.max(1, Math.abs(c), Math.abs(m)) && Math.abs(f - p) <= a.EPSILON * Math.max(1, Math.abs(f), Math.abs(p));
    };
    var a = o(r(0)),
        e = o(r(3)),
        u = o(r(4));

    function o(t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }

    function i(t, n, r) {
      var a = .5 * r[0],
          e = .5 * r[1],
          u = .5 * r[2],
          o = n[0],
          i = n[1],
          s = n[2],
          c = n[3];
      return t[0] = o, t[1] = i, t[2] = s, t[3] = c, t[4] = a * c + e * s - u * i, t[5] = e * c + u * o - a * s, t[6] = u * c + a * i - e * o, t[7] = -a * o - e * i - u * s, t;
    }

    function s(t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t;
    }

    n.getReal = e.copy;
    n.setReal = e.copy;

    function c(t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = r[4],
          s = r[5],
          c = r[6],
          f = r[7],
          M = n[4],
          h = n[5],
          l = n[6],
          v = n[7],
          d = r[0],
          b = r[1],
          m = r[2],
          p = r[3];
      return t[0] = a * p + o * d + e * m - u * b, t[1] = e * p + o * b + u * d - a * m, t[2] = u * p + o * m + a * b - e * d, t[3] = o * p - a * d - e * b - u * m, t[4] = a * f + o * i + e * c - u * s + M * p + v * d + h * m - l * b, t[5] = e * f + o * s + u * i - a * c + h * p + v * b + l * d - M * m, t[6] = u * f + o * c + a * s - e * i + l * p + v * m + M * b - h * d, t[7] = o * f - a * i - e * s - u * c + v * p - M * d - h * b - l * m, t;
    }

    n.mul = c;
    var f = n.dot = e.dot;
    var M = n.length = e.length,
        h = (n.len = M, n.squaredLength = e.squaredLength);
    n.sqrLen = h;
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.sub = n.mul = void 0, n.create = function () {
      var t = new a.ARRAY_TYPE(6);
      a.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0);
      return t[0] = 1, t[3] = 1, t;
    }, n.clone = function (t) {
      var n = new a.ARRAY_TYPE(6);
      return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n[4] = t[4], n[5] = t[5], n;
    }, n.copy = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t;
    }, n.identity = function (t) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;
    }, n.fromValues = function (t, n, r, e, u, o) {
      var i = new a.ARRAY_TYPE(6);
      return i[0] = t, i[1] = n, i[2] = r, i[3] = e, i[4] = u, i[5] = o, i;
    }, n.set = function (t, n, r, a, e, u, o) {
      return t[0] = n, t[1] = r, t[2] = a, t[3] = e, t[4] = u, t[5] = o, t;
    }, n.invert = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = n[4],
          i = n[5],
          s = r * u - a * e;
      if (!s) return null;
      return s = 1 / s, t[0] = u * s, t[1] = -a * s, t[2] = -e * s, t[3] = r * s, t[4] = (e * i - u * o) * s, t[5] = (a * o - r * i) * s, t;
    }, n.determinant = function (t) {
      return t[0] * t[3] - t[1] * t[2];
    }, n.multiply = e, n.rotate = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = n[4],
          s = n[5],
          c = Math.sin(r),
          f = Math.cos(r);
      return t[0] = a * f + u * c, t[1] = e * f + o * c, t[2] = a * -c + u * f, t[3] = e * -c + o * f, t[4] = i, t[5] = s, t;
    }, n.scale = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = n[4],
          s = n[5],
          c = r[0],
          f = r[1];
      return t[0] = a * c, t[1] = e * c, t[2] = u * f, t[3] = o * f, t[4] = i, t[5] = s, t;
    }, n.translate = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = n[4],
          s = n[5],
          c = r[0],
          f = r[1];
      return t[0] = a, t[1] = e, t[2] = u, t[3] = o, t[4] = a * c + u * f + i, t[5] = e * c + o * f + s, t;
    }, n.fromRotation = function (t, n) {
      var r = Math.sin(n),
          a = Math.cos(n);
      return t[0] = a, t[1] = r, t[2] = -r, t[3] = a, t[4] = 0, t[5] = 0, t;
    }, n.fromScaling = function (t, n) {
      return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = n[1], t[4] = 0, t[5] = 0, t;
    }, n.fromTranslation = function (t, n) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = n[0], t[5] = n[1], t;
    }, n.str = function (t) {
      return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")";
    }, n.frob = function (t) {
      return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2) + Math.pow(t[4], 2) + Math.pow(t[5], 2) + 1);
    }, n.add = function (t, n, r) {
      return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t[3] = n[3] + r[3], t[4] = n[4] + r[4], t[5] = n[5] + r[5], t;
    }, n.subtract = u, n.multiplyScalar = function (t, n, r) {
      return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = n[3] * r, t[4] = n[4] * r, t[5] = n[5] * r, t;
    }, n.multiplyScalarAndAdd = function (t, n, r, a) {
      return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t[2] = n[2] + r[2] * a, t[3] = n[3] + r[3] * a, t[4] = n[4] + r[4] * a, t[5] = n[5] + r[5] * a, t;
    }, n.exactEquals = function (t, n) {
      return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3] && t[4] === n[4] && t[5] === n[5];
    }, n.equals = function (t, n) {
      var r = t[0],
          e = t[1],
          u = t[2],
          o = t[3],
          i = t[4],
          s = t[5],
          c = n[0],
          f = n[1],
          M = n[2],
          h = n[3],
          l = n[4],
          v = n[5];
      return Math.abs(r - c) <= a.EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(e - f) <= a.EPSILON * Math.max(1, Math.abs(e), Math.abs(f)) && Math.abs(u - M) <= a.EPSILON * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(o - h) <= a.EPSILON * Math.max(1, Math.abs(o), Math.abs(h)) && Math.abs(i - l) <= a.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(s - v) <= a.EPSILON * Math.max(1, Math.abs(s), Math.abs(v));
    };

    var a = function (t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }(r(0));

    function e(t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = n[4],
          s = n[5],
          c = r[0],
          f = r[1],
          M = r[2],
          h = r[3],
          l = r[4],
          v = r[5];
      return t[0] = a * c + u * f, t[1] = e * c + o * f, t[2] = a * M + u * h, t[3] = e * M + o * h, t[4] = a * l + u * v + i, t[5] = e * l + o * v + s, t;
    }

    function u(t, n, r) {
      return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t[2] = n[2] - r[2], t[3] = n[3] - r[3], t[4] = n[4] - r[4], t[5] = n[5] - r[5], t;
    }

    n.mul = e, n.sub = u;
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.sub = n.mul = void 0, n.create = function () {
      var t = new a.ARRAY_TYPE(4);
      a.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0);
      return t[0] = 1, t[3] = 1, t;
    }, n.clone = function (t) {
      var n = new a.ARRAY_TYPE(4);
      return n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], n;
    }, n.copy = function (t, n) {
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t;
    }, n.identity = function (t) {
      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;
    }, n.fromValues = function (t, n, r, e) {
      var u = new a.ARRAY_TYPE(4);
      return u[0] = t, u[1] = n, u[2] = r, u[3] = e, u;
    }, n.set = function (t, n, r, a, e) {
      return t[0] = n, t[1] = r, t[2] = a, t[3] = e, t;
    }, n.transpose = function (t, n) {
      if (t === n) {
        var r = n[1];
        t[1] = n[2], t[2] = r;
      } else t[0] = n[0], t[1] = n[2], t[2] = n[1], t[3] = n[3];

      return t;
    }, n.invert = function (t, n) {
      var r = n[0],
          a = n[1],
          e = n[2],
          u = n[3],
          o = r * u - e * a;
      if (!o) return null;
      return o = 1 / o, t[0] = u * o, t[1] = -a * o, t[2] = -e * o, t[3] = r * o, t;
    }, n.adjoint = function (t, n) {
      var r = n[0];
      return t[0] = n[3], t[1] = -n[1], t[2] = -n[2], t[3] = r, t;
    }, n.determinant = function (t) {
      return t[0] * t[3] - t[2] * t[1];
    }, n.multiply = e, n.rotate = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = Math.sin(r),
          s = Math.cos(r);
      return t[0] = a * s + u * i, t[1] = e * s + o * i, t[2] = a * -i + u * s, t[3] = e * -i + o * s, t;
    }, n.scale = function (t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = r[0],
          s = r[1];
      return t[0] = a * i, t[1] = e * i, t[2] = u * s, t[3] = o * s, t;
    }, n.fromRotation = function (t, n) {
      var r = Math.sin(n),
          a = Math.cos(n);
      return t[0] = a, t[1] = r, t[2] = -r, t[3] = a, t;
    }, n.fromScaling = function (t, n) {
      return t[0] = n[0], t[1] = 0, t[2] = 0, t[3] = n[1], t;
    }, n.str = function (t) {
      return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
    }, n.frob = function (t) {
      return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2) + Math.pow(t[2], 2) + Math.pow(t[3], 2));
    }, n.LDU = function (t, n, r, a) {
      return t[2] = a[2] / a[0], r[0] = a[0], r[1] = a[1], r[3] = a[3] - t[2] * r[1], [t, n, r];
    }, n.add = function (t, n, r) {
      return t[0] = n[0] + r[0], t[1] = n[1] + r[1], t[2] = n[2] + r[2], t[3] = n[3] + r[3], t;
    }, n.subtract = u, n.exactEquals = function (t, n) {
      return t[0] === n[0] && t[1] === n[1] && t[2] === n[2] && t[3] === n[3];
    }, n.equals = function (t, n) {
      var r = t[0],
          e = t[1],
          u = t[2],
          o = t[3],
          i = n[0],
          s = n[1],
          c = n[2],
          f = n[3];
      return Math.abs(r - i) <= a.EPSILON * Math.max(1, Math.abs(r), Math.abs(i)) && Math.abs(e - s) <= a.EPSILON * Math.max(1, Math.abs(e), Math.abs(s)) && Math.abs(u - c) <= a.EPSILON * Math.max(1, Math.abs(u), Math.abs(c)) && Math.abs(o - f) <= a.EPSILON * Math.max(1, Math.abs(o), Math.abs(f));
    }, n.multiplyScalar = function (t, n, r) {
      return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = n[3] * r, t;
    }, n.multiplyScalarAndAdd = function (t, n, r, a) {
      return t[0] = n[0] + r[0] * a, t[1] = n[1] + r[1] * a, t[2] = n[2] + r[2] * a, t[3] = n[3] + r[3] * a, t;
    };

    var a = function (t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }(r(0));

    function e(t, n, r) {
      var a = n[0],
          e = n[1],
          u = n[2],
          o = n[3],
          i = r[0],
          s = r[1],
          c = r[2],
          f = r[3];
      return t[0] = a * i + u * s, t[1] = e * i + o * s, t[2] = a * c + u * f, t[3] = e * c + o * f, t;
    }

    function u(t, n, r) {
      return t[0] = n[0] - r[0], t[1] = n[1] - r[1], t[2] = n[2] - r[2], t[3] = n[3] - r[3], t;
    }

    n.mul = e, n.sub = u;
  }, function (t, n, r) {

    Object.defineProperty(n, "__esModule", {
      value: !0
    }), n.vec4 = n.vec3 = n.vec2 = n.quat2 = n.quat = n.mat4 = n.mat3 = n.mat2d = n.mat2 = n.glMatrix = void 0;
    var a = l(r(0)),
        e = l(r(9)),
        u = l(r(8)),
        o = l(r(5)),
        i = l(r(4)),
        s = l(r(3)),
        c = l(r(7)),
        f = l(r(6)),
        M = l(r(2)),
        h = l(r(1));

    function l(t) {
      if (t && t.__esModule) return t;
      var n = {};
      if (null != t) for (var r in t) {
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n["default"] = t, n;
    }

    n.glMatrix = a, n.mat2 = e, n.mat2d = u, n.mat3 = o, n.mat4 = i, n.quat = s, n.quat2 = c, n.vec2 = f, n.vec3 = M, n.vec4 = h;
  }]);
});

/***/ }),

/***/ "./node_modules/_gl-vec3@1.1.3@gl-vec3/add.js":
/*!****************************************************!*\
  !*** ./node_modules/_gl-vec3@1.1.3@gl-vec3/add.js ***!
  \****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/***/ }),

/***/ "./node_modules/_gl-vec3@1.1.3@gl-vec3/copy.js":
/*!*****************************************************!*\
  !*** ./node_modules/_gl-vec3@1.1.3@gl-vec3/copy.js ***!
  \*****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),

/***/ "./node_modules/_gl-vec3@1.1.3@gl-vec3/cross.js":
/*!******************************************************!*\
  !*** ./node_modules/_gl-vec3@1.1.3@gl-vec3/cross.js ***!
  \******************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/***/ }),

/***/ "./node_modules/_gl-vec3@1.1.3@gl-vec3/dot.js":
/*!****************************************************!*\
  !*** ./node_modules/_gl-vec3@1.1.3@gl-vec3/dot.js ***!
  \****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/***/ }),

/***/ "./node_modules/_gl-vec3@1.1.3@gl-vec3/scale.js":
/*!******************************************************!*\
  !*** ./node_modules/_gl-vec3@1.1.3@gl-vec3/scale.js ***!
  \******************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/***/ }),

/***/ "./node_modules/_gl-vec3@1.1.3@gl-vec3/scaleAndAdd.js":
/*!************************************************************!*\
  !*** ./node_modules/_gl-vec3@1.1.3@gl-vec3/scaleAndAdd.js ***!
  \************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/***/ }),

/***/ "./node_modules/_gl-vec3@1.1.3@gl-vec3/squaredDistance.js":
/*!****************************************************************!*\
  !*** ./node_modules/_gl-vec3@1.1.3@gl-vec3/squaredDistance.js ***!
  \****************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/***/ }),

/***/ "./node_modules/_gl-vec3@1.1.3@gl-vec3/subtract.js":
/*!*********************************************************!*\
  !*** ./node_modules/_gl-vec3@1.1.3@gl-vec3/subtract.js ***!
  \*********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/***/ }),

/***/ "./node_modules/_hilojs@2.0.0@hilojs/core/Class.js":
/*!*********************************************************!*\
  !*** ./node_modules/_hilojs@2.0.0@hilojs/core/Class.js ***!
  \*********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

/**
 * Hilo 2.0.0 for commonjs
 * Copyright 2016 alibaba.com
 * Licensed under the MIT License
 */

/**
 * @language=en
 * Create Example Class:
 * <pre>
 * var Bird = Hilo.Class.create({
 *     Extends: Animal,
 *     Mixes: EventMixin,
 *     constructor: function(name){
 *         this.name = name;
 *     },
 *     fly: function(){
 *         console.log('I am flying');
 *     },
 *     Statics: {
 *         isBird: function(bird){
 *             return bird instanceof Bird;
 *         }
 *     }
 * });
 *
 * var swallow = new Bird('swallow');
 * swallow.fly();
 * Bird.isBird(swallow);
 * </pre>
 * @namespace Class Class is created to aid the developer.
 * @static
 * @module hilo/core/Class
 */
var Class = function () {
  /**
   * @language=en
   * Create a class based on the parameters, properties and methods specified.
   * @param {Object} properties Properties and methods to create the class.
   * <ul>
   * <li><b>Extends</b> - Designed to inherit the parent class.</li>
   * <li><b>Mixes</b> - Specifies mixed member collection object.</li>
   * <li><b>Statics</b> - Static property or method specified class.</li>
   * <li><b>constructor</b> -  The constructor of specified class.</li>
   * <li>Other members of the property or method to create the class.</li>
   * </ul>
   * @returns {Object} Create classes.
   */
  var create = function create(properties) {
    properties = properties || {};
    var clazz = properties.hasOwnProperty('constructor') ? properties.constructor : function () {};
    implement.call(clazz, properties);
    return clazz;
  };
  /**
   * @language=en
   * @private
   */


  var implement = function implement(properties) {
    var proto = {},
        key,
        value;

    for (key in properties) {
      value = properties[key];

      if (classMutators.hasOwnProperty(key)) {
        classMutators[key].call(this, value);
      } else {
        proto[key] = value;
      }
    }

    mix(this.prototype, proto);
  };

  var classMutators =
  /** @ignore */
  {
    Extends: function Extends(parent) {
      var existed = this.prototype,
          proto = createProto(parent.prototype); //inherit static properites

      mix(this, parent); //keep existed properties

      mix(proto, existed); //correct constructor

      proto.constructor = this; //prototype chaining

      this.prototype = proto; //shortcut to parent's prototype

      this.superclass = parent.prototype;
    },
    Mixes: function Mixes(items) {
      items instanceof Array || (items = [items]);
      var proto = this.prototype,
          item;

      while (item = items.shift()) {
        mix(proto, item.prototype || item);
      }
    },
    Statics: function Statics(properties) {
      mix(this, properties);
    }
  };
  /**
   * @language=en
   * @private
   */

  var createProto = function () {
    if (Object.__proto__) {
      return function (proto) {
        return {
          __proto__: proto
        };
      };
    } else {
      var Ctor = function Ctor() {};

      return function (proto) {
        Ctor.prototype = proto;
        return new Ctor();
      };
    }
  }();
  /**
   * @language=en
   * Mixed property or method.
   * @param {Object} target Mixed audiences.
   * @param {Object} source The source whose methods and properties are to be mixed. It can support multiple source parameters.
   * @returns {Object} Mixed audiences.
   */


  var mix = function mix(target) {
    for (var i = 1, len = arguments.length; i < len; i++) {
      var source = arguments[i],
          defineProps;

      for (var key in source) {
        var prop = source[key];

        if (prop && typeof prop === 'object') {
          if (prop.value !== undefined || typeof prop.get === 'function' || typeof prop.set === 'function') {
            defineProps = defineProps || {};
            defineProps[key] = prop;
            continue;
          }
        }

        target[key] = prop;
      }

      if (defineProps) defineProperties(target, defineProps);
    }

    return target;
  };

  var defineProperty, defineProperties;

  try {
    defineProperty = Object.defineProperty;
    defineProperties = Object.defineProperties;
    defineProperty({}, '$', {
      value: 0
    });
  } catch (e) {
    if ('__defineGetter__' in Object) {
      defineProperty = function defineProperty(obj, prop, desc) {
        if ('value' in desc) obj[prop] = desc.value;
        if ('get' in desc) obj.__defineGetter__(prop, desc.get);
        if ('set' in desc) obj.__defineSetter__(prop, desc.set);
        return obj;
      };

      defineProperties = function defineProperties(obj, props) {
        for (var prop in props) {
          if (props.hasOwnProperty(prop)) {
            defineProperty(obj, prop, props[prop]);
          }
        }

        return obj;
      };
    }
  }

  return {
    create: create,
    mix: mix
  };
}();

module.exports = Class;

/***/ }),

/***/ "./node_modules/_hilojs@2.0.0@hilojs/event/EventMixin.js":
/*!***************************************************************!*\
  !*** ./node_modules/_hilojs@2.0.0@hilojs/event/EventMixin.js ***!
  \***************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Hilo 2.0.0 for commonjs
 * Copyright 2016 alibaba.com
 * Licensed under the MIT License
 */
var Class = __webpack_require__(/*! ../core/Class */ "./node_modules/_hilojs@2.0.0@hilojs/core/Class.js");
/**
 * @language=en
 * @class EventMixin is a mixin on event related functions. Use Class.mix(target, EventMixin) to add event function onto target.
 * @static
 * @mixin
 * @module hilo/event/EventMixin
 * @requires hilo/core/Class
 */


var EventMixin =
/** @lends EventMixin# */
{
  _listeners: null,

  /**
   * @language=en
   * Add an event listenser.
   * @param {String} type Event type to listen.
   * @param {Function} listener Callback function of event listening.
   * @param {Boolean} once Listen on event only once and no more response after the first response?
   * @returns {Object} The Event itself. Functions chain call supported.
   */
  on: function on(type, listener, once) {
    var listeners = this._listeners = this._listeners || {};
    var eventListeners = listeners[type] = listeners[type] || [];

    for (var i = 0, len = eventListeners.length; i < len; i++) {
      var el = eventListeners[i];
      if (el.listener === listener) return;
    }

    eventListeners.push({
      listener: listener,
      once: once
    });
    return this;
  },

  /**
   * @language=en
   * Remove one event listener. Remove all event listeners if no parameter provided, and remove all event listeners on one type which is provided as the only parameter.
   * @param {String} type The type of event listener that want to remove.
   * @param {Function} listener Event listener callback function to be removed.
   * @returns {Object} The Event itself. Functions chain call supported.
   */
  off: function off(type, listener) {
    //remove all event listeners
    if (arguments.length == 0) {
      this._listeners = null;
      return this;
    }

    var eventListeners = this._listeners && this._listeners[type];

    if (eventListeners) {
      //remove event listeners by specified type
      if (arguments.length == 1) {
        delete this._listeners[type];
        return this;
      }

      for (var i = 0, len = eventListeners.length; i < len; i++) {
        var el = eventListeners[i];

        if (el.listener === listener) {
          eventListeners.splice(i, 1);
          if (eventListeners.length === 0) delete this._listeners[type];
          break;
        }
      }
    }

    return this;
  },

  /**
   * @language=en
   * Send events. If the first parameter is an Object, take it  as an Event Object.
   * @param {String} type Event type to send.
   * @param {Object} detail The detail (parameters go with the event) of Event to send.
   * @returns {Boolean} Whether Event call successfully.
   */
  fire: function fire(type, detail) {
    var event, eventType;

    if (typeof type === 'string') {
      eventType = type;
    } else {
      event = type;
      eventType = type.type;
    }

    var listeners = this._listeners;
    if (!listeners) return false;
    var eventListeners = listeners[eventType];

    if (eventListeners) {
      var eventListenersCopy = eventListeners.slice(0);
      event = event || new EventObject(eventType, this, detail);
      if (event._stopped) return false;

      for (var i = 0; i < eventListenersCopy.length; i++) {
        var el = eventListenersCopy[i];
        el.listener.call(this, event);

        if (el.once) {
          var index = eventListeners.indexOf(el);

          if (index > -1) {
            eventListeners.splice(index, 1);
          }
        }
      }

      if (eventListeners.length == 0) delete listeners[eventType];
      return true;
    }

    return false;
  }
};
/**
 * @language=en
 * Event Object class. It's an private class now, but maybe will become a public class if needed.
 */

var EventObject = Class.create({
  constructor: function EventObject(type, target, detail) {
    this.type = type;
    this.target = target;
    this.detail = detail;
    this.timeStamp = +new Date();
  },
  type: null,
  target: null,
  detail: null,
  timeStamp: 0,
  stopImmediatePropagation: function stopImmediatePropagation() {
    this._stopped = true;
  }
}); //Trick: `stopImmediatePropagation` compatibility

var RawEvent = window.Event;

if (RawEvent) {
  var proto = RawEvent.prototype,
      stop = proto.stopImmediatePropagation;

  proto.stopImmediatePropagation = function () {
    stop && stop.call(this);
    this._stopped = true;
  };
}

module.exports = EventMixin;

/***/ }),

/***/ "./node_modules/_hilojs@2.0.0@hilojs/tween/Ease.js":
/*!*********************************************************!*\
  !*** ./node_modules/_hilojs@2.0.0@hilojs/tween/Ease.js ***!
  \*********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

/**
 * Hilo 2.0.0 for commonjs
 * Copyright 2016 alibaba.com
 * Licensed under the MIT License
 */

/**
 * @language=en
 * @class Ease class provides multiple easing functions for Tween.
 * @module hilo/tween/Ease
 * @static
 */
var Ease = function () {
  function createEase(obj, easeInFn, easeOutFn, easeInOutFn, easeNoneFn) {
    obj = obj || {};
    easeInFn && (obj.EaseIn = easeInFn);
    easeOutFn && (obj.EaseOut = easeOutFn);
    easeInOutFn && (obj.EaseInOut = easeInOutFn);
    easeNoneFn && (obj.EaseNone = easeNoneFn);
    return obj;
  }
  /**
   * @language=en
   * Linear easing function.Include EaseNone.
   */


  var Linear = createEase(null, null, null, null, function (k) {
    return k;
  });
  /**
   * @language=en
   * Quad easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Quad = createEase(null, function (k) {
    return k * k;
  }, function (k) {
    return -k * (k - 2);
  }, function (k) {
    return (k *= 2) < 1 ? 0.5 * k * k : -0.5 * (--k * (k - 2) - 1);
  });
  /**
   * @language=en
   * Cubic easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Cubic = createEase(null, function (k) {
    return k * k * k;
  }, function (k) {
    return --k * k * k + 1;
  }, function (k) {
    return (k *= 2) < 1 ? 0.5 * k * k * k : 0.5 * ((k -= 2) * k * k + 2);
  });
  /**
   * @language=en
   * Quart easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Quart = createEase(null, function (k) {
    return k * k * k * k;
  }, function (k) {
    return -(--k * k * k * k - 1);
  }, function (k) {
    return (k *= 2) < 1 ? 0.5 * k * k * k * k : -0.5 * ((k -= 2) * k * k * k - 2);
  });
  /**
   * @language=en
   * Quint easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Quint = createEase(null, function (k) {
    return k * k * k * k * k;
  }, function (k) {
    return (k = k - 1) * k * k * k * k + 1;
  }, function (k) {
    return (k *= 2) < 1 ? 0.5 * k * k * k * k * k : 0.5 * ((k -= 2) * k * k * k * k + 2);
  });
  var math = Math,
      PI = math.PI,
      HALF_PI = PI * 0.5,
      sin = math.sin,
      cos = math.cos,
      pow = math.pow,
      sqrt = math.sqrt;
  /**
   * @language=en
   * Sine easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Sine = createEase(null, function (k) {
    return -cos(k * HALF_PI) + 1;
  }, function (k) {
    return sin(k * HALF_PI);
  }, function (k) {
    return -0.5 * (cos(PI * k) - 1);
  });
  /**
   * @language=en
   * Expo easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Expo = createEase(null, function (k) {
    return k == 0 ? 0 : pow(2, 10 * (k - 1));
  }, function (k) {
    return k == 1 ? 1 : -pow(2, -10 * k) + 1;
  }, function (k) {
    if (k == 0 || k == 1) return k;
    if ((k *= 2) < 1) return 0.5 * pow(2, 10 * (k - 1));
    return 0.5 * (-pow(2, -10 * (k - 1)) + 2);
  });
  /**
   * @language=en
   * Circ easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Circ = createEase(null, function (k) {
    return -(sqrt(1 - k * k) - 1);
  }, function (k) {
    return sqrt(1 - --k * k);
  }, function (k) {
    if ((k /= 0.5) < 1) return -0.5 * (sqrt(1 - k * k) - 1);
    return 0.5 * (sqrt(1 - (k -= 2) * k) + 1);
  });
  /**
   * @language=en
   * Elastic easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Elastic = createEase({
    a: 1,
    p: 0.4,
    s: 0.1,
    config: function config(amplitude, period) {
      Elastic.a = amplitude;
      Elastic.p = period;
      Elastic.s = period / (2 * PI) * Math.asin(1 / amplitude) || 0;
    }
  }, function (k) {
    return -(Elastic.a * pow(2, 10 * (k -= 1)) * sin((k - Elastic.s) * (2 * PI) / Elastic.p));
  }, function (k) {
    return Elastic.a * pow(2, -10 * k) * sin((k - Elastic.s) * (2 * PI) / Elastic.p) + 1;
  }, function (k) {
    return (k *= 2) < 1 ? -0.5 * (Elastic.a * pow(2, 10 * (k -= 1)) * sin((k - Elastic.s) * (2 * PI) / Elastic.p)) : Elastic.a * pow(2, -10 * (k -= 1)) * sin((k - Elastic.s) * (2 * PI) / Elastic.p) * 0.5 + 1;
  });
  /**
   * @language=en
   * Back easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Back = createEase({
    o: 1.70158,
    s: 2.59491,
    config: function config(overshoot) {
      Back.o = overshoot;
      Back.s = overshoot * 1.525;
    }
  }, function (k) {
    return k * k * ((Back.o + 1) * k - Back.o);
  }, function (k) {
    return (k = k - 1) * k * ((Back.o + 1) * k + Back.o) + 1;
  }, function (k) {
    return (k *= 2) < 1 ? 0.5 * (k * k * ((Back.s + 1) * k - Back.s)) : 0.5 * ((k -= 2) * k * ((Back.s + 1) * k + Back.s) + 2);
  });
  /**
   * @language=en
   * Bounce easing function.Include EaseIn, EaseOut, EaseInOut.
   */

  var Bounce = createEase(null, function (k) {
    return 1 - Bounce.EaseOut(1 - k);
  }, function (k) {
    if ((k /= 1) < 0.36364) {
      return 7.5625 * k * k;
    } else if (k < 0.72727) {
      return 7.5625 * (k -= 0.54545) * k + 0.75;
    } else if (k < 0.90909) {
      return 7.5625 * (k -= 0.81818) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 0.95455) * k + 0.984375;
    }
  }, function (k) {
    return k < 0.5 ? Bounce.EaseIn(k * 2) * 0.5 : Bounce.EaseOut(k * 2 - 1) * 0.5 + 0.5;
  });
  return {
    Linear: Linear,
    Quad: Quad,
    Cubic: Cubic,
    Quart: Quart,
    Quint: Quint,
    Sine: Sine,
    Expo: Expo,
    Circ: Circ,
    Elastic: Elastic,
    Back: Back,
    Bounce: Bounce
  };
}();

module.exports = Ease;

/***/ }),

/***/ "./node_modules/_hilojs@2.0.0@hilojs/tween/Tween.js":
/*!**********************************************************!*\
  !*** ./node_modules/_hilojs@2.0.0@hilojs/tween/Tween.js ***!
  \**********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Hilo 2.0.0 for commonjs
 * Copyright 2016 alibaba.com
 * Licensed under the MIT License
 */
var Class = __webpack_require__(/*! ../core/Class */ "./node_modules/_hilojs@2.0.0@hilojs/core/Class.js");
/**
 * @language=en
 * <iframe src='../../../examples/Tween.html?noHeader' width = '550' height = '130' scrolling='no'></iframe>
 * <br/>
 * Demo:
 * <pre>
 * ticker.addTick(Hilo.Tween);//Tween works after being added to ticker
 *
 * var view = new View({x:5, y:10});
 * Hilo.Tween.to(view, {
 *     x:100,
 *     y:20,
 *     alpha:0
 * }, {
 *     duration:1000,
 *     delay:500,
 *     ease:Hilo.Ease.Quad.EaseIn,
 *     onComplete:function(){
 *         console.log('complete');
 *     }
 * });
 * </pre>
 * @class Tween class makes tweening (easing, slow motion).
 * @param {Object} target Tween target object.
 * @param {Object} fromProps Beginning properties of target tweening object.
 * @param {Object} toProps Ending properties of target tweening object.
 * @param {Object} params Tweening parameters, include all writable Tween class properties.
 * @module hilo/tween/Tween
 * @requires hilo/core/Class
 * @property {Object} target Tween target object, readonly!
 * @property {Int} duration Tweening duration, measure in ms.
 * @property {Int} delay Tweenning delay time, measure in ms.
 * @property {Boolean} paused Is tweening paused, default value is false.
 * @property {Boolean} loop Does tweening loop, default value is false.
 * @property {Boolean} reverse Does tweening reverse, default value is false.
 * @property {Int} repeat Repeat times of tweening, default value is 0.
 * @property {Int} repeatDelay Delay time of repeating tweening, measure in ms.
 * @property {Function} ease Tweening transform function, default value is null.
 * @property {Int} time Time that tweening taken, measure in ms, readonly!
 * @property {Function} onStart Function invoked on the beginning of tweening. Require 1 parameter: tween. default value is null.
 * @property {Function} onUpdate Function invoked on tweening update. Require 2 parameters: ratio, tween.  default value is null.
 * @property {Function} onComplete Function invoked on the end of tweening. Require 1 parameter: tween.  default value is null.
 */


var Tween = function () {
  function now() {
    return +new Date();
  }

  return Class.create(
  /** @lends Tween.prototype */
  {
    constructor: function constructor(target, fromProps, toProps, params) {
      var me = this;
      me.target = target;
      me._startTime = 0;
      me._seekTime = 0;
      me._pausedTime = 0;
      me._pausedStartTime = 0;
      me._reverseFlag = 1;
      me._repeatCount = 0; //no fromProps if pass 3 arguments

      if (arguments.length == 3) {
        params = toProps;
        toProps = fromProps;
        fromProps = null;
      }

      for (var p in params) {
        me[p] = params[p];
      }

      me._fromProps = fromProps;
      me._toProps = toProps; //for old version compatiblity

      if (!params.duration && params.time) {
        me.duration = params.time || 0;
        me.time = 0;
      }
    },
    target: null,
    duration: 1000,
    delay: 0,
    paused: false,
    loop: false,
    reverse: false,
    repeat: 0,
    repeatDelay: 0,
    ease: null,
    time: 0,
    //ready only
    isStart: false,
    isComplete: false,
    onStart: null,
    onUpdate: null,
    onComplete: null,

    /**
     * @language=en
     * Set beginning properties and ending properties of tweening object.
     * @param {Object} fromProps Beginning properties of target tweening object.
     * @param {Object} toProps Ending properties of target tweening object.
     * @returns {Tween} Current Tween, for chain calls.
     */
    setProps: function setProps(fromProps, toProps) {
      var me = this,
          target = me.target,
          propNames = fromProps || toProps,
          from = me._fromProps = {},
          to = me._toProps = {};
      fromProps = fromProps || target;
      toProps = toProps || target;

      for (var p in propNames) {
        to[p] = toProps[p] || 0;
        target[p] = from[p] = fromProps[p] || 0;
      }

      return me;
    },

    /**
     * @language=en
     * Starting the tweening.
     * @returns {Tween} Current Tween, for chain calls.
     */
    start: function start() {
      var me = this;
      me._startTime = now() + me.delay;
      me._seekTime = 0;
      me._pausedTime = 0;
      me._reverseFlag = 1;
      me._repeatCount = 0;
      me.paused = false;
      me.isStart = false;
      me.isComplete = false;
      Tween.add(me);
      return me;
    },

    /**
     * @language=en
     * Stop the tweening.
     * @returns {Tween} Current Tween, for chain calls.
     */
    stop: function stop() {
      Tween.remove(this);
      return this;
    },

    /**
     * @language=en
     * Pause the tweening.
     * @returns {Tween} Current Tween, for chain calls.
     */
    pause: function pause() {
      var me = this;
      me.paused = true;
      me._pausedStartTime = now();
      return me;
    },

    /**
     * @language=en
     * Continue to play the tweening.
     * @returns {Tween} Current Tween, for chain calls.
     */
    resume: function resume() {
      var me = this;
      me.paused = false;
      if (me._pausedStartTime) me._pausedTime += now() - me._pausedStartTime;
      me._pausedStartTime = 0;
      return me;
    },

    /**
     * @language=en
     * Tween jumps to some point.
     * @param {Number} time The time to jump to, range from 0 to duration.
     * @param {Boolean} pause Is paused.
     * @returns {Tween} Current Tween, for chain calls.
     */
    seek: function seek(time, pause) {
      var me = this,
          current = now();
      me._startTime = current;
      me._seekTime = time;
      me._pausedTime = 0;
      if (pause !== undefined) me.paused = pause;

      me._update(current, true);

      Tween.add(me);
      return me;
    },

    /**
     * @language=en
     * Link next Tween. The beginning time of next Tween depends on the delay value. If delay is a string that begins with '+' or '-', next Tween will begin at (delay) ms after or before the current tween is ended. If delay is out of previous situation, next Tween will begin at (delay) ms after the beginning point of current Tween.
     * @param {Tween} tween Tween to link.
     * @returns {Tween} next Tween, for chain calls.
     */
    link: function link(tween) {
      var me = this,
          delay = tween.delay,
          startTime = me._startTime;
      var plus, minus;

      if (typeof delay === 'string') {
        plus = delay.indexOf('+') == 0;
        minus = delay.indexOf('-') == 0;
        delay = plus || minus ? Number(delay.substr(1)) * (plus ? 1 : -1) : Number(delay);
      }

      tween.delay = delay;
      tween._startTime = plus || minus ? startTime + me.duration + delay : startTime + delay;
      me._next = tween;
      Tween.remove(tween);
      return tween;
    },

    /**
     * @language=en
     * Private render method inside Tween class.
     * @private
     */
    _render: function _render(ratio) {
      var me = this,
          target = me.target,
          fromProps = me._fromProps,
          p;

      for (p in fromProps) {
        target[p] = fromProps[p] + (me._toProps[p] - fromProps[p]) * ratio;
      }
    },

    /**
     * @language=en
     * Private update method inside Tween class.
     * @private
     */
    _update: function _update(time, forceUpdate) {
      var me = this;
      if (me.paused && !forceUpdate) return;
      if (me.isComplete) return true; //elapsed time

      var elapsed = time - me._startTime - me._pausedTime + me._seekTime;
      if (elapsed < 0) return; //elapsed ratio

      var ratio = elapsed / me.duration,
          callback;
      ratio = ratio <= 0 ? 0 : ratio >= 1 ? 1 : ratio;
      var easeRatio = me.ease ? me.ease(ratio) : ratio;

      if (me.reverse && me.isStart) {
        //backward
        if (me._reverseFlag < 0) {
          ratio = 1 - ratio;
          easeRatio = 1 - easeRatio;
        } //forward


        if (ratio < 1e-7) {
          //repeat complete or not loop
          if (me.repeat > 0 && me._repeatCount++ >= me.repeat || me.repeat == 0 && !me.loop) ; else {
            me._startTime = now();
            me._pausedTime = 0;
            me._reverseFlag *= -1;
          }
        }
      } //start callback


      if (!me.isStart) {
        me.setProps(me._fromProps, me._toProps);
        me.isStart = true;

        if (me.onStart) {
          me.onStart.call(me, me);
        }
      }

      me.time = elapsed; //render & update callback

      me._render(easeRatio);

      (callback = me.onUpdate) && callback.call(me, easeRatio, me); //check if complete

      if (ratio >= 1) {
        if (me.reverse) {
          me._startTime = now();
          me._pausedTime = 0;
          me._reverseFlag *= -1;
        } else if (me.loop || me.repeat > 0 && me._repeatCount++ < me.repeat) {
          me._startTime = now() + me.repeatDelay;
          me._pausedTime = 0;
        } else {
          me.isComplete = true;
        }
      } //next tween


      var next = me._next;

      if (next && next.time <= 0) {
        var nextStartTime = next._startTime;

        if (nextStartTime > 0 && nextStartTime <= time) {
          //parallel tween
          next._render(ratio);

          next.time = elapsed;
          Tween.add(next);
        } else if (me.isComplete && (nextStartTime < 0 || nextStartTime > time)) {
          //next tween
          next.start();
        }
      } //complete


      if (me.isComplete) {
        (callback = me.onComplete) && callback.call(me, me);
        return true;
      }
    },
    Statics:
    /** @lends Tween */
    {
      /**
       * @language=en
       * @private
       */
      _tweens: [],

      /**
       * @language=en
       * Update all Tween instances.
       * @returns {Object} Tween。
       */
      tick: function tick() {
        var tweens = Tween._tweens,
            tween,
            i,
            len = tweens.length;

        for (i = 0; i < len; i++) {
          tween = tweens[i];

          if (tween && tween._update(now())) {
            tweens.splice(i, 1);
            i--;
          }
        }

        return Tween;
      },

      /**
       * @language=en
       * Add a Tween instance.
       * @param {Tween} tween Tween object to add.
       * @returns {Object} Tween。
       */
      add: function add(tween) {
        var tweens = Tween._tweens;
        if (tweens.indexOf(tween) == -1) tweens.push(tween);
        return Tween;
      },

      /**
       * @language=en
       * Remove one Tween target.
       * @param {Tween|Object|Array} tweenOrTarget Tween object, target object or an array of object to remove
       * @returns {Object} Tween。
       */
      remove: function remove(tweenOrTarget) {
        var i, l;

        if (tweenOrTarget instanceof Array) {
          for (i = 0, l = tweenOrTarget.length; i < l; i++) {
            Tween.remove(tweenOrTarget[i]);
          }

          return Tween;
        }

        var tweens = Tween._tweens;

        if (tweenOrTarget instanceof Tween) {
          i = tweens.indexOf(tweenOrTarget);
          if (i > -1) tweens.splice(i, 1);
        } else {
          for (i = 0; i < tweens.length; i++) {
            if (tweens[i].target === tweenOrTarget) {
              tweens.splice(i, 1);
              i--;
            }
          }
        }

        return Tween;
      },

      /**
       * @language=en
       * Remove all Tween instances.
       * @returns {Object} Tween。
       */
      removeAll: function removeAll() {
        Tween._tweens.length = 0;
        return Tween;
      },

      /**
       * @language=en
       * Create a tween, make target object easing from beginning properties to ending properties.
       * @param {Object|Array} target Tweening target or tweening target array.
       * @param fromProps Beginning properties of target tweening object.
       * @param toProps Ending properties of target tweening object.
       * @param params Tweening parameters.
       * @returns {Tween|Array} An tween instance or an array of tween instance.
       */
      fromTo: function fromTo(target, fromProps, toProps, params) {
        params = params || {};
        var isArray = target instanceof Array;
        target = isArray ? target : [target];
        var tween,
            i,
            stagger = params.stagger,
            tweens = [];

        for (i = 0; i < target.length; i++) {
          tween = new Tween(target[i], fromProps, toProps, params);
          if (stagger) tween.delay = (params.delay || 0) + (i * stagger || 0);
          tween.start();
          tweens.push(tween);
        }

        return isArray ? tweens : tween;
      },

      /**
       * @language=en
       * Create a tween, make target object easing from current properties to ending properties.
       * @param {Object|Array} target Tweening target or tweening target array.
       * @param toProps Ending properties of target tweening object.
       * @param params Tweening parameters.
       * @returns {Tween|Array} An tween instance or an array of tween instance.
       */
      to: function to(target, toProps, params) {
        return Tween.fromTo(target, null, toProps, params);
      },

      /**
       * @language=en
       * Create a tween, make target object easing from beginning properties to current properties.
       * @param {Object|Array} target Tweening target or tweening target array.
       * @param fromProps Beginning properties of target tweening object.
       * @param params Tweening parameters.
       * @returns {Tween|Array} An tween instance or an array of tween instance.
       */
      from: function from(target, fromProps, params) {
        return Tween.fromTo(target, fromProps, null, params);
      }
    }
  });
}();

module.exports = Tween;

/***/ }),

/***/ "./node_modules/_hilojs@2.0.0@hilojs/util/Ticker.js":
/*!**********************************************************!*\
  !*** ./node_modules/_hilojs@2.0.0@hilojs/util/Ticker.js ***!
  \**********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Hilo 2.0.0 for commonjs
 * Copyright 2016 alibaba.com
 * Licensed under the MIT License
 */
var Class = __webpack_require__(/*! ../core/Class */ "./node_modules/_hilojs@2.0.0@hilojs/core/Class.js");

var browser = __webpack_require__(/*! ./browser */ "./node_modules/_hilojs@2.0.0@hilojs/util/browser.js");
/**
 * @language=en
 * @class Ticker is a Timer. It can run the code at specified framerate.
 * @param {Number} fps The fps of ticker.Default is 60.
 * @module hilo/util/Ticker
 * @requires hilo/core/Class
 * @requires hilo/util/browser
 */


var Ticker = Class.create(
/** @lends Ticker.prototype */
{
  constructor: function constructor(fps) {
    this._targetFPS = fps || 60;
    this._interval = 1000 / this._targetFPS;
    this._tickers = [];
  },
  _paused: false,
  _targetFPS: 0,
  _interval: 0,
  _intervalId: null,
  _tickers: null,
  _lastTime: 0,
  _tickCount: 0,
  _tickTime: 0,
  _measuredFPS: 0,

  /**
   * @language=en
   * Start the ticker.
   * @param {Boolean} userRAF Whether or not use requestAnimationFrame, default is true.
   */
  start: function start(useRAF) {
    if (useRAF === undefined) {
      useRAF = true;
    }

    if (this._intervalId) return;
    this._lastTime = +new Date();
    var self = this,
        interval = this._interval,
        raf = window.requestAnimationFrame || window[browser.jsVendor + 'RequestAnimationFrame'];

    var _runLoop2;

    if (useRAF && raf && interval < 17) {
      this._useRAF = true;

      _runLoop2 = function runLoop() {
        self._intervalId = raf(_runLoop2);

        self._tick();
      };
    } else {
      _runLoop2 = function _runLoop() {
        self._intervalId = setTimeout(_runLoop2, interval);

        self._tick();
      };
    }

    this._paused = false;

    _runLoop2();
  },

  /**
   * @language=en
   * Stop the ticker.
   */
  stop: function stop() {
    if (this._useRAF) {
      var cancelRAF = window.cancelAnimationFrame || window[browser.jsVendor + 'CancelAnimationFrame'];
      cancelRAF(this._intervalId);
    } else {
      clearTimeout(this._intervalId);
    }

    this._intervalId = null;
    this._lastTime = 0;
    this._paused = true;
  },

  /**
   * @language=en
   * Pause the ticker.
   */
  pause: function pause() {
    this._paused = true;
  },

  /**
   * @language=en
   * Resume the ticker.
   */
  resume: function resume() {
    this._paused = false;
  },

  /**
   * @private
   */
  _tick: function _tick() {
    if (this._paused) return;
    var startTime = +new Date(),
        deltaTime = startTime - this._lastTime,
        tickers = this._tickers; //calculates the real fps

    if (++this._tickCount >= this._targetFPS) {
      this._measuredFPS = 1000 / (this._tickTime / this._tickCount) + 0.5 >> 0;
      this._tickCount = 0;
      this._tickTime = 0;
    } else {
      this._tickTime += startTime - this._lastTime;
    }

    this._lastTime = startTime;
    var tickersCopy = tickers.slice(0);

    for (var i = 0, len = tickersCopy.length; i < len; i++) {
      tickersCopy[i].tick(deltaTime);
    }
  },

  /**
   * @language=en
   * Get the fps.
   */
  getMeasuredFPS: function getMeasuredFPS() {
    return Math.min(this._measuredFPS, this._targetFPS);
  },

  /**
   * @language=en
   * Add tickObject. The tickObject must implement the tick method.
   * @param {Object} tickObject The tickObject to add.It must implement the tick method.
   */
  addTick: function addTick(tickObject) {
    if (!tickObject || typeof tickObject.tick != 'function') {
      throw new Error('Ticker: The tick object must implement the tick method.');
    }

    this._tickers.push(tickObject);
  },

  /**
   * @language=en
   * Remove the tickObject
   * @param {Object} tickObject The tickObject to remove.
   */
  removeTick: function removeTick(tickObject) {
    var tickers = this._tickers,
        index = tickers.indexOf(tickObject);

    if (index >= 0) {
      tickers.splice(index, 1);
    }
  },

  /**
   * 下次tick时回调
   * @param  {Function} callback
   * @return {tickObj}
   */
  nextTick: function nextTick(callback) {
    var that = this;
    var tickObj = {
      tick: function tick(dt) {
        that.removeTick(tickObj);
        callback();
      }
    };
    that.addTick(tickObj);
    return tickObj;
  },

  /**
   * 延迟指定的时间后调用回调, 类似setTimeout
   * @param  {Function} callback
   * @param  {Number}   duration 延迟的毫秒数
   * @return {tickObj}
   */
  timeout: function timeout(callback, duration) {
    var that = this;
    var targetTime = new Date().getTime() + duration;
    var tickObj = {
      tick: function tick() {
        var nowTime = new Date().getTime();
        var dt = nowTime - targetTime;

        if (dt >= 0) {
          that.removeTick(tickObj);
          callback();
        }
      }
    };
    that.addTick(tickObj);
    return tickObj;
  },

  /**
   * 指定的时间周期来调用函数, 类似setInterval
   * @param  {Function} callback
   * @param  {Number}   duration 时间周期，单位毫秒
   * @return {tickObj}
   */
  interval: function interval(callback, duration) {
    var that = this;
    var targetTime = new Date().getTime() + duration;
    var tickObj = {
      tick: function tick() {
        var nowTime = new Date().getTime();
        var dt = nowTime - targetTime;

        if (dt >= 0) {
          if (dt < duration) {
            nowTime -= dt;
          }

          targetTime = nowTime + duration;
          callback();
        }
      }
    };
    that.addTick(tickObj);
    return tickObj;
  }
});
module.exports = Ticker;

/***/ }),

/***/ "./node_modules/_hilojs@2.0.0@hilojs/util/browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/_hilojs@2.0.0@hilojs/util/browser.js ***!
  \***********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

/**
 * Hilo 2.0.0 for commonjs
 * Copyright 2016 alibaba.com
 * Licensed under the MIT License
 */

/**
 * @language=en
 * @class Browser feature set
 * @static
 * @module hilo/util/browser
 */
var browser = function () {
  var ua = navigator.userAgent;
  var doc = document;
  var win = window;
  var docElem = doc.documentElement;
  var data =
  /** @lends browser */
  {
    /**
     * 是否是iphone
     * @type {Boolean}
     */
    iphone: /iphone/i.test(ua),

    /**
     * 是否是ipad
     * @type {Boolean}
     */
    ipad: /ipad/i.test(ua),

    /**
     * 是否是ipod
     * @type {Boolean}
     */
    ipod: /ipod/i.test(ua),

    /**
     * 是否是ios
     * @type {Boolean}
     */
    ios: /iphone|ipad|ipod/i.test(ua),

    /**
     * 是否是android
     * @type {Boolean}
     */
    android: /android/i.test(ua),

    /**
     * 是否是webkit
     * @type {Boolean}
     */
    webkit: /webkit/i.test(ua),

    /**
     * 是否是chrome
     * @type {Boolean}
     */
    chrome: /chrome/i.test(ua),

    /**
     * 是否是safari
     * @type {Boolean}
     */
    safari: /safari/i.test(ua),

    /**
     * 是否是firefox
     * @type {Boolean}
     */
    firefox: /firefox/i.test(ua),

    /**
     * 是否是ie
     * @type {Boolean}
     */
    ie: /msie/i.test(ua),

    /**
     * 是否是opera
     * @type {Boolean}
     */
    opera: /opera/i.test(ua),

    /**
     * 是否支持触碰事件。
     * @type {String}
     */
    supportTouch: 'ontouchstart' in win,

    /**
     * 是否支持canvas元素。
     * @type {Boolean}
     */
    supportCanvas: doc.createElement('canvas').getContext != null,

    /**
     * 是否支持本地存储localStorage。
     * @type {Boolean}
     */
    supportStorage: false,

    /**
     * 是否支持检测设备方向orientation。
     * @type {Boolean}
     */
    supportOrientation: 'orientation' in win || 'orientation' in win.screen,

    /**
     * 是否支持检测加速度devicemotion。
     * @type {Boolean}
     */
    supportDeviceMotion: 'ondevicemotion' in win
  }; //`localStorage` is null or `localStorage.setItem` throws error in some cases (e.g. localStorage is disabled)

  try {
    var value = 'hilo';
    localStorage.setItem(value, value);
    localStorage.removeItem(value);
    data.supportStorage = true;
  } catch (e) {}
  /**
   * 浏览器厂商CSS前缀的js值。比如：webkit。
   * @type {String}
   */


  var jsVendor = data.jsVendor = data.webkit ? 'webkit' : data.firefox ? 'webkit' : data.opera ? 'o' : data.ie ? 'ms' : '';
  /**
   * 浏览器厂商CSS前缀的css值。比如：-webkit-。
   * @type {String}
   */

  var cssVendor = data.cssVendor = '-' + jsVendor + '-'; //css transform/3d feature dectection

  var testElem = doc.createElement('div'),
      style = testElem.style;
  /**
   * 是否支持CSS Transform变换。
   * @type {Boolean}
   */

  var supportTransform = style[jsVendor + 'Transform'] != undefined;
  /**
   * 是否支持CSS Transform 3D变换。
   * @type {Boolean}
   */

  var supportTransform3D = style[jsVendor + 'Perspective'] != undefined;

  if (supportTransform3D) {
    testElem.id = 'test3d';
    style = doc.createElement('style');
    style.textContent = '@media (' + cssVendor + 'transform-3d){#test3d{height:3px}}';
    doc.head.appendChild(style);
    docElem.appendChild(testElem);
    supportTransform3D = testElem.offsetHeight == 3;
    doc.head.removeChild(style);
    docElem.removeChild(testElem);
  }

  data.supportTransform = supportTransform;
  data.supportTransform3D = supportTransform3D;
  var supportTouch = data.supportTouch;
  /**
   * 鼠标或触碰开始事件。对应touchstart或mousedown。
   * @type {String}
   */

  var POINTER_START = supportTouch ? 'touchstart' : 'mousedown';
  /**
   * 鼠标或触碰移动事件。对应touchmove或mousemove。
   * @type {String}
   */

  var POINTER_MOVE = supportTouch ? 'touchmove' : 'mousemove';
  /**
   * 鼠标或触碰结束事件。对应touchend或mouseup。
   * @type {String}
   */

  var POINTER_END = supportTouch ? 'touchend' : 'mouseup';
  data.POINTER_START = POINTER_START;
  data.POINTER_MOVE = POINTER_MOVE;
  data.POINTER_END = POINTER_END;
  return data;
}();

module.exports = browser;

/***/ }),

/***/ "./node_modules/_object-assign@4.1.1@object-assign/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/_object-assign@4.1.1@object-assign/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),

/***/ "./node_modules/_object-values@2.0.0@object-values/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/_object-values@2.0.0@object-values/index.js ***!
  \******************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {


module.exports = function (object) {
  return Object.keys(object).map(function (i) {
    return object[i];
  });
};

/***/ }),

/***/ "./node_modules/_object.keys@0.1.0@object.keys/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/_object.keys@0.1.0@object.keys/index.js ***!
  \**************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {
/**
 * Object.keys() - Polyfill
 *
 * @ref https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
 */


(function () {
  if (!Object.keys) {
    Object.keys = function () {

      var hasOwnProperty = Object.prototype.hasOwnProperty,
          hasDontEnumBug = !{
        toString: null
      }.propertyIsEnumerable('toString'),
          dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
          dontEnumsLength = dontEnums.length;
      return function (obj) {
        if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
          throw new TypeError('Object.keys called on non-object');
        }

        var result = [],
            prop,
            i;

        for (prop in obj) {
          if (hasOwnProperty.call(obj, prop)) {
            result.push(prop);
          }
        }

        if (hasDontEnumBug) {
          for (i = 0; i < dontEnumsLength; i++) {
            if (hasOwnProperty.call(obj, dontEnums[i])) {
              result.push(dontEnums[i]);
            }
          }
        }

        return result;
      };
    }();
  }
})();

/***/ }),

/***/ "./node_modules/_parse-hdr@1.0.0@parse-hdr/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/_parse-hdr@1.0.0@parse-hdr/index.js ***!
  \**********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

//Code ported by Marcin Ignac (2014)
//Based on Java implementation from
//https://code.google.com/r/cys12345-research/source/browse/hdr/image_processor/RGBE.java?r=7d84e9fd866b24079dbe61fa0a966ce8365f5726
var radiancePattern = "#\\?RADIANCE";
var commentPattern = "#.*";
var exposurePattern = "EXPOSURE=\\s*([0-9]*[.][0-9]*)";
var formatPattern = "FORMAT=32-bit_rle_rgbe";
var widthHeightPattern = "-Y ([0-9]+) \\+X ([0-9]+)"; //http://croquetweak.blogspot.co.uk/2014/08/deconstructing-floats-frexp-and-ldexp.html

function readPixelsRawRLE(buffer, data, offset, fileOffset, scanline_width, num_scanlines) {
  var rgbe = new Array(4);
  var scanline_buffer = null;
  var ptr;
  var ptr_end;
  var count;
  var buf = new Array(2);
  var bufferLength = buffer.length;

  function readBuf(buf) {
    var bytesRead = 0;

    do {
      buf[bytesRead++] = buffer[fileOffset];
    } while (++fileOffset < bufferLength && bytesRead < buf.length);

    return bytesRead;
  }

  function readBufOffset(buf, offset, length) {
    var bytesRead = 0;

    do {
      buf[offset + bytesRead++] = buffer[fileOffset];
    } while (++fileOffset < bufferLength && bytesRead < length);

    return bytesRead;
  }

  function readPixelsRaw(buffer, data, offset, numpixels) {
    var numExpected = 4 * numpixels;
    var numRead = readBufOffset(data, offset, numExpected);

    if (numRead < numExpected) {
      throw new Error('Error reading raw pixels: got ' + numRead + ' bytes, expected ' + numExpected);
    }
  }

  while (num_scanlines > 0) {
    if (readBuf(rgbe) < rgbe.length) {
      throw new Error("Error reading bytes: expected " + rgbe.length);
    }

    if (rgbe[0] != 2 || rgbe[1] != 2 || (rgbe[2] & 0x80) != 0) {
      //this file is not run length encoded
      data[offset++] = rgbe[0];
      data[offset++] = rgbe[1];
      data[offset++] = rgbe[2];
      data[offset++] = rgbe[3];
      readPixelsRaw(buffer, data, offset, scanline_width * num_scanlines - 1);
      return;
    }

    if (((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) != scanline_width) {
      throw new Error("Wrong scanline width " + ((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) + ", expected " + scanline_width);
    }

    if (scanline_buffer == null) {
      scanline_buffer = new Array(4 * scanline_width);
    }

    ptr = 0;
    /* read each of the four channels for the scanline into the buffer */

    for (var i = 0; i < 4; i++) {
      ptr_end = (i + 1) * scanline_width;

      while (ptr < ptr_end) {
        if (readBuf(buf) < buf.length) {
          throw new Error("Error reading 2-byte buffer");
        }

        if ((buf[0] & 0xFF) > 128) {
          /* a run of the same value */
          count = (buf[0] & 0xFF) - 128;

          if (count == 0 || count > ptr_end - ptr) {
            throw new Error("Bad scanline data");
          }

          while (count-- > 0) {
            scanline_buffer[ptr++] = buf[1];
          }
        } else {
          /* a non-run */
          count = buf[0] & 0xFF;

          if (count == 0 || count > ptr_end - ptr) {
            throw new Error("Bad scanline data");
          }

          scanline_buffer[ptr++] = buf[1];

          if (--count > 0) {
            if (readBufOffset(scanline_buffer, ptr, count) < count) {
              throw new Error("Error reading non-run data");
            }

            ptr += count;
          }
        }
      }
    }
    /* copy byte data to output */


    for (var i = 0; i < scanline_width; i++) {
      data[offset + 0] = scanline_buffer[i];
      data[offset + 1] = scanline_buffer[i + scanline_width];
      data[offset + 2] = scanline_buffer[i + 2 * scanline_width];
      data[offset + 3] = scanline_buffer[i + 3 * scanline_width];
      offset += 4;
    }

    num_scanlines--;
  }
} //Returns data as floats and flipped along Y by default


function parseHdr(buffer) {
  if (buffer instanceof ArrayBuffer) {
    buffer = new Uint8Array(buffer);
  }

  var fileOffset = 0;
  var bufferLength = buffer.length;
  var NEW_LINE = 10;

  function readLine() {
    var buf = "";

    do {
      var b = buffer[fileOffset];

      if (b == NEW_LINE) {
        ++fileOffset;
        break;
      }

      buf += String.fromCharCode(b);
    } while (++fileOffset < bufferLength);

    return buf;
  }

  var width = 0;
  var height = 0;
  var exposure = 1;
  var gamma = 1;
  var rle = false;

  for (var i = 0; i < 20; i++) {
    var line = readLine();
    var match;

    if (match = line.match(radiancePattern)) ; else if (match = line.match(formatPattern)) {
      rle = true;
    } else if (match = line.match(exposurePattern)) {
      exposure = Number(match[1]);
    } else if (match = line.match(commentPattern)) ; else if (match = line.match(widthHeightPattern)) {
      height = Number(match[1]);
      width = Number(match[2]);
      break;
    }
  }

  if (!rle) {
    throw new Error("File is not run length encoded!");
  }

  var data = new Uint8Array(width * height * 4);
  var scanline_width = width;
  var num_scanlines = height;
  readPixelsRawRLE(buffer, data, 0, fileOffset, scanline_width, num_scanlines); //TODO: Should be Float16

  var floatData = new Float32Array(width * height * 4);

  for (var offset = 0; offset < data.length; offset += 4) {
    var r = data[offset + 0] / 255;
    var g = data[offset + 1] / 255;
    var b = data[offset + 2] / 255;
    var e = data[offset + 3];
    var f = Math.pow(2.0, e - 128.0);
    r *= f;
    g *= f;
    b *= f;
    var floatOffset = offset;
    floatData[floatOffset + 0] = r;
    floatData[floatOffset + 1] = g;
    floatData[floatOffset + 2] = b;
    floatData[floatOffset + 3] = 1.0;
  }

  return {
    shape: [width, height],
    exposure: exposure,
    gamma: gamma,
    data: floatData
  };
}

module.exports = parseHdr;

/***/ }),

/***/ "./node_modules/_pinkie-promise@2.0.1@pinkie-promise/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/_pinkie-promise@2.0.1@pinkie-promise/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {


module.exports = typeof Promise === 'function' ? Promise : __webpack_require__(/*! pinkie */ "./node_modules/_pinkie@2.0.4@pinkie/index.js");

/***/ }),

/***/ "./node_modules/_pinkie@2.0.4@pinkie/index.js":
/*!****************************************************!*\
  !*** ./node_modules/_pinkie@2.0.4@pinkie/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {

var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';

var NOOP = function NOOP() {};

var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';
var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
  // run promise callbacks
  for (var i = 0; i < asyncQueue.length; i++) {
    asyncQueue[i][0](asyncQueue[i][1]);
  } // reset async asyncQueue


  asyncQueue = [];
  asyncTimer = false;
}

function asyncCall(callback, arg) {
  asyncQueue.push([callback, arg]);

  if (!asyncTimer) {
    asyncTimer = true;
    asyncSetTimer(asyncFlush, 0);
  }
}

function invokeResolver(resolver, promise) {
  function resolvePromise(value) {
    resolve(promise, value);
  }

  function rejectPromise(reason) {
    reject(promise, reason);
  }

  try {
    resolver(resolvePromise, rejectPromise);
  } catch (e) {
    rejectPromise(e);
  }
}

function invokeCallback(subscriber) {
  var owner = subscriber.owner;
  var settled = owner._state;
  var value = owner._data;
  var callback = subscriber[settled];
  var promise = subscriber.then;

  if (typeof callback === 'function') {
    settled = FULFILLED;

    try {
      value = callback(value);
    } catch (e) {
      reject(promise, e);
    }
  }

  if (!handleThenable(promise, value)) {
    if (settled === FULFILLED) {
      resolve(promise, value);
    }

    if (settled === REJECTED) {
      reject(promise, value);
    }
  }
}

function handleThenable(promise, value) {
  var resolved;

  try {
    if (promise === value) {
      throw new TypeError('A promises callback cannot return that same promise.');
    }

    if (value && (typeof value === 'function' || typeof value === 'object')) {
      // then should be retrieved only once
      var then = value.then;

      if (typeof then === 'function') {
        then.call(value, function (val) {
          if (!resolved) {
            resolved = true;

            if (value === val) {
              fulfill(promise, val);
            } else {
              resolve(promise, val);
            }
          }
        }, function (reason) {
          if (!resolved) {
            resolved = true;
            reject(promise, reason);
          }
        });
        return true;
      }
    }
  } catch (e) {
    if (!resolved) {
      reject(promise, e);
    }

    return true;
  }

  return false;
}

function resolve(promise, value) {
  if (promise === value || !handleThenable(promise, value)) {
    fulfill(promise, value);
  }
}

function fulfill(promise, value) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = value;
    asyncCall(publishFulfillment, promise);
  }
}

function reject(promise, reason) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = reason;
    asyncCall(publishRejection, promise);
  }
}

function publish(promise) {
  promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
  promise._state = FULFILLED;
  publish(promise);
}

function publishRejection(promise) {
  promise._state = REJECTED;
  publish(promise);

  if (!promise._handled && isNode) {
    global.process.emit('unhandledRejection', promise._data, promise);
  }
}

function notifyRejectionHandled(promise) {
  global.process.emit('rejectionHandled', promise);
}
/**
 * @class
 */


function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('Promise resolver ' + resolver + ' is not a function');
  }

  if (this instanceof Promise === false) {
    throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
  }

  this._then = [];
  invokeResolver(resolver, this);
}

Promise.prototype = {
  constructor: Promise,
  _state: PENDING,
  _then: null,
  _data: undefined,
  _handled: false,
  then: function then(onFulfillment, onRejection) {
    var subscriber = {
      owner: this,
      then: new this.constructor(NOOP),
      fulfilled: onFulfillment,
      rejected: onRejection
    };

    if ((onRejection || onFulfillment) && !this._handled) {
      this._handled = true;

      if (this._state === REJECTED && isNode) {
        asyncCall(notifyRejectionHandled, this);
      }
    }

    if (this._state === FULFILLED || this._state === REJECTED) {
      // already resolved, call callback async
      asyncCall(invokeCallback, subscriber);
    } else {
      // subscribe
      this._then.push(subscriber);
    }

    return subscriber.then;
  },
  "catch": function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

Promise.all = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.all().');
  }

  return new Promise(function (resolve, reject) {
    var results = [];
    var remaining = 0;

    function resolver(index) {
      remaining++;
      return function (value) {
        results[index] = value;

        if (! --remaining) {
          resolve(results);
        }
      };
    }

    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolver(i), reject);
      } else {
        results[i] = promise;
      }
    }

    if (!remaining) {
      resolve(results);
    }
  });
};

Promise.race = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.race().');
  }

  return new Promise(function (resolve, reject) {
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
  });
};

Promise.resolve = function (value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function (resolve) {
    resolve(value);
  });
};

Promise.reject = function (reason) {
  return new Promise(function (resolve, reject) {
    reject(reason);
  });
};

module.exports = Promise;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.43.0@webpack/buildin/global.js */ "./node_modules/_webpack@4.43.0@webpack/buildin/global.js"), __webpack_require__(/*! ./../_timers-browserify@2.0.11@timers-browserify/main.js */ "./node_modules/_timers-browserify@2.0.11@timers-browserify/main.js").setImmediate));

/***/ }),

/***/ "./node_modules/_process@0.11.10@process/browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/_process@0.11.10@process/browser.js ***!
  \**********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/_ray-3d@1.1.1@ray-3d/index.js":
/*!****************************************************!*\
  !*** ./node_modules/_ray-3d@1.1.1@ray-3d/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

var intersectRayTriangle = __webpack_require__(/*! ray-triangle-intersection */ "./node_modules/_ray-triangle-intersection@1.0.3@ray-triangle-intersection/index.js");

var intersectRayPlane = __webpack_require__(/*! ray-plane-intersection */ "./node_modules/_ray-plane-intersection@1.0.0@ray-plane-intersection/index.js");

var intersectRaySphere = __webpack_require__(/*! ray-sphere-intersection */ "./node_modules/_ray-sphere-intersection@1.0.0@ray-sphere-intersection/index.js");

var intersectRayBox = __webpack_require__(/*! ray-aabb-intersection */ "./node_modules/_ray-aabb-intersection@1.0.1@ray-aabb-intersection/index.js");

var copy3 = __webpack_require__(/*! gl-vec3/copy */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/copy.js");

var tmpTriangle = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
var tmp3 = [0, 0, 0];
module.exports = Ray;

function Ray(origin, direction) {
  this.origin = origin || [0, 0, 0];
  this.direction = direction || [0, 0, -1];
}

Ray.prototype.set = function (origin, direction) {
  this.origin = origin;
  this.direction = direction;
};

Ray.prototype.copy = function (other) {
  copy3(this.origin, other.origin);
  copy3(this.direction, other.direction);
};

Ray.prototype.clone = function () {
  var other = new Ray();
  other.copy(this);
  return other;
};

Ray.prototype.intersectsSphere = function (center, radius) {
  return intersectRaySphere(tmp3, this.origin, this.direction, center, radius);
};

Ray.prototype.intersectsPlane = function (normal, distance) {
  return intersectRayPlane(tmp3, this.origin, this.direction, normal, distance);
};

Ray.prototype.intersectsTriangle = function (triangle) {
  return intersectRayTriangle(tmp3, this.origin, this.direction, triangle);
};

Ray.prototype.intersectsBox = function (aabb) {
  return intersectRayBox(tmp3, this.origin, this.direction, aabb);
};

Ray.prototype.intersectsTriangleCell = function (cell, positions) {
  var a = cell[0],
      b = cell[1],
      c = cell[2];
  tmpTriangle[0] = positions[a];
  tmpTriangle[1] = positions[b];
  tmpTriangle[2] = positions[c];
  return this.intersectsTriangle(tmpTriangle);
};

/***/ }),

/***/ "./node_modules/_ray-aabb-intersection@1.0.1@ray-aabb-intersection/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/_ray-aabb-intersection@1.0.1@ray-aabb-intersection/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = intersection;
module.exports.distance = distance;

function intersection(out, ro, rd, aabb) {
  var d = distance(ro, rd, aabb);

  if (d === Infinity) {
    out = null;
  } else {
    out = out || [];

    for (var i = 0; i < ro.length; i++) {
      out[i] = ro[i] + rd[i] * d;
    }
  }

  return out;
}

function distance(ro, rd, aabb) {
  var dims = ro.length;
  var lo = -Infinity;
  var hi = +Infinity;

  for (var i = 0; i < dims; i++) {
    var dimLo = (aabb[0][i] - ro[i]) / rd[i];
    var dimHi = (aabb[1][i] - ro[i]) / rd[i];

    if (dimLo > dimHi) {
      var tmp = dimLo;
      dimLo = dimHi;
      dimHi = tmp;
    }

    if (dimHi < lo || dimLo > hi) {
      return Infinity;
    }

    if (dimLo > lo) lo = dimLo;
    if (dimHi < hi) hi = dimHi;
  }

  return lo > hi ? Infinity : lo;
}

/***/ }),

/***/ "./node_modules/_ray-plane-intersection@1.0.0@ray-plane-intersection/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/_ray-plane-intersection@1.0.0@ray-plane-intersection/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

var dot = __webpack_require__(/*! gl-vec3/dot */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/dot.js");

var add = __webpack_require__(/*! gl-vec3/add */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/add.js");

var scale = __webpack_require__(/*! gl-vec3/scale */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/scale.js");

var copy = __webpack_require__(/*! gl-vec3/copy */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/copy.js");

module.exports = intersectRayPlane;
var v0 = [0, 0, 0];

function intersectRayPlane(out, origin, direction, normal, dist) {
  var denom = dot(direction, normal);

  if (denom !== 0) {
    var t = -(dot(origin, normal) + dist) / denom;

    if (t < 0) {
      return null;
    }

    scale(v0, direction, t);
    return add(out, origin, v0);
  } else if (dot(normal, origin) + dist === 0) {
    return copy(out, origin);
  } else {
    return null;
  }
}

/***/ }),

/***/ "./node_modules/_ray-sphere-intersection@1.0.0@ray-sphere-intersection/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/_ray-sphere-intersection@1.0.0@ray-sphere-intersection/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

var squaredDist = __webpack_require__(/*! gl-vec3/squaredDistance */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/squaredDistance.js");

var dot = __webpack_require__(/*! gl-vec3/dot */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/dot.js");

var sub = __webpack_require__(/*! gl-vec3/subtract */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/subtract.js");

var scaleAndAdd = __webpack_require__(/*! gl-vec3/scaleAndAdd */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/scaleAndAdd.js");

var scale = __webpack_require__(/*! gl-vec3/scale */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/scale.js");

var add = __webpack_require__(/*! gl-vec3/add */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/add.js");

var tmp = [0, 0, 0];
module.exports = intersectRaySphere;

function intersectRaySphere(out, origin, direction, center, radius) {
  sub(tmp, center, origin);
  var len = dot(direction, tmp);

  if (len < 0) {
    // sphere is behind ray
    return null;
  }

  scaleAndAdd(tmp, origin, direction, len);
  var dSq = squaredDist(center, tmp);
  var rSq = radius * radius;

  if (dSq > rSq) {
    return null;
  }

  scale(out, direction, len - Math.sqrt(rSq - dSq));
  return add(out, out, origin);
}

/***/ }),

/***/ "./node_modules/_ray-triangle-intersection@1.0.3@ray-triangle-intersection/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/_ray-triangle-intersection@1.0.3@ray-triangle-intersection/index.js ***!
  \******************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

var cross = __webpack_require__(/*! gl-vec3/cross */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/cross.js");

var dot = __webpack_require__(/*! gl-vec3/dot */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/dot.js");

var sub = __webpack_require__(/*! gl-vec3/subtract */ "./node_modules/_gl-vec3@1.1.3@gl-vec3/subtract.js");

var EPSILON = 0.000001;
var edge1 = [0, 0, 0];
var edge2 = [0, 0, 0];
var tvec = [0, 0, 0];
var pvec = [0, 0, 0];
var qvec = [0, 0, 0];
module.exports = intersectTriangle;

function intersectTriangle(out, pt, dir, tri) {
  sub(edge1, tri[1], tri[0]);
  sub(edge2, tri[2], tri[0]);
  cross(pvec, dir, edge2);
  var det = dot(edge1, pvec);
  if (det < EPSILON) return null;
  sub(tvec, pt, tri[0]);
  var u = dot(tvec, pvec);
  if (u < 0 || u > det) return null;
  cross(qvec, tvec, edge1);
  var v = dot(dir, qvec);
  if (v < 0 || u + v > det) return null;
  var t = dot(edge2, qvec) / det;
  out[0] = pt[0] + t * dir[0];
  out[1] = pt[1] + t * dir[1];
  out[2] = pt[2] + t * dir[2];
  return out;
}

/***/ }),

/***/ "./node_modules/_setimmediate@1.0.5@setimmediate/setImmediate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/_setimmediate@1.0.5@setimmediate/setImmediate.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined$1) {

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined$1, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.43.0@webpack/buildin/global.js */ "./node_modules/_webpack@4.43.0@webpack/buildin/global.js"), __webpack_require__(/*! ./../_process@0.11.10@process/browser.js */ "./node_modules/_process@0.11.10@process/browser.js")));

/***/ }),

/***/ "./node_modules/_timers-browserify@2.0.11@timers-browserify/main.js":
/*!**************************************************************************!*\
  !*** ./node_modules/_timers-browserify@2.0.11@timers-browserify/main.js ***!
  \**************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/_setimmediate@1.0.5@setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.43.0@webpack/buildin/global.js */ "./node_modules/_webpack@4.43.0@webpack/buildin/global.js")));

/***/ }),

/***/ "./node_modules/_webpack@4.43.0@webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/Hilo3d.js":
/*!*************************************!*\
  !*** ./src/Hilo3d.js + 100 modules ***!
  \*************************************/
/*! exports provided: util, GLTFExtensions, Class, EventMixin, Fog, Mesh, Node, SkinedMesh, Skeleton, Stage, Tween, version, BoxGeometry, Geometry, GeometryData, MorphGeometry, PlaneGeometry, SphereGeometry, Camera, PerspectiveCamera, OrthographicCamera, Buffer, capabilities, extensions, Framebuffer, glType, logGLResource, Program, RenderInfo, RenderList, VertexArrayObject, WebGLRenderer, WebGLResourceManager, WebGLState, BasicLoader, CubeTextureLoader, GLTFLoader, GLTFParser, AliAMCExtension, HDRLoader, KTXLoader, LoadCache, LoadQueue, ShaderMaterialLoader, TextureLoader, Loader, Texture, LazyTexture, CubeTexture, DataTexture, Shader, BasicMaterial, GeometryMaterial, Material, PBRMaterial, semantic, ShaderMaterial, AxisHelper, AxisNetHelper, CameraHelper, AmbientLight, AreaLight, DirectionalLight, CubeLightShadow, Light, LightManager, LightShadow, PointLight, SpotLight, Animation, AnimationStates, MeshPicker, Ticker, log, Cache, browser, WebGLSupport, constants, Color, Euler, EulerNotifier, Frustum, math, Matrix3, Matrix4, Matrix4Notifier, Plane, Quaternion, Ray, Sphere, SphericalHarmonics3, Vector2, Vector3, Vector3Notifier, Vector4 */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_amc@1.0.6@amc/build/amd.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_gl-constants@1.0.0@gl-constants/1.0/index.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_gl-extensions-constants@1.0.0@gl-extensions-constants/index.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_gl-matrix@2.8.1@gl-matrix/dist/gl-matrix-min.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_hilojs@2.0.0@hilojs/core/Class.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_hilojs@2.0.0@hilojs/event/EventMixin.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_hilojs@2.0.0@hilojs/tween/Ease.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_hilojs@2.0.0@hilojs/tween/Tween.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_hilojs@2.0.0@hilojs/util/Ticker.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_hilojs@2.0.0@hilojs/util/browser.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_parse-hdr@1.0.0@parse-hdr/index.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/_ray-3d@1.1.1@ray-3d/index.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/shader/basic.frag (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/shader/basic.vert (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/shader/geometry.frag (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/shader/pbr.frag (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/shader/screen.frag (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./src/shader/screen.vert (<- Module is not an ECMAScript module) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "util", function() { return /* reexport */ util_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "GLTFExtensions", function() { return /* reexport */ GLTFExtensions_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "Class", function() { return /* reexport */ core_Class; });
__webpack_require__.d(__webpack_exports__, "EventMixin", function() { return /* reexport */ core_EventMixin; });
__webpack_require__.d(__webpack_exports__, "Fog", function() { return /* reexport */ core_Fog; });
__webpack_require__.d(__webpack_exports__, "Mesh", function() { return /* reexport */ core_Mesh; });
__webpack_require__.d(__webpack_exports__, "Node", function() { return /* reexport */ core_Node; });
__webpack_require__.d(__webpack_exports__, "SkinedMesh", function() { return /* reexport */ core_SkinedMesh; });
__webpack_require__.d(__webpack_exports__, "Skeleton", function() { return /* reexport */ core_Skeleton; });
__webpack_require__.d(__webpack_exports__, "Stage", function() { return /* reexport */ core_Stage; });
__webpack_require__.d(__webpack_exports__, "Tween", function() { return /* reexport */ core_Tween; });
__webpack_require__.d(__webpack_exports__, "version", function() { return /* reexport */ core_version; });
__webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return /* reexport */ geometry_BoxGeometry; });
__webpack_require__.d(__webpack_exports__, "Geometry", function() { return /* reexport */ geometry_Geometry; });
__webpack_require__.d(__webpack_exports__, "GeometryData", function() { return /* reexport */ geometry_GeometryData; });
__webpack_require__.d(__webpack_exports__, "MorphGeometry", function() { return /* reexport */ geometry_MorphGeometry; });
__webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return /* reexport */ geometry_PlaneGeometry; });
__webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return /* reexport */ geometry_SphereGeometry; });
__webpack_require__.d(__webpack_exports__, "Camera", function() { return /* reexport */ camera_Camera; });
__webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return /* reexport */ camera_PerspectiveCamera; });
__webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return /* reexport */ camera_OrthographicCamera; });
__webpack_require__.d(__webpack_exports__, "Buffer", function() { return /* reexport */ renderer_Buffer; });
__webpack_require__.d(__webpack_exports__, "capabilities", function() { return /* reexport */ renderer_capabilities; });
__webpack_require__.d(__webpack_exports__, "extensions", function() { return /* reexport */ renderer_extensions; });
__webpack_require__.d(__webpack_exports__, "Framebuffer", function() { return /* reexport */ renderer_Framebuffer; });
__webpack_require__.d(__webpack_exports__, "glType", function() { return /* reexport */ renderer_glType; });
__webpack_require__.d(__webpack_exports__, "logGLResource", function() { return /* reexport */ renderer_logGLResource; });
__webpack_require__.d(__webpack_exports__, "Program", function() { return /* reexport */ renderer_Program; });
__webpack_require__.d(__webpack_exports__, "RenderInfo", function() { return /* reexport */ renderer_RenderInfo; });
__webpack_require__.d(__webpack_exports__, "RenderList", function() { return /* reexport */ renderer_RenderList; });
__webpack_require__.d(__webpack_exports__, "VertexArrayObject", function() { return /* reexport */ renderer_VertexArrayObject; });
__webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return /* reexport */ renderer_WebGLRenderer; });
__webpack_require__.d(__webpack_exports__, "WebGLResourceManager", function() { return /* reexport */ renderer_WebGLResourceManager; });
__webpack_require__.d(__webpack_exports__, "WebGLState", function() { return /* reexport */ renderer_WebGLState; });
__webpack_require__.d(__webpack_exports__, "BasicLoader", function() { return /* reexport */ loader_BasicLoader; });
__webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return /* reexport */ loader_CubeTextureLoader; });
__webpack_require__.d(__webpack_exports__, "GLTFLoader", function() { return /* reexport */ loader_GLTFLoader; });
__webpack_require__.d(__webpack_exports__, "GLTFParser", function() { return /* reexport */ loader_GLTFParser; });
__webpack_require__.d(__webpack_exports__, "AliAMCExtension", function() { return /* reexport */ loader_AliAMCExtension; });
__webpack_require__.d(__webpack_exports__, "HDRLoader", function() { return /* reexport */ loader_HDRLoader; });
__webpack_require__.d(__webpack_exports__, "KTXLoader", function() { return /* reexport */ loader_KTXLoader; });
__webpack_require__.d(__webpack_exports__, "LoadCache", function() { return /* reexport */ loader_LoadCache; });
__webpack_require__.d(__webpack_exports__, "LoadQueue", function() { return /* reexport */ loader_LoadQueue; });
__webpack_require__.d(__webpack_exports__, "ShaderMaterialLoader", function() { return /* reexport */ loader_ShaderMaterialLoader; });
__webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return /* reexport */ loader_TextureLoader; });
__webpack_require__.d(__webpack_exports__, "Loader", function() { return /* reexport */ loader_Loader; });
__webpack_require__.d(__webpack_exports__, "Texture", function() { return /* reexport */ texture_Texture; });
__webpack_require__.d(__webpack_exports__, "LazyTexture", function() { return /* reexport */ texture_LazyTexture; });
__webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return /* reexport */ texture_CubeTexture; });
__webpack_require__.d(__webpack_exports__, "DataTexture", function() { return /* reexport */ texture_DataTexture; });
__webpack_require__.d(__webpack_exports__, "Shader", function() { return /* reexport */ shader_Shader; });
__webpack_require__.d(__webpack_exports__, "BasicMaterial", function() { return /* reexport */ material_BasicMaterial; });
__webpack_require__.d(__webpack_exports__, "GeometryMaterial", function() { return /* reexport */ material_GeometryMaterial; });
__webpack_require__.d(__webpack_exports__, "Material", function() { return /* reexport */ material_Material; });
__webpack_require__.d(__webpack_exports__, "PBRMaterial", function() { return /* reexport */ material_PBRMaterial; });
__webpack_require__.d(__webpack_exports__, "semantic", function() { return /* reexport */ material_semantic; });
__webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return /* reexport */ material_ShaderMaterial; });
__webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return /* reexport */ helper_AxisHelper; });
__webpack_require__.d(__webpack_exports__, "AxisNetHelper", function() { return /* reexport */ helper_AxisNetHelper; });
__webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return /* reexport */ helper_CameraHelper; });
__webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return /* reexport */ light_AmbientLight; });
__webpack_require__.d(__webpack_exports__, "AreaLight", function() { return /* reexport */ light_AreaLight; });
__webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return /* reexport */ light_DirectionalLight; });
__webpack_require__.d(__webpack_exports__, "CubeLightShadow", function() { return /* reexport */ light_CubeLightShadow; });
__webpack_require__.d(__webpack_exports__, "Light", function() { return /* reexport */ light_Light; });
__webpack_require__.d(__webpack_exports__, "LightManager", function() { return /* reexport */ light_LightManager; });
__webpack_require__.d(__webpack_exports__, "LightShadow", function() { return /* reexport */ light_LightShadow; });
__webpack_require__.d(__webpack_exports__, "PointLight", function() { return /* reexport */ light_PointLight; });
__webpack_require__.d(__webpack_exports__, "SpotLight", function() { return /* reexport */ light_SpotLight; });
__webpack_require__.d(__webpack_exports__, "Animation", function() { return /* reexport */ animation_Animation; });
__webpack_require__.d(__webpack_exports__, "AnimationStates", function() { return /* reexport */ animation_AnimationStates; });
__webpack_require__.d(__webpack_exports__, "MeshPicker", function() { return /* reexport */ utils_MeshPicker; });
__webpack_require__.d(__webpack_exports__, "Ticker", function() { return /* reexport */ utils_Ticker; });
__webpack_require__.d(__webpack_exports__, "log", function() { return /* reexport */ utils_log; });
__webpack_require__.d(__webpack_exports__, "Cache", function() { return /* reexport */ utils_Cache; });
__webpack_require__.d(__webpack_exports__, "browser", function() { return /* reexport */ utils_browser; });
__webpack_require__.d(__webpack_exports__, "WebGLSupport", function() { return /* reexport */ utils_WebGLSupport; });
__webpack_require__.d(__webpack_exports__, "constants", function() { return /* reexport */ src_constants; });
__webpack_require__.d(__webpack_exports__, "Color", function() { return /* reexport */ math_Color; });
__webpack_require__.d(__webpack_exports__, "Euler", function() { return /* reexport */ math_Euler; });
__webpack_require__.d(__webpack_exports__, "EulerNotifier", function() { return /* reexport */ math_EulerNotifier; });
__webpack_require__.d(__webpack_exports__, "Frustum", function() { return /* reexport */ math_Frustum; });
__webpack_require__.d(__webpack_exports__, "math", function() { return /* reexport */ math_math; });
__webpack_require__.d(__webpack_exports__, "Matrix3", function() { return /* reexport */ math_Matrix3; });
__webpack_require__.d(__webpack_exports__, "Matrix4", function() { return /* reexport */ math_Matrix4; });
__webpack_require__.d(__webpack_exports__, "Matrix4Notifier", function() { return /* reexport */ math_Matrix4Notifier; });
__webpack_require__.d(__webpack_exports__, "Plane", function() { return /* reexport */ math_Plane; });
__webpack_require__.d(__webpack_exports__, "Quaternion", function() { return /* reexport */ math_Quaternion; });
__webpack_require__.d(__webpack_exports__, "Ray", function() { return /* reexport */ math_Ray; });
__webpack_require__.d(__webpack_exports__, "Sphere", function() { return /* reexport */ math_Sphere; });
__webpack_require__.d(__webpack_exports__, "SphericalHarmonics3", function() { return /* reexport */ math_SphericalHarmonics3; });
__webpack_require__.d(__webpack_exports__, "Vector2", function() { return /* reexport */ math_Vector2; });
__webpack_require__.d(__webpack_exports__, "Vector3", function() { return /* reexport */ math_Vector3; });
__webpack_require__.d(__webpack_exports__, "Vector3Notifier", function() { return /* reexport */ math_Vector3Notifier; });
__webpack_require__.d(__webpack_exports__, "Vector4", function() { return /* reexport */ math_Vector4; });

// NAMESPACE OBJECT: ./src/constants/Hilo.js
var Hilo_namespaceObject = {};
__webpack_require__.r(Hilo_namespaceObject);
__webpack_require__.d(Hilo_namespaceObject, "POSITION", function() { return POSITION; });
__webpack_require__.d(Hilo_namespaceObject, "NORMAL", function() { return NORMAL; });
__webpack_require__.d(Hilo_namespaceObject, "DEPTH", function() { return DEPTH; });
__webpack_require__.d(Hilo_namespaceObject, "DISTANCE", function() { return DISTANCE; });

// NAMESPACE OBJECT: ./src/utils/util.js
var util_namespaceObject = {};
__webpack_require__.r(util_namespaceObject);
__webpack_require__.d(util_namespaceObject, "each", function() { return util_each; });
__webpack_require__.d(util_namespaceObject, "getRelativePath", function() { return getRelativePath; });
__webpack_require__.d(util_namespaceObject, "convertUint8ArrayToString", function() { return convertUint8ArrayToString; });
__webpack_require__.d(util_namespaceObject, "getExtension", function() { return getExtension; });
__webpack_require__.d(util_namespaceObject, "getIndexFromSortedArray", function() { return getIndexFromSortedArray; });
__webpack_require__.d(util_namespaceObject, "insertToSortedArray", function() { return insertToSortedArray; });
__webpack_require__.d(util_namespaceObject, "padLeft", function() { return padLeft; });
__webpack_require__.d(util_namespaceObject, "getTypedArrayClass", function() { return getTypedArrayClass; });
__webpack_require__.d(util_namespaceObject, "copyArrayData", function() { return copyArrayData; });
__webpack_require__.d(util_namespaceObject, "isStrOrNumber", function() { return isStrOrNumber; });
__webpack_require__.d(util_namespaceObject, "getTypedArrayGLType", function() { return getTypedArrayGLType; });
__webpack_require__.d(util_namespaceObject, "getBlobUrl", function() { return getBlobUrl; });
__webpack_require__.d(util_namespaceObject, "isBlobUrl", function() { return isBlobUrl; });
__webpack_require__.d(util_namespaceObject, "revokeBlobUrl", function() { return revokeBlobUrl; });
__webpack_require__.d(util_namespaceObject, "isArrayLike", function() { return isArrayLike; });
__webpack_require__.d(util_namespaceObject, "getElementRect", function() { return getElementRect; });
__webpack_require__.d(util_namespaceObject, "serialRun", function() { return serialRun; });
__webpack_require__.d(util_namespaceObject, "hasOwnProperty", function() { return util_hasOwnProperty; });

// NAMESPACE OBJECT: ./src/loader/GLTFExtensions.js
var GLTFExtensions_namespaceObject = {};
__webpack_require__.r(GLTFExtensions_namespaceObject);
__webpack_require__.d(GLTFExtensions_namespaceObject, "ALI_amc_mesh_compression", function() { return loader_AliAMCExtension; });
__webpack_require__.d(GLTFExtensions_namespaceObject, "WEB3D_quantized_attributes", function() { return WEB3D_quantized_attributes; });
__webpack_require__.d(GLTFExtensions_namespaceObject, "HILO_animation_clips", function() { return HILO_animation_clips; });
__webpack_require__.d(GLTFExtensions_namespaceObject, "ALI_animation_clips", function() { return ALI_animation_clips; });
__webpack_require__.d(GLTFExtensions_namespaceObject, "ALI_bounding_box", function() { return ALI_bounding_box; });
__webpack_require__.d(GLTFExtensions_namespaceObject, "KHR_materials_pbrSpecularGlossiness", function() { return KHR_materials_pbrSpecularGlossiness; });
__webpack_require__.d(GLTFExtensions_namespaceObject, "KHR_lights_punctual", function() { return KHR_lights_punctual; });
__webpack_require__.d(GLTFExtensions_namespaceObject, "KHR_techniques_webgl", function() { return GLTFExtensions_KHR_techniques_webgl; });

// CONCATENATED MODULE: ./src/utils/log.js
/* eslint prefer-spread: "off", prefer-rest-params:"off" */
var cache = {};
var LEVEL_NONE = 0;
var LEVEL_LOG = 1;
var LEVEL_WARN = 2;
var LEVEL_ERROR = 4;
/**
 * 向 Web 控制台输出一条消息，可以通过设置等级过滤输出的消息。
 * @namespace
 * @type {Object}
 * @name log
 * @example
 * Hilo3d.log.level = Hilo3d.log.LEVEL_LOG | Hilo3d.log.LEVEL_ERROR;
 * Hilo3d.log.error("ERROR!");
 */

var log = {
  _cache: cache,

  /**
   * log级别
   * @type {Number}
   * @default LEVEL_LOG | LEVEL_WARN | LEVEL_ERROR
   */
  level: LEVEL_LOG | LEVEL_WARN | LEVEL_ERROR,

  /**
   * 不显示任何
   * @readOnly
   * @type {Number}
   * @default 0
   */
  LEVEL_NONE: LEVEL_NONE,

  /**
   * 显示 log
   * @readOnly
   * @type {Number}
   * @default 1
   */
  LEVEL_LOG: LEVEL_LOG,

  /**
   * 显示 warn
   * @readOnly
   * @type {Number}
   * @default 2
   */
  LEVEL_WARN: LEVEL_WARN,

  /**
   * 显示 error
   * @readOnly
   * @type {Number}
   * @default 4
   */
  LEVEL_ERROR: LEVEL_ERROR,

  /**
   * log，等同 console.log
   * @return {log} this
   */
  log: function log() {
    var console = this.console;

    if (this.level & LEVEL_LOG) {
      console.log.apply(console, arguments);
    }

    return this;
  },

  /**
   * warn，等同 console.warn
   * @return {log} this
   */
  warn: function warn() {
    var console = this.console;

    if (this.level & LEVEL_WARN) {
      console.warn.apply(console, arguments);
    }

    return this;
  },

  /**
   * error，等同 console.error
   * @return {log} this
   */
  error: function error() {
    var console = this.console;

    if (this.level & LEVEL_ERROR) {
      console.error.apply(console, arguments);
    }

    return this;
  },

  /**
   * logOnce 相同 id 只 log 一次
   * @param {String} id
   * @return {log} this
   */
  logOnce: function logOnce(id) {
    if (!cache['log_' + id]) {
      cache['log_' + id] = true;
      this.log.apply(this, Array.prototype.slice.call(arguments, 1));
    }

    return this;
  },

  /**
   * warnOnce  相同 id 只 once 一次
   * @param {String} id
   * @return {log} this
   */
  warnOnce: function warnOnce(id) {
    if (!cache['warn_' + id]) {
      cache['warn_' + id] = true;
      this.warn.apply(this, Array.prototype.slice.call(arguments, 1));
    }

    return this;
  },

  /**
   * errorOnce 相同 id 只 error 一次
   * @param {String} id
   * @return {log} this
   */
  errorOnce: function errorOnce(id) {
    if (!cache['error_' + id]) {
      cache['error_' + id] = true;
      this.error.apply(this, Array.prototype.slice.call(arguments, 1));
    }

    return this;
  },
  _console: console,

  /**
   * @private
   * @type {Object}
   */
  get console() {
    return this._console;
  },

  set console(value) {
    this._console = value;
  }

};
/* harmony default export */ var utils_log = (log);
// EXTERNAL MODULE: ./node_modules/_gl-constants@1.0.0@gl-constants/1.0/index.js
var _1_0 = __webpack_require__("./node_modules/_gl-constants@1.0.0@gl-constants/1.0/index.js");
var _1_0_default = /*#__PURE__*/__webpack_require__.n(_1_0);

// CONCATENATED MODULE: ./src/constants/webgl.js

/* harmony default export */ var webgl = (_1_0_default.a);
// EXTERNAL MODULE: ./node_modules/_gl-extensions-constants@1.0.0@gl-extensions-constants/index.js
var _gl_extensions_constants_1_0_0_gl_extensions_constants = __webpack_require__("./node_modules/_gl-extensions-constants@1.0.0@gl-extensions-constants/index.js");
var _gl_extensions_constants_1_0_0_gl_extensions_constants_default = /*#__PURE__*/__webpack_require__.n(_gl_extensions_constants_1_0_0_gl_extensions_constants);

// CONCATENATED MODULE: ./src/constants/webglExtensions.js

/* harmony default export */ var webglExtensions = (_gl_extensions_constants_1_0_0_gl_extensions_constants_default.a);
// CONCATENATED MODULE: ./src/constants/Hilo.js
// vertexType
var POSITION = 'POSITION';
var NORMAL = 'NORMAL';
var DEPTH = 'DEPTH';
var DISTANCE = 'DISTANCE';
// CONCATENATED MODULE: ./src/constants/index.js



/**
 * WebGL, WebGL extensions 枚举值
 * @constant
 * @type {Object}
 * @example
 * Hilo3d.constants.LINEAR_MIPMAP_NEAREST
 */

var constants = {
  webgl: webgl,
  webglExtensions: webglExtensions,
  Hilo: Hilo_namespaceObject
};
Object.assign(constants, webgl, webglExtensions, Hilo_namespaceObject);
/* harmony default export */ var src_constants = (constants);
// CONCATENATED MODULE: ./src/utils/util.js
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var BYTE = src_constants.BYTE,
    UNSIGNED_BYTE = src_constants.UNSIGNED_BYTE,
    SHORT = src_constants.SHORT,
    UNSIGNED_SHORT = src_constants.UNSIGNED_SHORT,
    UNSIGNED_INT = src_constants.UNSIGNED_INT,
    FLOAT = src_constants.FLOAT;

function getRelativePath(basePath, path) {
  if (/^(?:http|blob|data:|\/)/.test(path)) {
    return path;
  }

  basePath = basePath.replace(/\/[^/]*?$/, '').split('/');
  path = path.split('/');
  var i;

  for (i = 0; i < path.length; i++) {
    var p = path[i];

    if (p === '..') {
      basePath.pop();
    } else if (p !== '.') {
      break;
    }
  }

  return basePath.join('/') + '/' + path.slice(i).join('/');
}

var utf8Decoder;

function convertUint8ArrayToString(array, isUTF8) {
  if (window.TextDecoder) {
    if (!utf8Decoder) {
      utf8Decoder = new TextDecoder('utf-8');
    }

    if (!(array instanceof Uint8Array)) {
      array = new Uint8Array(array);
    }

    return utf8Decoder.decode(array);
  }

  var str = '';

  for (var i = 0; i < array.length; i++) {
    str += String.fromCharCode(array[i]);
  }

  if (isUTF8) {
    // utf8 str fix
    // https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/btoa
    str = decodeURIComponent(escape(str));
  }

  return str;
}

function getExtension(url) {
  var extRegExp = /\/?[^/]+\.(\w+)(\?\S+)?$/i;
  var match = String(url).match(extRegExp);
  return match && match[1].toLowerCase() || null;
}

function util_each(obj, fn) {
  if (!obj) {
    return;
  }

  if (Array.isArray(obj)) {
    obj.forEach(fn);
  } else {
    Object.keys(obj).forEach(function (key) {
      fn(obj[key], key);
    });
  }
}

function getIndexFromSortedArray(array, value, compareFn) {
  if (!array || !array.length) {
    return [0, 0];
  }

  var len = array.length;
  var low = 0;
  var high = len - 1;

  while (low <= high) {
    var mid = low + high >> 1;
    var diff = compareFn(array[mid], value);

    if (diff === 0) {
      return [mid, mid];
    }

    if (diff < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  if (low > high) {
    return [high, low];
  }

  return [low, high];
}

function insertToSortedArray(array, item, compareFn) {
  var indices = getIndexFromSortedArray(array, item, compareFn);
  array.splice(indices[1], 0, item);
}

function padLeft(str, len, _char) {
  if (len <= str.length) {
    return str;
  }

  return new Array(len - str.length + 1).join(_char || '0') + str;
}

function getTypedArrayGLType(array) {
  if (array instanceof Float32Array) {
    return FLOAT;
  }

  if (array instanceof Int8Array) {
    return BYTE;
  }

  if (array instanceof Uint8Array) {
    return UNSIGNED_BYTE;
  }

  if (array instanceof Int16Array) {
    return SHORT;
  }

  if (array instanceof Uint16Array) {
    return UNSIGNED_SHORT;
  }

  if (array instanceof Uint32Array) {
    return UNSIGNED_INT;
  }

  return FLOAT;
}

var getTypedArrayClass = function () {
  var _TypedArrayClassMap;

  var TypedArrayClassMap = (_TypedArrayClassMap = {}, _defineProperty(_TypedArrayClassMap, BYTE, Int8Array), _defineProperty(_TypedArrayClassMap, UNSIGNED_BYTE, Uint8Array), _defineProperty(_TypedArrayClassMap, SHORT, Int16Array), _defineProperty(_TypedArrayClassMap, UNSIGNED_SHORT, Uint16Array), _defineProperty(_TypedArrayClassMap, UNSIGNED_INT, Uint32Array), _defineProperty(_TypedArrayClassMap, FLOAT, Float32Array), _TypedArrayClassMap);
  return function (type) {
    return TypedArrayClassMap[type] || Float32Array;
  };
}();

function copyArrayData(destArr, srcArr, destIdx, srcIdx, count) {
  if (!destArr || !srcArr) {
    return;
  }

  if (srcArr.isGeometryData) {
    srcArr = srcArr.data;
  }

  for (var i = 0; i < count; i++) {
    destArr[destIdx + i] = srcArr[srcIdx + i];
  }
}

function isStrOrNumber(d) {
  return typeof d === 'string' || typeof d === 'number';
}

function isBlobUrl(url) {
  return /^blob:/.test(url);
}

function revokeBlobUrl(blobUrl) {
  if (window.URL) {
    URL.revokeObjectURL(blobUrl);
  }
}

function getBlobUrl(mimeType, data) {
  if (data instanceof ArrayBuffer) {
    data = new Uint8Array(data);
  }

  if (window.Blob && window.URL) {
    try {
      var blob = new Blob([data], {
        type: mimeType
      });
      var blobUrl = window.URL.createObjectURL(blob);
      return blobUrl;
    } catch (err) {
      utils_log.warn('new Blob error', mimeType);
    }
  }

  return "data:".concat(mimeType, ";base64,").concat(btoa(convertUint8ArrayToString(data)));
}

function isArrayLike(obj) {
  return Array.isArray(obj) || obj.BYTES_PER_ELEMENT || obj.length;
}

function getElementRect(elem) {
  var docElem = document.documentElement;
  var bounds;

  try {
    // this fails if it's a disconnected DOM node
    bounds = elem.getBoundingClientRect();
  } catch (e) {
    bounds = {
      top: elem.offsetTop,
      left: elem.offsetLeft,
      right: elem.offsetLeft + elem.offsetWidth,
      bottom: elem.offsetTop + elem.offsetHeight
    };
  }

  var offsetX = (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0) || 0;
  var offsetY = (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0) || 0;
  var styles = window.getComputedStyle ? getComputedStyle(elem) : elem.currentStyle;
  var parseIntFn = parseInt;
  var padLeft = parseIntFn(styles.paddingLeft) + parseIntFn(styles.borderLeftWidth) || 0;
  var padTop = parseIntFn(styles.paddingTop) + parseIntFn(styles.borderTopWidth) || 0;
  var padRight = parseIntFn(styles.paddingRight) + parseIntFn(styles.borderRightWidth) || 0;
  var padBottom = parseIntFn(styles.paddingBottom) + parseIntFn(styles.borderBottomWidth) || 0;
  var top = bounds.top || 0;
  var left = bounds.left || 0;
  var right = bounds.right || 0;
  var bottom = bounds.bottom || 0;
  return {
    left: left + offsetX + padLeft,
    top: top + offsetY + padTop,
    width: right - padRight - left - padLeft,
    height: bottom - padBottom - top - padTop
  };
}

function serialRun() {
  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fn = arguments.length > 1 ? arguments[1] : undefined;

  if (!Array.isArray(data)) {
    data = Object.values(data);
  }

  return data.reduce(function (seq, d, i) {
    return seq.then(function () {
      return fn(d, i);
    });
  }, Promise.resolve());
}

function util_hasOwnProperty(obj, name) {
  return Object.prototype.hasOwnProperty.call(obj, name);
}


// EXTERNAL MODULE: ./node_modules/_hilojs@2.0.0@hilojs/core/Class.js
var Class = __webpack_require__("./node_modules/_hilojs@2.0.0@hilojs/core/Class.js");
var Class_default = /*#__PURE__*/__webpack_require__.n(Class);

// CONCATENATED MODULE: ./src/core/Class.js

/**
 * Class是提供类的创建的辅助工具。
 * @namespace  Class
 * @see {@link https://hiloteam.github.io/Hilo/docs/api-zh/symbols/Class.html}
 */

/* harmony default export */ var core_Class = (Class_default.a);
/**
 * @memberOf Class
 * @method create
 * @param {ClassProperty | Object} props
 */

/**
 * 类属性
 * @interface ClassProperty
 * @property {Object} [Statics] 静态属性
 * @property {Object} [Extends] 继承
 * @property {Object} [Mixes] mixes
 * @property {Function} [constructor] 构造函数
 */
// EXTERNAL MODULE: ./node_modules/_hilojs@2.0.0@hilojs/event/EventMixin.js
var EventMixin = __webpack_require__("./node_modules/_hilojs@2.0.0@hilojs/event/EventMixin.js");
var EventMixin_default = /*#__PURE__*/__webpack_require__.n(EventMixin);

// CONCATENATED MODULE: ./src/core/EventMixin.js

/**
 * EventMixin是一个包含事件相关功能的mixin。可以通过 Object.assign(target, EventMixin) 来为target增加事件功能。
 * @class EventMixin
 * @see {@link https://hiloteam.github.io/Hilo/docs/api-zh/symbols/EventMixin.html}
 */

/* harmony default export */ var core_EventMixin = (EventMixin_default.a);
/**
 * 增加一个事件监听。
 * @name EventMixin#on
 * @function
 * @param {String} type 要监听的事件类型。
 * @param {EventMixinCallback} listener 事件监听回调函数。
 * @param {Boolean} [once] 是否是一次性监听，即回调函数响应一次后即删除，不再响应。
 * @returns {any} 对象本身。链式调用支持。
 */

/**
 * 删除一个事件监听。如果不传入任何参数，则删除所有的事件监听；如果不传入第二个参数，则删除指定类型的所有事件监听。
 * @name EventMixin#off
 * @function
 * @param {String} [type] 要删除监听的事件类型。
 * @param {EventMixinCallback} [listener] 要删除监听的回调函数。
 * @returns {any} 对象本身。链式调用支持。
*/

/**
 * 发送事件。当第一个参数类型为Object时，则把它作为一个整体事件对象。
 * @name EventMixin#fire
 * @function
 * @param {String|EventObject} [type] 要发送的事件类型或者一个事件对象。
 * @param {Object} [detail] 要发送的事件的具体信息，即事件随带参数。
 * @returns {Boolean} 是否成功调度事件。
 */

/**
 * 事件对象
 * @interface EventObject
 * @property {String} type 事件类型
 * @property {any} [detail=null] 事件数据
 */

/**
 * @callback EventMixinCallback
 * @param {Object} [e] 事件对象
 * @param {String} e.type 事件类型
 * @param {Object} e.detail 事件数据
 * @param {Object} e.target 事件触发对象
 * @param {Date} e.timeStamp 时间戳
 */
// EXTERNAL MODULE: ./node_modules/_gl-matrix@2.8.1@gl-matrix/dist/gl-matrix-min.js
var gl_matrix_min = __webpack_require__("./node_modules/_gl-matrix@2.8.1@gl-matrix/dist/gl-matrix-min.js");

// CONCATENATED MODULE: ./src/math/Vector3.js


/**
 * 三维向量
 * @class
 */

var Vector3 = core_Class.create(
/** @lends Vector3.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Vector3
   */
  className: 'Vector3',

  /**
   * @type {Boolean}
   * @default true
   */
  isVector3: true,

  /**
   * Creates a new empty vec3
   * @param {Number} [x=0] X component
   * @param {Number} [y=0] Y component
   * @param {Number} [z=0] Z component
   * @constructs
   */
  constructor: function constructor() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    /**
     * 数据
     * @type {Float32Array}
     */
    this.elements = gl_matrix_min["vec3"].fromValues(x, y, z);
  },

  /**
   * Copy the values from one vec3 to this
   * @param  {Vector3} m the source vector
   * @return {Vector3} this
   */
  copy: function copy(v) {
    gl_matrix_min["vec3"].copy(this.elements, v.elements);
    return this;
  },

  /**
   * Creates a new vec3 initialized with values from this vec3
   * @return {Vector3} a new Vector3
   */
  clone: function clone() {
    var elements = this.elements;
    return new this.constructor(elements[0], elements[1], elements[2]);
  },

  /**
   * 转换到数组
   * @param  {Array}  [array=[]] 数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Array}
   */
  toArray: function toArray() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;
    array[0 + offset] = elements[0];
    array[1 + offset] = elements[1];
    array[2 + offset] = elements[2];
    return array;
  },

  /**
   * 从数组赋值
   * @param  {Array} array  数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Vector3} this
   */
  fromArray: function fromArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;
    elements[0] = array[offset + 0];
    elements[1] = array[offset + 1];
    elements[2] = array[offset + 2];
    return this;
  },

  /**
   * Set the components of a vec3 to the given values
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {Vector3} this
   */
  set: function set(x, y, z) {
    gl_matrix_min["vec3"].set(this.elements, x, y, z);
    return this;
  },

  /**
   * Adds two vec3's
   * @param {Vector3} a
   * @param {Vector3} [b] 如果不传，计算 this 和 a 的和
   * @returns {Vector3} this
   */
  add: function add(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].add(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Subtracts vector b from vector a
   * @param {Vector3} a
   * @param {Vector3} [b] 如果不传，计算 this 和 a 的差
   * @returns {Vector3} this
   */
  subtract: function subtract(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].subtract(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Multiplies two vec3's
   * @param {Vector3} a
   * @param {Vector3} [b] 如果不传，计算 this 和 a 的积
   * @returns {Vector3} this
   */
  multiply: function multiply(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].multiply(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Divides two vec3's
   * @param {Vector3} a
   * @param {Vector3} [b] 如果不传，计算 this 和 a 的商
   * @returns {Vector3} this
   */
  divide: function divide(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].divide(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Math.ceil the components of this
   * @returns {Vector3} this
   */
  ceil: function ceil() {
    gl_matrix_min["vec3"].ceil(this.elements, this.elements);
    return this;
  },

  /**
   * Math.floor the components of this
   * @returns {Vector3} this
   */
  floor: function floor() {
    gl_matrix_min["vec3"].floor(this.elements, this.elements);
    return this;
  },

  /**
   * Returns the minimum of two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @returns {Vector3} this
   */
  min: function min(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].min(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Returns the maximum of two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b]  如果不传，计算 this 和 a 的结果
   * @returns {Vector3} this
   */
  max: function max(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].max(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Math.round the components of this
   * @returns {Vector3} this
   */
  round: function round() {
    gl_matrix_min["vec3"].round(this.elements, this.elements);
    return this;
  },

  /**
   * Scales this by a scalar number
   * @param  {Number} scale amount to scale the vector by
   * @returns {Vector3} this
   */
  scale: function scale(_scale) {
    gl_matrix_min["vec3"].scale(this.elements, this.elements, _scale);
    return this;
  },

  /**
   * Adds two vec3's after scaling the second vector by a scalar value
   * @param  {Number} scale the amount to scale the second vector by before adding
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @returns {Vector3} this
   */
  scaleAndAdd: function scaleAndAdd(scale, a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].scaleAndAdd(this.elements, a.elements, b.elements, scale);
    return this;
  },

  /**
   * Calculates the euclidian distance between two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number} distance between a and b
   */
  distance: function distance(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].distance(a.elements, b.elements);
  },

  /**
   * Calculates the squared euclidian distance between two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number} squared distance between a and b
   */
  squaredDistance: function squaredDistance(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].squaredDistance(a.elements, b.elements);
  },

  /**
   * Calculates the length of this
   * @return {Number} length of this
   */
  length: function length() {
    return gl_matrix_min["vec3"].length(this.elements);
  },

  /**
   * Calculates the squared length of this
   * @return {Number} squared length of this
   */
  squaredLength: function squaredLength() {
    return gl_matrix_min["vec3"].squaredLength(this.elements);
  },

  /**
   * Negates the components of this
   * @returns {Vector3} this
   */
  negate: function negate() {
    gl_matrix_min["vec3"].negate(this.elements, this.elements);
    return this;
  },

  /**
   * Returns the inverse of the components of a vec3
   * @param  {Vector3} [a=this]
   * @returns {Vector3} this
   */
  inverse: function inverse(a) {
    if (!a) {
      a = this;
    }

    gl_matrix_min["vec3"].inverse(this.elements, a.elements);
    return this;
  },

  /**
   * Normalize this
   * @returns {Vector3} this
   */
  normalize: function normalize() {
    gl_matrix_min["vec3"].normalize(this.elements, this.elements);
    return this;
  },

  /**
   * Calculates the dot product of two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number}  product of a and b
   */
  dot: function dot(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].dot(a.elements, b.elements);
  },

  /**
   * Computes the cross product of two vec3's
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number}  cross product of a and b
   */
  cross: function cross(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].cross(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Performs a linear interpolation between two vec3's
   * @param  {Vector3} v
   * @param  {Number} t interpolation amount between the two vectors
   * @returns {Vector3} this
   */
  lerp: function lerp(v, t) {
    gl_matrix_min["vec3"].lerp(this.elements, this.elements, v.elements, t);
    return this;
  },

  /**
   * Performs a hermite interpolation with two control points
   * @param  {Vector3} a
   * @param  {Vector3} b
   * @param  {Vector3} c
   * @param  {Vector3} d
   * @param  {Number} t interpolation amount between the two inputs
   * @return {Vector3} this
   */
  hermite: function hermite(a, b, c, d, t) {
    gl_matrix_min["vec3"].hermite(this.elements, a.elements, b.elements, c.elements, d.elements, t);
    return this;
  },

  /**
   * Performs a bezier interpolation with two control points
   * @param  {Vector3} a
   * @param  {Vector3} b
   * @param  {Vector3} c
   * @param  {Vector3} d
   * @param  {Number} t interpolation amount between the two inputs
   * @return {Vector3} this
   */
  bezier: function bezier(a, b, c, d, t) {
    gl_matrix_min["vec3"].bezier(this.elements, a.elements, b.elements, c.elements, d.elements, t);
    return this;
  },

  /**
   * Generates a random vector with the given scale
   * @param  {Number} [scale=1] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {Vector3} this
   */
  random: function random(scale) {
    gl_matrix_min["vec3"].random(this.elements, scale);
    return this;
  },

  /**
   * Transforms the vec3 with a mat3
   * @param  {Matrix3} m matrix to transform with
   * @returns {Vector3} this
   */
  transformMat3: function transformMat3(m) {
    gl_matrix_min["vec3"].transformMat3(this.elements, this.elements, m.elements);
    return this;
  },

  /**
   * Transforms the vec3 with a mat4
   * @param  {Matrix4} m matrix to transform with
   * @returns {Vector3} this
   */
  transformMat4: function transformMat4(m) {
    gl_matrix_min["vec3"].transformMat4(this.elements, this.elements, m.elements);
    return this;
  },

  /**
   * Transforms the vec3 direction with a mat4
   * @param  {Matrix4} m matrix to transform with
   * @returns {Vector3} this
   */
  transformDirection: function transformDirection(m) {
    var elements = this.elements;
    var mElements = m.elements;
    var x = elements[0];
    var y = elements[1];
    var z = elements[2];
    elements[0] = x * mElements[0] + y * mElements[4] + z * mElements[8];
    elements[1] = x * mElements[1] + y * mElements[5] + z * mElements[9];
    elements[2] = x * mElements[2] + y * mElements[6] + z * mElements[10];
    return this;
  },

  /**
   * Transforms the vec3 with a quat
   * @param  {Quaternion} q quaternion to transform with
   * @returns {Vector3} this
   */
  transformQuat: function transformQuat(q) {
    gl_matrix_min["vec3"].transformQuat(this.elements, this.elements, q.elements);
    return this;
  },

  /**
   * Rotate this 3D vector around the x-axis
   * @param  {Vector3} origin The origin of the rotation
   * @param  {Number} rotation The angle of rotation
   * @return {Vector3} this
   */
  rotateX: function rotateX(origin, rotation) {
    gl_matrix_min["vec3"].rotateX(this.elements, this.elements, origin.elements, rotation);
    return this;
  },

  /**
   * Rotate this 3D vector around the y-axis
   * @param  {Vector3} origin The origin of the rotation
   * @param  {Number} rotation The angle of rotation
   * @return {Vector3} this
   */
  rotateY: function rotateY(origin, rotation) {
    gl_matrix_min["vec3"].rotateY(this.elements, this.elements, origin.elements, rotation);
    return this;
  },

  /**
   * Rotate this 3D vector around the z-axis
   * @param  {Vector3} origin The origin of the rotation
   * @param  {Number} rotation The angle of rotation
   * @return {Vector3} this
   */
  rotateZ: function rotateZ(origin, rotation) {
    gl_matrix_min["vec3"].rotateZ(this.elements, this.elements, origin.elements, rotation);
    return this;
  },

  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Boolean} True if the vectors are equal, false otherwise.
   */
  exactEquals: function exactEquals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].exactEquals(a.elements, b.elements);
  },

  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Boolean} True if the vectors are equal, false otherwise.
   */
  equals: function equals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].equals(a.elements, b.elements);
  },

  /**
   * X component
   * @type {Number}
   */
  x: {
    get: function get() {
      return this.elements[0];
    },
    set: function set(value) {
      this.elements[0] = value;
    }
  },

  /**
   * Y component
   * @type {Number}
   */
  y: {
    get: function get() {
      return this.elements[1];
    },
    set: function set(value) {
      this.elements[1] = value;
    }
  },

  /**
   * Z component
   * @type {Number}
   */
  z: {
    get: function get() {
      return this.elements[2];
    },
    set: function set(value) {
      this.elements[2] = value;
    }
  }
});
/**
 * Alias for {@link Vector3#subtract}
 * @function
 */

Vector3.prototype.sub = Vector3.prototype.subtract;
/**
 * Alias for {@link Vector3#multiply}
 * @function
 */

Vector3.prototype.mul = Vector3.prototype.multiply;
/**
 * Alias for {@link Vector3#divide}
 * @function
 */

Vector3.prototype.div = Vector3.prototype.divide;
/**
 * Alias for {@link Vector3#distance}
 * @function
 */

Vector3.prototype.dist = Vector3.prototype.distance;
/**
 * Alias for {@link Vector3#squaredDistance}
 * @function
 */

Vector3.prototype.sqrDist = Vector3.prototype.squaredDistance;
/**
 * Alias for {@link Vector3#length}
 * @function
 */

Vector3.prototype.len = Vector3.prototype.length;
/**
 * Alias for {@link Vector3#squaredLength}
 * @function
 */

Vector3.prototype.sqrLen = Vector3.prototype.squaredLength;
/* harmony default export */ var math_Vector3 = (Vector3);
// CONCATENATED MODULE: ./src/math/Matrix3.js


/**
 * 3x3 矩阵
 * @class
 */

var Matrix3 = core_Class.create(
/** @lends Matrix3.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Matrix3
   */
  className: 'Matrix3',

  /**
   * @type {Boolean}
   * @default true
   */
  isMatrix3: true,

  /**
   * Creates a new identity mat3
   * @constructs
   */
  constructor: function constructor() {
    /**
     * 数据
     * @type {Float32Array}
     */
    this.elements = gl_matrix_min["mat3"].create();
  },

  /**
   * Copy the values from one mat3 to this
   * @param  {Matrix3} m the source matrix
   * @return {Matrix3} this
   */
  copy: function copy(m) {
    gl_matrix_min["mat3"].copy(this.elements, m.elements);
    return this;
  },

  /**
   * Creates a new mat3 initialized with values from this matrix
   * @return {Matrix3} a new Matrix3
   */
  clone: function clone() {
    var m = new this.constructor();
    gl_matrix_min["mat3"].copy(m.elements, this.elements);
    return m;
  },

  /**
   * 转换到数组
   * @param  {Array}  [array=[]] 数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Array}
   */
  toArray: function toArray() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;

    for (var i = 0; i < 9; i++) {
      array[offset + i] = elements[i];
    }

    return array;
  },

  /**
   * 从数组赋值
   * @param  {Array} array  数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Matrix3} this
   */
  fromArray: function fromArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;

    for (var i = 0; i < 9; i++) {
      elements[i] = array[offset + i];
    }

    return this;
  },

  /**
   * Set the components of a mat3 to the given values
   * @param {Number} m00
   * @param {Number} m01
   * @param {Number} m02
   * @param {Number} m10
   * @param {Number} m11
   * @param {Number} m12
   * @param {Number} m20
   * @param {Number} m21
   * @param {Number} m22
   * @return {Matrix3} this
   */
  set: function set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    gl_matrix_min["mat3"].set(this.elements, m00, m01, m02, m10, m11, m12, m20, m21, m22);
    return this;
  },

  /**
   * Set this to the identity matrix
   * @return {Matrix3} this
   */
  identity: function identity() {
    gl_matrix_min["mat3"].identity(this.elements);
    return this;
  },

  /**
   * Transpose the values of this
   * @return {Matrix3} this
   */
  transpose: function transpose() {
    gl_matrix_min["mat3"].transpose(this.elements, this.elements);
    return this;
  },

  /**
   * invert a matrix
   * @param  {Matrix3} [m = this]
   * @return {Matrix3} this
   */
  invert: function invert() {
    var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
    gl_matrix_min["mat3"].invert(this.elements, m.elements);
    return this;
  },

  /**
   * Calculates the adjugate of a mat3
   * @param  {Matrix3} [m=this]
   * @return {Matrix3} this
   */
  adjoint: function adjoint() {
    var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
    gl_matrix_min["mat3"].adjoint(this.elements, m.elements);
    return this;
  },

  /**
   * Calculates the determinant of this
   * @return {Number}
   */
  determinant: function determinant() {
    return gl_matrix_min["mat3"].determinant(this.elements);
  },

  /**
   * Multiplies two matrix3's
   * @param  {Matrix3} a
   * @param  {Matrix3} [b] 如果不传，计算 this 和 a 的乘积
   * @return {Matrix3} this
   */
  multiply: function multiply(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["mat3"].multiply(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * 左乘
   * @param  {Matrix3} m
   * @return {Matrix3}  this
   */
  premultiply: function premultiply(m) {
    this.multiply(m, this);
    return this;
  },

  /**
   * Translate this by the given vector
   * @param  {Vector2} v vector to translate by
   * @return {Matrix3} this
   */
  translate: function translate(v) {
    gl_matrix_min["mat3"].translate(this.elements, this.elements, v.elements);
    return this;
  },

  /**
   * Rotates this by the given angle
   * @param  {Number} rad the angle to rotate the matrix by
   * @return {Matrix3} this
   */
  rotate: function rotate(rad) {
    gl_matrix_min["mat3"].rotate(this.elements, this.elements, rad);
    return this;
  },

  /**
   * Scales the mat3 by the dimensions in the given vec2
   * @param  {Vector2} v the vec2 to scale the matrix by
   * @return {Matrix3} this
   */
  scale: function scale(v) {
    gl_matrix_min["mat3"].scale(this.elements, this.elements, v.elements);
    return this;
  },

  /**
   * Creates a matrix from a vector translation
   * @param  {Vector2} v Translation vector
   * @return {Matrix3} this
   */
  fromTranslation: function fromTranslation(v) {
    gl_matrix_min["mat3"].fromTranslation(this.elements, v.elements);
    return this;
  },

  /**
   * Creates a matrix from a given angle
   * @param  {Number} rad the angle to rotate the matrix by
   * @return {Matrix3} this
   */
  fromRotation: function fromRotation(rad) {
    gl_matrix_min["mat3"].fromRotation(this.elements, rad);
    return this;
  },

  /**
   * Creates a matrix from a vector scaling
   * @param  {Vector2} v Scaling vector
   * @return {Matrix3} this
   */
  fromScaling: function fromScaling(v) {
    gl_matrix_min["mat3"].fromScaling(this.elements, v.elements);
    return this;
  },

  /**
   * Calculates a 3x3 matrix from the given quaternion
   * @param  {Quaternion} q Quaternion to create matrix from
   * @return {Matrix3} this
   */
  fromQuat: function fromQuat(q) {
    gl_matrix_min["mat3"].fromQuat(this.elements, q.elements);
    return this;
  },

  /**
   * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
   * @param  {Matrix4} m Mat4 to derive the normal matrix from
   * @return {Matrix3} this
   */
  normalFromMat4: function normalFromMat4(m) {
    gl_matrix_min["mat3"].normalFromMat4(this.elements, m.elements);
    return this;
  },

  /**
   * Copies the upper-left 3x3 values into the given mat3.
   * @param  {Matrix4} m the source 4x4 matrix
   * @return {Matrix3} this
   */
  fromMat4: function fromMat4(m) {
    gl_matrix_min["mat3"].fromMat4(this.elements, m.elements);
    return this;
  },

  /**
   * Returns Frobenius norm of this
   * @return {Number} Frobenius norm
   */
  frob: function frob() {
    return gl_matrix_min["mat3"].frob(this.elements);
  },

  /**
   * Adds two mat3's
   * @param {Matrix3} a
   * @param {Matrix3} [b] 如果不传，计算 this 和 a 的和
   * @return {Matrix4} this
   */
  add: function add(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["mat3"].add(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Subtracts matrix b from matrix a
   * @param {Matrix3} a
   * @param {Matrix3} [b] 如果不传，计算 this 和 a 的差
   * @return {Matrix4} this
   */
  subtract: function subtract(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["mat3"].subtract(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   * @param {Matrix3} a
   * @param {Matrix3} [b] 如果不传，比较 this 和 a 是否相等
   * @return {Boolean}
   */
  exactEquals: function exactEquals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["mat3"].exactEquals(a.elements, b.elements);
  },

  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   * @param {Matrix3} a
   * @param {Matrix3} [b] 如果不传，比较 this 和 a 是否近似相等
   * @return {Boolean}
   */
  equals: function equals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["mat3"].equals(a.elements, b.elements);
  },

  /**
   * fromRotationTranslationScale
   * @param  {Number} r rad angle
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} scaleX
   * @param  {Number} scaleY
   * @return {Matrix3}
   */
  fromRotationTranslationScale: function fromRotationTranslationScale(rotation, x, y, scaleX, scaleY) {
    var cos = Math.cos(rotation);
    var sin = Math.sin(rotation);
    this.set(scaleX * cos, -scaleY * sin, 0, scaleX * sin, scaleY * cos, 0, x, y, 1);
    return this;
  }
});
/**
 * Alias for {@link Matrix3#subtract}
 * @function
 */

Matrix3.prototype.sub = Matrix3.prototype.subtract;
/**
 * Alias for {@link Matrix3#multiply}
 * @function
 */

Matrix3.prototype.mul = Matrix3.prototype.multiply;
/* harmony default export */ var math_Matrix3 = (Matrix3);
// CONCATENATED MODULE: ./src/math/Quaternion.js




var tempMat3 = new math_Matrix3();
/**
 * @class
 * @mixes EventMixin
 * @fires update 数据更新事件
 */

var Quaternion = core_Class.create(
/** @lends Quaternion.prototype */
{
  Mixes: core_EventMixin,

  /**
   * 类名
   * @type {String}
   * @default Quaternion
   */
  className: 'Quaternion',

  /**
   * @type {Boolean}
   * @default true
   */
  isQuaternion: true,

  /**
   * Creates a new identity quat
   * @constructs
   * @param  {Number} [x=0] X component
   * @param  {Number} [y=0] Y component
   * @param  {Number} [z=0] Z component
   * @param  {Number} [w=1] W component
   */
  constructor: function constructor() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    this.elements = gl_matrix_min["quat"].fromValues(x, y, z, w);
  },

  /**
   * Copy the values from one quat to this
   * @param  {Quaternion} q
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  copy: function copy(q, dontFireEvent) {
    gl_matrix_min["quat"].copy(this.elements, q.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Creates a new quat initialized with values from an existing quaternion
   * @return {Quaternion} a new quaternion
   */
  clone: function clone() {
    var el = this.elements;
    return new this.constructor(el[0], el[1], el[2], el[3]);
  },

  /**
   * 转换到数组
   * @param  {Array}  [array=[]] 数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Array}
   */
  toArray: function toArray() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var el = this.elements;
    array[offset] = el[0];
    array[offset + 1] = el[1];
    array[offset + 2] = el[2];
    array[offset + 3] = el[3];
    return array;
  },

  /**
   * 从数组赋值
   * @param  {Array} array  数组
   * @param  {Number} [offset=0] 数组偏移值
   * @param {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  fromArray: function fromArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var dontFireEvent = arguments.length > 2 ? arguments[2] : undefined;
    var el = this.elements;
    el[0] = array[offset];
    el[1] = array[offset + 1];
    el[2] = array[offset + 2];
    el[3] = array[offset + 3];

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Set the components of a quat to the given values
   * @param {Number} x  X component
   * @param {Number} y  Y component
   * @param {Number} z  Z component
   * @param {Number} w  W component
   * @param {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  set: function set(x, y, z, w, dontFireEvent) {
    gl_matrix_min["quat"].set(this.elements, x, y, z, w);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Set this to the identity quaternion
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  identity: function identity(dontFireEvent) {
    gl_matrix_min["quat"].identity(this.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   * @param  {Vector3} a the initial vector
   * @param  {Vector3} b the destination vector
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  rotationTo: function rotationTo(a, b, dontFireEvent) {
    gl_matrix_min["quat"].rotationTo(this.elements, a.elements, b.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {Vector3} view  the vector representing the viewing direction
   * @param {Vector3} right the vector representing the local "right" direction
   * @param {Vector3} up    the vector representing the local "up" direction
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  setAxes: function setAxes(view, right, up, dontFireEvent) {
    gl_matrix_min["quat"].setAxes(this.elements, view.elements, right.elements, up.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   * @param {Vector3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @param {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  setAxisAngle: function setAxisAngle(axis, rad, dontFireEvent) {
    gl_matrix_min["quat"].setAxisAngle(this.elements, axis.elements, rad);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @param  {Vector3} out_axis  Vector receiving the axis of rotation
   * @return {Number} Angle, in radians, of the rotation
   */
  getAxisAngle: function getAxisAngle(axis) {
    return gl_matrix_min["quat"].getAxisAngle(axis.elements, this.elements);
  },

  /**
   * Adds two quat's
   * @param {Quaternion} q
   * @param {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  add: function add(q, dontFireEvent) {
    gl_matrix_min["quat"].add(this.elements, this.elements, q.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Multiplies two quat's
   * @param  {Quaternion} q
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  multiply: function multiply(q, dontFireEvent) {
    gl_matrix_min["quat"].multiply(this.elements, this.elements, q.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * premultiply the quat
   * @param  {Quaternion} q
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  premultiply: function premultiply(q, dontFireEvent) {
    gl_matrix_min["quat"].multiply(this.elements, q.elements, this.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Scales a quat by a scalar number
   * @param  {Vector3} scale the vector to scale
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  scale: function scale(_scale, dontFireEvent) {
    gl_matrix_min["quat"].scale(this.elements, this.elements, _scale);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Rotates a quaternion by the given angle about the X axis
   * @param  {Number} rad angle (in radians) to rotate
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  rotateX: function rotateX(rad, dontFireEvent) {
    gl_matrix_min["quat"].rotateX(this.elements, this.elements, rad);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Rotates a quaternion by the given angle about the Y axis
   * @param  {Number} rad angle (in radians) to rotate
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  rotateY: function rotateY(rad, dontFireEvent) {
    gl_matrix_min["quat"].rotateY(this.elements, this.elements, rad);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Rotates a quaternion by the given angle about the Z axis
   * @param  {Number} rad angle (in radians) to rotate
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  rotateZ: function rotateZ(rad, dontFireEvent) {
    gl_matrix_min["quat"].rotateZ(this.elements, this.elements, rad);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Calculates the W component of a quat from the X, Y, and Z components.
   * Assumes that quaternion is 1 unit in length.
   * Any existing W component will be ignored.
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @returns {Quaternion} this
   */
  calculateW: function calculateW(dontFireEvent) {
    gl_matrix_min["quat"].calculateW(this.elements, this.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Calculates the dot product of two quat's
   * @param  {Quaternion} q
   * @return {Number} dot product of two quat's
   */
  dot: function dot(q) {
    return gl_matrix_min["quat"].dot(this.elements, q.elements);
  },

  /**
   * Performs a linear interpolation between two quat's
   * @param  {Quaternion} q
   * @param  {Number} t interpolation amount between the two inputs
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  lerp: function lerp(q, t, dontFireEvent) {
    gl_matrix_min["quat"].lerp(this.elements, this.elements, q.elements, t);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Performs a spherical linear interpolation between two quat
   * @param  {Quaternion} q
   * @param  {Number} t interpolation amount between the two inputs
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  slerp: function slerp(q, t, dontFireEvent) {
    gl_matrix_min["quat"].slerp(this.elements, this.elements, q.elements, t);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Performs a spherical linear interpolation with two control points
   * @param  {Quaternion} qa
   * @param  {Quaternion} qb
   * @param  {Quaternion} qc
   * @param  {Quaternion} qd
   * @param  {Number} t interpolation amount
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  sqlerp: function sqlerp(qa, qb, qc, qd, t, dontFireEvent) {
    gl_matrix_min["quat"].sqlerp(this.elements, qa.elements, qb.elements, qc.elements, qd.elements, t);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Calculates the inverse of a quat
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  invert: function invert(dontFireEvent) {
    gl_matrix_min["quat"].invert(this.elements, this.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  conjugate: function conjugate(dontFireEvent) {
    gl_matrix_min["quat"].conjugate(this.elements, this.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Calculates the length of a quat
   * @return {Number} length of this
   */
  length: function length() {
    return gl_matrix_min["quat"].length(this.elements);
  },

  /**
   * Calculates the squared length of a quat
   * @return {Number} squared length of this
   */
  squaredLength: function squaredLength() {
    return gl_matrix_min["quat"].squaredLength(this.elements);
  },

  /**
   * Normalize this
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  normalize: function normalize(dontFireEvent) {
    gl_matrix_min["quat"].normalize(this.elements, this.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {Matrix3} m rotation matrix
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  fromMat3: function fromMat3(mat, dontFireEvent) {
    gl_matrix_min["quat"].fromMat3(this.elements, mat.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {Matrix4} m rotation matrix
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  fromMat4: function fromMat4(mat, dontFireEvent) {
    tempMat3.fromMat4(mat);
    this.fromMat3(tempMat3, dontFireEvent);
    return this;
  },

  /**
   * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
   * @param  {Quaternion} q
   * @return {Boolean}
   */
  exactEquals: function exactEquals(q) {
    return gl_matrix_min["quat"].exactEquals(this.elements, q.elements);
  },

  /**
   * Returns whether or not the quaternions have approximately the same elements in the same position.
   * @param  {Quaternion} q
   * @return {Boolean}
   */
  equals: function equals(q) {
    return gl_matrix_min["quat"].equals(this.elements, q.elements);
  },

  /**
   * Creates a quaternion from the given euler.
   * @param  {Euler} euler
   * @param  {Boolean} [dontFireEvent=false] wether or not don`t fire change event.
   * @return {Quaternion} this
   */
  fromEuler: function fromEuler(euler, dontFireEvent) {
    // Based on https://github.com/mrdoob/three.js/blob/dev/src/math/Quaternion.js#L200
    // quat.fromEuler(this.elements, euler.x, euler.y, euler.z);
    var x = euler.x * .5;
    var y = euler.y * .5;
    var z = euler.z * .5;
    var order = euler.order || 'ZYX';
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    var out = this.elements;

    if (order === 'XYZ') {
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
    } else if (order === 'YXZ') {
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
    } else if (order === 'ZXY') {
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
    } else if (order === 'ZYX') {
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
    } else if (order === 'YZX') {
      out[0] = sx * cy * cz + cx * sy * sz;
      out[1] = cx * sy * cz + sx * cy * sz;
      out[2] = cx * cy * sz - sx * sy * cz;
      out[3] = cx * cy * cz - sx * sy * sz;
    } else if (order === 'XZY') {
      out[0] = sx * cy * cz - cx * sy * sz;
      out[1] = cx * sy * cz - sx * cy * sz;
      out[2] = cx * cy * sz + sx * sy * cz;
      out[3] = cx * cy * cz + sx * sy * sz;
    }

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * X component
   * @type {Number}
   */
  x: {
    get: function get() {
      return this.elements[0];
    },
    set: function set(value) {
      this.elements[0] = value;
      this.fire('update');
    }
  },

  /**
   * Y component
   * @type {Number}
   */
  y: {
    get: function get() {
      return this.elements[1];
    },
    set: function set(value) {
      this.elements[1] = value;
      this.fire('update');
    }
  },

  /**
   * Z component
   * @type {Number}
   */
  z: {
    get: function get() {
      return this.elements[2];
    },
    set: function set(value) {
      this.elements[2] = value;
      this.fire('update');
    }
  },

  /**
   * W component
   * @type {Number}
   */
  w: {
    get: function get() {
      return this.elements[3];
    },
    set: function set(value) {
      this.elements[3] = value;
      this.fire('update');
    }
  }
});
/**
 * Alias for {@link Quaternion#multiply}
 * @function
 */

Quaternion.prototype.mul = Quaternion.prototype.multiply;
/**
 * Alias for {@link Quaternion#length}
 * @function
 */

Quaternion.prototype.len = Quaternion.prototype.length;
/**
 * Alias for {@link Quaternion#squaredLength}
 * @function
 */

Quaternion.prototype.sqrLen = Quaternion.prototype.squaredLength;
/* harmony default export */ var math_Quaternion = (Quaternion);
// CONCATENATED MODULE: ./src/math/Matrix4.js




var tempMatrix4;
var tempVector3 = new math_Vector3();
var tempVector32 = new math_Vector3();
/**
 * 4x4 矩阵
 * @class
 */

var Matrix4 = core_Class.create(
/** @lends Matrix4.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Matrix4
   */
  className: 'Matrix4',

  /**
   * @type {Boolean}
   * @default true
   */
  isMatrix4: true,

  /**
   * Creates a new identity mat4
   * @constructs
   */
  constructor: function constructor() {
    /**
     * 数据
     * @type {Float32Array}
     */
    this.elements = gl_matrix_min["mat4"].create();
  },

  /**
   * Copy the values from one mat4 to this
   * @param  {Matrix4} m the source matrix
   * @return {Matrix4} this
   */
  copy: function copy(m) {
    gl_matrix_min["mat4"].copy(this.elements, m.elements);
    return this;
  },

  /**
   * Creates a new mat4 initialized with values from this matrix
   * @return {Matrix4} a new Matrix4
   */
  clone: function clone() {
    var m = new this.constructor();
    gl_matrix_min["mat4"].copy(m.elements, this.elements);
    return m;
  },

  /**
   * 转换到数组
   * @param  {Array}  [array=[]] 数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Array}
   */
  toArray: function toArray() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;

    for (var i = 0; i < 16; i++) {
      array[offset + i] = elements[i];
    }

    return array;
  },

  /**
   * 从数组赋值
   * @param  {Array} array  数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Matrix4} this
   */
  fromArray: function fromArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;

    for (var i = 0; i < 16; i++) {
      elements[i] = array[offset + i];
    }

    return this;
  },

  /**
   * Set the components of a mat3 to the given values
   * @param {Number} m00
   * @param {Number} m01
   * @param {Number} m02
   * @param {Number} m03
   * @param {Number} m10
   * @param {Number} m11
   * @param {Number} m12
   * @param {Number} m13
   * @param {Number} m20
   * @param {Number} m21
   * @param {Number} m22
   * @param {Number} m23
   * @param {Number} m30
   * @param {Number} m31
   * @param {Number} m32
   * @param {Number} m33
   * @return {Matrix4} this
   */
  set: function set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    gl_matrix_min["mat4"].set(this.elements, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    return this;
  },

  /**
   * Set this to the identity matrix
   * @return {Matrix4} this
   */
  identity: function identity() {
    gl_matrix_min["mat4"].identity(this.elements);
    return this;
  },

  /**
   * Transpose the values of this
   * @return {Matrix4} this
   */
  transpose: function transpose() {
    gl_matrix_min["mat4"].transpose(this.elements, this.elements);
    return this;
  },

  /**
   * invert a matrix
   * @param {Matrix4} [m=this]
   * @return {Matrix4} this
   */
  invert: function invert() {
    var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
    gl_matrix_min["mat4"].invert(this.elements, m.elements);
    return this;
  },

  /**
   * Calculates the adjugate of a mat4
   * @param {Matrix4} [m=this]
   * @return {Matrix4} this
   */
  adjoint: function adjoint() {
    var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
    gl_matrix_min["mat4"].adjoint(this.elements, m.elements);
    return this;
  },

  /**
   * Calculates the determinant of this
   * @return {Matrix4} this
   */
  determinant: function determinant() {
    return gl_matrix_min["mat4"].determinant(this.elements);
  },

  /**
   * Multiplies two matrix4's
   * @param {Matrix4} a
   * @param {Matrix4} [b] 如果不传，计算 this 和 a 的乘积
   * @return {Matrix4} this
   */
  multiply: function multiply(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["mat4"].multiply(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * 左乘
   * @param {Matrix4} m
   * @return {Matrix4} this
   */
  premultiply: function premultiply(m) {
    this.multiply(m, this);
    return this;
  },

  /**
   * Translate this by the given vector
   * @param {Vector3} v vector to translate by
   * @return {Matrix4} this
   */
  translate: function translate(v) {
    gl_matrix_min["mat4"].translate(this.elements, this.elements, v.elements);
    return this;
  },

  /**
   * Scales the mat3 by the dimensions in the given vec2
   * @param {Vector3} v the vec3 to scale the matrix by
   * @return {Matrix4} this
   */
  scale: function scale(v) {
    gl_matrix_min["mat4"].scale(this.elements, this.elements, v.elements);
    return this;
  },

  /**
   * Rotates this by the given angle
   * @param {Number} rad the angle to rotate the matrix by
   * @param {Vector3} axis the axis to rotate around
   * @return {Matrix4} this
   */
  rotate: function rotate(rad, axis) {
    gl_matrix_min["mat4"].rotate(this.elements, this.elements, rad, axis.elements);
    return this;
  },

  /**
   * Rotates this by the given angle around the X axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4} this
   */
  rotateX: function rotateX(rad) {
    gl_matrix_min["mat4"].rotateX(this.elements, this.elements, rad);
    return this;
  },

  /**
   * Rotates this by the given angle around the Y axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4} this
   */
  rotateY: function rotateY(rad) {
    gl_matrix_min["mat4"].rotateY(this.elements, this.elements, rad);
    return this;
  },

  /**
   * Rotates this by the given angle around the Z axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4} this
   */
  rotateZ: function rotateZ(rad) {
    gl_matrix_min["mat4"].rotateZ(this.elements, this.elements, rad);
    return this;
  },

  /**
   * Creates a matrix from a vector translation
   * @param {Vector3} transition Translation vector
   * @return {Matrix4} this
   */
  fromTranslation: function fromTranslation(v) {
    gl_matrix_min["mat4"].fromTranslation(this.elements, v.elements);
    return this;
  },

  /**
   * Creates a matrix from a vector scaling
   * @param  {Vector3} v Scaling vector
   * @return {Matrix4} this
   */
  fromScaling: function fromScaling(v) {
    gl_matrix_min["mat4"].fromScaling(this.elements, v.elements);
    return this;
  },

  /**
   * Creates a matrix from a given angle around a given axis
   * @param {Number} rad the angle to rotate the matrix by
   * @param {Vector3} axis the axis to rotate around
   * @return {Matrix4} this
   */
  fromRotation: function fromRotation(rad, axis) {
    gl_matrix_min["mat4"].fromRotation(this.elements, rad, axis.elements);
    return this;
  },

  /**
   * Creates a matrix from the given angle around the X axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4} this
   */
  fromXRotation: function fromXRotation(rad) {
    gl_matrix_min["mat4"].fromXRotation(this.elements, rad);
    return this;
  },

  /**
   * Creates a matrix from the given angle around the Y axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4} this
   */
  fromYRotation: function fromYRotation(rad) {
    gl_matrix_min["mat4"].fromYRotation(this.elements, rad);
    return this;
  },

  /**
   * Creates a matrix from the given angle around the Z axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4} this
   */
  fromZRotation: function fromZRotation(rad) {
    gl_matrix_min["mat4"].fromZRotation(this.elements, rad);
    return this;
  },

  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * @param  {Quaternion} q Rotation quaternion
   * @param  {Vector3} v Translation vector
   * @return {Matrix4} this
   */
  fromRotationTranslation: function fromRotationTranslation(q, v) {
    gl_matrix_min["mat4"].fromRotationTranslation(this.elements, q.elements, v.elements);
    return this;
  },

  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {Vector3} [out=new Vector3] Vector to receive translation component
   * @return {Vector3} out
   */
  getTranslation: function getTranslation() {
    var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new math_Vector3();
    gl_matrix_min["mat4"].getTranslation(out.elements, this.elements);
    return out;
  },

  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {Vector3} [out=new Vector3] Vector to receive scaling factor component
   * @return {Vector3} out
   */
  getScaling: function getScaling() {
    var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new math_Vector3();
    gl_matrix_min["mat4"].getScaling(out.elements, this.elements);
    return out;
  },

  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {Quaternion} out Quaternion to receive the rotation component
   * @return {Quaternion} out
   */
  getRotation: function getRotation() {
    var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new math_Quaternion();
    gl_matrix_min["mat4"].getRotation(out.elements, this.elements);
    return out;
  },

  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * @param  {Quaternion} q Rotation quaternion
   * @param  {Vector3} v Translation vector
   * @param  {Vector3} s Scaling vector
   * @return {Matrix4} this
   */
  fromRotationTranslationScale: function fromRotationTranslationScale(q, v, s) {
    gl_matrix_min["mat4"].fromRotationTranslationScale(this.elements, q.elements, v.elements, s.elements);
    return this;
  },

  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * @param  {Quaternion} q Rotation quaternion
   * @param  {Vector3} v Translation vector
   * @param  {Vector3} s Scaling vector
   * @param  {Vector3} o The origin vector around which to scale and rotate
   * @return {Matrix4} this
   */
  fromRotationTranslationScaleOrigin: function fromRotationTranslationScaleOrigin(q, v, s, o) {
    gl_matrix_min["mat4"].fromRotationTranslationScaleOrigin(this.elements, q.elements, v.elements, s.elements, o.elements);
    return this;
  },

  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param {Quaternion} q Quaternion to create matrix from
   * @return {Matrix4} this
   */
  fromQuat: function fromQuat(q) {
    gl_matrix_min["mat4"].fromQuat(this.elements, q.elements);
    return this;
  },

  /**
   * Generates a frustum matrix with the given bounds
   * @param  {Number} left  Left bound of the frustum
   * @param  {Number} right Right bound of the frustum
   * @param  {Number} bottom Bottom bound of the frustum
   * @param  {Number} top Top bound of the frustum
   * @param  {Number} near Near bound of the frustum
   * @param  {Number} far Far bound of the frustum
   * @return {Matrix4} this
   */
  frustum: function frustum(left, right, bottom, top, near, far) {
    gl_matrix_min["mat4"].frustum(this.elements, left, right, bottom, top, near, far);
    return this;
  },

  /**
   * Generates a perspective projection matrix with the given bounds
   * @param {Number} fovy Vertical field of view in radians
   * @param {Number} aspect Aspect ratio. typically viewport width/height
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @return {Matrix4} this
   */
  perspective: function perspective(fovy, aspect, near, far) {
    gl_matrix_min["mat4"].perspective(this.elements, fovy, aspect, near, far);
    return this;
  },

  /**
   * Generates a perspective projection matrix with the given field of view.
   * @param  {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param  {Number} Near bound of the frustum
   * @param  {Number} far Far bound of the frustum
   * @return {Matrix4} this
   */
  perspectiveFromFieldOfView: function perspectiveFromFieldOfView(fov, near, far) {
    gl_matrix_min["mat4"].perspectiveFromFieldOfView(this.elements, fov, near, far);
    return this;
  },

  /**
   * Generates a orthogonal projection matrix with the given bounds
   * @param  {Number} left  Left bound of the frustum
   * @param  {Number} right Right bound of the frustum
   * @param  {Number} bottom Bottom bound of the frustum
   * @param  {Number} top Top bound of the frustum
   * @param  {Number} near Near bound of the frustum
   * @param  {Number} far Far bound of the frustum
   * @return {Matrix4} this
   */
  ortho: function ortho(left, right, bottom, top, near, far) {
    gl_matrix_min["mat4"].ortho(this.elements, left, right, bottom, top, near, far);
    return this;
  },

  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis
   * @param  {XYZObject} eye Position of the viewer
   * @param  {XYZObject} center Point the viewer is looking at
   * @param  {Vector3} up pointing up
   * @return {Matrix4} this
   */
  lookAt: function lookAt(eye, center, up) {
    if (!eye.isVector3) {
      eye = tempVector3.set(eye.x, eye.y, eye.z);
    }

    if (!center.isVector3) {
      center = tempVector32.set(center.x, center.y, center.z);
    }

    gl_matrix_min["mat4"].lookAt(this.elements, eye.elements, center.elements, up.elements);
    return this;
  },

  /**
   * Generates a matrix that makes something look at something else.
   * @param  {XYZObject} eye Position of the viewer
   * @param  {XYZObject} Point the viewer is looking at
   * @param  {Vector3} up pointing up
   * @return {Matrix4} this
   */
  targetTo: function targetTo(eye, target, up) {
    if (!eye.isVector3) {
      eye = tempVector3.set(eye.x, eye.y, eye.z);
    }

    if (!target.isVector3) {
      target = tempVector32.set(target.x, target.y, target.z);
    } // mat4.targetTo(this.elements, eye.elements, target.elements, up.elements);


    eye = eye.elements;
    target = target.elements;
    up = up.elements;
    var out = this.elements;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var z0 = eyex - target[0];
    var z1 = eyey - target[1];
    var z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    } else {
      z2 = 1;
    }

    var x0 = upy * z2 - upz * z1;
    var x1 = upz * z0 - upx * z2;
    var x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    } else {
      upx += 0.0000001;
      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;
      len = x0 * x0 + x1 * x1 + x2 * x2;
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return this;
  },

  /**
   * Returns Frobenius norm of a mat4
   * @return {Number} Frobenius norm
   */
  frob: function frob() {
    return gl_matrix_min["mat4"].frob(this.elements);
  },

  /**
   * Adds two mat4's
   * @param {Matrix4} a
   * @param {Matrix4} [b] 如果不传，计算 this 和 a 的和
   * @return {Matrix4} this
   */
  add: function add(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["mat4"].add(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Subtracts matrix b from matrix a
   * @param {Matrix4} a
   * @param {Matrix4} [b]  如果不传，计算 this 和 a 的差
   * @return {Matrix4} this
   */
  subtract: function subtract(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["mat4"].subtract(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   * @param {Matrix4} a
   * @param {Matrix4} [b] 如果不传，比较 this 和 a 是否相等
   * @return {Boolean}
   */
  exactEquals: function exactEquals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["mat4"].exactEquals(a.elements, b.elements);
  },

  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   * @param {Matrix4} a
   * @param {Matrix4} [b] 如果不传，比较 this 和 a 是否近似相等
   * @return {Boolean}
   */
  equals: function equals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["mat4"].equals(a.elements, b.elements);
  },

  /**
   * compose
   * @param  {Quaternion} q quaternion
   * @param  {Vector3} v position
   * @param  {Vector3} s scale
   * @param  {Vector3} p [pivot]
   * @return {Matrix4}  this
   */
  compose: function compose(q, v, s, p) {
    if (p) {
      this.fromRotationTranslationScaleOrigin(q, v, s, p);
    } else {
      this.fromRotationTranslationScale(q, v, s);
    }

    return this;
  },

  /**
   * decompose
   * @param  {Quaternion} q quaternion
   * @param  {Vector3} v position
   * @param  {Vector3} s scale
   * @param  {Vector3} p [pivot]
   * @return {Matrix4}  this
   */
  decompose: function decompose(q, v, s, p) {
    this.getScaling(s);
    this.getTranslation(v);

    if (!tempMatrix4) {
      tempMatrix4 = new Matrix4();
    }

    var det = this.determinant();
    if (det < 0) s.x *= -1;
    tempMatrix4.copy(this);
    tempVector3.inverse(s);
    tempMatrix4.scale(tempVector3);
    q.fromMat4(tempMatrix4);

    if (p) {
      p.set(0, 0, 0);
    }

    return this;
  }
});
/**
 * Alias for {@link Matrix4#subtract}
 * @function
 */

Matrix4.prototype.sub = Matrix4.prototype.subtract;
/**
 * Alias for {@link Matrix4#multiply}
 * @function
 */

Matrix4.prototype.mul = Matrix4.prototype.multiply;
/* harmony default export */ var math_Matrix4 = (Matrix4);
/**
 * 含x, y, z属性的对象
 * @typedef {object} XYZObject
 * @property {Number} x
 * @property {Number} y
 * @property {Number} z
 */
// CONCATENATED MODULE: ./src/math/Matrix4Notifier.js






var Matrix4Notifier_tempMatrix4;
var Matrix4Notifier_tempVector3 = new math_Vector3();
var Matrix4Notifier_tempVector32 = new math_Vector3();
/**
 * 4x4 矩阵, 数据改变会发送事件
 * @class
 * @extends {Matrix4}
 */

var Matrix4Notifier = core_Class.create(
/** @lends Matrix4Notifier.prototype */
{
  Mixes: core_EventMixin,
  Extends: math_Matrix4,

  /**
   * 类名
   * @type {String}
   * @default Matrix4Notifier
   */
  className: 'Matrix4Notifier',

  /**
   * @type {Boolean}
   * @default true
   */
  isMatrix4Notifier: true,

  /**
   * Creates a new identity mat4
   * @constructs
   */
  constructor: function constructor() {
    /**
     * 数据
     * @type {Float32Array}
     */
    this.elements = gl_matrix_min["mat4"].create();
  },

  /**
   * Copy the values from one mat4 to this
   * @param  {Matrix4} m the source matrix
   * @return {Matrix4Notifier} this
   */
  copy: function copy(m) {
    gl_matrix_min["mat4"].copy(this.elements, m.elements);
    this.fire('update');
    return this;
  },

  /**
   * 从数组赋值
   * @param  {Array} array  数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Matrix4Notifier} this
   */
  fromArray: function fromArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;

    for (var i = 0; i < 16; i++) {
      elements[i] = array[offset + i];
    }

    this.fire('update');
    return this;
  },

  /**
   * Set the components of a mat3 to the given values
   * @param {Number} m00
   * @param {Number} m01
   * @param {Number} m02
   * @param {Number} m03
   * @param {Number} m10
   * @param {Number} m11
   * @param {Number} m12
   * @param {Number} m13
   * @param {Number} m20
   * @param {Number} m21
   * @param {Number} m22
   * @param {Number} m23
   * @param {Number} m30
   * @param {Number} m31
   * @param {Number} m32
   * @param {Number} m33
   * @return {Matrix4Notifier} this
   */
  set: function set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    gl_matrix_min["mat4"].set(this.elements, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    this.fire('update');
    return this;
  },

  /**
   * Set this to the identity matrix
   * @return {Matrix4Notifier} this
   */
  identity: function identity() {
    gl_matrix_min["mat4"].identity(this.elements);
    this.fire('update');
    return this;
  },

  /**
   * Transpose the values of this
   * @return {Matrix4Notifier} this
   */
  transpose: function transpose() {
    gl_matrix_min["mat4"].transpose(this.elements, this.elements);
    this.fire('update');
    return this;
  },

  /**
   * invert a matrix
   * @param {Matrix4} [m=this]
   * @return {Matrix4Notifier} this
   */
  invert: function invert() {
    var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
    gl_matrix_min["mat4"].invert(this.elements, m.elements);
    this.fire('update');
    return this;
  },

  /**
   * Calculates the adjugate of a mat4
   * @param {Matrix4} [m=this]
   * @return {Matrix4Notifier} this
   */
  adjoint: function adjoint() {
    var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
    gl_matrix_min["mat4"].adjoint(this.elements, m.elements);
    this.fire('update');
    return this;
  },

  /**
   * Calculates the determinant of this
   * @return {Matrix4Notifier} this
   */
  determinant: function determinant() {
    return gl_matrix_min["mat4"].determinant(this.elements);
  },

  /**
   * Multiplies two matrix4's
   * @param {Matrix4} a
   * @param {Matrix4} [b] 如果不传，计算 this 和 a 的乘积
   * @return {Matrix4Notifier} this
   */
  multiply: function multiply(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["mat4"].multiply(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * 左乘
   * @param {Matrix4} m
   * @return {Matrix4Notifier} this
   */
  premultiply: function premultiply(m) {
    this.multiply(m, this);
    this.fire('update');
    return this;
  },

  /**
   * Translate this by the given vector
   * @param {Vector3} v vector to translate by
   * @return {Matrix4Notifier} this
   */
  translate: function translate(v) {
    gl_matrix_min["mat4"].translate(this.elements, this.elements, v.elements);
    this.fire('update');
    return this;
  },

  /**
   * Scales the mat3 by the dimensions in the given vec2
   * @param {Vector3} v the vec3 to scale the matrix by
   * @return {Matrix4Notifier} this
   */
  scale: function scale(v) {
    gl_matrix_min["mat4"].scale(this.elements, this.elements, v.elements);
    this.fire('update');
    return this;
  },

  /**
   * Rotates this by the given angle
   * @param {Number} rad the angle to rotate the matrix by
   * @param {Vector3} axis the axis to rotate around
   * @return {Matrix4Notifier} this
   */
  rotate: function rotate(rad, axis) {
    gl_matrix_min["mat4"].rotate(this.elements, this.elements, rad, axis.elements);
    this.fire('update');
    return this;
  },

  /**
   * Rotates this by the given angle around the X axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4Notifier} this
   */
  rotateX: function rotateX(rad) {
    gl_matrix_min["mat4"].rotateX(this.elements, this.elements, rad);
    this.fire('update');
    return this;
  },

  /**
   * Rotates this by the given angle around the Y axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4Notifier} this
   */
  rotateY: function rotateY(rad) {
    gl_matrix_min["mat4"].rotateY(this.elements, this.elements, rad);
    this.fire('update');
    return this;
  },

  /**
   * Rotates this by the given angle around the Z axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4Notifier} this
   */
  rotateZ: function rotateZ(rad) {
    gl_matrix_min["mat4"].rotateZ(this.elements, this.elements, rad);
    this.fire('update');
    return this;
  },

  /**
   * Creates a matrix from a vector translation
   * @param {Vector3} transition Translation vector
   * @return {Matrix4Notifier} this
   */
  fromTranslation: function fromTranslation(v) {
    gl_matrix_min["mat4"].fromTranslation(this.elements, v.elements);
    this.fire('update');
    return this;
  },

  /**
   * Creates a matrix from a vector scaling
   * @param  {Vector3} v Scaling vector
   * @return {Matrix4Notifier} this
   */
  fromScaling: function fromScaling(v) {
    gl_matrix_min["mat4"].fromScaling(this.elements, v.elements);
    this.fire('update');
    return this;
  },

  /**
   * Creates a matrix from a given angle around a given axis
   * @param {Number} rad the angle to rotate the matrix by
   * @param {Vector3} axis the axis to rotate around
   * @return {Matrix4Notifier} this
   */
  fromRotation: function fromRotation(rad, axis) {
    gl_matrix_min["mat4"].fromRotation(this.elements, rad, axis.elements);
    this.fire('update');
    return this;
  },

  /**
   * Creates a matrix from the given angle around the X axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4Notifier} this
   */
  fromXRotation: function fromXRotation(rad) {
    gl_matrix_min["mat4"].fromXRotation(this.elements, rad);
    this.fire('update');
    return this;
  },

  /**
   * Creates a matrix from the given angle around the Y axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4Notifier} this
   */
  fromYRotation: function fromYRotation(rad) {
    gl_matrix_min["mat4"].fromYRotation(this.elements, rad);
    this.fire('update');
    return this;
  },

  /**
   * Creates a matrix from the given angle around the Z axis
   * @param {Number} rad the angle to rotate the matrix by
   * @return {Matrix4Notifier} this
   */
  fromZRotation: function fromZRotation(rad) {
    gl_matrix_min["mat4"].fromZRotation(this.elements, rad);
    this.fire('update');
    return this;
  },

  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * @param  {Quaternion} q Rotation quaternion
   * @param  {Vector3} v Translation vector
   * @return {Matrix4Notifier} this
   */
  fromRotationTranslation: function fromRotationTranslation(q, v) {
    gl_matrix_min["mat4"].fromRotationTranslation(this.elements, q.elements, v.elements);
    this.fire('update');
    return this;
  },

  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {Vector3} [out=new Vector3] Vector to receive translation component
   * @return {Vector3} out
   */
  getTranslation: function getTranslation() {
    var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new math_Vector3();
    gl_matrix_min["mat4"].getTranslation(out.elements, this.elements);
    return out;
  },

  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {Vector3} [out=new Vector3] Vector to receive scaling factor component
   * @return {Vector3} out
   */
  getScaling: function getScaling() {
    var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new math_Vector3();
    gl_matrix_min["mat4"].getScaling(out.elements, this.elements);
    return out;
  },

  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {Quaternion} out Quaternion to receive the rotation component
   * @return {Quaternion} out
   */
  getRotation: function getRotation() {
    var out = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new math_Quaternion();
    gl_matrix_min["mat4"].getRotation(out.elements, this.elements);
    return out;
  },

  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * @param  {Quaternion} q Rotation quaternion
   * @param  {Vector3} v Translation vector
   * @param  {Vector3} s Scaling vector
   * @return {Matrix4Notifier} this
   */
  fromRotationTranslationScale: function fromRotationTranslationScale(q, v, s) {
    gl_matrix_min["mat4"].fromRotationTranslationScale(this.elements, q.elements, v.elements, s.elements);
    this.fire('update');
    return this;
  },

  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * @param  {Quaternion} q Rotation quaternion
   * @param  {Vector3} v Translation vector
   * @param  {Vector3} s Scaling vector
   * @param  {Vector3} o The origin vector around which to scale and rotate
   * @param  {Boolean} [dontFireEvent=false] dontFireEvent
   * @return {Matrix4Notifier} this
   */
  fromRotationTranslationScaleOrigin: function fromRotationTranslationScaleOrigin(q, v, s, o, dontFireEvent) {
    gl_matrix_min["mat4"].fromRotationTranslationScaleOrigin(this.elements, q.elements, v.elements, s.elements, o.elements);

    if (!dontFireEvent) {
      this.fire('update');
    }

    return this;
  },

  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param {Quaternion} q Quaternion to create matrix from
   * @return {Matrix4Notifier} this
   */
  fromQuat: function fromQuat(q) {
    gl_matrix_min["mat4"].fromQuat(this.elements, q.elements);
    this.fire('update');
    return this;
  },

  /**
   * Generates a frustum matrix with the given bounds
   * @param  {Number} left  Left bound of the frustum
   * @param  {Number} right Right bound of the frustum
   * @param  {Number} bottom Bottom bound of the frustum
   * @param  {Number} top Top bound of the frustum
   * @param  {Number} near Near bound of the frustum
   * @param  {Number} far Far bound of the frustum
   * @return {Matrix4Notifier} this
   */
  frustum: function frustum(left, right, bottom, top, near, far) {
    gl_matrix_min["mat4"].frustum(this.elements, left, right, bottom, top, near, far);
    this.fire('update');
    return this;
  },

  /**
   * Generates a perspective projection matrix with the given bounds
   * @param {Number} fovy Vertical field of view in radians
   * @param {Number} aspect Aspect ratio. typically viewport width/height
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @return {Matrix4Notifier} this
   */
  perspective: function perspective(fovy, aspect, near, far) {
    gl_matrix_min["mat4"].perspective(this.elements, fovy, aspect, near, far);
    this.fire('update');
    return this;
  },

  /**
   * Generates a perspective projection matrix with the given field of view.
   * @param  {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param  {Number} Near bound of the frustum
   * @param  {Number} far Far bound of the frustum
   * @return {Matrix4Notifier} this
   */
  perspectiveFromFieldOfView: function perspectiveFromFieldOfView(fov, near, far) {
    gl_matrix_min["mat4"].perspectiveFromFieldOfView(this.elements, fov, near, far);
    this.fire('update');
    return this;
  },

  /**
   * Generates a orthogonal projection matrix with the given bounds
   * @param  {Number} left  Left bound of the frustum
   * @param  {Number} right Right bound of the frustum
   * @param  {Number} bottom Bottom bound of the frustum
   * @param  {Number} top Top bound of the frustum
   * @param  {Number} near Near bound of the frustum
   * @param  {Number} far Far bound of the frustum
   * @return {Matrix4Notifier} this
   */
  ortho: function ortho(left, right, bottom, top, near, far) {
    gl_matrix_min["mat4"].ortho(this.elements, left, right, bottom, top, near, far);
    this.fire('update');
    return this;
  },

  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis
   * @param  {XYZObject} eye Position of the viewer
   * @param  {XYZObject} center Point the viewer is looking at
   * @param  {Vector3} up pointing up
   * @return {Matrix4Notifier} this
   */
  lookAt: function lookAt(eye, center, up) {
    if (!eye.isVector3) {
      eye = Matrix4Notifier_tempVector3.set(eye.x, eye.y, eye.z);
    }

    if (!center.isVector3) {
      center = Matrix4Notifier_tempVector32.set(center.x, center.y, center.z);
    }

    gl_matrix_min["mat4"].lookAt(this.elements, eye.elements, center.elements, up.elements);
    this.fire('update');
    return this;
  },

  /**
   * Generates a matrix that makes something look at something else.
   * @param  {XYZObject} eye Position of the viewer
   * @param  {XYZObject} Point the viewer is looking at
   * @param  {Vector3} up pointing up
   * @return {Matrix4Notifier} this
   */
  targetTo: function targetTo(eye, target, up) {
    if (!eye.isVector3) {
      eye = Matrix4Notifier_tempVector3.set(eye.x, eye.y, eye.z);
    }

    if (!target.isVector3) {
      target = Matrix4Notifier_tempVector32.set(target.x, target.y, target.z);
    } // mat4.targetTo(this.elements, eye.elements, target.elements, up.elements);


    eye = eye.elements;
    target = target.elements;
    up = up.elements;
    var out = this.elements;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var z0 = eyex - target[0];
    var z1 = eyey - target[1];
    var z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    } else {
      z2 = 1;
    }

    var x0 = upy * z2 - upz * z1;
    var x1 = upz * z0 - upx * z2;
    var x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    } else {
      upx += 0.0000001;
      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;
      len = x0 * x0 + x1 * x1 + x2 * x2;
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    this.fire('update');
    return this;
  },

  /**
   * Returns Frobenius norm of a mat4
   * @return {Number} Frobenius norm
   */
  frob: function frob() {
    return gl_matrix_min["mat4"].frob(this.elements);
  },

  /**
   * Adds two mat4's
   * @param {Matrix4} a
   * @param {Matrix4} [b] 如果不传，计算 this 和 a 的和
   * @return {Matrix4} this
   */
  add: function add(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["mat4"].add(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * Subtracts matrix b from matrix a
   * @param {Matrix4} a
   * @param {Matrix4} [b]  如果不传，计算 this 和 a 的差
   * @return {Matrix4} this
   */
  subtract: function subtract(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["mat4"].subtract(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   * @param {Matrix4} a
   * @param {Matrix4} [b] 如果不传，比较 this 和 a 是否相等
   * @return {Boolean}
   */
  exactEquals: function exactEquals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["mat4"].exactEquals(a.elements, b.elements);
  },

  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   * @param {Matrix4} a
   * @param {Matrix4} [b] 如果不传，比较 this 和 a 是否近似相等
   * @return {Boolean}
   */
  equals: function equals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["mat4"].equals(a.elements, b.elements);
  },

  /**
   * compose
   * @param  {Quaternion} q quaternion
   * @param  {Vector3} v position
   * @param  {Vector3} s scale
   * @param  {Vector3} p [pivot]
   * @return {Matrix4Notifier}  this
   */
  compose: function compose(q, v, s, p) {
    if (p) {
      this.fromRotationTranslationScaleOrigin(q, v, s, p);
    } else {
      this.fromRotationTranslationScale(q, v, s);
    }

    return this;
  },

  /**
   * decompose
   * @param  {Quaternion} q quaternion
   * @param  {Vector3} v position
   * @param  {Vector3} s scale
   * @param  {Vector3} p [pivot]
   * @return {Matrix4Notifier}  this
   */
  decompose: function decompose(q, v, s, p) {
    this.getScaling(s);
    this.getTranslation(v);

    if (!Matrix4Notifier_tempMatrix4) {
      Matrix4Notifier_tempMatrix4 = new math_Matrix4();
    }

    var det = this.determinant();
    if (det < 0) s.x *= -1;
    Matrix4Notifier_tempMatrix4.copy(this);
    Matrix4Notifier_tempVector3.inverse(s);
    Matrix4Notifier_tempMatrix4.scale(Matrix4Notifier_tempVector3);
    q.fromMat4(Matrix4Notifier_tempMatrix4);

    if (p) {
      p.set(0, 0, 0);
    }

    return this;
  }
});
/* harmony default export */ var math_Matrix4Notifier = (Matrix4Notifier);
// CONCATENATED MODULE: ./src/math/Vector3Notifier.js




/**
 * 三维向量, 数据改变会发送事件
 * @class
 * @mixes EventMixin
 * @extends Vector3
 * @fires update 数据更新事件
 */

var Vector3Notifier = core_Class.create(
/** @lends Vector3Notifier.prototype */
{
  Mixes: core_EventMixin,
  Extends: math_Vector3,

  /**
   * 类名  notify
   * @type {String}
   * @default Vector3Notifier
   */
  className: 'Vector3Notifier',

  /**
   * @type {Boolean}
   * @default true
   */
  isVector3Notifier: true,

  /**
   * Creates a new empty vec3
   * @param {Number} [x=0] X component
   * @param {Number} [y=0] Y component
   * @param {Number} [z=0] Z component
   * @constructs
   */
  constructor: function constructor() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    /**
     * 数据
     * @type {Float32Array}
     */
    this.elements = gl_matrix_min["vec3"].fromValues(x, y, z);
  },

  /**
   * Copy the values from one vec3 to this
   * @param  {Vector3} m the source vector
   * @return {Vector3} this
   */
  copy: function copy(v) {
    gl_matrix_min["vec3"].copy(this.elements, v.elements);
    this.fire('update');
    return this;
  },

  /**
   * Creates a new vec3 initialized with values from this vec3
   * @return {Vector3} a new Vector3
   */
  clone: function clone() {
    var elements = this.elements;
    return new this.constructor(elements[0], elements[1], elements[2]);
  },

  /**
   * 转换到数组
   * @param  {Array}  [array=[]] 数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Array}
   */
  toArray: function toArray() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;
    array[0 + offset] = elements[0];
    array[1 + offset] = elements[1];
    array[2 + offset] = elements[2];
    return array;
  },

  /**
   * 从数组赋值
   * @param  {Array} array  数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Vector3} this
   */
  fromArray: function fromArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;
    elements[0] = array[offset + 0];
    elements[1] = array[offset + 1];
    elements[2] = array[offset + 2];
    this.fire('update');
    return this;
  },

  /**
   * Set the components of a vec3 to the given values
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {Vector3Notifier} this
   */
  set: function set(x, y, z) {
    gl_matrix_min["vec3"].set(this.elements, x, y, z);
    this.fire('update');
    return this;
  },

  /**
   * Adds two vec3's
   * @param {Vector3} a
   * @param {Vector3} [b] 如果不传，计算 this 和 a 的和
   * @returns {Vector3Notifier} this
   */
  add: function add(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].add(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * Subtracts vector b from vector a
   * @param {Vector3} a
   * @param {Vector3} [b] 如果不传，计算 this 和 a 的差
   * @returns {Vector3Notifier} this
   */
  subtract: function subtract(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].subtract(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * Multiplies two vec3's
   * @param {Vector3} a
   * @param {Vector3} [b] 如果不传，计算 this 和 a 的积
   * @returns {Vector3Notifier} this
   */
  multiply: function multiply(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].multiply(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * Divides two vec3's
   * @param {Vector3} a
   * @param {Vector3} [b] 如果不传，计算 this 和 a 的商
   * @returns {Vector3Notifier} this
   */
  divide: function divide(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].divide(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * Math.ceil the components of this
   * @returns {Vector3Notifier} this
   */
  ceil: function ceil() {
    gl_matrix_min["vec3"].ceil(this.elements, this.elements);
    this.fire('update');
    return this;
  },

  /**
   * Math.floor the components of this
   * @returns {Vector3Notifier} this
   */
  floor: function floor() {
    gl_matrix_min["vec3"].floor(this.elements, this.elements);
    this.fire('update');
    return this;
  },

  /**
   * Returns the minimum of two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @returns {Vector3Notifier} this
   */
  min: function min(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].min(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * Returns the maximum of two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b]  如果不传，计算 this 和 a 的结果
   * @returns {Vector3Notifier} this
   */
  max: function max(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].max(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * Math.round the components of this
   * @returns {Vector3Notifier} this
   */
  round: function round() {
    gl_matrix_min["vec3"].round(this.elements, this.elements);
    this.fire('update');
    return this;
  },

  /**
   * Scales this by a scalar number
   * @param  {Number} scale amount to scale the vector by
   * @returns {Vector3Notifier} this
   */
  scale: function scale(_scale) {
    gl_matrix_min["vec3"].scale(this.elements, this.elements, _scale);
    this.fire('update');
    return this;
  },

  /**
   * Adds two vec3's after scaling the second vector by a scalar value
   * @param  {Number} scale the amount to scale the second vector by before adding
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @returns {Vector3Notifier} this
   */
  scaleAndAdd: function scaleAndAdd(scale, a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].scaleAndAdd(this.elements, a.elements, b.elements, scale);
    this.fire('update');
    return this;
  },

  /**
   * Calculates the euclidian distance between two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number} distance between a and b
   */
  distance: function distance(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].distance(a.elements, b.elements);
  },

  /**
   * Calculates the squared euclidian distance between two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number} squared distance between a and b
   */
  squaredDistance: function squaredDistance(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].squaredDistance(a.elements, b.elements);
  },

  /**
   * Calculates the length of this
   * @return {Number} length of this
   */
  length: function length() {
    return gl_matrix_min["vec3"].length(this.elements);
  },

  /**
   * Calculates the squared length of this
   * @return {Number} squared length of this
   */
  squaredLength: function squaredLength() {
    return gl_matrix_min["vec3"].squaredLength(this.elements);
  },

  /**
   * Negates the components of this
   * @returns {Vector3Notifier} this
   */
  negate: function negate() {
    gl_matrix_min["vec3"].negate(this.elements, this.elements);
    this.fire('update');
    return this;
  },

  /**
   * Returns the inverse of the components of a vec3
   * @param  {Vector3} [a=this]
   * @returns {Vector3Notifier} this
   */
  inverse: function inverse(a) {
    if (!a) {
      a = this;
    }

    gl_matrix_min["vec3"].inverse(this.elements, a.elements);
    this.fire('update');
    return this;
  },

  /**
   * Normalize this
   * @returns {Vector3Notifier} this
   */
  normalize: function normalize() {
    gl_matrix_min["vec3"].normalize(this.elements, this.elements);
    this.fire('update');
    return this;
  },

  /**
   * Calculates the dot product of two vec3's
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number}  product of a and b
   */
  dot: function dot(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].dot(a.elements, b.elements);
  },

  /**
   * Computes the cross product of two vec3's
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number}  cross product of a and b
   */
  cross: function cross(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec3"].cross(this.elements, a.elements, b.elements);
    this.fire('update');
    return this;
  },

  /**
   * Performs a linear interpolation between two vec3's
   * @param  {Vector3} v
   * @param  {Number} t interpolation amount between the two vectors
   * @returns {Vector3Notifier} this
   */
  lerp: function lerp(v, t) {
    gl_matrix_min["vec3"].lerp(this.elements, this.elements, v.elements, t);
    this.fire('update');
    return this;
  },

  /**
   * Performs a hermite interpolation with two control points
   * @param  {Vector3} a
   * @param  {Vector3} b
   * @param  {Vector3} c
   * @param  {Vector3} d
   * @param  {Number} t interpolation amount between the two inputs
   * @return {Vector3} this
   */
  hermite: function hermite(a, b, c, d, t) {
    gl_matrix_min["vec3"].hermite(this.elements, a.elements, b.elements, c.elements, d.elements, t);
    this.fire('update');
    return this;
  },

  /**
   * Performs a bezier interpolation with two control points
   * @param  {Vector3} a
   * @param  {Vector3} b
   * @param  {Vector3} c
   * @param  {Vector3} d
   * @param  {Number} t interpolation amount between the two inputs
   * @return {Vector3} this
   */
  bezier: function bezier(a, b, c, d, t) {
    gl_matrix_min["vec3"].bezier(this.elements, a.elements, b.elements, c.elements, d.elements, t);
    this.fire('update');
    return this;
  },

  /**
   * Generates a random vector with the given scale
   * @param  {Number} [scale=1] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {Vector3Notifier} this
   */
  random: function random(scale) {
    gl_matrix_min["vec3"].random(this.elements, scale);
    this.fire('update');
    return this;
  },

  /**
   * Transforms the vec3 with a mat3
   * @param  {Matrix3} m matrix to transform with
   * @returns {Vector3Notifier} this
   */
  transformMat3: function transformMat3(m) {
    gl_matrix_min["vec3"].transformMat3(this.elements, this.elements, m.elements);
    this.fire('update');
    return this;
  },

  /**
   * Transforms the vec3 with a mat4
   * @param  {Matrix4} m matrix to transform with
   * @returns {Vector3Notifier} this
   */
  transformMat4: function transformMat4(m) {
    gl_matrix_min["vec3"].transformMat4(this.elements, this.elements, m.elements);
    this.fire('update');
    return this;
  },

  /**
   * Transforms the vec3 direction with a mat4
   * @param  {Matrix4} m matrix to transform with
   * @returns {Vector3Notifier} this
   */
  transformDirection: function transformDirection(m) {
    var elements = this.elements;
    var mElements = m.elements;
    var x = elements[0];
    var y = elements[1];
    var z = elements[2];
    elements[0] = x * mElements[0] + y * mElements[4] + z * mElements[8];
    elements[1] = x * mElements[1] + y * mElements[5] + z * mElements[9];
    elements[2] = x * mElements[2] + y * mElements[6] + z * mElements[10];
    this.fire('update');
    return this;
  },

  /**
   * Transforms the vec3 with a quat
   * @param  {Quaternion} q quaternion to transform with
   * @returns {Vector3Notifier} this
   */
  transformQuat: function transformQuat(q) {
    gl_matrix_min["vec3"].transformQuat(this.elements, this.elements, q.elements);
    this.fire('update');
    return this;
  },

  /**
   * Rotate this 3D vector around the x-axis
   * @param  {Vector3} origin The origin of the rotation
   * @param  {Number} rotation The angle of rotation
   * @return {Vector3} this
   */
  rotateX: function rotateX(origin, rotation) {
    gl_matrix_min["vec3"].rotateX(this.elements, this.elements, origin.elements, rotation);
    this.fire('update');
    return this;
  },

  /**
   * Rotate this 3D vector around the y-axis
   * @param  {Vector3} origin The origin of the rotation
   * @param  {Number} rotation The angle of rotation
   * @return {Vector3} this
   */
  rotateY: function rotateY(origin, rotation) {
    gl_matrix_min["vec3"].rotateY(this.elements, this.elements, origin.elements, rotation);
    this.fire('update');
    return this;
  },

  /**
   * Rotate this 3D vector around the z-axis
   * @param  {Vector3} origin The origin of the rotation
   * @param  {Number} rotation The angle of rotation
   * @return {Vector3} this
   */
  rotateZ: function rotateZ(origin, rotation) {
    gl_matrix_min["vec3"].rotateZ(this.elements, this.elements, origin.elements, rotation);
    this.fire('update');
    return this;
  },

  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Boolean} True if the vectors are equal, false otherwise.
   */
  exactEquals: function exactEquals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].exactEquals(a.elements, b.elements);
  },

  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @param  {Vector3} a
   * @param  {Vector3} [b] 如果不传，计算 this 和 a 的结果
   * @return {Boolean} True if the vectors are equal, false otherwise.
   */
  equals: function equals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec3"].equals(a.elements, b.elements);
  },

  /**
   * X component
   * @type {Number}
   */
  x: {
    get: function get() {
      return this.elements[0];
    },
    set: function set(value) {
      this.elements[0] = value;
      this.fire('update');
    }
  },

  /**
   * Y component
   * @type {Number}
   */
  y: {
    get: function get() {
      return this.elements[1];
    },
    set: function set(value) {
      this.elements[1] = value;
      this.fire('update');
    }
  },

  /**
   * Z component
   * @type {Number}
   */
  z: {
    get: function get() {
      return this.elements[2];
    },
    set: function set(value) {
      this.elements[2] = value;
      this.fire('update');
    }
  }
});
/* harmony default export */ var math_Vector3Notifier = (Vector3Notifier);
// CONCATENATED MODULE: ./src/math/math.js
/**
 * @namespace math
 * @type {Object}
 */
var math = {
  /**
   * 角度值转弧度值
   * @type {Number}
   */
  DEG2RAD: Math.PI / 180,

  /**
   * 弧度值转角度值
   * @type {Number}
   */
  RAD2DEG: 180 / Math.PI,

  /**
   * 生成唯一ID
   * @function
   * @param  {String} [prefix=''] ID前缀
   * @return {String} ID
   */
  generateUUID: function () {
    var uid = 0;
    return function (prefix) {
      var id = ++uid;

      if (prefix) {
        id = prefix + '_' + id;
      } else {
        id += '';
      }

      return id;
    };
  }(),

  /**
   * 截取
   * @param  {Number} value 值
   * @param  {Number} min 最小值
   * @param  {Number} max 最大值
   * @return {Number}
   */
  clamp: function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },

  /**
   * 角度值转换成弧度值
   * @param  {Number} deg 角度值
   * @return {Number} 弧度值
   */
  degToRad: function degToRad(deg) {
    return deg * this.DEG2RAD;
  },

  /**
   * 弧度值转换成角度值
   * @param  {Number} rad 弧度值
   * @return {Number} 角度值
   */
  radToDeg: function radToDeg(rad) {
    return rad * this.RAD2DEG;
  },

  /**
   * 是否是 2 的指数值
   * @param  {Number}  value
   * @return {Boolean}
   */
  isPowerOfTwo: function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  },

  /**
   * 最近的 2 的指数值
   * @param  {Number} value
   * @return {Number}
   */
  nearestPowerOfTwo: function nearestPowerOfTwo(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
  },

  /**
   * 下一个的 2 的指数值
   * @param  {Number} value
   * @return {Number}
   */
  nextPowerOfTwo: function nextPowerOfTwo(value) {
    value--;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value++;
    return value;
  }
};
/* harmony default export */ var math_math = (math);
// CONCATENATED MODULE: ./src/math/Euler.js




var tempMatrix = new math_Matrix4();
var DEG2RAD = math_math.DEG2RAD;
var RAD2DEG = math_math.RAD2DEG;
/**
 * @class
 */

var Euler = core_Class.create(
/** @lends Euler.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Euler
   */
  className: 'Euler',

  /**
   * @type {boolean}
   * @default true
   */
  isEuler: true,

  /**
   * 旋转顺序，默认为 ZYX
   * @type {string}
   * @default 'ZYX'
   */
  order: 'ZYX',

  /**
   * @constructs
   * @param  {Number} [x=0]  角度 X, 弧度制
   * @param  {Number} [y=0]  角度 Y, 弧度制
   * @param  {Number} [z=0]  角度 Z, 弧度制
   */
  constructor: function constructor() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    this.elements = new Float32Array([x, y, z]);
    this.updateDegrees();
  },

  /**
   * 克隆
   * @return {Euler}
   */
  clone: function clone() {
    var euler = new this.constructor();
    euler.copy(this);
    return euler;
  },

  /**
   * 复制
   * @param  {Euler} euler
   * @return {Euler} this
   */
  copy: function copy(euler) {
    this.elements[0] = euler.x;
    this.elements[1] = euler.y;
    this.elements[2] = euler.z;
    this.order = euler.order;
    this.updateDegrees();
    return this;
  },

  /**
   * Set the components of a euler to the given values
   * @param {Number} x x 轴旋转角度, 弧度制
   * @param {Number} y y 轴旋转角度, 弧度制
   * @param {Number} z z 轴旋转角度, 弧度制
   * @return {Euler} this
   */
  set: function set(x, y, z) {
    this.elements[0] = x;
    this.elements[1] = y;
    this.elements[2] = z;
    this.updateDegrees();
    return this;
  },

  /**
   * 设置角度
   * @param {Number} degX x 轴旋转角度, 角度制
   * @param {Number} degY y 轴旋转角度, 角度制
   * @param {Number} degZ z 轴旋转角度, 角度制
   * @return {Euler} this
   */
  setDegree: function setDegree(degX, degY, degZ) {
    this._degX = degX;
    this._degY = degY;
    this._degZ = degZ;
    this.updateRadians();
    return this;
  },

  /**
   * 从数组赋值
   * @param  {Array} array  数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Euler} this
   */
  fromArray: function fromArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    this.elements[0] = array[offset];
    this.elements[1] = array[offset + 1];
    this.elements[2] = array[offset + 2];
    this.updateDegrees();
    return this;
  },

  /**
   * 转换到数组
   * @param  {Array}  [array=[]] 数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Array}
   */
  toArray: function toArray() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    array[offset] = this.elements[0];
    array[offset + 1] = this.elements[0 + 1];
    array[offset + 2] = this.elements[0 + 2];
    return array;
  },

  /**
   * Creates a euler from the given 4x4 rotation matrix.
   * @param {Matrix4} mat rotation matrix
   * @param {string} [order=this.order] 旋转顺序，默认为当前Euler实例的order
   * @return {Euler} this
   */
  fromMat4: function fromMat4(mat, order) {
    // Based on https://github.com/mrdoob/three.js/blob/dev/src/math/Euler.js#L133
    var elements = mat.elements;
    var m11 = elements[0];
    var m21 = elements[1];
    var m31 = elements[2];
    var m12 = elements[4];
    var m22 = elements[5];
    var m32 = elements[6];
    var m13 = elements[8];
    var m23 = elements[9];
    var m33 = elements[10];
    order = order || this.order;
    this.order = order;
    var clamp = math_math.clamp;

    if (order === 'XYZ') {
      this.elements[1] = Math.asin(clamp(m13, -1, 1));

      if (Math.abs(m13) < 0.99999) {
        this.elements[0] = Math.atan2(-m23, m33);
        this.elements[2] = Math.atan2(-m12, m11);
      } else {
        this.elements[0] = Math.atan2(m32, m22);
        this.elements[2] = 0;
      }
    } else if (order === 'YXZ') {
      this.elements[0] = Math.asin(-clamp(m23, -1, 1));

      if (Math.abs(m23) < 0.99999) {
        this.elements[1] = Math.atan2(m13, m33);
        this.elements[2] = Math.atan2(m21, m22);
      } else {
        this.elements[1] = Math.atan2(-m31, m11);
        this.elements[2] = 0;
      }
    } else if (order === 'ZXY') {
      this.elements[0] = Math.asin(clamp(m32, -1, 1));

      if (Math.abs(m32) < 0.99999) {
        this.elements[1] = Math.atan2(-m31, m33);
        this.elements[2] = Math.atan2(-m12, m22);
      } else {
        this.elements[1] = 0;
        this.elements[2] = Math.atan2(m21, m11);
      }
    } else if (order === 'ZYX') {
      this.elements[1] = Math.asin(-clamp(m31, -1, 1));

      if (Math.abs(m31) < 0.99999) {
        this.elements[0] = Math.atan2(m32, m33);
        this.elements[2] = Math.atan2(m21, m11);
      } else {
        this.elements[0] = 0;
        this.elements[2] = Math.atan2(-m12, m22);
      }
    } else if (order === 'YZX') {
      this.elements[2] = Math.asin(clamp(m21, -1, 1));

      if (Math.abs(m21) < 0.99999) {
        this.elements[0] = Math.atan2(-m23, m22);
        this.elements[1] = Math.atan2(-m31, m11);
      } else {
        this.elements[0] = 0;
        this.elements[1] = Math.atan2(m13, m33);
      }
    } else if (order === 'XZY') {
      this.elements[2] = Math.asin(-clamp(m12, -1, 1));

      if (Math.abs(m12) < 0.99999) {
        this.elements[0] = Math.atan2(m32, m22);
        this.elements[1] = Math.atan2(m13, m11);
      } else {
        this.elements[0] = Math.atan2(-m23, m33);
        this.elements[1] = 0;
      }
    } else {
      utils_log.warn('Euler fromMat4() unsupported order: ' + order);
    }

    this.updateDegrees();
    return this;
  },

  /**
   * Creates a euler from the given quat.
   * @param  {Quaternion} quat
   * @param  {String} [order=this.order] 旋转顺序，默认为当前Euler实例的order
   * @return {Euler} this
   */
  fromQuat: function fromQuat(quat, order) {
    tempMatrix.fromQuat(quat);
    return this.fromMat4(tempMatrix, order);
  },
  updateDegrees: function updateDegrees() {
    this._degX = this.elements[0] * RAD2DEG;
    this._degY = this.elements[1] * RAD2DEG;
    this._degZ = this.elements[2] * RAD2DEG;
    return this;
  },
  updateRadians: function updateRadians() {
    this.elements[0] = this._degX * DEG2RAD;
    this.elements[1] = this._degY * DEG2RAD;
    this.elements[2] = this._degZ * DEG2RAD;
    return this;
  },

  /**
   * 角度 X, 角度制
   * @type {Number}
   */
  degX: {
    get: function get() {
      return this._degX;
    },
    set: function set(value) {
      this._degX = value;
      this.elements[0] = value * DEG2RAD;
    }
  },

  /**
   * 角度 Y, 角度制
   * @type {Number}
   */
  degY: {
    get: function get() {
      return this._degY;
    },
    set: function set(value) {
      this._degY = value;
      this.elements[1] = value * DEG2RAD;
    }
  },

  /**
   * 角度 Z, 角度制
   * @type {Number}
   */
  degZ: {
    get: function get() {
      return this._degZ;
    },
    set: function set(value) {
      this._degZ = value;
      this.elements[2] = value * DEG2RAD;
    }
  },

  /**
   * 角度 X, 弧度制
   * @type {Number}
   */
  x: {
    get: function get() {
      return this.elements[0];
    },
    set: function set(value) {
      this.elements[0] = value;
      this._degX = value * RAD2DEG;
    }
  },

  /**
   * 角度 Y, 弧度制
   * @type {Number}
   */
  y: {
    get: function get() {
      return this.elements[1];
    },
    set: function set(value) {
      this.elements[1] = value;
      this._degY = value * RAD2DEG;
    }
  },

  /**
   * 角度 Z, 弧度制
   * @type {Number}
   */
  z: {
    get: function get() {
      return this.elements[2];
    },
    set: function set(value) {
      this.elements[2] = value;
      this._degZ = value * RAD2DEG;
    }
  }
});
/* harmony default export */ var math_Euler = (Euler);
// CONCATENATED MODULE: ./src/math/EulerNotifier.js




var EulerNotifier_DEG2RAD = math_math.DEG2RAD;
var EulerNotifier_RAD2DEG = math_math.RAD2DEG;
/**
 * 欧拉角, 数据改变会发送事件
 * @class
 * @mixes EventMixin
 * @extends Euler
 * @fires update 数据更新事件
 */

var EulerNotifier = core_Class.create(
/** @lends EulerNotifier.prototype */
{
  Mixes: core_EventMixin,
  Extends: math_Euler,

  /**
   * 类名
   * @type {String}
   * @default EulerNotifier
   */
  className: 'EulerNotifier',

  /**
   * @type {Boolean}
   * @default true
   */
  isEulerNotifier: true,

  /**
   * @constructs
   * @param  {Number} [x=0]  角度 X, 弧度制
   * @param  {Number} [y=0]  角度 Y, 弧度制
   * @param  {Number} [z=0]  角度 Z, 弧度制
   */
  constructor: function constructor() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    math_Euler.call(this, x, y, z);
  },
  updateDegrees: function updateDegrees() {
    EulerNotifier.superclass.updateDegrees.call(this);
    this.fire('update');
    return this;
  },
  updateRadians: function updateRadians() {
    EulerNotifier.superclass.updateRadians.call(this);
    this.fire('update');
    return this;
  },

  /**
   * 角度 X, 角度制
   * @type {Number}
   */
  degX: {
    get: function get() {
      return this._degX;
    },
    set: function set(value) {
      this._degX = value;
      this.elements[0] = value * EulerNotifier_DEG2RAD;
      this.fire('update');
    }
  },

  /**
   * 角度 Y, 角度制
   * @type {Number}
   */
  degY: {
    get: function get() {
      return this._degY;
    },
    set: function set(value) {
      this._degY = value;
      this.elements[1] = value * EulerNotifier_DEG2RAD;
      this.fire('update');
    }
  },

  /**
   * 角度 Z, 角度制
   * @type {Number}
   */
  degZ: {
    get: function get() {
      return this._degZ;
    },
    set: function set(value) {
      this._degZ = value;
      this.elements[2] = value * EulerNotifier_DEG2RAD;
      this.fire('update');
    }
  },

  /**
   * 角度 X, 弧度制
   * @type {Number}
   */
  x: {
    get: function get() {
      return this.elements[0];
    },
    set: function set(value) {
      this.elements[0] = value;
      this._degX = value * EulerNotifier_RAD2DEG;
      this.fire('update');
    }
  },

  /**
   * 角度 Y, 弧度制
   * @type {Number}
   */
  y: {
    get: function get() {
      return this.elements[1];
    },
    set: function set(value) {
      this.elements[1] = value;
      this._degY = value * EulerNotifier_RAD2DEG;
      this.fire('update');
    }
  },

  /**
   * 角度 Z, 弧度制
   * @type {Number}
   */
  z: {
    get: function get() {
      return this.elements[2];
    },
    set: function set(value) {
      this.elements[2] = value;
      this._degZ = value * EulerNotifier_RAD2DEG;
      this.fire('update');
    }
  }
});
/* harmony default export */ var math_EulerNotifier = (EulerNotifier);
// CONCATENATED MODULE: ./src/core/Node.js










var defaultUp = new math_Vector3(0, 1, 0);
var Node_tempMatrix4 = new math_Matrix4();
var TRAVERSE_STOP_NONE = false;
var TRAVERSE_STOP_CHILDREN = 1;
var TRAVERSE_STOP_ALL = true;
/**
 * 节点，3D场景中的元素，是大部分类的基类
 * @class
 * @mixes EventMixin
 * @example
 * const node = new Hilo3d.Node({
 *     name:'test',
 *     x:100,
 *     rotationX:30,
 *     onUpdate(){
 *         this.rotationY ++;
 *     }
 * });
 * node.scaleX = 0.3;
 * stage.addChild(node);
 */

var Node = core_Class.create(
/** @lends Node.prototype */
{
  Statics: {
    /**
     * traverse callback 返回值，执行后不暂停 traverse
     * @memberOf Node
     * @type {any}
     */
    TRAVERSE_STOP_NONE: TRAVERSE_STOP_NONE,

    /**
     * traverse callback 返回值，执行后暂停子元素 traverse
     * @memberOf Node
     * @type {any}
     */
    TRAVERSE_STOP_CHILDREN: TRAVERSE_STOP_CHILDREN,

    /**
     * traverse callback 返回值，执行后暂停所有 traverse
     * @memberOf Node
     * @type {any}
     */
    TRAVERSE_STOP_ALL: TRAVERSE_STOP_ALL
  },
  Mixes: core_EventMixin,

  /**
   * @default true
   * @type {boolean}
   */
  isNode: true,

  /**
   * @default Node
   * @type {string}
   */
  className: 'Node',

  /**
   * Node 的名字，可以通过 getChildByName 查找
   * @type {string}
   */
  name: '',

  /**
   * 动画
   * @type {Animation}
   * @default null
   */
  anim: null,

  /**
   * animation 查找 id
   * @type {String}
   * @default ''
   */
  animationId: '',

  /**
   * 骨骼名称
   * @type {String}
   * @default ''
   */
  jointName: '',

  /**
   * 是否自动更新世界矩阵
   * @default true
   * @type {boolean}
   */
  autoUpdateWorldMatrix: true,

  /**
   * 是否自动更新子元素世界矩阵
   * @default true
   * @type {boolean}
   */
  autoUpdateChildWorldMatrix: true,

  /**
   * 父节点
   * @default null
   * @type {Node}
   */
  parent: null,
  _quatDirty: false,
  _matrixDirty: false,

  /**
   * 每次更新的时候是否调用子节点的 onUpdate 方法
   * @default true
   * @type {boolean}
   */
  needCallChildUpdate: true,

  /**
   * 节点是否显示
   * @default true
   * @type {boolean}
   */
  visible: true,

  /**
   * 可视对象是否接受交互事件。默认为接受交互事件，即true。
   * @default true
   * @type {Boolean}
   */
  pointerEnabled: true,

  /**
   * 子元素是否接受交互事件。
   * @default true
   * @type {Boolean}
   */
  pointerChildren: true,

  /**
   * 是否用鼠标指针
   * @default false
   * @type {Boolean}
   */
  useHandCursor: false,

  /**
   * 是否强制使用父元素 worldMatrix，供高级开发者使用
   * @private
   * @type {Boolean}
   */
  __forceUseParentWorldMatrix: false,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    var _this = this;

    /**
     * @type {string}
     */
    this.id = math_math.generateUUID(this.className);
    /**
     * 元素的up向量
     * @type {Vector3}
     */

    this.up = defaultUp.clone();
    /**
     * 元素直接点数组
     * @type {Node[]}
     */

    this.children = [];
    /**
     * 元素的世界矩阵
     * @type {Matrix4}
     */

    this.worldMatrix = new math_Matrix4();
    this._matrix = new math_Matrix4Notifier();
    this._position = new math_Vector3Notifier(0, 0, 0);
    this._scale = new math_Vector3Notifier(1, 1, 1);
    this._pivot = new math_Vector3Notifier(0, 0, 0);
    this._rotation = new math_EulerNotifier();
    this._quaternion = new math_Quaternion();

    this._matrix.on('update', function () {
      _this._onMatrixUpdate();
    });

    this._position.on('update', function () {
      _this._onPositionUpdate();
    });

    this._scale.on('update', function () {
      _this._onScaleUpdate();
    });

    this._pivot.on('update', function () {
      _this._onPivotUpdate();
    });

    this._rotation.on('update', function () {
      _this._onRotationUpdate();
    });

    this._quaternion.on('update', function () {
      _this._onQuaternionUpdate();
    });

    Object.assign(this, params);
  },

  /**
   * @param {boolean} [isChild=false] 是否子节点，子节点不会处理动画及骨骼Mesh，即如果有动画将共享
   * @return {Node} 返回clone的Node
   */
  clone: function clone(isChild) {
    var node = new this.constructor();
    node.name = this.name;
    node.jointName = this.jointName;
    node.animationId = this.animationId;
    node.setPosition(this.x, this.y, this.z);
    node.setScale(this.scaleX, this.scaleY, this.scaleZ);
    node.setRotation(this.rotationX, this.rotationY, this.rotationZ);
    this.children.forEach(function (child) {
      node.addChild(child.clone(true));
    });

    if (!isChild) {
      if (this.anim) {
        node.anim = this.anim.clone(node);
      }

      node.resetSkinedMeshRootNode();
    }

    return node;
  },

  /**
   * 设置节点的动画，这个需要是模型的根节点
   * @param {Animation} anim 动画实例
   * @return {Node} this
   */
  setAnim: function setAnim(anim) {
    this.anim = anim;
    anim.rootNode = this;
    return this;
  },

  /**
   * 重置子孙元素中 SkinedMesh 的根节点为当前元素
   */
  resetSkinedMeshRootNode: function resetSkinedMeshRootNode() {
    var _this2 = this;

    this.traverse(function (mesh) {
      if (mesh.isSkinedMesh && mesh.skeleton) {
        mesh.skeleton.rootNode = _this2;
      }
    }, true);
  },

  /**
   * 将所以子孙元素放到一个对象中，对象key为元素的name，value为该元素
   * @return {Object} 返回获取的对象
   */
  getChildrenNameMap: function getChildrenNameMap() {
    var map = {};
    this.traverse(function (child) {
      map[child.name] = child; // fix smd animation bug

      var originName = child._originName;

      if (originName !== undefined && !map[originName]) {
        map[originName] = child;
      }
    }, true);
    return map;
  },

  /**
   * 添加一个子元素
   * @param {Node} child 需要添加的子元素
   * @return {Node} this
   */
  addChild: function addChild(child) {
    if (child.parent) {
      child.removeFromParent();
    }

    child.parent = this;
    this.children.push(child);
    return this;
  },

  /**
   * 移除指定的子元素
   * @param {Node} child 需要移除的元素
   * @return {Node} this
   */
  removeChild: function removeChild(child) {
    var index = this.children.indexOf(child);

    if (index > -1) {
      this.children.splice(index, 1);
      child.parent = null;
    }

    return this;
  },

  /**
   * 将当前元素添加到某个父元素的子元素中
   * @param {Node} parent 需要添加到的父元素
   * @return {Node} this
   */
  addTo: function addTo(parent) {
    parent.addChild(this);
    return this;
  },

  /**
   * 将当前元素从其父元素中移除
   * @return {Node} this
   */
  removeFromParent: function removeFromParent() {
    if (this.parent) {
      this.parent.removeChild(this);
    }

    return this;
  },

  /**
   * 更新本地矩阵
   * @return {Node} this
   */
  updateMatrix: function updateMatrix() {
    if (this._matrixDirty) {
      this._matrixDirty = false;
      this.matrixVersion++;

      this._matrix.fromRotationTranslationScaleOrigin(this.quaternion, this._position, this._scale, this._pivot, true);
    }

    return this;
  },

  /**
   * 更新四元数
   * @return {Node} this
   */
  updateQuaternion: function updateQuaternion() {
    if (this._quatDirty) {
      this._quatDirty = false;

      this._quaternion.fromEuler(this._rotation, true);
    }

    return this;
  },

  /**
   * 更新transform属性
   * @return {Node} this
   */
  updateTransform: function updateTransform() {
    this._matrix.decompose(this._quaternion, this._position, this._scale, this._pivot);

    this._onQuaternionUpdate();

    this._matrixDirty = false;
    return this;
  },

  /**
   * 更新世界矩阵
   * @param  {Boolean} [force=true] 是否强制更新
   * @return {Node} this
   */
  updateMatrixWorld: function updateMatrixWorld(force) {
    this.traverse(function (node) {
      if (node.autoUpdateWorldMatrix || force) {
        if (node.parent) {
          if (!node.__forceUseParentWorldMatrix) {
            node.worldMatrix.multiply(node.parent.worldMatrix, node.matrix);
          } else {
            node.worldMatrix.copy(node.parent.worldMatrix);
          }
        } else {
          node.worldMatrix.copy(node.matrix);
        }
      }

      if (!node.autoUpdateChildWorldMatrix && !force) {
        return TRAVERSE_STOP_CHILDREN;
      }

      return TRAVERSE_STOP_NONE;
    });
    return this;
  },

  /**
   * 获取当前元素相对于指定元素的矩阵
   * @param {Node} [ancestor] 相对于的元素，需要是当前元素的祖先元素，不传表示获取世界矩阵
   * @return {Matrix4} 返回获取的矩阵
   */
  getConcatenatedMatrix: function getConcatenatedMatrix(ancestor) {
    var mtx = new math_Matrix4();

    for (var o = this; o && o !== ancestor; o = o.parent) {
      mtx.multiply(o.matrix, mtx);
    }

    return mtx;
  },

  /**
   * _traverse
   * @private
   * @param  {NodeTraverseCallback} callback
   * @param  {Boolean}  onlyChild
   * @return {Enum}  TRAVERSE_STOP_ALL, TRAVERSE_STOP_CHILDREN, TRAVERSE_STOP_NONE
   */
  _traverse: function _traverse(callback, onlyChild) {
    if (!onlyChild) {
      var res = callback(this);

      if (res) {
        return res;
      }
    }

    var children = this.children;

    for (var i = 0, l = children.length; i < l; i++) {
      var _res = children[i]._traverse(callback, false);

      if (_res === TRAVERSE_STOP_ALL) {
        return _res;
      }
    }

    return TRAVERSE_STOP_NONE;
  },

  /**
   * 遍历当前元素的子孙元素
   * @param {NodeTraverseCallback} callback 每个元素都会调用这个函数处理
   * @param {Boolean} [onlyChild=false] 是否只遍历子元素
   * @return {Node} this
   */
  traverse: function traverse(callback) {
    var onlyChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    this._traverse(callback, onlyChild);

    return this;
  },

  /**
   * 遍历当前元素的子孙元素(广度优先)
   * @param {NodeTraverseCallback} callback 每个元素都会调用这个函数处理
   * @param {Boolean} [onlyChild=false] 是否只遍历子元素
   * @return {Node} this
   */
  traverseBFS: function traverseBFS(callback) {
    var onlyChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var currentQueue;
    var nextQueue;

    if (!onlyChild) {
      nextQueue = [this];
    } else {
      nextQueue = this.children;
    }

    while (nextQueue.length) {
      currentQueue = nextQueue;
      nextQueue = [];

      for (var i = 0, l = currentQueue.length; i < l; i++) {
        var child = currentQueue[i];
        var res = callback(child);

        if (!res) {
          nextQueue = nextQueue.concat(child.children);
        } else if (res === TRAVERSE_STOP_ALL) {
          return this;
        }
      }
    }

    return this;
  },

  /**
   * 根据函数来获取一个子孙元素(广度优先)
   * @param {NodeGetChildByCallback} fn 判读函数
   * @return {Node|null} 返回获取到的子孙元素
   */
  getChildByFnBFS: function getChildByFnBFS(fn) {
    var result = null;
    this.traverseBFS(function (child) {
      if (fn(child)) {
        result = child;
        return TRAVERSE_STOP_ALL;
      }

      return TRAVERSE_STOP_NONE;
    }, true);
    return result;
  },

  /**
   * 根据 name path 来获取子孙元素
   * @param  {String[]} path 名字数组, e.g., getChildByNamePath(['a', 'b', 'c'])
   * @return {Node|null} 返回获取到的子孙元素
   */
  getChildByNamePath: function getChildByNamePath(path) {
    var currentNode = this;

    var _loop = function _loop(i, l) {
      var name = path[i];
      var node = currentNode.getChildByFnBFS(function (child) {
        return child.name === name;
      });

      if (node) {
        currentNode = node;
      } else {
        return {
          v: null
        };
      }
    };

    for (var i = 0, l = path.length; i < l; i++) {
      var _ret = _loop(i);

      if (typeof _ret === "object") return _ret.v;
    }

    return currentNode;
  },

  /**
   * 遍历调用子孙元素onUpdate方法
   * @param  {Number} dt
   * @return {Node} this
   */
  traverseUpdate: function traverseUpdate(dt) {
    this.traverse(function (node) {
      if (node.onUpdate) {
        node.onUpdate(dt);
      }

      if (!node.needCallChildUpdate) {
        return TRAVERSE_STOP_CHILDREN;
      }

      return TRAVERSE_STOP_NONE;
    });
    return this;
  },

  /**
   * 根据函数来获取一个子孙元素
   * @param {NodeGetChildByCallback} fn 判读函数
   * @return {Node|null} 返回获取到的子孙元素
   */
  getChildByFn: function getChildByFn(fn) {
    var result = null;
    this.traverse(function (child) {
      if (fn(child)) {
        result = child;
        return TRAVERSE_STOP_ALL;
      }

      return TRAVERSE_STOP_NONE;
    }, true);
    return result;
  },

  /**
   * 根据函数来获取匹配的所有子孙元素
   * @param {NodeGetChildByCallback} fn 判读函数
   * @return {Node[]} 返回获取到的子孙元素
   */
  getChildrenByFn: function getChildrenByFn(fn) {
    var result = [];
    this.traverse(function (child) {
      if (fn(child)) {
        result.push(child);
      }
    }, true);
    return result;
  },

  /**
   * 获取指定name的首个子孙元素
   * @param {string} name 元素name
   * @return {Node|null} 获取的元素
   */
  getChildByName: function getChildByName(name) {
    return this.getChildByFn(function (child) {
      return child.name === name;
    });
  },

  /**
   * 获取指定name的所有子孙元素
   * @param {string} name 元素name
   * @return {Node[]} 获取的元素数组
   */
  getChildrenByName: function getChildrenByName(name) {
    return this.getChildrenByFn(function (child) {
      return child.name === name;
    });
  },

  /**
   * 获取指定id的子孙元素
   * @param {string} id 元素id
   * @return {Node|null} 获取的元素
   */
  getChildById: function getChildById(id) {
    return this.getChildByFn(function (child) {
      return child.id === id;
    });
  },

  /**
   * 获取指定类名的所有子孙元素
   * @param {string} className 类名
   * @return {Node[]} 获取的元素数组
   */
  getChildrenByClassName: function getChildrenByClassName(className) {
    return this.getChildrenByFn(function (child) {
      return child.className === className;
    });
  },

  /**
   * 获取指定基类名的所有子孙元素
   * @param {string} className 类名
   * @return {Node[]} 获取的元素数组
   */
  getChildrenByBaseClassName: function getChildrenByBaseClassName(className) {
    return this.getChildrenByFn(function (child) {
      return child['is' + className];
    });
  },

  /**
   * 设置元素的缩放比例
   * @param {number} x X缩放比例
   * @param {number} y Y缩放比例
   * @param {number} z Z缩放比例
   * @return {Node} this
   */
  setScale: function setScale(x) {
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : y;

    this._scale.set(x, y, z);

    return this;
  },

  /**
   * 设置元素的位置
   * @param {number} x X方向位置
   * @param {number} y Y方向位置
   * @param {number} z Z方向位置
   * @return {Node} this
   */
  setPosition: function setPosition(x, y, z) {
    this._position.set(x, y, z);

    return this;
  },

  /**
   * 设置元素的旋转
   * @param {number} x X轴旋转角度, 角度制
   * @param {number} y Y轴旋转角度, 角度制
   * @param {number} z Z轴旋转角度, 角度制
   * @return {Node} this
   */
  setRotation: function setRotation(x, y, z) {
    this._rotation.setDegree(x, y, z);

    return this;
  },

  /**
   * 设置中心点
   * @param {Number} x 中心点x
   * @param {Number} y 中心点y
   * @param {Number} z 中心点z
   * @return {Node} this
   */
  setPivot: function setPivot(x, y, z) {
    this._pivot.set(x, y, z);

    return this;
  },

  /**
   * 改变元素的朝向
   * @param {Node|Object|Vector3} node 需要朝向的元素，或者坐标
   * @return {Node} this
   */
  lookAt: function lookAt(node) {
    if (this.isCamera) {
      Node_tempMatrix4.targetTo(this, node, this.up);
    } else {
      Node_tempMatrix4.targetTo(node, this, this.up);
    }

    this._quaternion.fromMat4(Node_tempMatrix4);

    return this;
  },

  /**
   * raycast
   * @param  {Ray} ray
   * @param {Boolean} [sort=false] 是否按距离排序
   * @param {Boolean} [eventMode=false] 是否事件模式
   * @return {raycastInfo[]|null}
   */
  raycast: function raycast(ray) {
    var _this3 = this;

    var sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var eventMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!this.visible) {
      return null;
    }

    var resArray = [];
    this.traverse(function (child) {
      if (eventMode && !child.pointerEnabled) {
        return TRAVERSE_STOP_CHILDREN;
      }

      if (child.isMesh) {
        var res = child.raycast(ray, false);

        if (res) {
          resArray = resArray.concat(res.map(function (point) {
            return {
              mesh: child,
              point: point
            };
          }));
        }
      }

      if (eventMode && !_this3.pointerChildren) {
        return TRAVERSE_STOP_CHILDREN;
      }

      return false;
    });

    if (resArray.length) {
      if (sort) {
        ray.sortPoints(resArray, 'point');
      }

      return resArray;
    }

    return null;
  },

  /**
   * 元素的矩阵
   * @type {Matrix4Notifier}
   * @readOnly
   */
  matrix: {
    get: function get() {
      this.updateMatrix();
      return this._matrix;
    },
    set: function set(value) {
      utils_log.warnOnce('Node.matrix.set', 'node.matrix is readOnly.Use node.matrix.copy instead.');

      this._matrix.copy(value);
    }
  },

  /**
   * 位置
   * @type {Vector3Notifier}
   * @readOnly
   */
  position: {
    get: function get() {
      return this._position;
    },
    set: function set(value) {
      utils_log.warnOnce('Node.position.set', 'node.position is readOnly.Use node.position.copy instead.');

      this._position.copy(value);
    }
  },

  /**
   * x轴坐标
   * @type {number}
   */
  x: {
    get: function get() {
      return this._position.elements[0];
    },
    set: function set(value) {
      this._position.elements[0] = value;
      this._matrixDirty = true;
    }
  },

  /**
   * y轴坐标
   * @type {number}
   */
  y: {
    get: function get() {
      return this._position.elements[1];
    },
    set: function set(value) {
      this._position.elements[1] = value;
      this._matrixDirty = true;
    }
  },

  /**
   * z轴坐标
   * @type {number}
   */
  z: {
    get: function get() {
      return this._position.elements[2];
    },
    set: function set(value) {
      this._position.elements[2] = value;
      this._matrixDirty = true;
    }
  },

  /**
   * 缩放
   * @type {Vector3Notifier}
   * @readOnly
   */
  scale: {
    get: function get() {
      return this._scale;
    },
    set: function set(value) {
      utils_log.warnOnce('Node.scale.set', 'node.scale is readOnly.Use node.scale.copy instead.');

      this._scale.copy(value);
    }
  },

  /**
   * 缩放比例x
   * @type {number}
   */
  scaleX: {
    get: function get() {
      return this._scale.elements[0];
    },
    set: function set(value) {
      this._scale.elements[0] = value;
      this._matrixDirty = true;
    }
  },

  /**
   * 缩放比例y
   * @type {number}
   */
  scaleY: {
    get: function get() {
      return this._scale.elements[1];
    },
    set: function set(value) {
      this._scale.elements[1] = value;
      this._matrixDirty = true;
    }
  },

  /**
   * 缩放比例z
   * @type {number}
   */
  scaleZ: {
    get: function get() {
      return this._scale.elements[2];
    },
    set: function set(value) {
      this._scale.elements[2] = value;
      this._matrixDirty = true;
    }
  },

  /**
   * 中心点
   * @type {Vector3Notifier}
   * @readOnly
   */
  pivot: {
    get: function get() {
      return this._pivot;
    },
    set: function set(value) {
      utils_log.warnOnce('Node.pivot.set', 'node.pivot is readOnly.Use node.pivot.copy instead.');

      this._pivot.copy(value);
    }
  },

  /**
   * 中心点x
   * @type {Number}
   */
  pivotX: {
    get: function get() {
      return this._pivot.elements[0];
    },
    set: function set(value) {
      this._pivot.elements[0] = value;
      this._matrixDirty = true;
    }
  },

  /**
   * 中心点y
   * @type {Number}
   */
  pivotY: {
    get: function get() {
      return this._pivot.elements[1];
    },
    set: function set(value) {
      this._pivot.elements[1] = value;
      this._matrixDirty = true;
    }
  },

  /**
   * 中心点z
   * @type {Number}
   */
  pivotZ: {
    get: function get() {
      return this._pivot.elements[2];
    },
    set: function set(value) {
      this._pivot.elements[2] = value;
      this._matrixDirty = true;
    }
  },

  /**
   * 欧拉角
   * @type {EulerNotifier}
   * @readOnly
   */
  rotation: {
    get: function get() {
      return this._rotation;
    },
    set: function set(value) {
      utils_log.warnOnce('Node.rotation.set', 'node.rotation is readOnly.Use node.rotation.copy instead.');

      this._rotation.copy(value);
    }
  },

  /**
   * 旋转角度 x, 角度制
   * @type {number}
   */
  rotationX: {
    get: function get() {
      return this._rotation.degX;
    },
    set: function set(value) {
      this._rotation.degX = value;
    }
  },

  /**
   * 旋转角度 y, 角度制
   * @type {number}
   */
  rotationY: {
    get: function get() {
      return this._rotation.degY;
    },
    set: function set(value) {
      this._rotation.degY = value;
    }
  },

  /**
   * 旋转角度 z, 角度制
   * @type {number}
   */
  rotationZ: {
    get: function get() {
      return this._rotation.degZ;
    },
    set: function set(value) {
      this._rotation.degZ = value;
    }
  },

  /**
   * 四元数角度
   * @type {Quaternion}
   */
  quaternion: {
    get: function get() {
      this.updateQuaternion();
      return this._quaternion;
    },
    set: function set(value) {
      utils_log.warnOnce('Node.quaternion.set', 'node.quaternion is readOnly.Use node.quaternion.copy instead.');

      this._quaternion.copy(value);
    }
  },
  matrixVersion: 0,

  /**
   * 获取元素的包围盒信息
   *
   * @param {Node} [parent] 元素相对于哪个祖先元素的包围盒，不传表示世界
   * @param {Matrix4} [currentMatrix] 当前计算的矩阵
   * @param {Bounds} [bounds] 当前计算的包围盒信息
   * @return {Bounds} 返回计算的包围盒信息
   */
  getBounds: function getBounds(parent, currentMatrix, bounds) {
    if (!currentMatrix) {
      currentMatrix = this.getConcatenatedMatrix(parent);
    } else {
      currentMatrix.multiply(this.matrix);
    }

    this.children.forEach(function (child) {
      bounds = child.getBounds(null, currentMatrix.clone(), bounds);
    });

    if (this.isMesh) {
      bounds = this.geometry.getBounds(currentMatrix, bounds);
    }

    return bounds;
  },

  /**
   * 冒泡鼠标事件
   * @param {Object} event
   * @private
   */
  _fireMouseEvent: function _fireMouseEvent(event) {
    event.eventCurrentTarget = this;
    this.fire(event); // 处理mouseover事件 mouseover不需要阻止冒泡
    // handle mouseover event, mouseover needn't stop propagation.

    if (event.type === 'mousemove') {
      if (!this.__mouseOver) {
        this.__mouseOver = true;
        var overEvent = Object.assign({}, event);
        overEvent.type = 'mouseover';
        this.fire(overEvent);
      }
    } else if (event.type === 'mouseout') {
      this.__mouseOver = false;
    } // 向上冒泡
    // handle event propagation


    var parent = this.parent;

    if (!event._stopped && !event._stopPropagationed && parent) {
      parent._fireMouseEvent(event);
    }
  },

  /**
   * 销毁 Node 资源
   * @param {WebGLRenderer} [renderer] stage时可以不传
   * @param {Boolean} [destroyTextures=false] 是否销毁材质的贴图，默认不销毁
   * @return {Node} this
   */
  destroy: function destroy(renderer) {
    var destroyTextures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var nodes = this.getChildrenByBaseClassName('Node');
    this.off();
    nodes.forEach(function (node) {
      if (node.isMesh) {
        node.destroy(renderer, destroyTextures);
      } else {
        node.off();
        node.removeFromParent();
      }
    });
    this.removeFromParent();
    return this;
  },
  _onMatrixUpdate: function _onMatrixUpdate() {
    this.matrixVersion++;
    this.updateTransform();
  },
  _onPositionUpdate: function _onPositionUpdate() {
    this._matrixDirty = true;
  },
  _onScaleUpdate: function _onScaleUpdate() {
    this._matrixDirty = true;
  },
  _onPivotUpdate: function _onPivotUpdate() {
    this._matrixDirty = true;
  },
  _onRotationUpdate: function _onRotationUpdate() {
    this._quatDirty = true;
    this._matrixDirty = true;
  },
  _onQuaternionUpdate: function _onQuaternionUpdate() {
    this._rotation.fromQuat(this._quaternion);

    this._quatDirty = false;
  }
});
/* harmony default export */ var core_Node = (Node);
/**
 * 包围盒信息
 * @typedef {object} Bounds
 * @property {number} x 包围盒中心的X坐标
 * @property {number} y 包围盒中心的Y坐标
 * @property {number} z 包围盒中心的Z坐标
 * @property {number} width 包围盒的宽度
 * @property {number} height 包围盒的高度
 * @property {number} depth 包围盒的深度
 * @property {number} xMin X轴的最小值
 * @property {number} xMax X轴的最大值
 * @property {number} yMin Y轴的最小值
 * @property {number} yMax Y轴的最大值
 * @property {number} zMin Z轴的最小值
 * @property {number} zMax Z轴的最大值
 */

/**
 * 碰撞信息
 * @typedef {object} raycastInfo
 * @property {Mesh} mesh 碰撞的 mesh
 * @property {Vector3} point 碰撞得点
 */

/**
 * Node traverse 回调
 * @callback NodeTraverseCallback
 * @param {Node} node
 * @return {any} Node.TRAVERSE_STOP_NONE | Node.TRAVERSE_STOP_CHILDREN | Node.TRAVERSE_STOP_ALL
 */

/**
 * Node getChildByCallback 回调
 * @callback NodeGetChildByCallback
 * @param {Node} node
 * @return {boolean}
 */
// CONCATENATED MODULE: ./src/math/Vector4.js


/**
 * 四维向量
 * @class
 */

var Vector4 = core_Class.create(
/** @lends Vector4.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Vector4
   */
  className: 'Vector4',

  /**
   * @type {Boolean}
   * @default true
   */
  isVector4: true,

  /**
   * Creates a new empty vec4
   * @param {Number} [x=0] X component
   * @param {Number} [y=0] Y component
   * @param {Number} [z=0] Z component
   * @param {Number} [w=0] W component
   * @constructs
   */
  constructor: function constructor() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    /**
     * 数据
     * @type {Float32Array}
     */
    this.elements = gl_matrix_min["vec4"].fromValues(x, y, z, w);
  },

  /**
   * Copy the values from one vec4 to this
   * @param  {Vector4} m the source vector
   * @return {Vector4} this
   */
  copy: function copy(v) {
    gl_matrix_min["vec4"].copy(this.elements, v.elements);
    return this;
  },

  /**
   * Creates a new vec4 initialized with values from this vector
   * @return {Vector4} a new Vector4
   */
  clone: function clone() {
    var elements = this.elements;
    return new this.constructor(elements[0], elements[1], elements[2], elements[3]);
  },

  /**
   * 转换到数组
   * @param  {Array}  [array=[]] 数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Array}
   */
  toArray: function toArray() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;
    array[0 + offset] = elements[0];
    array[1 + offset] = elements[1];
    array[2 + offset] = elements[2];
    array[3 + offset] = elements[3];
    return array;
  },

  /**
   * 从数组赋值
   * @param  {Array} array  数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {this}
   */
  fromArray: function fromArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;
    elements[0] = array[offset + 0];
    elements[1] = array[offset + 1];
    elements[2] = array[offset + 2];
    elements[3] = array[offset + 3];
    return this;
  },

  /**
   * Set the components of a vec4 to the given values
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {Vector4} this
   */
  set: function set(x, y, z, w) {
    gl_matrix_min["vec4"].set(this.elements, x, y, z, w);
    return this;
  },

  /**
   * Adds two vec4's
   * @param {Vector4} a
   * @param {Vector4} [b] 如果不传，计算 this 和 a 的和
   * @returns {Vector4} this
   */
  add: function add(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec4"].add(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Subtracts vector b from vector a
   * @param {Vector4} a
   * @param {Vector4} [b] 如果不传，计算 this 和 a 的差
   * @returns {Vector4} this
   */
  subtract: function subtract(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec4"].subtract(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Multiplies two vec4's
   * @param {Vector4} a
   * @param {Vector4} [b] 如果不传，计算 this 和 a 的积
   * @returns {Vector4} this
   */
  multiply: function multiply(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec4"].multiply(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Divides two vec4's
   * @param {Vector4} a
   * @param {Vector4} [b] 如果不传，计算 this 和 a 的商
   * @returns {Vector4} this
   */
  divide: function divide(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec4"].divide(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Math.ceil the components of this
   * @returns {Vector4} this
   */
  ceil: function ceil() {
    gl_matrix_min["vec4"].ceil(this.elements, this.elements);
    return this;
  },

  /**
   * Math.floor the components of this
   * @returns {Vector4} this
   */
  floor: function floor() {
    gl_matrix_min["vec4"].floor(this.elements, this.elements);
    return this;
  },

  /**
   * Returns the minimum of two vec4's
   * @param  {Vector4} a
   * @param  {Vector4} [b] 如果不传，计算 this 和 a 的结果
   * @returns {Vector4} this
   */
  min: function min(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec4"].min(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Returns the maximum of two vec4's
   * @param  {Vector4} a
   * @param  {Vector4} [b]  如果不传，计算 this 和 a 的结果
   * @returns {Vector4} this
   */
  max: function max(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec4"].max(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Math.round the components of this
   * @returns {Vector4} this
   */
  round: function round() {
    gl_matrix_min["vec4"].round(this.elements, this.elements);
    return this;
  },

  /**
   * Scales this by a scalar number
   * @param  {Number} scale amount to scale the vector by
   * @returns {Vector4} this
   */
  scale: function scale(_scale) {
    gl_matrix_min["vec4"].scale(this.elements, this.elements, _scale);
    return this;
  },

  /**
   * Adds two vec4's after scaling the second vector by a scalar value
   * @param  {Number} scale the amount to scale the second vector by before adding
   * @param  {Vector4} a
   * @param  {Vector4} [b] 如果不传，计算 this 和 a 的结果
   * @returns {Vector4} this
   */
  scaleAndAdd: function scaleAndAdd(scale, a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec4"].scaleAndAdd(this.elements, a.elements, b.elements, scale);
    return this;
  },

  /**
   * Calculates the euclidian distance between two vec4's
   * @param  {Vector4} a
   * @param  {Vector4} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number} distance between a and b
   */
  distance: function distance(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec4"].distance(a.elements, b.elements);
  },

  /**
   * Calculates the squared euclidian distance between two vec4's
   * @param  {Vector4} a
   * @param  {Vector4} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number} squared distance between a and b
   */
  squaredDistance: function squaredDistance(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec4"].squaredDistance(a.elements, b.elements);
  },

  /**
   * Calculates the length of this
   * @return {Number} length of this
   */
  length: function length() {
    return gl_matrix_min["vec4"].length(this.elements);
  },

  /**
   * Calculates the squared length of this
   * @return {Number} squared length of this
   */
  squaredLength: function squaredLength() {
    return gl_matrix_min["vec4"].squaredLength(this.elements);
  },

  /**
   * Negates the components of this
   * @returns {Vector4} this
   */
  negate: function negate() {
    gl_matrix_min["vec4"].negate(this.elements, this.elements);
    return this;
  },

  /**
   * Returns the inverse of the components of a vec4
   * @param  {Vector4} [a=this]
   * @returns {Vector4} this
   */
  inverse: function inverse(a) {
    if (!a) {
      a = this;
    }

    gl_matrix_min["vec4"].inverse(this.elements, a.elements);
    return this;
  },

  /**
   * Normalize this
   * @returns {Vector4} this
   */
  normalize: function normalize() {
    gl_matrix_min["vec4"].normalize(this.elements, this.elements);
    return this;
  },

  /**
   * Calculates the dot product of two vec4's
   * @param  {Vector4} a
   * @param  {Vector4} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number}  product of a and b
   */
  dot: function dot(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec4"].dot(a.elements, b.elements);
  },

  /**
   * Performs a linear interpolation between two vec4's
   * @param  {Vector4} v
   * @param  {Number} t interpolation amount between the two vectors
   * @returns {Vector4} this
   */
  lerp: function lerp(v, t) {
    gl_matrix_min["vec4"].lerp(this.elements, this.elements, v.elements, t);
    return this;
  },

  /**
   * Generates a random vector with the given scale
   * @param  {Number} [scale=1] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {Vector4} this
   */
  random: function random(scale) {
    scale = scale || 1;
    this.elements[0] = Math.random();
    this.elements[1] = Math.random();
    this.elements[2] = Math.random();
    this.elements[3] = Math.random();
    this.normalize();
    this.scale(scale);
    return this;
  },

  /**
   * Transforms the vec4 with a mat4
   * @param  {Matrix4} m matrix to transform with
   * @returns {Vector4} this
   */
  transformMat4: function transformMat4(m) {
    gl_matrix_min["vec4"].transformMat4(this.elements, this.elements, m.elements);
    return this;
  },

  /**
   * Transforms the vec4 with a quat
   * @param  {Quaternion} q quaternion to transform with
   * @returns {Vector4} this
   */
  transformQuat: function transformQuat(q) {
    gl_matrix_min["vec4"].transformQuat(this.elements, this.elements, q.elements);
    return this;
  },

  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @param  {Vector4} a
   * @param  {Vector4} [b] 如果不传，计算 this 和 a 的结果
   * @return {Boolean} True if the vectors are equal, false otherwise.
   */
  exactEquals: function exactEquals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec4"].exactEquals(a.elements, b.elements);
  },

  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @param  {Vector4} a
   * @param  {Vector4} [b] 如果不传，计算 this 和 a 的结果
   * @return {Boolean} True if the vectors are equal, false otherwise.
   */
  equals: function equals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec4"].equals(a.elements, b.elements);
  },

  /**
   * X component
   * @type {Number}
   */
  x: {
    get: function get() {
      return this.elements[0];
    },
    set: function set(value) {
      this.elements[0] = value;
    }
  },

  /**
   * Y component
   * @type {Number}
   */
  y: {
    get: function get() {
      return this.elements[1];
    },
    set: function set(value) {
      this.elements[1] = value;
    }
  },

  /**
   * Z component
   * @type {Number}
   */
  z: {
    get: function get() {
      return this.elements[2];
    },
    set: function set(value) {
      this.elements[2] = value;
    }
  },

  /**
   * W component
   * @type {Number}
   */
  w: {
    get: function get() {
      return this.elements[3];
    },
    set: function set(value) {
      this.elements[3] = value;
    }
  }
});
/**
 * Alias for {@link Vector4#subtract}
 * @function
 */

Vector4.prototype.sub = Vector4.prototype.subtract;
/**
 * Alias for {@link Vector4#multiply}
 * @function
 */

Vector4.prototype.mul = Vector4.prototype.multiply;
/**
 * Alias for {@link Vector4#divide}
 * @function
 */

Vector4.prototype.div = Vector4.prototype.divide;
/**
 * Alias for {@link Vector4#distance}
 * @function
 */

Vector4.prototype.dist = Vector4.prototype.distance;
/**
 * Alias for {@link Vector4#squaredDistance}
 * @function
 */

Vector4.prototype.sqrDist = Vector4.prototype.squaredDistance;
/**
 * Alias for {@link Vector4#length}
 * @function
 */

Vector4.prototype.len = Vector4.prototype.length;
/**
 * Alias for {@link Vector4#squaredLength}
 * @function
 */

Vector4.prototype.sqrLen = Vector4.prototype.squaredLength;
/* harmony default export */ var math_Vector4 = (Vector4);
// CONCATENATED MODULE: ./src/math/Color.js



/**
 * 颜色类
 * @class
 * @extends Vector4
 */

var Color = core_Class.create(
/** @lends Color.prototype */
{
  Extends: math_Vector4,

  /**
   * 类名
   * @type {String}
   * @default Color
   */
  className: 'Color',

  /**
   * @type {Boolean}
   * @default true
   */
  isColor: true,

  /**
   * r
   * @type {Number}
   */
  r: {
    get: function get() {
      return this.x;
    },
    set: function set(v) {
      this.x = v;
    }
  },

  /**
   * g
   * @type {Number}
   */
  g: {
    get: function get() {
      return this.y;
    },
    set: function set(v) {
      this.y = v;
    }
  },

  /**
   * b
   * @type {Number}
   */
  b: {
    get: function get() {
      return this.z;
    },
    set: function set(v) {
      this.z = v;
    }
  },

  /**
   * a
   * @type {Number}
   */
  a: {
    get: function get() {
      return this.w;
    },
    set: function set(v) {
      this.w = v;
    }
  },

  /**
   * @constructs
   * @param  {Number} [r=1]
   * @param  {Number} [g=1]
   * @param  {Number} [b=1]
   * @param  {Number} [a=1]
   */
  constructor: function constructor() {
    var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    Color.superclass.constructor.call(this, r, g, b, a);
  },

  /**
   * 转换到数组
   * @param  {Array}  [array=[]] 转换到的数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Array}
   */
  toRGBArray: function toRGBArray() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var el = this.elements;
    array[offset] = el[0];
    array[offset + 1] = el[1];
    array[offset + 2] = el[2];
    return array;
  },

  /**
   * 从数组赋值
   * @param  {Array} array 数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Color}
   */
  fromUintArray: function fromUintArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    this.elements[0] = array[offset] / 255;
    this.elements[1] = array[offset + 1] / 255;
    this.elements[2] = array[offset + 2] / 255;
    this.elements[3] = array[offset + 3] / 255;
    return this;
  },

  /**
   * 从十六进制值赋值
   * @param  {String|Number} hex 颜色的十六进制值，可以以下形式："#ff9966", "ff9966", "#f96", "f96", 0xff9966
   * @return {Color}
   */
  fromHEX: function fromHEX(hex) {
    if (typeof hex === 'number') {
      hex = padLeft(hex.toString(16), 6);
    } else {
      if (hex[0] === '#') {
        hex = hex.slice(1);
      }

      if (hex.length === 3) {
        hex = hex.replace(/(\w)/g, '$1$1');
      }
    }

    this.elements[0] = parseInt(hex.slice(0, 2), 16) / 255;
    this.elements[1] = parseInt(hex.slice(2, 4), 16) / 255;
    this.elements[2] = parseInt(hex.slice(4, 6), 16) / 255;
    return this;
  },

  /**
   * 转16进制
   * @return {String}
   */
  toHEX: function toHEX() {
    var hex = '';

    for (var i = 0; i < 3; i++) {
      hex += padLeft(Math.floor(this.elements[i] * 255).toString(16), 2);
    }

    return hex;
  }
});
/* harmony default export */ var math_Color = (Color);
// CONCATENATED MODULE: ./src/light/Light.js



var tempColor = new math_Color();
/**
 * 灯光基础类
 * @class
 * @extends Node
 */

var Light = core_Class.create(
/** @lends Light.prototype */
{
  Extends: core_Node,
  isLight: true,
  className: 'Light',

  /**
   * 光强度
   * @type {Number}
   * @default 1
   */
  amount: 1,

  /**
   * 是否开启灯光
   * @type {Boolean}
   * @default true
   */
  enabled: true,

  /**
   * 光常量衰减值, PointLight 和 SpotLight 时生效
   * @type {Number}
   * @default 1
   */
  constantAttenuation: 1,

  /**
   * 光线性衰减值, PointLight 和 SpotLight 时生效
   * @type {Number}
   * @default 0
   */
  linearAttenuation: 0,

  /**
   * 光二次衰减值, PointLight 和 SpotLight 时生效
   * @type {Number}
   * @default 0
   */
  quadraticAttenuation: 0,
  _range: 0,

  /**
   * 光照范围, PointLight 和 SpotLight 时生效, 0 时代表光照范围无限大。
   * @type {Number}
   * @default 0
   */
  range: {
    get: function get() {
      return this._range;
    },
    set: function set(value) {
      this.constantAttenuation = 1;

      if (value <= 0) {
        this.linearAttenuation = 0;
        this.quadraticAttenuation = 0;
      } else {
        this.linearAttenuation = 4.5 / value;
        this.quadraticAttenuation = 75 / (value * value);
      }

      this._range = value;
    }
  },

  /**
   * 阴影生成参数，默认不生成阴影
   * @default null
   * @type {object}
   * @property {boolean} [debug=false] 是否显示生成的阴影贴图
   * @property {number} [width=render.width] 阴影贴图的宽，默认为画布宽
   * @property {number} [height=render.height] 阴影贴图的高，默认为画布高
   * @property {number} [maxBias=0.05] depth最大差值，实际的bias为max(maxBias * (1 - dot(normal, lightDir)), minBias)
   * @property {number} [minBias=0.005] depth最小差值
   * @property {Object} [cameraInfo=null] 阴影摄像机信息，没有会根据当前相机自动计算
   */
  shadow: null,

  /**
   * @constructs
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    /**
     * 灯光颜色
     * @default new Color(1, 1, 1)
     * @type {Color}
     */
    this.color = new math_Color(1, 1, 1);
    Light.superclass.constructor.call(this, params);
  },

  /**
   * 获取光范围信息, PointLight 和 SpotLight 时生效
   * @param  {Array} out  信息接受数组
   * @param  {Number} offset 偏移值
   */
  toInfoArray: function toInfoArray(out, offset) {
    out[offset + 0] = this.constantAttenuation;
    out[offset + 1] = this.linearAttenuation;
    out[offset + 2] = this.quadraticAttenuation;
    return this;
  },
  getRealColor: function getRealColor() {
    return tempColor.copy(this.color).scale(this.amount);
  },

  /**
   * 生成阴影贴图，支持阴影的子类需要重写
   * @param  {WebGLRenderer} renderer
   * @param  {Camera} camera
   */
  createShadowMap: function createShadowMap(renderer, camera) {// eslint-disable-line no-unused-vars
  }
});
/* harmony default export */ var light_Light = (Light);
// CONCATENATED MODULE: ./src/math/Plane.js


/**
 * 平面
 * @class
 */

var Plane = core_Class.create(
/** @lends Plane.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Plane
   */
  className: 'Plane',

  /**
   * @type {Boolean}
   * @default true
   */
  isPlane: true,

  /**
   * @constructs
   * @param  {Vector3} [normal=new Vector3]   法线
   * @param  {Number}  [distance=0] 距离
   */
  constructor: function constructor() {
    var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new math_Vector3();
    var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    this.normal = normal;
    this.distance = distance;
  },

  /**
   * Copy the values from one plane to this
   * @param  {Plane} m the source plane
   * @return {Plane} this
   */
  copy: function copy(plane) {
    this.normal.copy(plane.normal);
    this.distance = plane.distance;
    return this;
  },

  /**
   * Creates a new plane initialized with values from this plane
   * @return {Plane} a new Plane
   */
  clone: function clone() {
    return new this.constructor(this.normal.clone(), this.distance);
  },

  /**
   * [set description]
   * @param {Number} x 法线 x
   * @param {Number} y 法线 y
   * @param {Number} z 法线 z
   * @param {Number} w 距离
   * @return {Plane} this
   */
  set: function set(x, y, z, w) {
    this.normal.set(x, y, z);
    this.distance = w;
    return this;
  },

  /**
   * 归一化
   * @return {Plane} this
   */
  normalize: function normalize() {
    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.scale(inverseNormalLength);
    this.distance *= inverseNormalLength;
    return this;
  },

  /**
   * 与点的距离
   * @param  {Vector3} point
   * @return {Number}
   */
  distanceToPoint: function distanceToPoint(point) {
    return this.normal.dot(point) + this.distance;
  },

  /**
   * 投影点
   * @param  {Vector3} point
   * @return {Vector3}
   */
  projectPoint: function projectPoint(point) {
    return new math_Vector3().copy(this.normal).scale(-this.distanceToPoint(point)).add(point);
  }
});
/* harmony default export */ var math_Plane = (Plane);
// CONCATENATED MODULE: ./src/math/Frustum.js


/**
 * 平截头体
 * @class
 */

var Frustum = core_Class.create(
/** @lends Frustum.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Frustum
   */
  className: 'Frustum',

  /**
   * @type {Boolean}
   * @default true
   */
  isFrustum: true,

  /**
   * @constructs
   */
  constructor: function constructor() {
    this.planes = [];
    var num = 6;

    while (num--) {
      this.planes.push(new math_Plane());
    }
  },

  /**
   * Copy the values from one frustum to this
   * @param  {Frustum} m the source frustum
   * @return {Frustum} this
   */
  copy: function copy(frustum) {
    var planes = frustum.planes;
    this.planes.forEach(function (plane, index) {
      plane.copy(planes[index]);
    });
    return this;
  },

  /**
   * Creates a new frustum initialized with values from this frustum
   * @return {Frustum} a new Frustum
   */
  clone: function clone() {
    var frustum = new this.constructor();
    frustum.copy(this);
    return frustum;
  },

  /**
   * fromMatrix
   * @param  {Matrix4} mat
   * @return {Frustum}  this
   */
  fromMatrix: function fromMatrix(mat) {
    // Based on https://github.com/mrdoob/three.js/blob/dev/src/math/Frustum.js#L63
    var planes = this.planes;
    var me = mat.elements;
    var me0 = me[0];
    var me1 = me[1];
    var me2 = me[2];
    var me3 = me[3];
    var me4 = me[4];
    var me5 = me[5];
    var me6 = me[6];
    var me7 = me[7];
    var me8 = me[8];
    var me9 = me[9];
    var me10 = me[10];
    var me11 = me[11];
    var me12 = me[12];
    var me13 = me[13];
    var me14 = me[14];
    var me15 = me[15];
    planes[0].set(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].set(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].set(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].set(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].set(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].set(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },

  /**
   * 与球体相交
   * @param  {Sphere} sphere
   * @return {Boolean} 是否相交
   */
  intersectsSphere: function intersectsSphere(sphere) {
    var planes = this.planes;
    var center = sphere.center;
    var negRadius = -sphere.radius;

    for (var i = 0; i < 6; i++) {
      var distance = planes[i].distanceToPoint(center);

      if (distance < negRadius) {
        return false;
      }
    }

    return true;
  }
});
/* harmony default export */ var math_Frustum = (Frustum);
// CONCATENATED MODULE: ./src/camera/Camera.js




var Camera_tempMatrix4 = new math_Matrix4();
/**
 * 摄像机
 * @class
 * @extends Node
 */

var Camera = core_Class.create(
/** @lends Camera.prototype */
{
  Extends: core_Node,

  /**
   * @default true
   * @type {boolean}
   */
  isCamera: true,

  /**
   * @default Camera
   * @type {string}
   */
  className: 'Camera',

  /**
   * 是否需要更新投影矩阵
   * @private
   * @default true
   * @type {Boolean}
   */
  _needUpdateProjectionMatrix: true,
  _isGeometryDirty: false,

  /**
   * @constructs
   * @param {object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    /**
     * 相对于摄像头的矩阵
     * @type {Matrix4}
     */
    this.viewMatrix = new math_Matrix4();
    /**
     * 投影矩阵
     * @type {Matrix4}
     */

    this.projectionMatrix = new math_Matrix4();
    /**
     * View 联结投影矩阵
     * @type {Matrix4}
     */

    this.viewProjectionMatrix = new math_Matrix4();
    this._frustum = new math_Frustum();
    Camera.superclass.constructor.call(this, params);
  },

  /**
   * 更新viewMatrix
   * @return {Camera} this
   */
  updateViewMatrix: function updateViewMatrix() {
    this.updateMatrixWorld(true);
    this.viewMatrix.invert(this.worldMatrix);
    return this;
  },

  /**
   * 更新投影矩阵，子类必须重载这个方法
   */
  updateProjectionMatrix: function updateProjectionMatrix() {},

  /**
   * 获取几何体，子类必须重写
   * @param  {Boolean} forceUpdate 是否强制更新
   * @return {Geometry}
   */
  getGeometry: function getGeometry(forceUpdate) {// eslint-disable-line no-unused-vars
  },

  /**
   * 更新viewProjectionMatrix
   * @return {Camera} this
   */
  updateViewProjectionMatrix: function updateViewProjectionMatrix() {
    if (this._needUpdateProjectionMatrix) {
      this.updateProjectionMatrix();
      this._needUpdateProjectionMatrix = false;
    }

    this.updateViewMatrix();
    this.viewProjectionMatrix.multiply(this.projectionMatrix, this.viewMatrix);
    this.updateFrustum(this.viewProjectionMatrix);
    return this;
  },

  /**
   * 获取元素相对于当前Camera的矩阵
   * @param {Node} node 目标元素
   * @param {Matrix4} [out] 传递将在这个矩阵上做计算，不传将创建一个新的 Matrix4
   * @return {Matrix4} 返回获取的矩阵
   */
  getModelViewMatrix: function getModelViewMatrix(node, out) {
    out = out || new math_Matrix4();
    out.multiply(this.viewMatrix, node.worldMatrix);
    return out;
  },

  /**
   * 获取元素的投影矩阵
   * @param {Node} node 目标元素
   * @param {Matrix4} [out] 传递将在这个矩阵上做计算，不传将创建一个新的 Matrix4
   * @return {Matrix4} 返回获取的矩阵
   */
  getModelProjectionMatrix: function getModelProjectionMatrix(node, out) {
    out = out || new math_Matrix4();
    out.multiply(this.viewProjectionMatrix, node.worldMatrix);
    return out;
  },

  /**
   * 获取世界坐标系(三维)中一个点在画布(二维)上的位置
   * @param {Vector3} vector 点坐标
   * @param {number} [width] 画布宽，不传的话返回-1~1
   * @param {number} [height] 画布高，不传的话返回-1~1
   * @return {Vector3} 返回获取的坐标位置，如 { x: 0, y: 0 }
   */
  projectVector: function projectVector(vector, width, height) {
    var result = vector.clone();
    result.transformMat4(this.viewProjectionMatrix);

    if (width && height) {
      result.x = (result.x + 1) / 2 * width;
      result.y = height - (result.y + 1) / 2 * height;
    }

    return result;
  },

  /**
   * 屏幕坐标转换世界坐标系
   * @param {Vector3} vector 点坐标
   * @param {number} [width] 画布宽，传的话vector会认为是屏幕坐标
   * @param {number} [height] 画布高，传的话vector会认为是屏幕坐标
   * @return {Vector3} 返回世界坐标系(三维)中一个点
   */
  unprojectVector: function unprojectVector(vector, width, height) {
    var result = vector.clone();

    if (width && height) {
      result.x = result.x / width * 2 - 1;
      result.y = 1 - result.y / height * 2;
    }

    Camera_tempMatrix4.invert(this.viewProjectionMatrix);
    result.transformMat4(Camera_tempMatrix4);
    return result;
  },

  /**
   * point是否摄像机可见
   * @param  {Vector3}  point
   * @return {Boolean}
   */
  isPointVisible: function isPointVisible(point) {
    var isPointInFrustum = this._frustum.intersectsSphere({
      center: point,
      radius: 0
    });

    if (isPointInFrustum) {
      return true;
    }

    return false;
  },

  /**
   * mesh 是否摄像机可见
   * @param  {Mesh}  mesh
   * @return {Boolean}
   */
  isMeshVisible: function isMeshVisible(mesh) {
    var geometry = mesh.geometry;

    if (geometry) {
      var sphere = geometry.getSphereBounds(mesh.worldMatrix);

      if (this._frustum.intersectsSphere(sphere)) {
        return true;
      }
    }

    return false;
  },

  /**
   * 更新 frustum
   * @param  {Matrix4} matrix
   * @return {Camera} this
   */
  updateFrustum: function updateFrustum(matrix) {
    this._frustum.fromMatrix(matrix);

    return this;
  }
});
/* harmony default export */ var camera_Camera = (Camera);
// CONCATENATED MODULE: ./src/math/Vector2.js


/**
 * 二维向量
 * @class
 */

var Vector2 = core_Class.create(
/** @lends Vector2.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Vector2
   */
  className: 'Vector2',

  /**
   * @type {Boolean}
   * @default true
   */
  isVector2: true,

  /**
   * Creates a new empty vec2
   * @param {Number} [x=0] X component
   * @param {Number} [y=0] Y component
   * @constructs
   */
  constructor: function constructor() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    /**
     * 数据
     * @type {Float32Array}
     */
    this.elements = gl_matrix_min["vec2"].fromValues(x, y);
  },

  /**
   * Copy the values from one vec2 to this
   * @param  {Vector2} m the source vector
   * @return {Vector2} this
   */
  copy: function copy(v) {
    gl_matrix_min["vec2"].copy(this.elements, v.elements);
    return this;
  },

  /**
   * Creates a new vec2 initialized with values from this vector
   * @return {Vector2} a new Vector2
   */
  clone: function clone() {
    var elements = this.elements;
    return new this.constructor(elements[0], elements[1]);
  },

  /**
   * 转换到数组
   * @param  {Array}  [array=[]] 数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Array}
   */
  toArray: function toArray() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;
    array[0 + offset] = elements[0];
    array[1 + offset] = elements[1];
    return array;
  },

  /**
   * 从数组赋值
   * @param  {Array} array  数组
   * @param  {Number} [offset=0] 数组偏移值
   * @return {Vector2} this
   */
  fromArray: function fromArray(array) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var elements = this.elements;
    elements[0] = array[offset + 0];
    elements[1] = array[offset + 1];
    return this;
  },

  /**
   * Set the components of a vec4 to the given values
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {Vector2} this
   */
  set: function set(x, y) {
    gl_matrix_min["vec2"].set(this.elements, x, y);
    return this;
  },

  /**
   * Adds two vec2's
   * @param {Vector2} a
   * @param {Vector2} [b] 如果不传，计算 this 和 a 的和
   * @returns {Vector2} this
   */
  add: function add(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec2"].add(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Subtracts vector b from vector a
   * @param {Vector2} a
   * @param {Vector2} [b] 如果不传，计算 this 和 a 的差
   * @returns {Vector2} this
   */
  subtract: function subtract(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec2"].subtract(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Multiplies two vec2's
   * @param {Vector2} a
   * @param {Vector2} [b] 如果不传，计算 this 和 a 的积
   * @returns {Vector2} this
   */
  multiply: function multiply(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec2"].multiply(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Divides two vec2's
   * @param {Vector2} a
   * @param {Vector2} [b] 如果不传，计算 this 和 a 的商
   * @returns {Vector2} this
   */
  divide: function divide(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec2"].divide(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Math.ceil the components of this
   * @returns {Vector2} this
   */
  ceil: function ceil() {
    gl_matrix_min["vec2"].ceil(this.elements, this.elements);
    return this;
  },

  /**
   * Math.floor the components of this
   * @returns {Vector2} this
   */
  floor: function floor() {
    gl_matrix_min["vec2"].floor(this.elements, this.elements);
    return this;
  },

  /**
   * Returns the minimum of two vec2's
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @returns {Vector2} this
   */
  min: function min(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec2"].min(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Returns the maximum of two vec2's
   * @param  {Vector2} a
   * @param  {Vector2} [b]  如果不传，计算 this 和 a 的结果
   * @returns {Vector2} this
   */
  max: function max(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec2"].max(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Math.round the components of this
   * @returns {Vector2} this
   */
  round: function round() {
    gl_matrix_min["vec2"].round(this.elements, this.elements);
    return this;
  },

  /**
   * Scales this by a scalar number
   * @param  {Number} scale amount to scale the vector by
   * @returns {Vector2} this
   */
  scale: function scale(_scale) {
    gl_matrix_min["vec2"].scale(this.elements, this.elements, _scale);
    return this;
  },

  /**
   * Adds two vec2's after scaling the second vector by a scalar value
   * @param  {Number} scale the amount to scale the second vector by before adding
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @returns {Vector2} this
   */
  scaleAndAdd: function scaleAndAdd(scale, a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec2"].scaleAndAdd(this.elements, a.elements, b.elements, scale);
    return this;
  },

  /**
   * Calculates the euclidian distance between two vec2's
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number} distance between a and b
   */
  distance: function distance(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec2"].distance(a.elements, b.elements);
  },

  /**
   * Calculates the squared euclidian distance between two vec2's
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number} squared distance between a and b
   */
  squaredDistance: function squaredDistance(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec2"].squaredDistance(a.elements, b.elements);
  },

  /**
   * Calculates the length of this
   * @return {Number} length of this
   */
  length: function length() {
    return gl_matrix_min["vec2"].length(this.elements);
  },

  /**
   * Calculates the squared length of this
   * @return {Number} squared length of this
   */
  squaredLength: function squaredLength() {
    return gl_matrix_min["vec2"].squaredLength(this.elements);
  },

  /**
   * Negates the components of this
   * @returns {Vector2} this
   */
  negate: function negate() {
    gl_matrix_min["vec2"].negate(this.elements, this.elements);
    return this;
  },

  /**
   * Returns the inverse of the components of a vec2
   * @param  {Vector2} [a=this]
   * @returns {Vector2} this
   */
  inverse: function inverse(a) {
    if (!a) {
      a = this;
    }

    gl_matrix_min["vec2"].inverse(this.elements, a.elements);
    return this;
  },

  /**
   * Normalize this
   * @returns {Vector2} this
   */
  normalize: function normalize() {
    gl_matrix_min["vec2"].normalize(this.elements, this.elements);
    return this;
  },

  /**
   * Calculates the dot product of two vec2's
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number}  product of a and b
   */
  dot: function dot(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec2"].dot(a.elements, b.elements);
  },

  /**
   * Computes the cross product of two vec2's
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @return {Number}  cross product of a and b
   */
  cross: function cross(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    gl_matrix_min["vec2"].cross(this.elements, a.elements, b.elements);
    return this;
  },

  /**
   * Performs a linear interpolation between two vec2's
   * @param  {Vector2} v
   * @param  {Number} t interpolation amount between the two vectors
   * @returns {Vector2} this
   */
  lerp: function lerp(v, t) {
    gl_matrix_min["vec2"].lerp(this.elements, this.elements, v.elements, t);
    return this;
  },

  /**
   * Generates a random vector with the given scale
   * @param  {Number} [scale=1] Length of the resulting vector. If ommitted, a unit vector will be returned
   * @returns {Vector2} this
   */
  random: function random(scale) {
    gl_matrix_min["vec2"].random(this.elements, scale);
    return this;
  },

  /**
   * Transforms the vec2 with a mat3
   * @param  {Matrix3} m matrix to transform with
   * @returns {Vector2} this
   */
  transformMat3: function transformMat3(m) {
    gl_matrix_min["vec2"].transformMat3(this.elements, this.elements, m.elements);
    return this;
  },

  /**
   * Transforms the vec2 with a mat4
   * @param  {Matrix4} m matrix to transform with
   * @returns {Vector2} this
   */
  transformMat4: function transformMat4(m) {
    gl_matrix_min["vec2"].transformMat4(this.elements, this.elements, m.elements);
    return this;
  },

  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @return {Boolean} True if the vectors are equal, false otherwise.
   */
  exactEquals: function exactEquals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec2"].exactEquals(a.elements, b.elements);
  },

  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @param  {Vector2} a
   * @param  {Vector2} [b] 如果不传，计算 this 和 a 的结果
   * @return {Boolean} True if the vectors are equal, false otherwise.
   */
  equals: function equals(a, b) {
    if (!b) {
      b = a;
      a = this;
    }

    return gl_matrix_min["vec2"].equals(a.elements, b.elements);
  },

  /**
   * X component
   * @type {Number}
   */
  x: {
    get: function get() {
      return this.elements[0];
    },
    set: function set(value) {
      this.elements[0] = value;
    }
  },

  /**
   * Y component
   * @type {Number}
   */
  y: {
    get: function get() {
      return this.elements[1];
    },
    set: function set(value) {
      this.elements[1] = value;
    }
  }
});
/**
 * Alias for {@link Vector2#subtract}
 * @function
 */

Vector2.prototype.sub = Vector2.prototype.subtract;
/**
 * Alias for {@link Vector2#multiply}
 * @function
 */

Vector2.prototype.mul = Vector2.prototype.multiply;
/**
 * Alias for {@link Vector2#divide}
 * @function
 */

Vector2.prototype.div = Vector2.prototype.divide;
/**
 * Alias for {@link Vector2#distance}
 * @function
 */

Vector2.prototype.dist = Vector2.prototype.distance;
/**
 * Alias for {@link Vector2#squaredDistance}
 * @function
 */

Vector2.prototype.sqrDist = Vector2.prototype.squaredDistance;
/**
 * Alias for {@link Vector2#length}
 * @function
 */

Vector2.prototype.len = Vector2.prototype.length;
/**
 * Alias for {@link Vector2#squaredLength}
 * @function
 */

Vector2.prototype.sqrLen = Vector2.prototype.squaredLength;
/* harmony default export */ var math_Vector2 = (Vector2);
// CONCATENATED MODULE: ./src/math/Sphere.js


var Sphere_tempVector3 = new math_Vector3();
var Sphere = core_Class.create(
/** @lends Sphere.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Sphere
   */
  className: 'Sphere',

  /**
   * @type {Boolean}
   * @default true
   */
  isSphere: true,

  /**
   * 半径
   * @type {Number}
   * @default 0
   */
  radius: 0,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    Object.assign(this, params);

    if (!this.center) {
      this.center = new math_Vector3(0, 0, 0);
    }
  },

  /**
   * 克隆
   * @return {Sphere}
   */
  clone: function clone() {
    var sphere = new this.constructor();
    sphere.copy(this);
    return sphere;
  },

  /**
   * 复制
   * @param  {Sphere} sphere
   * @return {Sphere} this
   */
  copy: function copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },

  /**
   * 从点生成
   * @param  {Array} points
   * @return {Sphere} this
   */
  fromPoints: function fromPoints(points) {
    var center = this.center;
    var maxSquaredRadius = 0;

    for (var i = 0; i < points.length; i += 3) {
      var x = points[i] - center.x;
      var y = points[i + 1] - center.y;
      var z = points[i + 2] - center.z;
      maxSquaredRadius = Math.max(x * x + y * y + z * z, maxSquaredRadius);
    }

    this.radius = Math.sqrt(maxSquaredRadius);
    return this;
  },

  /**
   * 从点生成
   * @param  {GeometryData} geometryData
   * @return {Sphere} this
   */
  fromGeometryData: function fromGeometryData(geometryData) {
    var center = this.center;
    var maxSquaredRadius = 0;
    geometryData.traverse(function (vertexData) {
      var x = vertexData.x - center.x;
      var y = vertexData.y - center.y;
      var z = vertexData.z - center.z;
      maxSquaredRadius = Math.max(x * x + y * y + z * z, maxSquaredRadius);
    });
    this.radius = Math.sqrt(maxSquaredRadius);
    return this;
  },

  /**
   * transformMat4
   * @param  {Matrix4} mat4
   * @return {Sphere} this
   */
  transformMat4: function transformMat4(mat4) {
    this.center.transformMat4(mat4);
    var scale = mat4.getScaling(Sphere_tempVector3);
    this.radius *= Math.max(scale.x, scale.y, scale.z);
    return this;
  }
});
/* harmony default export */ var math_Sphere = (Sphere);
// CONCATENATED MODULE: ./src/geometry/GeometryData.js








var sizeVectorMap = {
  2: new math_Vector2(),
  3: new math_Vector3(),
  4: new math_Vector4(),
  16: new math_Matrix4()
};
/**
 * geometry vertex data
 * @class
 */

var GeometryData = core_Class.create(
/** @lends GeometryData.prototype */
{
  /**
   * 类名
   * @type {String}
   * @readOnly
   * @default GeometryData
   */
  className: 'GeometryData',

  /**
   * isGeometryData
   * @type {Boolean}
   * @readOnly
   * @default true
   */
  isGeometryData: true,

  /**
   * The number of components per vertex attribute.Must be 1, 2, 3, or 4.
   * @type {Number}
   */
  size: undefined,

  /**
   * Whether integer data values should be normalized when being casted to a float.
   * @type {Boolean}
   * @default false
   */
  normalized: false,

  /**
   * The data type of each component in the array.
   * @type {GLenum}
   */
  type: undefined,
  _isSubDirty: false,
  _isAllDirty: false,

  /**
   * @type {Boolean}
   * @default false
   */
  isDirty: {
    get: function get() {
      return this._isSubDirty || this._isAllDirty;
    },
    set: function set(value) {
      this._isAllDirty = value;

      if (value === false) {
        this.clearSubData();
      }
    }
  },

  /**
   * @type {String}
   */
  bufferViewId: undefined,

  /**
   * glBuffer
   * @type {Buffer}
   */
  glBuffer: null,

  /**
   * @constructs
   * @param  {TypedArray} data  数据
   * @param  {Number} size The number of components per vertex attribute.Must be 1, 2, 3, or 4.
   * @param  {Object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(data, size, params) {
    /**
     * id
     * @type {string}
     */
    this.id = math_math.generateUUID(this.className);
    /**
     * @type {TypedArray}
     */

    this.data = data;
    this.size = size;
    Object.assign(this, params);

    if (!this.bufferViewId) {
      this.bufferViewId = this.id;
    }

    if (!this.size) {
      utils_log.warn('GeometryData.constructor: geometryData must set size!', this);
    }
  },
  _stride: 0,

  /**
   * The offset in bytes between the beginning of consecutive vertex attributes.
   * @type {Number}
   * @default this.size
   */
  stride: {
    get: function get() {
      return this._stride;
    },
    set: function set(value) {
      this._stride = value;
      this.strideSize = value === 0 ? 0 : value / this.data.BYTES_PER_ELEMENT;
    }
  },
  strideSize: 0,
  _offset: 0,

  /**
   * An offset in bytes of the first component in the vertex attribute array. Must be a multiple of type.
   * @type {Number}
   * @default 0
   */
  offset: {
    get: function get() {
      return this._offset;
    },
    set: function set(value) {
      this._offset = value;
      this.offsetSize = value / this.data.BYTES_PER_ELEMENT;
    }
  },
  offsetSize: 0,

  /**
   * @type {TypedArray}
   */
  data: {
    set: function set(data) {
      if (data) {
        this._data = data;
        this.type = getTypedArrayGLType(data);
        this.stride = this._stride;
        this.offset = this._offset;
        this._isAllDirty = true;
      }
    },
    get: function get() {
      return this._data;
    }
  },

  /**
   * @type {Number}
   * @readOnly
   */
  length: {
    get: function get() {
      return this._data.length;
    }
  },

  /**
   * @type {Number}
   * @readOnly
   */
  realLength: {
    get: function get() {
      if (this.strideSize === 0) {
        return this._data.length;
      }

      return this._data.length / this.strideSize * this.size;
    }
  },

  /**
   * 获取数据大小，单位为字节
   * @return {number} 数据大小
   */
  getByteLength: function getByteLength() {
    return this._data.BYTES_PER_ELEMENT * this.realLength;
  },

  /**
   * @type {Number}
   * @readOnly
   */
  count: {
    get: function get() {
      if (this.strideSize === 0) {
        return this._data.length / this.size;
      }

      return this._data.length / this.strideSize;
    }
  },

  /**
   * 更新部分数据
   * @param {Number} offset 偏移index
   * @param {TypedArray} data 数据
   */
  setSubData: function setSubData(offset, data) {
    this._isSubDirty = true;
    this.data.set(data, offset);

    if (!this.subDataList) {
      this.subDataList = [];
    }

    var byteOffset = data.BYTES_PER_ELEMENT * offset;
    this.subDataList.push({
      byteOffset: byteOffset,
      data: data
    });
  },

  /**
   * 清除 subData
   */
  clearSubData: function clearSubData() {
    if (this.subDataList) {
      this.subDataList.length = 0;
    }

    this._isSubDirty = false;
  },

  /**
   * clone
   * @return {GeometryData}
   */
  clone: function clone() {
    var res = new GeometryData(null, 1);
    res.copy(this);
    return res;
  },

  /**
   * copy
   * @param  {GeometryData} geometryData
   */
  copy: function copy(geometryData) {
    var data = geometryData.data;
    this.data = new data.constructor(data);
    this.size = geometryData.size;
    this.stride = geometryData.stride;
    this.normalized = geometryData.normalized;
    this.type = geometryData.type;
    this.offset = geometryData.offset;
  },

  /**
   * 获取偏移值
   * @param  {Number} index
   * @return {Number}
   */
  getOffset: function getOffset(index) {
    var strideSize = this.strideSize;

    if (strideSize === 0) {
      return index * this.size;
    }

    return index * strideSize + this.offsetSize;
  },

  /**
   * Get the value by index.
   * Please note that it will return the same reference for performance reasons. If you want to get a copy, use #getCopy instead.
   * @param  {Number} index
   * @return {Number|Vector2|Vector3|Vector4}
   */
  get: function get(index) {
    var offset = this.getOffset(index);
    return this.getByOffset(offset);
  },

  /**
   * Get the value by index.
   * It will return a copy of value.
   * @param  {Number} index
   * @return {Number|Vector2|Vector3|Vector4}
   */
  getCopy: function getCopy(index) {
    return this.get(index).clone();
  },

  /**
   * 设置值
   * @param {Number} index
   * @param {Number|Vector2|Vector3|Vector4} value
   */
  set: function set(index, value) {
    var offset = this.getOffset(index);
    this.setByOffset(offset, value);
    return offset;
  },

  /**
   * 根据 offset 获取值
   * @param  {Number} offset
   * @return {Number|Vector2|Vector3|Vector4}
   */
  getByOffset: function getByOffset(offset) {
    var size = this.size;

    if (size > 1) {
      var tempVector = sizeVectorMap[size];
      return tempVector.fromArray(this._data, offset);
    }

    return this._data[offset];
  },

  /**
   * 根据 offset 设置值
   * @param {Number} offset
   * @param {Number|Vector2|Vector3|Vector4} value
   */
  setByOffset: function setByOffset(offset, value) {
    var size = this.size;
    var data = this._data;

    if (size > 1) {
      value.toArray(data, offset);
    } else {
      data[offset] = value;
    }

    this._isAllDirty = true;
  },

  /**
   * 按 index 遍历
   * @param  {GeometryDataTraverseCallback} callback
   * @return {Boolean}
   */
  traverse: function traverse(callback) {
    var count = this.count;

    for (var index = 0; index < count; index++) {
      var offset = this.getOffset(index);
      var attribute = this.getByOffset(offset);

      if (callback(attribute, index, offset)) {
        return true;
      }
    }

    return false;
  },

  /**
   * 按 Component 遍历 Component
   * @param  {GeometryDataTraverseByComponentCallback} callback
   * @return {Boolean}
   */
  traverseByComponent: function traverseByComponent(callback) {
    var count = this.count;
    var size = this.size;
    var data = this._data;

    for (var index = 0; index < count; index++) {
      var offset = this.getOffset(index);
      var componentIndex = index * size;

      for (var i = 0; i < size; i++) {
        var componentOffset = offset + i;

        if (callback(data[componentOffset], componentIndex + i, componentOffset)) {
          return true;
        }
      }
    }

    return false;
  },
  merge: function merge(geometryData, transform) {
    if (geometryData.type !== this.type || geometryData.size !== this.size) {
      utils_log.warn('geometryData type or size not same, cannot merge!', this, geometryData);
      return this;
    }

    var DataClass = getTypedArrayClass(this.type);
    var length0 = this.realLength;
    var length1 = geometryData.realLength;
    var newData = new DataClass(length0 + length1);
    this.traverseByComponent(function (data, index) {
      newData[index] = data;
    });
    geometryData.traverseByComponent(function (data, index) {
      if (transform) {
        data = transform(data, index);
      }

      newData[length0 + index] = data;
    });
    this.stride = 0;
    this.offset = 0;
    this.data = newData;
    return this;
  }
});
/* harmony default export */ var geometry_GeometryData = (GeometryData);
/**
 * @callback GeometryDataTraverseCallback
 * @param {Number|Vector2|Vector3|Vector4} attribute
 * @param {Number} index
 * @param {Number} offset
 */

/**
 * @callback GeometryDataTraverseByComponentCallback
 * @param {Number} component
 * @param {Number} index
 * @param {Number} offset
 */
// CONCATENATED MODULE: ./src/geometry/Geometry.js













var TRIANGLES = src_constants.TRIANGLES,
    LINES = src_constants.LINES,
    FRONT = src_constants.FRONT,
    BACK = src_constants.BACK,
    FRONT_AND_BACK = src_constants.FRONT_AND_BACK;
var tempVector31 = new math_Vector3();
var Geometry_tempVector32 = new math_Vector3();
var tempVector33 = new math_Vector3();
var tempVector41 = new math_Vector4();
var tempVector21 = new math_Vector2();
var tempVector22 = new math_Vector2();
var tempVector23 = new math_Vector2();
var tempMatrix3 = new math_Matrix3();
var Geometry_tempMatrix4 = new math_Matrix4();
var tempQuaternion = new math_Quaternion();
/**
 * 几何体
 * @class
 * @example
 * const geometry = new Hilo3d.Geometry();
 * geometry.addFace([-0.5, -0.289, 0], [0.5, -0.289, 0], [0, 0.577, 0]);
 */

var Geometry = core_Class.create(
/** @lends Geometry.prototype */
{
  /**
   * @default true
   * @type {boolean}
   */
  isGeometry: true,

  /**
   * @default Geometry
   * @type {string}
   */
  className: 'Geometry',

  /**
   * 顶点数据
   * @default null
   * @type {GeometryData}
   */
  vertices: null,

  /**
   * uv 数据
   * @default null
   * @type {GeometryData}
   */
  uvs: null,

  /**
   * uv1 数据
   * @default null
   * @type {GeometryData}
   */
  uvs1: null,

  /**
   * color 数据
   * @default null
   * @type {GeometryData}
   */
  colors: null,

  /**
   * 顶点索引数据
   * @default null
   * @type {GeometryData}
   */
  indices: null,

  /**
   * 骨骼索引
   * @default null
   * @type {GeometryData}
   */
  skinIndices: null,

  /**
   * 骨骼权重数据
   * @default null
   * @type {GeometryData}
   */
  skinWeights: null,

  /**
   * 绘制模式
   * @default TRIANGLES
   * @type {number}
   */
  mode: TRIANGLES,

  /**
   * 是否是静态
   * @type {Boolean}
   * @default true
   */
  isStatic: true,

  /**
   * 是否需要更新
   * @type {Boolean}
   * @default true
   */
  isDirty: true,

  /**
   * 使用 aabb 碰撞检测
   * @type {Boolean}
   */
  useAABBRaycast: false,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    /**
     * id
     * @type {string}
     */
    this.id = math_math.generateUUID(this.className);
    Object.assign(this, params);
    this.currentVerticesCount = 0;
    this.currentIndicesCount = 0;
  },
  _needUpdateNormals: false,

  /**
   * 法向量数据，如果没有的话会自动生成
   * @default null
   * @type {GeometryData}
   */
  normals: {
    get: function get() {
      if (this._needUpdateNormals || !this._normals) {
        this.calculateNormals();
      }

      return this._normals;
    },
    set: function set(data) {
      this._normals = data;
      this._needUpdateNormals = false;
    }
  },
  calculateNormals: function calculateNormals() {
    var vertices = this.vertices;

    if (!vertices) {
      utils_log.warnOnce('geometry.calculateNormals', 'geometry.calculateNormals error:no vertices data.');
      return;
    }

    if (!this._normals) {
      this._normals = new geometry_GeometryData(new Float32Array(vertices.realLength), 3);
    }

    var normals = this._normals;
    var indices;

    if (this.indices) {
      indices = this.indices.data;
    } else {
      var len = vertices.length / 3;
      indices = new Array(len);

      for (var i = 0; i < len; i++) {
        indices[i] = i;
      }
    }

    var idx = 0;
    var verticesInFaceCountList = new Uint8Array(vertices.count);

    for (var _i = 0; _i < indices.length; _i += 3) {
      idx = indices[_i];
      tempVector31.copy(vertices.get(idx));
      idx = indices[_i + 1];
      Geometry_tempVector32.copy(vertices.get(idx));
      idx = indices[_i + 2];
      tempVector33.copy(vertices.get(idx));
      Geometry_tempVector32.sub(tempVector31);
      tempVector33.sub(tempVector31);
      Geometry_tempVector32.cross(tempVector33);

      for (var j = 0; j < 3; j++) {
        idx = indices[_i + j];

        if (verticesInFaceCountList[idx]) {
          var oldNormal = normals.get(idx);
          oldNormal.scale(verticesInFaceCountList[idx]);
          oldNormal.add(Geometry_tempVector32);
          oldNormal.scale(1 / (verticesInFaceCountList[idx] + 1));
          normals.set(idx, oldNormal);
        } else {
          normals.set(idx, Geometry_tempVector32);
        }

        verticesInFaceCountList[idx]++;
      }
    }

    this.isDirty = true;
    this._needUpdateNormals = false;
  },

  /**
   * 切线向量数据，如果没有的话会自动生成
   * @default null
   * @type {GeometryData}
   */
  tangents: {
    get: function get() {
      if (!this._tangents) {
        this.calculateTangents(this.uvs, '_tangents');
      }

      return this._tangents;
    },
    set: function set(data) {
      this._tangents = data;
    }
  },

  /**
   * 切线向量数据，如果没有的话会自动生成
   * @default null
   * @type {GeometryData}
   */
  tangents1: {
    get: function get() {
      if (!this._tangents1) {
        this.calculateTangents(this.uvs1, '_tangents1');
      }

      return this._tangents1;
    },
    set: function set(data) {
      this._tangents1 = data;
    }
  },
  calculateTangents: function calculateTangents(uvs, tangentsName) {
    var vertices = this.vertices;

    if (!vertices) {
      utils_log.warnOnce('geometry.calculateTangents', 'geometry.calculateTangents error:no vertices data.');
      return;
    }

    if (!this[tangentsName]) {
      this[tangentsName] = new geometry_GeometryData(new Float32Array(vertices.count * 4), 4);
    }

    var tangents = this[tangentsName];
    var indices;

    if (this.indices) {
      indices = this.indices.data;
    } else {
      var len = vertices.length / 3;
      indices = new Array(len);

      for (var i = 0; i < len; i++) {
        indices[i] = i;
      }
    }

    var idx = 0;

    for (var _i2 = 0; _i2 < indices.length; _i2 += 3) {
      idx = indices[_i2];
      tempVector31.copy(vertices.get(idx));
      tempVector21.copy(uvs.get(idx));
      idx = indices[_i2 + 1];
      Geometry_tempVector32.copy(vertices.get(idx));
      tempVector22.copy(uvs.get(idx));
      idx = indices[_i2 + 2];
      tempVector33.copy(vertices.get(idx));
      tempVector23.copy(uvs.get(idx)); // eage1

      Geometry_tempVector32.sub(tempVector31); // eage2

      tempVector33.sub(tempVector31); // deltauv1

      tempVector22.sub(tempVector21); // deltauv2

      tempVector23.sub(tempVector21);
      var f = 1 / (tempVector22.x * tempVector23.y - tempVector23.x * tempVector22.y);

      if (!Number.isFinite(f)) {
        tempVector31.x = 0;
        tempVector31.y = 0;
        tempVector31.z = 1;
      } else {
        tempVector31.x = f * (tempVector23.y * Geometry_tempVector32.x - tempVector22.y * tempVector33.x);
        tempVector31.y = f * (tempVector23.y * Geometry_tempVector32.y - tempVector22.y * tempVector33.y);
        tempVector31.z = f * (tempVector23.y * Geometry_tempVector32.z - tempVector22.y * tempVector33.z);
      }

      tempVector41.set(tempVector31.x, tempVector31.y, tempVector31.z, 1);
      tangents.set(indices[_i2], tempVector41);
      tangents.set(indices[_i2 + 1], tempVector41);
      tangents.set(indices[_i2 + 2], tempVector41);
    }

    this.isDirty = true;
  },

  /**
   * 将三角形模式转换为线框模式，即 Material 中的 wireframe
   */
  convertToLinesMode: function convertToLinesMode() {
    if (this.mode !== TRIANGLES) {
      utils_log.warn('Only support convert triangles to lines mode!');
      return;
    }

    if (!this.indices) {
      utils_log.warn('Has no indices!');
      return;
    }

    var newIndices = new Uint16Array(this.indices.length * 2);
    var data = this.indices.data;

    for (var i = 0; i < data.length; i += 3) {
      newIndices[i * 2] = data[i]; // A

      newIndices[i * 2 + 1] = data[i + 1]; // B

      newIndices[i * 2 + 2] = data[i + 1]; // B

      newIndices[i * 2 + 3] = data[i + 2]; // C

      newIndices[i * 2 + 4] = data[i + 2]; // C

      newIndices[i * 2 + 5] = data[i]; // A
    }

    this.indices.data = newIndices;
    this.mode = LINES;
  },

  /**
   * 平移
   * @param  {Number} [x=0]
   * @param  {Number} [y=0]
   * @param  {Number} [z=0]
   * @return {Geometry} this
   */
  translate: function translate() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    this.transformMat4(Geometry_tempMatrix4.fromTranslation(tempVector31.set(x, y, z)));
    return this;
  },

  /**
   * 缩放
   * @param  {Number} [x=1]
   * @param  {Number} [y=1]
   * @param  {Number} [z=1]
   * @return {Geometry} this
   */
  scale: function scale() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    this.transformMat4(Geometry_tempMatrix4.fromScaling(tempVector31.set(x, y, z)));
    return this;
  },

  /**
   * 旋转
   * @param  {Number} [x=0] 旋转角度x
   * @param  {Number} [y=0] 旋转角度y
   * @param  {Number} [z=0] 旋转角度z
   * @return {Geometry} this
   */
  rotate: function rotate() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    this.transformMat4(Geometry_tempMatrix4.fromQuat(tempQuaternion.fromEuler({
      x: x * math_math.DEG2RAD,
      y: y * math_math.DEG2RAD,
      z: z * math_math.DEG2RAD
    })));
    return this;
  },

  /**
   * Transforms the geometry with a mat4.
   * @param  {Matrix4} mat4
   * @return {Geometry} this
   */
  transformMat4: function transformMat4(mat4) {
    var vertices = this.vertices;

    if (vertices) {
      vertices.traverse(function (vertex, index, offset) {
        vertices.setByOffset(offset, vertex.transformMat4(mat4));
      });
    }

    tempMatrix3.normalFromMat4(mat4);

    if (this._normals) {
      var normals = this.normals;
      normals.traverse(function (vertex, index, offset) {
        normals.setByOffset(offset, vertex.transformMat3(tempMatrix3).normalize());
      });
    }

    if (this._tangents) {
      var tangents = this.tangents;
      tangents.traverse(function (vertex, index, offset) {
        tangents.setByOffset(offset, vertex.transformMat3(tempMatrix3).normalize());
      });
    }

    this.isDirty = true;
    return this;
  },

  /**
   * 合并两个 geometry
   * @param  {Geometry} geometry
   * @param  {Matrix4} [matrix=null] 合并的矩阵
   * @return {Geometry} this
   */
  merge: function merge(geometry, matrix) {
    var vertices = geometry.vertices;

    if (vertices && this.vertices) {
      var count = this.vertices.count;

      if (matrix) {
        vertices = geometry.vertices.clone();
        vertices.traverse(function (vertex, index, offset) {
          vertices.setByOffset(offset, vertex.transformMat4(matrix));
        });
      }

      this.vertices.merge(vertices);

      if (this.indices && geometry.indices) {
        this.indices.merge(geometry.indices, function (data) {
          return data + count;
        });
      } else {
        this.indices = null;
      }
    }

    if (this.uvs && geometry.uvs) {
      this.uvs.merge(geometry.uvs);
    } else {
      this.uvs = null;
    }

    if (this.uvs1 && geometry.uvs1) {
      this.uvs1.merge(geometry.uvs1);
    } else {
      this.uvs1 = null;
    }

    if (this.colors && geometry.colors) {
      this.colors.merge(geometry.colors);
    } else {
      this.colors = null;
    }

    if (this._normals) {
      this._normals = null;
    }

    if (this._tangents) {
      this._tangents = null;
    }

    if (this._tangents1) {
      this._tangents1 = null;
    }

    this.isDirty = true;
    return this;
  },
  ensureData: function ensureData(name, size, total, TypedArray) {
    var geometryData = this[name];

    if (!geometryData || total > geometryData.length) {
      var newData = new TypedArray(total);

      if (geometryData) {
        newData.set(geometryData.data);
        geometryData.data = newData;
      } else {
        this[name] = new geometry_GeometryData(newData, size);
      }
    }
  },

  /**
   * 添加顶点
   * @param {...number[]} points 顶点坐标，如 addPoints([x, y, z], [x, y, z])
   */
  addPoints: function addPoints() {
    var _this = this;

    var points = [].slice.call(arguments);
    var total = (this.currentVerticesCount + points.length) * 3;
    this.ensureData('vertices', 3, total, Float32Array);
    var data = this.vertices.data;
    points.forEach(function (point) {
      var start = _this.currentVerticesCount++ * 3;
      data[start] = point[0];
      data[start + 1] = point[1];
      data[start + 2] = point[2];
    });
    return this.currentVerticesCount - points.length;
  },

  /**
   * 添加顶点索引
   * @param {...number} indices 顶点索引，如 addIndices(0, 1, 2)
   */
  addIndices: function addIndices() {
    var _this2 = this;

    var indices = [].slice.call(arguments);
    var total = this.currentIndicesCount + indices.length;
    this.ensureData('indices', 1, total, Uint16Array);
    var data = this.indices.data;
    indices.forEach(function (idx) {
      data[_this2.currentIndicesCount++] = idx;
    });
    this._needUpdateNormals = true;
  },

  /**
   * 添加一条线
   * @param {number[]} p1 起点坐标，如 [x, y, z]
   * @param {number[]} p2 终点坐标
   */
  addLine: function addLine(p1, p2) {
    var start = this.addPoints(p1, p2);
    this.addIndices(start, start + 1);
  },

  /**
   * 添加一个三角形 ABC
   * @param {number[]} p1 点A，如 [x, y, z]
   * @param {number[]} p2 点B
   * @param {number[]} p3 点C
   */
  addFace: function addFace(p1, p2, p3) {
    var start = this.addPoints(p1, p2, p3);
    this.addIndices(start, start + 1, start + 2);
  },

  /**
   * 添加一个矩形 ABCD
   * @param {number[]} p1 点A，如 [x, y, z]
   * @param {number[]} p2 点B
   * @param {number[]} p3 点C
   * @param {number[]} p4 点D
   */
  addRect: function addRect(p1, p2, p3, p4) {
    var start = this.addPoints(p1, p2, p3, p4); // 0 1 2 & 0 2 3 make a rect

    this.addIndices(start, start + 1, start + 2, start, start + 2, start + 3);
  },

  /**
   * 设置顶点对应的uv坐标
   * @param {number} start 开始的顶点索引
   * @param {number[][]} uvs uv坐标数据，如 [[0, 0], [1, 0]]
   */
  setVertexUV: function setVertexUV(start, uvs) {
    this.ensureData('uvs', 2, this.vertices.length / 3 * 2, Float32Array);
    var data = this.uvs.data;

    for (var i = 0; i < uvs.length; i++) {
      data[start + i * 2] = uvs[i][0];
      data[start + i * 2 + 1] = uvs[i][1];
    }
  },

  /**
   * 设置三角形ABC的uv
   * @param {number} start 开始的顶点索引
   * @param {number[]} p1 点A的uv，如 [0, 0]
   * @param {number[]} p2 点B的uv
   * @param {number[]} p3 点C的uv
   */
  setFaceUV: function setFaceUV(start, p1, p2, p3) {
    this.setVertexUV(start, [p1, p2, p3]);
  },

  /**
   * 设置矩形ABCD的uv
   * @param {number} start 开始的顶点索引
   * @param {number[]} p1 点A的uv，如 [0, 0]
   * @param {number[]} p2 点B的uv
   * @param {number[]} p3 点C的uv
   * @param {number[]} p4 点D的uv
   */
  setRectUV: function setRectUV(start, p1, p2, p3, p4) {
    this.setVertexUV(start, [p1, p2, p3, p4]);
  },

  /**
   * 获取指定matrix变化后的包围盒数据
   *
   * @param {Matrix4} [matrix=null] matrix 需要变换的矩阵
   * @param {Bounds} [bounds=null] 包围盒数据，传入的话会改变他
   * @return {Bounds} 包围盒数据
   */
  getBounds: function getBounds(matrix, bounds) {
    if (!bounds) {
      bounds = {
        xMin: Infinity,
        xMax: -Infinity,
        yMin: Infinity,
        yMax: -Infinity,
        zMin: Infinity,
        zMax: -Infinity
      };
    }

    var vertices = this.vertices;

    if (!vertices) {
      utils_log.warnOnce('geometry.getBounds', 'geometry has no vertices data, geometry.getBounds will return Infinity bounds.');
      return bounds;
    }

    vertices.traverse(function (vertexData) {
      if (matrix) {
        vertexData.transformMat4(matrix);
      }

      bounds.xMax = Math.max(bounds.xMax, vertexData.x);
      bounds.yMax = Math.max(bounds.yMax, vertexData.y);
      bounds.zMax = Math.max(bounds.zMax, vertexData.z);
      bounds.xMin = Math.min(bounds.xMin, vertexData.x);
      bounds.yMin = Math.min(bounds.yMin, vertexData.y);
      bounds.zMin = Math.min(bounds.zMin, vertexData.z);
    });
    bounds.width = bounds.xMax - bounds.xMin;
    bounds.height = bounds.yMax - bounds.yMin;
    bounds.depth = bounds.zMax - bounds.zMin;
    bounds.x = (bounds.xMin + bounds.xMax) / 2;
    bounds.y = (bounds.yMin + bounds.yMax) / 2;
    bounds.z = (bounds.zMin + bounds.zMax) / 2;
    return bounds;
  },

  /**
   * 获取本地包围盒
   * @param  {Boolean} [force=false] 是否强制刷新
   * @return {Bounds}
   */
  getLocalBounds: function getLocalBounds() {
    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (!this._localBounds || force) {
      this._localBounds = this.getBounds();
    }

    return this._localBounds;
  },

  /**
   * 获取球面包围盒
   * @param  {Matrix4} matrix
   * @return {Sphere}
   */
  getSphereBounds: function getSphereBounds(matrix) {
    if (!this._sphereBounds) {
      this._sphereBounds = new math_Sphere();
    }

    var sphereBounds = this._sphereBounds;
    sphereBounds.copy(this.getLocalSphereBounds());

    if (matrix) {
      sphereBounds.transformMat4(matrix);
    }

    return sphereBounds;
  },

  /**
   * 获取本地球面包围盒
   * @param  {Boolean} [force=false] 是否强制刷新
   * @return {Sphere}
   */
  getLocalSphereBounds: function getLocalSphereBounds() {
    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    if (!this._localSphereBounds || force) {
      var localBounds = this.getLocalBounds(force);
      var sphere = new math_Sphere({
        center: new math_Vector3(localBounds.x, localBounds.y, localBounds.z)
      });
      var vertices = this.vertices;

      if (vertices) {
        sphere.fromGeometryData(vertices);
      } else {
        utils_log.warnOnce('geometry.getLocalSphereBounds', 'geometry has no vertices data, geometry.getLocalSphereBounds will return Infinity bounds.');
        sphere.radius = Infinity;
      }

      this._localSphereBounds = sphere;
    }

    return this._localSphereBounds;
  },

  /**
   * 将 Geometry 转换成无 indices
   * @param {number} [verticesItemLen=3] 转换结果的顶点数据的位数(3 or 4)，如果为4会补1
   */
  convertToNoIndices: function convertToNoIndices() {
    var verticesItemLen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;

    if (this.mode !== TRIANGLES) {
      utils_log.warn('Only support convert triangles to lines mode!');
      return;
    }

    if (!this.indices) {
      utils_log.warn('Has no indices!');
      return;
    }

    var indices = this.indices.data;
    var indicesLen = indices.length;
    var vertices = new Float32Array(indicesLen * verticesItemLen);
    var uvs = this.uvs ? new Float32Array(indicesLen * 2) : null;
    var normals = new Float32Array(indicesLen * 3);
    var colors = this.colors ? new Float32Array(this.colors.size * indicesLen) : null;
    var skinIndices = this.skinIndices ? new Float32Array(indicesLen * 4) : null;
    var skinWeights = this.skinWeights ? new Float32Array(indicesLen * 4) : null;

    for (var i = 0; i < indicesLen; i++) {
      var idx = indices[i];
      copyArrayData(vertices, this.vertices, i * verticesItemLen, idx * 3, 3);

      if (verticesItemLen === 4) {
        vertices[i * 4 + 3] = 1;
      }

      copyArrayData(uvs, this.uvs, i * 2, idx * 2, 2);
      copyArrayData(normals, this.normals, i * 3, idx * 3, 3);
      copyArrayData(skinIndices, this.skinIndices, i * 4, idx * 4, 4);
      copyArrayData(skinWeights, this.skinWeights, i * 4, idx * 4, 4);

      if (this.colors) {
        copyArrayData(colors, this.colors, i * this.colors.size, idx * this.colors.size, this.colors.size);
      }
    }

    delete this.indices;
    this.vertices.data = vertices;

    if (this.uvs) {
      this.uvs.data = uvs;
    }

    if (this.normals) {
      this.normals.data = normals;
    }

    if (this.colors) {
      this.colors.data = colors;
    }

    if (this.skinIndices) {
      this.skinIndices.data = skinIndices;
    }

    if (this.skinWeights) {
      this.skinWeights.data = skinWeights;
    }
  },

  /**
   * clone当前Geometry
   * @return {Geometry} 返回clone的Geometry
   */
  clone: function clone() {
    var geometry = new this.constructor({
      mode: this.mode
    });

    if (this.vertices) {
      geometry.vertices = this.vertices.clone();
    }

    if (this.uvs) {
      geometry.uvs = this.uvs.clone();
    }

    if (this.uvs1) {
      geometry.uvs1 = this.uvs1.clone();
    }

    if (this.colors) {
      geometry.colors = this.colors.clone();
    }

    if (this.indices) {
      geometry.indices = this.indices.clone();
    }

    if (this.skinWeights) {
      geometry.skinWeights = this.skinWeights.clone();
    }

    if (this.skinIndices) {
      geometry.skinIndices = this.skinIndices.clone();
    }

    if (this._normals) {
      geometry._normals = this._normals.clone();
    }

    if (this._tangents) {
      geometry._tangents = this._tangents.clone();
    }

    if (this._tangents1) {
      geometry._tangents1 = this._tangents1.clone();
    }

    if (this.positionDecodeMat) {
      geometry.positionDecodeMat = this.positionDecodeMat;
    }

    if (this.uvDecodeMat) {
      geometry.uvDecodeMat = this.uvDecodeMat;
    }

    if (this.uv1DecodeMat) {
      geometry.uv1DecodeMat = this.uv1DecodeMat;
    }

    if (this.normalDecodeMat) {
      geometry.normalDecodeMat = this.normalDecodeMat;
    }

    return geometry;
  },

  /**
   * 检测 aabb 碰撞
   * @param  {Ray} ray
   * @return {Vector3[]|null}
   */
  _aabbRaycast: function _aabbRaycast(ray) {
    var bounds = this.getLocalBounds();
    var res = ray.intersectsBox([[bounds.xMin, bounds.yMin, bounds.zMin], [bounds.xMax, bounds.yMax, bounds.zMax]]);

    if (res) {
      return [res];
    }

    return null;
  },

  /**
   * _raycast，子类可覆盖实现
   * @param  {Ray} ray
   * @param  {GLenum} side
   * @return {Vector3[]|null}
   */
  _raycast: function _raycast(ray, side) {
    // TODO:optimize
    var vertices = this.vertices;

    if (!vertices) {
      return null;
    }

    var indices = this.indices;
    var triangle = [];
    var resArray = [];
    var len;

    if (indices) {
      len = indices.realLength;
    } else {
      len = vertices.realLength / 3;
    }

    for (var i = 0; i < len; i += 3) {
      var idx = indices ? indices.get(i) : i;
      tempVector31.copy(vertices.get(idx));
      idx = indices ? indices.get(i + 1) : i + 1;
      Geometry_tempVector32.copy(vertices.get(idx));
      idx = indices ? indices.get(i + 2) : i + 2;
      tempVector33.copy(vertices.get(idx));
      var res = void 0;

      if (side === FRONT) {
        triangle[0] = tempVector31.elements;
        triangle[1] = Geometry_tempVector32.elements;
        triangle[2] = tempVector33.elements;
        res = ray.intersectsTriangle(triangle);
      } else if (side === BACK) {
        triangle[1] = tempVector31.elements;
        triangle[0] = Geometry_tempVector32.elements;
        triangle[2] = tempVector33.elements;
        res = ray.intersectsTriangle(triangle);
      } else if (side === FRONT_AND_BACK) {
        triangle[0] = tempVector31.elements;
        triangle[1] = Geometry_tempVector32.elements;
        triangle[2] = tempVector33.elements;
        res = ray.intersectsTriangle(triangle);

        if (!res) {
          triangle[1] = tempVector31.elements;
          triangle[0] = Geometry_tempVector32.elements;
          triangle[2] = tempVector33.elements;
          res = ray.intersectsTriangle(triangle);
        }
      }

      if (res) {
        resArray.push(res);
      }
    }

    return resArray.length ? resArray : null;
  },

  /**
   * raycast
   * @param  {Ray} ray
   * @param  {GLenum} side
   * @param {Boolean} [sort=true] 是否按距离排序
   * @return {Vector3[]|null}
   */
  raycast: function raycast(ray, side) {
    var sort = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var res;

    if (this.useAABBRaycast) {
      res = this._aabbRaycast(ray);
    } else {
      res = this._raycast(ray, side);
    }

    if (res && sort) {
      ray.sortPoints(res);
    }

    return res;
  },
  getRenderOption: function getRenderOption() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (this.positionDecodeMat) {
      opt.QUANTIZED = 1;
      opt.POSITION_QUANTIZED = 1;
    }

    if (this.normalDecodeMat) {
      opt.QUANTIZED = 1;
      opt.NORMAL_QUANTIZED = 1;
    }

    if (this.uvDecodeMat) {
      opt.QUANTIZED = 1;
      opt.UV_QUANTIZED = 1;
    }

    if (this.uv1DecodeMat) {
      opt.QUANTIZED = 1;
      opt.UV1_QUANTIZED = 1;
    }

    if (this.colors) {
      opt.HAS_COLOR = 1;
      opt.COLOR_SIZE = this.colors.size;
    }

    return opt;
  },
  getShaderKey: function getShaderKey() {
    if (this._shaderKey === undefined) {
      this._shaderKey = 'geometry';

      if (this.isMorphGeometry) {
        this._shaderKey += "_id_".concat(this.id);
      } else {
        if (this.colors) {
          this._shaderKey += '_colors';
        }

        if (this.positionDecodeMat) {
          this._shaderKey += 'positionDecodeMat';
        }
      }
    }

    return this._shaderKey;
  },

  /**
   * 获取数据的内存大小，只处理顶点数据，单位为字节
   * @return {number} 内存占用大小
   */
  getSize: function getSize() {
    var sum = 0;

    for (var key in this) {
      if (util_hasOwnProperty(this, key) && this[key] && this[key].isGeometryData) {
        sum += this[key].getByteLength();
      }
    }

    return sum;
  },

  /**
   * @deprecated
   * @return {Geometry} this
   */
  destroy: function destroy() {
    utils_log.warn('Geometry.destroy has been deprecated, use mesh.destroy(renderer) instead.');
  }
});
/* harmony default export */ var geometry_Geometry = (Geometry);
// CONCATENATED MODULE: ./src/camera/PerspectiveCamera.js




/**
 * 透视投影摄像机
 * @class
 * @extends Camera
 */

var PerspectiveCamera = core_Class.create(
/** @lends PerspectiveCamera.prototype */
{
  Extends: camera_Camera,

  /**
   * @default true
   * @type {boolean}
   */
  isPerspectiveCamera: true,

  /**
   * @default PerspectiveCamera
   * @type {string}
   */
  className: 'PerspectiveCamera',
  _near: 0.1,

  /**
   * 相机视锥体近平面z
   * @default 0.1
   * @type {number}
   */
  near: {
    get: function get() {
      return this._near;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._near = value;
    }
  },
  _far: null,

  /**
   * 相机视锥体远平面z，null 时为无限远
   * @default null
   * @type {number}
   */
  far: {
    get: function get() {
      return this._far;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._far = value;
    }
  },
  _fov: 50,

  /**
   * 相机视野大小，角度制
   * @default 50
   * @type {number}
   */
  fov: {
    get: function get() {
      return this._fov;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._fov = value;
    }
  },
  _aspect: 1,

  /**
   * 宽高比
   * @default 1
   * @type {number}
   */
  aspect: {
    get: function get() {
      return this._aspect;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._aspect = value;
    }
  },

  /**
   * @constructs
   * @param {object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    PerspectiveCamera.superclass.constructor.call(this, params);
    this.updateProjectionMatrix();
  },

  /**
   * 更新投影矩阵
   */
  updateProjectionMatrix: function updateProjectionMatrix() {
    // this.projectionMatrix.perspective(math.degToRad(this.fov), this.aspect, this.near, this.far);
    var elements = this.projectionMatrix.elements;
    var near = this.near,
        far = this.far,
        aspect = this.aspect,
        fov = this.fov;
    var f = 1 / Math.tan(0.5 * math_math.degToRad(fov));
    elements[0] = f / aspect;
    elements[5] = f;
    elements[11] = -1;
    elements[15] = 0;

    if (far) {
      var nf = 1 / (near - far);
      elements[10] = (near + far) * nf;
      elements[14] = 2 * far * near * nf;
    } else {
      elements[10] = -1;
      elements[14] = -2 * near;
    }
  },
  getGeometry: function getGeometry(forceUpdate) {
    if (forceUpdate || !this._geometry || this._isGeometryDirty) {
      this._isGeometryDirty = false;
      var geometry = new geometry_Geometry();
      var tan = Math.tan(this.fov / 2 * Math.PI / 180);
      var near = this.near;
      var far = this.far;
      var vNear = near * tan;
      var vFar = far * tan;
      var hNear = this.aspect * vNear;
      var hFar = this.aspect * vFar;
      var p1 = [-hNear, -vNear, -near];
      var p2 = [hNear, -vNear, -near];
      var p3 = [hNear, vNear, -near];
      var p4 = [-hNear, vNear, -near];
      var p5 = [-hFar, -vFar, -far];
      var p6 = [hFar, -vFar, -far];
      var p7 = [hFar, vFar, -far];
      var p8 = [-hFar, vFar, -far];
      geometry.addRect(p5, p6, p7, p8); // front

      geometry.addRect(p6, p2, p3, p7); // right

      geometry.addRect(p2, p1, p4, p3); // back

      geometry.addRect(p1, p5, p8, p4); // left

      geometry.addRect(p8, p7, p3, p4); // top

      geometry.addRect(p1, p2, p6, p5); // bottom

      this._geometry = geometry;
    }

    return this._geometry;
  }
});
/* harmony default export */ var camera_PerspectiveCamera = (PerspectiveCamera);
// CONCATENATED MODULE: ./src/utils/Cache.js

/**
 * 缓存类
 * @class
 * @example
 * const cache = new Hilo3d.Cache();
 * cache.add('id1', {a:1});
 * cache.get('id1');
 * cache.remove('id1');
 */

var Cache = core_Class.create(
/** @lends Cache.prototype */
{
  /**
   * @constructs
   */
  constructor: function constructor() {
    this._cache = {};
  },

  /**
   * 获取对象
   * @param  {String} id
   * @return {Object}
   */
  get: function get(id) {
    return this._cache[id];
  },

  /**
   * 获取对象
   * @param {Object} obj
   * @return {Object} [description]
   */
  getObject: function getObject(obj) {
    return this._cache[obj.__cacheId];
  },

  /**
   * 增加对象
   * @param {String} id
   * @param {Object} obj
   */
  add: function add(id, obj) {
    if (typeof obj === 'object') {
      obj.__cacheId = id;
    }

    this._cache[id] = obj;
  },

  /**
   * 移除对象
   * @param {String} id
   */
  remove: function remove(id) {
    delete this._cache[id];
  },

  /**
   * 移除对象
   * @param {Object} obj
   */
  removeObject: function removeObject(obj) {
    delete this._cache[obj.__cacheId];
  },

  /**
   * 移除所有对象
   */
  removeAll: function removeAll() {
    this._cache = {};
  },

  /**
   * 遍历所有缓存
   * @param  {Function} callback
   */
  each: function each(callback) {
    var cache = this._cache;

    for (var id in cache) {
      callback(cache[id], id);
    }
  }
});
/* harmony default export */ var utils_Cache = (Cache);
// CONCATENATED MODULE: ./src/renderer/extensions.js
/**
 * WebGL 扩展
 * @namespace extensions
 * @type {Object}
 * @description WebGL 扩展管理，默认开启的扩展有：ANGLE_instanced_arrays, OES_vertex_array_object, OES_texture_float, WEBGL_lose_context, OES_element_index_uint, EXT_shader_texture_lod
 */
var extensions_extensions = {
  /**
   * ANGLE_instanced_arrays扩展
   * @type {ANGLEInstancedArrays}
   */
  instanced: undefined,

  /**
   * OES_vertex_array_object扩展
   * @type {OESVertexArrayObject}
   */
  vao: undefined,

  /**
   * OES_texture_float扩展
   * @type {OESTextureFloat}
   */
  texFloat: undefined,

  /**
   * WEBGL_lose_context扩展
   * @type {WebGLLoseContext}
   */
  loseContext: undefined,

  /**
   * EXT_texture_filter_anisotropic
   * @type {EXTTextureFilterAnisotropic}
   */
  textureFilterAnisotropic: undefined,
  _usedExtensions: {},
  _disabledExtensions: {},

  /**
   * 初始化
   * @param {WebGLRenderingContext} gl
   */
  init: function init(gl) {
    this.reset(gl);
  },

  /**
   * 重置扩展
   * @param {WebGLRenderingContext} gl
   */
  reset: function reset(gl) {
    this.gl = gl;
    var usedExtensions = this._usedExtensions;

    for (var name in usedExtensions) {
      var alias = usedExtensions[name];
      this[alias] = undefined;
      this.get(name, alias);
    }
  },

  /**
   * 使用扩展
   * @param  {String} name 扩展名称
   * @param {String} [alias=name] 别名，默认和 name 相同
   */
  use: function use(name) {
    var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : name;

    if (this.gl) {
      this.get(name, alias);
    } else {
      this._usedExtensions[name] = alias;
    }
  },

  /**
   * 获取扩展，如果不支持返回 null，必须在 Renderer 初始化完后用
   * @param  {String} name 扩展名称
   * @param {String} [alias=name] 别名，默认和 name 相同
   * @return {Object|null}
   */
  get: function get(name) {
    var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : name;

    if (this._disabledExtensions[name]) {
      return null;
    }

    var ext = this[alias];

    if (ext === undefined) {
      ext = this._getExtension(name);
      this[alias] = ext;
    }

    return ext;
  },

  /**
   * 禁止扩展
   * @param  {String} name 扩展名称
   */
  disable: function disable(name) {
    this._disabledExtensions[name] = true;
  },

  /**
   * 开启扩展
   * @param  {String} name 扩展名称
   */
  enable: function enable(name) {
    this._disabledExtensions[name] = false;
  },
  _getExtension: function _getExtension(name) {
    var gl = this.gl;

    if (gl && gl.getExtension) {
      return gl.getExtension(name) || gl.getExtension('WEBKIT_' + name) || gl.getExtension('MOZ_' + name) || null;
    }

    return null;
  }
};
extensions_extensions.use('ANGLE_instanced_arrays', 'instanced');
extensions_extensions.use('OES_vertex_array_object', 'vao');
extensions_extensions.use('OES_texture_float', 'texFloat');
extensions_extensions.use('WEBGL_lose_context', 'loseContext');
extensions_extensions.use('OES_element_index_uint', 'uintIndices');
extensions_extensions.use('EXT_shader_texture_lod', 'shaderTextureLod');
extensions_extensions.use('EXT_texture_filter_anisotropic', 'textureFilterAnisotropic');
/* harmony default export */ var renderer_extensions = (extensions_extensions);
/**
 * @typedef {any} ANGLEInstancedArrays
 */

/**
 * @typedef {any} OESVertexArrayObject
 */

/**
 * @typedef {any} OESTextureFloat
 */

/**
 * @typedef {any} WebGLLoseContext
 */

/**
 * @typedef {any} EXTTextureFilterAnisotropic
 */
// CONCATENATED MODULE: ./src/renderer/capabilities.js

/**
 * WebGL 能力
 * @namespace capabilities
 * @type {Object}
 */

var capabilities = {
  /**
   * 最大纹理数量
   * @type {Number}
   */
  MAX_TEXTURE_INDEX: null,

  /**
   * 最高着色器精度, 可以是以下值：highp, mediump, lowp
   * @type {String}
   */
  MAX_PRECISION: null,

  /**
   * 最高顶点着色器精度, 可以是以下值：highp, mediump, lowp
   * @type {String}
   */
  MAX_VERTEX_PRECISION: null,

  /**
   * 最高片段着色器精度, 可以是以下值：highp, mediump, lowp
   * @type {String}
   */
  MAX_FRAGMENT_PRECISION: null,

  /**
   * 顶点浮点数纹理
   * @type {Boolean}
   */
  VERTEX_TEXTURE_FLOAT: null,

  /**
   * 片段浮点数纹理
   * @type {Boolean}
   */
  FRAGMENT_TEXTURE_FLOAT: null,

  /**
   * MAX_TEXTURE_MAX_ANISOTROPY
   * @type {Number}
   */
  MAX_TEXTURE_MAX_ANISOTROPY: 1,

  /**
   * 初始化
   * @param {WebGLRenderingContext} gl
   */
  init: function init(gl) {
    var _this = this;

    this.gl = gl;
    var arr = ['MAX_RENDERBUFFER_SIZE', 'MAX_COMBINED_TEXTURE_IMAGE_UNITS', 'MAX_CUBE_MAP_TEXTURE_SIZE', 'MAX_FRAGMENT_UNIFORM_VECTORS', 'MAX_TEXTURE_IMAGE_UNITS', 'MAX_TEXTURE_SIZE', 'MAX_VARYING_VECTORS', 'MAX_VERTEX_ATTRIBS', 'MAX_VERTEX_TEXTURE_IMAGE_UNITS', 'MAX_VERTEX_UNIFORM_VECTORS', 'MAX_COMBINED_TEXTURE_IMAGE_UNITS'];
    arr.forEach(function (name) {
      _this.get(name);
    });
    this.MAX_TEXTURE_INDEX = this.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    this.MAX_VERTEX_PRECISION = this._getMaxSupportPrecision(gl.VERTEX_SHADER);
    this.MAX_FRAGMENT_PRECISION = this._getMaxSupportPrecision(gl.FRAGMENT_SHADER);
    this.MAX_PRECISION = this.getMaxPrecision(this.MAX_FRAGMENT_PRECISION, this.MAX_VERTEX_PRECISION);
    this.VERTEX_TEXTURE_FLOAT = !!renderer_extensions.texFloat && this.MAX_VERTEX_TEXTURE_IMAGE_UNITS > 0;
    this.FRAGMENT_TEXTURE_FLOAT = !!renderer_extensions.texFloat;
    this.EXT_FRAG_DEPTH = renderer_extensions.get('EXT_frag_depth');
    this.SHADER_TEXTURE_LOD = !!renderer_extensions.shaderTextureLod;

    if (renderer_extensions.textureFilterAnisotropic) {
      this.MAX_TEXTURE_MAX_ANISOTROPY = gl.getParameter(renderer_extensions.textureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    }
  },

  /**
   * 获取 WebGL 能力
   * @param  {String} name
   * @return {Number|String}
   */
  get: function get(name) {
    var gl = this.gl;
    var value = this[name];

    if (value === undefined) {
      value = this[name] = gl.getParameter(gl[name]);
    }

    return value;
  },
  _getMaxSupportPrecision: function _getMaxSupportPrecision(shaderType) {
    var gl = this.gl;
    var maxPrecision = 'lowp';

    if (gl.getShaderPrecisionFormat) {
      var precisions = [{
        name: 'highp',
        type: gl.HIGH_FLOAT
      }, {
        name: 'mediump',
        type: gl.MEDIUM_FLOAT
      }];

      for (var i = 0; i < precisions.length; i++) {
        var precision = precisions[i];
        var precisionFormat = gl.getShaderPrecisionFormat(shaderType, precision.type) || {};

        if (precisionFormat.precision > 0) {
          maxPrecision = precision.name;
          break;
        }
      }
    } else {
      maxPrecision = 'mediump';
    }

    return maxPrecision;
  },

  /**
   * 获取最大支持精度
   * @param  {String} a
   * @param  {String} b
   * @return {String}
   */
  getMaxPrecision: function getMaxPrecision(a, b) {
    if (a === 'highp' || a === 'mediump' && b === 'lowp') {
      return b;
    }

    return a;
  }
};
/* harmony default export */ var renderer_capabilities = (capabilities);
// EXTERNAL MODULE: ./src/shader/basic.frag
var basic = __webpack_require__("./src/shader/basic.frag");
var basic_default = /*#__PURE__*/__webpack_require__.n(basic);

// EXTERNAL MODULE: ./src/shader/basic.vert
var shader_basic = __webpack_require__("./src/shader/basic.vert");
var shader_basic_default = /*#__PURE__*/__webpack_require__.n(shader_basic);

// EXTERNAL MODULE: ./src/shader/geometry.frag
var shader_geometry = __webpack_require__("./src/shader/geometry.frag");
var geometry_default = /*#__PURE__*/__webpack_require__.n(shader_geometry);

// EXTERNAL MODULE: ./src/shader/pbr.frag
var pbr = __webpack_require__("./src/shader/pbr.frag");
var pbr_default = /*#__PURE__*/__webpack_require__.n(pbr);

// CONCATENATED MODULE: ./src/shader/Shader.js
/* eslint global-require: "off" */








var Shader_cache = new utils_Cache();
var headerCache = new utils_Cache();
var CUSTUM_OPTION_PREFIX = 'HILO_CUSTUM_OPTION_';
/**
 * Shader类
 * @class
 */

var Shader = core_Class.create(
/** @lends Shader.prototype */
{
  /**
   * @default true
   * @type {boolean}
   */
  isShader: true,

  /**
   * @default Shader
   * @type {string}
   */
  className: 'Shader',

  /**
   * vs 顶点代码
   * @default ''·
   * @type {String}
   */
  vs: '',

  /**
   * vs 片段代码
   * @default ''
   * @type {String}
   */
  fs: '',
  Statics:
  /** @lends Shader */
  {
    commonOptions: {},

    /**
     * 内部的所有shader块字符串，可以用来拼接glsl代码
     * @type {Object}
     */
    shaders: {
      'chunk/baseDefine.glsl': __webpack_require__(/*! ./chunk/baseDefine.glsl */ "./src/shader/chunk/baseDefine.glsl"),
      'chunk/color.frag': __webpack_require__(/*! ./chunk/color.frag */ "./src/shader/chunk/color.frag"),
      'chunk/color.vert': __webpack_require__(/*! ./chunk/color.vert */ "./src/shader/chunk/color.vert"),
      'chunk/color_main.vert': __webpack_require__(/*! ./chunk/color_main.vert */ "./src/shader/chunk/color_main.vert"),
      'chunk/diffuse.frag': __webpack_require__(/*! ./chunk/diffuse.frag */ "./src/shader/chunk/diffuse.frag"),
      'chunk/diffuse_main.frag': __webpack_require__(/*! ./chunk/diffuse_main.frag */ "./src/shader/chunk/diffuse_main.frag"),
      'chunk/extensions.frag': __webpack_require__(/*! ./chunk/extensions.frag */ "./src/shader/chunk/extensions.frag"),
      'chunk/extensions.vert': __webpack_require__(/*! ./chunk/extensions.vert */ "./src/shader/chunk/extensions.vert"),
      'chunk/fog.frag': __webpack_require__(/*! ./chunk/fog.frag */ "./src/shader/chunk/fog.frag"),
      'chunk/fog_main.frag': __webpack_require__(/*! ./chunk/fog_main.frag */ "./src/shader/chunk/fog_main.frag"),
      'chunk/frag_color.frag': __webpack_require__(/*! ./chunk/frag_color.frag */ "./src/shader/chunk/frag_color.frag"),
      'chunk/joint.vert': __webpack_require__(/*! ./chunk/joint.vert */ "./src/shader/chunk/joint.vert"),
      'chunk/joint_main.vert': __webpack_require__(/*! ./chunk/joint_main.vert */ "./src/shader/chunk/joint_main.vert"),
      'chunk/light.frag': __webpack_require__(/*! ./chunk/light.frag */ "./src/shader/chunk/light.frag"),
      'chunk/lightFog.frag': __webpack_require__(/*! ./chunk/lightFog.frag */ "./src/shader/chunk/lightFog.frag"),
      'chunk/lightFog.vert': __webpack_require__(/*! ./chunk/lightFog.vert */ "./src/shader/chunk/lightFog.vert"),
      'chunk/lightFog_main.frag': __webpack_require__(/*! ./chunk/lightFog_main.frag */ "./src/shader/chunk/lightFog_main.frag"),
      'chunk/lightFog_main.vert': __webpack_require__(/*! ./chunk/lightFog_main.vert */ "./src/shader/chunk/lightFog_main.vert"),
      'chunk/logDepth.frag': __webpack_require__(/*! ./chunk/logDepth.frag */ "./src/shader/chunk/logDepth.frag"),
      'chunk/logDepth_main.frag': __webpack_require__(/*! ./chunk/logDepth_main.frag */ "./src/shader/chunk/logDepth_main.frag"),
      'chunk/logDepth.vert': __webpack_require__(/*! ./chunk/logDepth.vert */ "./src/shader/chunk/logDepth.vert"),
      'chunk/logDepth_main.vert': __webpack_require__(/*! ./chunk/logDepth_main.vert */ "./src/shader/chunk/logDepth_main.vert"),
      'chunk/morph.vert': __webpack_require__(/*! ./chunk/morph.vert */ "./src/shader/chunk/morph.vert"),
      'chunk/morph_main.vert': __webpack_require__(/*! ./chunk/morph_main.vert */ "./src/shader/chunk/morph_main.vert"),
      'chunk/normal.frag': __webpack_require__(/*! ./chunk/normal.frag */ "./src/shader/chunk/normal.frag"),
      'chunk/normal.vert': __webpack_require__(/*! ./chunk/normal.vert */ "./src/shader/chunk/normal.vert"),
      'chunk/normal_main.frag': __webpack_require__(/*! ./chunk/normal_main.frag */ "./src/shader/chunk/normal_main.frag"),
      'chunk/normal_main.vert': __webpack_require__(/*! ./chunk/normal_main.vert */ "./src/shader/chunk/normal_main.vert"),
      'chunk/pbr.frag': __webpack_require__(/*! ./chunk/pbr.frag */ "./src/shader/chunk/pbr.frag"),
      'chunk/pbr_main.frag': __webpack_require__(/*! ./chunk/pbr_main.frag */ "./src/shader/chunk/pbr_main.frag"),
      'chunk/phong.frag': __webpack_require__(/*! ./chunk/phong.frag */ "./src/shader/chunk/phong.frag"),
      'chunk/phong_main.frag': __webpack_require__(/*! ./chunk/phong_main.frag */ "./src/shader/chunk/phong_main.frag"),
      'chunk/precision.frag': __webpack_require__(/*! ./chunk/precision.frag */ "./src/shader/chunk/precision.frag"),
      'chunk/precision.vert': __webpack_require__(/*! ./chunk/precision.vert */ "./src/shader/chunk/precision.vert"),
      'chunk/transparency.frag': __webpack_require__(/*! ./chunk/transparency.frag */ "./src/shader/chunk/transparency.frag"),
      'chunk/transparency_main.frag': __webpack_require__(/*! ./chunk/transparency_main.frag */ "./src/shader/chunk/transparency_main.frag"),
      'chunk/unQuantize.vert': __webpack_require__(/*! ./chunk/unQuantize.vert */ "./src/shader/chunk/unQuantize.vert"),
      'chunk/unQuantize_main.vert': __webpack_require__(/*! ./chunk/unQuantize_main.vert */ "./src/shader/chunk/unQuantize_main.vert"),
      'chunk/uv.frag': __webpack_require__(/*! ./chunk/uv.frag */ "./src/shader/chunk/uv.frag"),
      'chunk/uv.vert': __webpack_require__(/*! ./chunk/uv.vert */ "./src/shader/chunk/uv.vert"),
      'chunk/uv_main.vert': __webpack_require__(/*! ./chunk/uv_main.vert */ "./src/shader/chunk/uv_main.vert"),
      'method/encoding.glsl': __webpack_require__(/*! ./method/encoding.glsl */ "./src/shader/method/encoding.glsl"),
      'method/getDiffuse.glsl': __webpack_require__(/*! ./method/getDiffuse.glsl */ "./src/shader/method/getDiffuse.glsl"),
      'method/getLightAttenuation.glsl': __webpack_require__(/*! ./method/getLightAttenuation.glsl */ "./src/shader/method/getLightAttenuation.glsl"),
      'method/getShadow.glsl': __webpack_require__(/*! ./method/getShadow.glsl */ "./src/shader/method/getShadow.glsl"),
      'method/getSpecular.glsl': __webpack_require__(/*! ./method/getSpecular.glsl */ "./src/shader/method/getSpecular.glsl"),
      'method/packFloat.glsl': __webpack_require__(/*! ./method/packFloat.glsl */ "./src/shader/method/packFloat.glsl"),
      'method/textureEnvMap.glsl': __webpack_require__(/*! ./method/textureEnvMap.glsl */ "./src/shader/method/textureEnvMap.glsl"),
      'method/transpose.glsl': __webpack_require__(/*! ./method/transpose.glsl */ "./src/shader/method/transpose.glsl"),
      'method/unpackFloat.glsl': __webpack_require__(/*! ./method/unpackFloat.glsl */ "./src/shader/method/unpackFloat.glsl"),
      'basic.frag': __webpack_require__(/*! ./basic.frag */ "./src/shader/basic.frag"),
      'basic.vert': __webpack_require__(/*! ./basic.vert */ "./src/shader/basic.vert"),
      'geometry.frag': __webpack_require__(/*! ./geometry.frag */ "./src/shader/geometry.frag"),
      'pbr.frag': __webpack_require__(/*! ./pbr.frag */ "./src/shader/pbr.frag"),
      'screen.frag': __webpack_require__(/*! ./screen.frag */ "./src/shader/screen.frag"),
      'screen.vert': __webpack_require__(/*! ./screen.vert */ "./src/shader/screen.vert")
    },

    /**
     * 初始化
     * @param  {WebGLRenderer} renderer
     */
    init: function init(renderer) {
      this.renderer = renderer;
      this.commonHeader = this._getCommonHeader(this.renderer);
    },

    /**
     * Shader 缓存
     * @readOnly
     * @type {Cache}
     */
    cache: {
      get: function get() {
        return Shader_cache;
      }
    },

    /**
     * Shader header缓存，一般不用管
     * @readOnly
     * @type {Cache}
     */
    headerCache: {
      get: function get() {
        return headerCache;
      }
    },

    /**
     * 重置
     */
    reset: function reset(gl) {
      // eslint-disable-line no-unused-vars
      Shader_cache.removeAll();
    },

    /**
     * 获取header缓存的key
     * @param {Mesh} mesh mesh
     * @param {Material} material 材质
     * @param {LightManager} lightManager lightManager
     * @param {Fog} fog fog
     * @param {Boolean} useLogDepth 是否使用对数深度
     * @return {string}
     */
    getHeaderKey: function getHeaderKey(mesh, material, lightManager, fog, useLogDepth) {
      var headerKey = 'header_' + material.id + '_' + lightManager.lightInfo.uid;

      if (mesh.isSkinedMesh) {
        headerKey += '_joint' + mesh.skeleton.jointCount;
      }

      if (fog) {
        headerKey += '_fog_' + fog.mode;
      }

      headerKey += '_' + mesh.geometry.getShaderKey();

      if (useLogDepth) {
        headerKey += '_fogDepth';
      }

      return headerKey;
    },

    /**
     * 获取header
     * @param {Mesh} mesh
     * @param {Material} material
     * @param {LightManager} lightManager
     * @param {Fog} fog
     * @return {String}
     */
    getHeader: function getHeader(mesh, material, lightManager, fog, useLogDepth) {
      var headerKey = this.getHeaderKey(mesh, material, lightManager, fog);
      var header = headerCache.get(headerKey);

      if (!header || material.isDirty) {
        var headers = {};
        Object.assign(headers, this.commonOptions);
        var lightType = material.lightType;

        if (lightType && lightType !== 'NONE') {
          lightManager.getRenderOption(headers);
        }

        material.getRenderOption(headers);
        mesh.getRenderOption(headers);

        if (fog) {
          headers.HAS_FOG = 1;
          fog.getRenderOption(headers);
        }

        if (useLogDepth) {
          headers.USE_LOG_DEPTH = 1;

          if (renderer_capabilities.EXT_FRAG_DEPTH) {
            headers.USE_EXT_FRAG_DEPTH = 1;
          }
        }

        if (headers.HAS_NORMAL && headers.NORMAL_MAP) {
          headers.HAS_TANGENT = 1;
        }

        if (!headers.RECEIVE_SHADOWS) {
          delete headers.DIRECTIONAL_LIGHTS_SMC;
          delete headers.SPOT_LIGHTS_SMC;
          delete headers.POINT_LIGHTS_SMC;
        }

        header = "#define SHADER_NAME ".concat(material.className, "\n");
        header += Object.keys(headers).map(function (name) {
          if (name.indexOf(CUSTUM_OPTION_PREFIX) > -1) {
            return "#define ".concat(name.replace(CUSTUM_OPTION_PREFIX, ''), " ").concat(headers[name]);
          }

          return "#define HILO_".concat(name, " ").concat(headers[name]);
        }).join('\n') + '\n';
        headerCache.add(headerKey, header);
      }

      return header;
    },
    _getCommonHeader: function _getCommonHeader(renderer) {
      var vertexPrecision = renderer_capabilities.getMaxPrecision(renderer_capabilities.MAX_VERTEX_PRECISION, renderer.vertexPrecision);
      var fragmentPrecision = renderer_capabilities.getMaxPrecision(renderer_capabilities.MAX_FRAGMENT_PRECISION, renderer.fragmentPrecision);
      var precision = renderer_capabilities.getMaxPrecision(vertexPrecision, fragmentPrecision);
      return "\n#define HILO_MAX_PRECISION ".concat(precision, "\n#define HILO_MAX_VERTEX_PRECISION ").concat(vertexPrecision, "\n#define HILO_MAX_FRAGMENT_PRECISION ").concat(fragmentPrecision, "\n");
    },

    /**
     * 获取 shader
     * @param {Mesh} mesh
     * @param {Material} material
     * @param {Boolean} isUseInstance
     * @param {LightManager} lightManager
     * @param {Fog} fog
     * @param {Boolean} useLogDepth
     * @return {Shader}
     */
    getShader: function getShader(mesh, material, isUseInstance, lightManager, fog, useLogDepth) {
      var header = this.getHeader(mesh, material, lightManager, fog, useLogDepth);

      if (material.isBasicMaterial || material.isPBRMaterial) {
        return this.getBasicShader(material, isUseInstance, header);
      }

      if (material.isShaderMaterial) {
        return this.getCustomShader(material.vs, material.fs, header, material.shaderCacheId || material.id, material.useHeaderCache);
      }

      return null;
    },

    /**
     * 获取基础 shader
     * @param  {Material}  material
     * @param  {Boolean} isUseInstance
     * @param  {LightManager}  lightManager
     * @param  {Fog}  fog
     * @return {Shader}
     */
    getBasicShader: function getBasicShader(material, isUseInstance, header) {
      var instancedUniforms = '';

      if (isUseInstance) {
        instancedUniforms = material.getInstancedUniforms().map(function (x) {
          return x.name;
        });
        instancedUniforms = instancedUniforms.join('|');
      }

      var key = material.className + ':' + instancedUniforms;

      if (material.onBeforeCompile) {
        key += ':' + (material.shaderCacheId || material.id);
      }

      var shader = Shader_cache.get(key);

      if (!shader) {
        var fs = '';
        var vs = shader_basic_default.a;

        if (material.isBasicMaterial) {
          if (material.isGeometryMaterial) {
            fs += geometry_default.a;
          } else {
            fs += basic_default.a;
          }
        } else if (material.isPBRMaterial) {
          fs += pbr_default.a;
        }

        if (material.onBeforeCompile) {
          var newCode = material.onBeforeCompile(vs, fs);
          fs = newCode.fs;
          vs = newCode.vs;
        }

        if (instancedUniforms) {
          var instancedUniformsReg = new RegExp("^\\s*uniform\\s+(\\w+)\\s+(".concat(instancedUniforms, ");"), 'gm');
          vs = vs.replace(instancedUniformsReg, 'attribute $1 $2;');
        }

        shader = this.getCustomShader(vs, fs, header, key, true);
      }

      if (shader) {
        var shaderNumId = this._getNumId(shader);

        if (shaderNumId !== null) {
          material._shaderNumId = shaderNumId;
        }
      }

      return shader;
    },
    _getNumId: function _getNumId(obj) {
      var id = obj.id;
      var res = id.match(/_(\d+)/);

      if (res && res[1]) {
        return parseInt(res[1], 10);
      }

      return null;
    },

    /**
     * 获取自定义shader
     * @param  {String} vs 顶点代码
     * @param  {String} fs 片段代码
     * @param  {String} [cacheKey] 如果有，会以此值缓存 shader
     * @param  {String} [useHeaderCache=false] 如果cacheKey和useHeaderCache同时存在，使用 cacheKey+useHeaderCache缓存 shader
     * @return {Shader}
     */
    getCustomShader: function getCustomShader(vs, fs, header, cacheKey, useHeaderCache) {
      var commonHeader = this.commonHeader;
      var shader;

      if (cacheKey) {
        if (useHeaderCache) {
          cacheKey += ':' + header;
        }

        shader = Shader_cache.get(cacheKey);
      }

      if (!shader) {
        shader = new Shader({
          vs: commonHeader + header + vs,
          fs: commonHeader + header + fs
        });

        if (cacheKey) {
          Shader_cache.add(cacheKey, shader);
        }
      }

      return shader;
    }
  },

  /**
   * 是否始终使用
   * @default true
   * @type {Boolean}
   */
  alwaysUse: false,

  /**
   * @constructs
   * @param  {Object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    this.id = math_math.generateUUID(this.className);
    Object.assign(this, params);
  },

  /**
   * 没有被引用时销毁资源
   * @param  {WebGLRenderer} renderer
   * @return {Shader} this
   */
  destroyIfNoRef: function destroyIfNoRef(renderer) {
    var resourceManager = renderer.resourceManager;
    resourceManager.destroyIfNoRef(this);
    return this;
  },

  /**
   * 销毁资源
   * @return {Shader} this
   */
  destroy: function destroy() {
    if (this._isDestroyed) {
      return this;
    }

    Shader_cache.removeObject(this);
    this._isDestroyed = true;
    return this;
  }
});
/* harmony default export */ var shader_Shader = (Shader);
// EXTERNAL MODULE: ./src/shader/screen.vert
var screen = __webpack_require__("./src/shader/screen.vert");
var screen_default = /*#__PURE__*/__webpack_require__.n(screen);

// EXTERNAL MODULE: ./src/shader/screen.frag
var shader_screen = __webpack_require__("./src/shader/screen.frag");
var shader_screen_default = /*#__PURE__*/__webpack_require__.n(shader_screen);

// CONCATENATED MODULE: ./src/renderer/glType.js
var DATA_TYPES = [{
  name: 'FLOAT',
  byteSize: 4,
  uniformFuncName: 'uniform1f',
  type: 'Scalar',
  size: 1
}, {
  name: 'FLOAT_VEC2',
  byteSize: 8,
  uniformFuncName: 'uniform2f',
  type: 'Vector',
  size: 2
}, {
  name: 'FLOAT_VEC3',
  byteSize: 12,
  uniformFuncName: 'uniform3f',
  type: 'Vector',
  size: 3
}, {
  name: 'FLOAT_VEC4',
  byteSize: 16,
  uniformFuncName: 'uniform4f',
  type: 'Vector',
  size: 4
}, {
  name: 'FLOAT_MAT2',
  byteSize: 16,
  uniformFuncName: 'uniformMatrix2fv',
  type: 'Matrix',
  size: 4
}, {
  name: 'FLOAT_MAT3',
  byteSize: 36,
  uniformFuncName: 'uniformMatrix3fv',
  type: 'Matrix',
  size: 9
}, {
  name: 'FLOAT_MAT4',
  byteSize: 64,
  uniformFuncName: 'uniformMatrix4fv',
  type: 'Matrix',
  size: 16
}, {
  name: 'INT',
  byteSize: 4,
  uniformFuncName: 'uniform1i',
  type: 'Scalar',
  size: 1
}, {
  name: 'INT_VEC2',
  byteSize: 8,
  uniformFuncName: 'uniform2i',
  type: 'Vector',
  size: 2
}, {
  name: 'INT_VEC3',
  byteSize: 12,
  uniformFuncName: 'uniform3i',
  type: 'Vector',
  size: 3
}, {
  name: 'INT_VEC4',
  byteSize: 16,
  uniformFuncName: 'uniform4i',
  type: 'Vector',
  size: 4
}, {
  name: 'BOOL',
  byteSize: 4,
  uniformFuncName: 'uniform1i',
  type: 'Scalar',
  size: 1
}, {
  name: 'BOOL_VEC2',
  byteSize: 8,
  uniformFuncName: 'uniform2i',
  type: 'Vector',
  size: 2
}, {
  name: 'BOOL_VEC3',
  byteSize: 12,
  uniformFuncName: 'uniform3i',
  type: 'Vector',
  size: 3
}, {
  name: 'BOOL_VEC4',
  byteSize: 16,
  uniformFuncName: 'uniform4i',
  type: 'Vector',
  size: 4
}, {
  name: 'SAMPLER_2D',
  byteSize: 4,
  uniformFuncName: 'uniform1i',
  type: 'Scalar',
  size: 1
}, {
  name: 'SAMPLER_CUBE',
  byteSize: 4,
  uniformFuncName: 'uniform1i',
  type: 'Scalar',
  size: 1
}];
var DATA_DICT = {};
/**
 * @namespace glType
 * @type {Object}
 */

var glType = {
  dict: DATA_DICT,

  /**
   * init
   * @param  {WebGLRenderingContext} gl
   */
  init: function init(gl) {
    DATA_TYPES.forEach(function (dataType) {
      var name = dataType.name;
      var uniform;
      var uniformArray;
      var uniformFuncName = dataType.uniformFuncName;
      var uniformArrayFuncName = uniformFuncName + 'v';

      if (dataType.type === 'Matrix') {
        uniform = uniformArray = function uniformArray(location, value) {
          if (value === undefined) {
            return;
          }

          gl[uniformFuncName](location, false, value);
        };
      } else {
        uniform = function uniform(location, value) {
          if (value === undefined) {
            return;
          }

          gl[uniformFuncName](location, value);
        };

        uniformArray = function uniformArray(location, value) {
          gl[uniformArrayFuncName](location, value);
        };
      }

      DATA_DICT[gl[name]] = Object.assign(dataType, {
        glValue: gl[name],
        uniform: uniform,
        uniformArray: uniformArray
      });
    });
  },

  /**
   * 获取信息
   * @param  {GLenum} type
   * @return {glTypeInfo}
   */
  get: function get(type) {
    return DATA_DICT[type];
  }
};
/* harmony default export */ var renderer_glType = (glType);
/**
 * @typedef {Object} glTypeInfo
 * @property {String} name 名字，e.g. FLOAT_VEC2
 * @property {Number} byteSize 字节大小
 * @property {String} uniformFuncName uniform方法名字，e.g. uniform3f
 * @property {String} type 类型，可以是 Scalar, Vector, Matrix
 * @property {Number} size 数量
 * @property {GLenum} glValue gl enum值
 * @property {function} uniform uniform单个值方法
 * @property {function} uniformArray uniform多个值方法
 */
// CONCATENATED MODULE: ./src/renderer/Program.js







var Program_cache = new utils_Cache();
/**
 * @class
 */

var Program = core_Class.create(
/** @lends Program.prototype */
{
  Statics:
  /** @lends Program */
  {
    /**
     * 缓存
     * @readOnly
     * @return {Cache}
     */
    cache: {
      get: function get() {
        return Program_cache;
      }
    },

    /**
     * 重置缓存
     */
    reset: function reset(gl) {
      // eslint-disable-line no-unused-vars
      Program_cache.each(function (program) {
        program.destroy();
      });
    },

    /**
     * 获取程序
     * @param  {Shader} shader
     * @param  {WebGLState} state
     * @param  {Boolean} [ignoreError=false]
     * @return {Program}
     */
    getProgram: function getProgram(shader, state) {
      var ignoreError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var id = shader.id;
      var program = Program_cache.get(id);

      if (!program) {
        program = new Program({
          state: state,
          vertexShader: shader.vs,
          fragShader: shader.fs,
          ignoreError: ignoreError
        });
        Program_cache.add(id, program);
      }

      return program;
    },

    /**
     * 获取空白程序
     * @param  {WebGLState} state
     * @return {Program}
     */
    getBlankProgram: function getBlankProgram(state) {
      var shader = shader_Shader.getCustomShader('void main(){}', 'precision HILO_MAX_FRAGMENT_PRECISION float;void main(){gl_FragColor = vec4(0.0);}', '', '__hiloBlankShader');
      return this.getProgram(shader, state, true);
    }
  },

  /**
   * @default Program
   * @type {String}
   */
  className: 'Program',

  /**
   * @default true
   * @type {Boolean}
   */
  isProgram: true,

  /**
   * 片段代码
   * @type {String}
   * @default ''
   */
  fragShader: '',

  /**
   * 顶点代码
   * @type {String}
   * @default ''
   */
  vertexShader: '',

  /**
   * attribute 集合
   * @type {Object}
   * @default null
   */
  attributes: null,

  /**
   * uniform 集合
   * @type {Object}
   * @default null
   */
  uniforms: null,

  /**
   * program
   * @type {WebGLProgram}
   * @default null
   */
  program: null,

  /**
   * gl
   * @type {WebGLRenderingContext}
   */
  gl: null,

  /**
   * webglState
   * @type {WebGLState}
   * @default null
   */
  state: null,

  /**
   * 是否始终使用
   * @default true
   * @type {Boolean}
   */
  alwaysUse: false,

  /**
   * @constructs
   * @param  {Object} [params] 初始化参数，所有params都会复制到实例上
   * @param  {WebGLState} params.state WebGL state
   */
  constructor: function constructor(params) {
    /**
     * id
     * @type {String}
     */
    this.id = math_math.generateUUID(this.className);
    Object.assign(this, params);
    this._dict = {};
    this.attributes = {};
    this.uniforms = {};
    this.gl = this.state.gl;
    this.program = this.createProgram();

    if (this.program) {
      this.initAttributes();
      this.initUniforms();
      return this;
    }

    if (this.ignoreError) {
      return this;
    }

    return Program.getBlankProgram(params.state);
  },

  /**
   * 生成 program
   * @return {WebGLProgram}
   */
  createProgram: function createProgram() {
    var gl = this.gl;
    var program = gl.createProgram();
    var vertexShader = this.createShader(gl.VERTEX_SHADER, this.vertexShader);
    var fragShader = this.createShader(gl.FRAGMENT_SHADER, this.fragShader);

    if (vertexShader && fragShader) {
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragShader);
      gl.linkProgram(program);
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragShader);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var error = gl.getProgramInfoLog(program);
        utils_log.error('compileProgramError: ' + error, this);
        gl.deleteProgram(program);
        return null;
      }

      return program;
    }

    return null;
  },

  /**
   * 使用 program
   */
  useProgram: function useProgram() {
    this.state.useProgram(this.program);
  },

  /**
   * 生成 shader
   * @param  {Number} shaderType
   * @param  {String} code
   * @return {WebGLShader}
   */
  createShader: function createShader(shaderType, code) {
    var gl = this.gl;
    var shader = gl.createShader(shaderType);
    gl.shaderSource(shader, code);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      var error = gl.getShaderInfoLog(shader);
      utils_log.error('compileShaderError: ' + error, code.split('\n').map(function (line, index) {
        return "".concat(index + 1, " ").concat(line);
      }).join('\n'));
      return null;
    }

    return shader;
  },

  /**
   * 初始化 attribute 信息
   */
  initAttributes: function initAttributes() {
    var _this = this;

    var gl = this.gl;
    var program = this.program;
    var num = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    var instancedExtension = renderer_extensions.instanced;

    var _loop = function _loop(i) {
      var _gl$getActiveAttrib = gl.getActiveAttrib(program, i),
          name = _gl$getActiveAttrib.name,
          type = _gl$getActiveAttrib.type,
          size = _gl$getActiveAttrib.size;

      var location = gl.getAttribLocation(program, name);
      var glTypeInfo = renderer_glType.get(type);

      var pointer = function pointer(_ref) {
        var _ref$type = _ref.type,
            type = _ref$type === void 0 ? gl.FLOAT : _ref$type,
            _ref$normalized = _ref.normalized,
            normalized = _ref$normalized === void 0 ? false : _ref$normalized,
            _ref$stride = _ref.stride,
            stride = _ref$stride === void 0 ? 0 : _ref$stride,
            _ref$offset = _ref.offset,
            offset = _ref$offset === void 0 ? 0 : _ref$offset;
        gl.vertexAttribPointer(location, glTypeInfo.size, type, normalized, stride, offset);
      };

      var enable = function enable() {
        gl.enableVertexAttribArray(location);
      };

      var divisor = function divisor() {};

      var addTo = function addTo(array, data) {
        array[location] = data;
      };

      if (instancedExtension) {
        divisor = function divisor() {
          var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          instancedExtension.vertexAttribDivisorANGLE(location, d);
        };
      }

      if (glTypeInfo.type === 'Matrix') {
        var matrixStride = glTypeInfo.byteSize;
        var _size = glTypeInfo.size;
        var matSize = Math.sqrt(_size);
        var vectorByteSize = matSize * 4;

        var each = function each(callback) {
          for (var _i = 0; _i < matSize; _i++) {
            callback(location + _i, _i);
          }
        };

        pointer = function pointer(_ref2) {
          var _ref2$type = _ref2.type,
              type = _ref2$type === void 0 ? gl.FLOAT : _ref2$type,
              _ref2$normalized = _ref2.normalized,
              normalized = _ref2$normalized === void 0 ? false : _ref2$normalized,
              _ref2$stride = _ref2.stride,
              stride = _ref2$stride === void 0 ? 0 : _ref2$stride,
              _ref2$offset = _ref2.offset,
              offset = _ref2$offset === void 0 ? 0 : _ref2$offset;
          var realStride;

          if (stride === 0) {
            realStride = matrixStride;
          } else {
            realStride = stride;
          }

          each(function (location, i) {
            gl.vertexAttribPointer(location, matSize, type, normalized, realStride, offset + vectorByteSize * i);
          });
        };

        enable = function enable() {
          each(function (location) {
            gl.enableVertexAttribArray(location);
          });
        };

        addTo = function addTo(array, data) {
          each(function (location) {
            array[location] = data;
          });
        };

        if (instancedExtension) {
          divisor = function divisor() {
            var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            each(function (location) {
              instancedExtension.vertexAttribDivisorANGLE(location, d);
            });
          };
        }
      }

      _this.attributes[name] = {
        name: name,
        location: location,
        type: type,
        size: size,
        glTypeInfo: glTypeInfo,
        pointer: pointer,
        enable: enable,
        divisor: divisor,
        addTo: addTo
      };
    };

    for (var i = 0; i < num; i++) {
      _loop(i);
    }
  },

  /**
   * 初始化 uniform 信息
   */
  initUniforms: function initUniforms() {
    var _this2 = this;

    var gl = this.gl;
    var program = this.program;
    var num = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    var textureIndex = 0;

    var _loop2 = function _loop2(i) {
      var _gl$getActiveUniform = gl.getActiveUniform(program, i),
          name = _gl$getActiveUniform.name,
          size = _gl$getActiveUniform.size,
          type = _gl$getActiveUniform.type;

      name = name.replace(/\[0\]$/, '');
      var location = gl.getUniformLocation(program, name);
      var glTypeInfo = renderer_glType.get(type);
      var uniformArray = glTypeInfo.uniformArray,
          uniform = glTypeInfo.uniform;
      _this2.uniforms[name] = {
        name: name,
        location: location,
        type: type,
        size: size,
        glTypeInfo: glTypeInfo
      };

      if (type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) {
        _this2.uniforms[name].textureIndex = textureIndex;
        textureIndex += size;
      }

      Object.defineProperty(_this2, name, {
        set: glTypeInfo.size > 1 || size > 1 ? function (value) {
          uniformArray(location, value);
        } : function (value) {
          if (_this2._dict[name] !== value) {
            _this2._dict[name] = value;
            uniform(location, value);
          }
        }
      });
    };

    for (var i = 0; i < num; i++) {
      _loop2(i);
    }
  },

  /**
   * 没有被引用时销毁资源
   * @param  {WebGLRenderer} renderer
   * @return {Program} this
   */
  destroyIfNoRef: function destroyIfNoRef(renderer) {
    var resourceManager = renderer.resourceManager;
    resourceManager.destroyIfNoRef(this);
    return this;
  },

  /**
   * 销毁资源
   * @return {Program} this
   */
  destroy: function destroy() {
    if (this._isDestroyed) {
      return this;
    }

    this.gl.deleteProgram(this.program);
    this.uniforms = null;
    this.attributes = null;
    this.program = null;
    this.gl = null;
    this.state = null;
    this._dict = null;
    Program_cache.removeObject(this);
    this._isDestroyed = true;
    return this;
  }
});
/* harmony default export */ var renderer_Program = (Program);
// CONCATENATED MODULE: ./src/renderer/Buffer.js
/* eslint no-buffer-constructor: "off" */




var ARRAY_BUFFER = src_constants.ARRAY_BUFFER,
    ELEMENT_ARRAY_BUFFER = src_constants.ELEMENT_ARRAY_BUFFER,
    STATIC_DRAW = src_constants.STATIC_DRAW;
var Buffer_cache = new utils_Cache();
/**
 * 缓冲
 * @class
 */

var Buffer = core_Class.create(
/** @lends Buffer.prototype */
{
  Statics:
  /** @lends Buffer */
  {
    /**
     * 缓存
     * @readOnly
     * @return {Cache}
     */
    cache: {
      get: function get() {
        return Buffer_cache;
      }
    },

    /**
     * 重置缓存
     */
    reset: function reset(gl) {
      // eslint-disable-line no-unused-vars
      Buffer_cache.each(function (buffer) {
        buffer.destroy();
      });
    },

    /**
     * 生成顶点缓冲
     * @param  {WebGLRenderingContext} gl
     * @param  {GeometryData} geometryData
     * @param  {GLenum} [usage = STATIC_DRAW]
     * @return {Buffer}
     */
    createVertexBuffer: function createVertexBuffer(gl, geometryData) {
      var usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STATIC_DRAW;
      return this.createBuffer(gl, ARRAY_BUFFER, geometryData, usage);
    },
    createBuffer: function createBuffer(gl, target, geometryData, usage) {
      var id = geometryData.bufferViewId;
      var buffer = Buffer_cache.get(id);

      if (buffer) {
        return buffer;
      }

      geometryData.isDirty = false;
      buffer = new Buffer(gl, target, geometryData.data, usage);
      Buffer_cache.add(id, buffer);
      return buffer;
    },

    /**
     * 生成索引缓冲
     * @param  {WebGLRenderingContext} gl
     * @param  {GeometryData} geometryData
     * @param  {GLenum} [usage = STATIC_DRAW]
     * @return {Buffer}
     */
    createIndexBuffer: function createIndexBuffer(gl, geometryData) {
      var usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : STATIC_DRAW;
      return this.createBuffer(gl, ELEMENT_ARRAY_BUFFER, geometryData, usage);
    }
  },

  /**
   * @default Buffer
   * @type {String}
   */
  className: 'Buffer',

  /**
   * @default true
   * @type {Boolean}
   */
  isBuffer: true,

  /**
   * @constructs
   * @param  {WebGLRenderingContext} gl
   * @param  {GLenum} [target = ARRAY_BUFFER]
   * @param  {TypedArray} [data = null]
   * @param  {GLenum} [usage = STATIC_DRAW]
   */
  constructor: function constructor(gl) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ARRAY_BUFFER;
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var usage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STATIC_DRAW;

    /**
     * id
     * @type {String}
     */
    this.id = math_math.generateUUID(this.className);
    this.gl = gl;
    /**
     * target
     * @type {GLenum}
     */

    this.target = target;
    /**
     * usage
     * @type {GLenum}
     */

    this.usage = usage;
    /**
     * buffer
     * @type {WebGLBuffer}
     */

    this.buffer = gl.createBuffer();

    if (data) {
      this.bufferData(data);
    }
  },

  /**
   * 绑定
   * @return {Buffer} this
   */
  bind: function bind() {
    this.gl.bindBuffer(this.target, this.buffer);
    return this;
  },

  /**
   * 上传数据
   * @param  {TypedArray} data
   * @return {Buffer} this
   */
  bufferData: function bufferData(data) {
    var gl = this.gl,
        target = this.target,
        usage = this.usage;
    this.bind();
    gl.bufferData(target, data, usage);
    this.data = data;
    return this;
  },

  /**
   * 上传部分数据
   * @param  {Number} byteOffset
   * @param  {TypedArray} data
   * @param  {Boolean} [isBinding=false]
   * @return {Buffer} this
   */
  bufferSubData: function bufferSubData(byteOffset, data) {
    var isBinding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var gl = this.gl,
        target = this.target;

    if (!isBinding) {
      this.bind();
    }

    gl.bufferSubData(target, byteOffset, data);
    return this;
  },

  /**
   * @param  {GeometryData} geometryData
   * @return {Buffer} this
   */
  uploadGeometryData: function uploadGeometryData(geometryData) {
    var _this = this;

    var subDataList = geometryData.subDataList;

    if (!this.data || this.data.byteLength < geometryData.data.byteLength || geometryData._isAllDirty === true) {
      this.bufferData(geometryData.data);
    } else if (subDataList && subDataList.length) {
      this.bind();
      subDataList.forEach(function (subData) {
        _this.bufferSubData(subData.byteOffset, subData.data, true);
      });
    } else {
      this.bufferData(geometryData.data);
    }

    geometryData.isDirty = false;
    return this;
  },

  /**
   * 没有被引用时销毁资源
   * @param  {WebGLRenderer} renderer
   * @return {Buffer} this
   */
  destroyIfNoRef: function destroyIfNoRef(renderer) {
    var resourceManager = renderer.resourceManager;
    resourceManager.destroyIfNoRef(this);
    return this;
  },

  /**
   * 销毁资源
   * @return {Buffer} this
   */
  destroy: function destroy() {
    if (this._isDestroyed) {
      return this;
    }

    this.gl.deleteBuffer(this.buffer);
    this.data = null;
    Buffer_cache.removeObject(this);
    this._isDestroyed = true;
    return this;
  }
});
/* harmony default export */ var renderer_Buffer = (Buffer);
// CONCATENATED MODULE: ./src/utils/bufferUtil.js
var cachedBuffer = new ArrayBuffer(1);
var bufferUtil = {
  getTypedArray: function getTypedArray(constructor, length) {
    this._updateBuffer(length * constructor.BYTES_PER_ELEMENT);

    return new constructor(cachedBuffer, 0, length);
  },
  fillArrayData: function fillArrayData(typedArray, data) {
    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    for (var i = 0, l = data.length; i < l; i++) {
      typedArray[offset + i] = data[i];
    }
  },
  _updateBuffer: function _updateBuffer(byteSize) {
    if (cachedBuffer.byteLength < byteSize) {
      cachedBuffer = new ArrayBuffer(byteSize * 2);
    }
  }
};
/* harmony default export */ var utils_bufferUtil = (bufferUtil);
// CONCATENATED MODULE: ./src/renderer/VertexArrayObject.js








var VertexArrayObject_TRIANGLES = src_constants.TRIANGLES;
var globalStates = [];
var currentVao = null;
var VertexArrayObject_cache = new utils_Cache();
/**
 * VAO
 * @class
 */

var VertexArrayObject = core_Class.create(
/** @lends VertexArrayObject.prototype */
{
  Statics: {
    /**
     * 缓存
     * @readOnly
     * @memberOf VertexArrayObject
     * @return {Cache}
     */
    cache: {
      get: function get() {
        return VertexArrayObject_cache;
      }
    },

    /**
     * 获取 vao
     * @memberOf VertexArrayObject
     * @param  {WebGLRenderingContext} gl
     * @param  {String} id  缓存id
     * @param  {Object} params
     * @return {VertexArrayObject}
     */
    getVao: function getVao(gl, id, params) {
      var vao = VertexArrayObject_cache.get(id);

      if (!vao) {
        vao = new VertexArrayObject(gl, id, params);
        VertexArrayObject_cache.add(id, vao);
      } else if (params.mode && params.mode !== vao.mode) {
        // for geometry.mode change
        vao.mode = params.mode;
      }

      return vao;
    },

    /**
     * 重置所有vao
     * @memberOf VertexArrayObject
     * @param  {WebGLRenderingContext} gl
     */
    reset: function reset(gl) {
      // eslint-disable-line no-unused-vars
      currentVao = null;
      globalStates = [];
      this.bindSystemVao();
      VertexArrayObject_cache.each(function (vao) {
        vao.destroy(gl);
      });
    },

    /**
     * 绑定系统vao
     * @memberOf VertexArrayObject
     */
    bindSystemVao: function bindSystemVao() {
      if (renderer_extensions.vao) {
        renderer_extensions.vao.bindVertexArrayOES(null);
      }

      currentVao = null;
    }
  },

  /**
   * @default VertexArrayObject
   * @type {String}
   */
  className: 'VertexArrayObject',

  /**
   * @default true
   * @type {Boolean}
   */
  isVertexArrayObject: true,

  /**
   * 顶点数量
   * @type {Number}
   * @private
   */
  vertexCount: null,

  /**
   * 是否使用 vao
   * @type {Boolean}
   * @default false
   */
  useVao: false,

  /**
   * 是否使用 instanced
   * @type {Boolean}
   * @default false
   */
  useInstanced: false,

  /**
   * 绘图方式
   * @type {GLenum}
   * @default gl.TRIANGLES
   */
  mode: VertexArrayObject_TRIANGLES,

  /**
   * 是否脏
   * @type {Boolean}
   * @default true
   */
  isDirty: true,

  /**
   * @constructs
   * @param  {WebGLRenderingContext} gl
   * @param  {String} id  缓存id
   * @param  {Object} params
   */
  constructor: function constructor(gl, id, params) {
    this.gl = gl;
    this.id = id;
    this.vaoExtension = renderer_extensions.vao;
    this.instancedExtension = renderer_extensions.instanced;
    Object.assign(this, params);

    if (!this.vaoExtension) {
      this.useVao = false;
    }

    if (!this.instancedExtension) {
      this.useInstanced = false;
    }

    if (this.useVao) {
      this.vao = this.vaoExtension.createVertexArrayOES();
    }

    this.attributes = [];
    this.activeStates = [];
    this.indexBuffer = null;
  },

  /**
   * bind
   */
  bind: function bind() {
    if (currentVao !== this) {
      if (this.useVao) {
        this.vaoExtension.bindVertexArrayOES(this.vao);
      } else {
        this.bindSystemVao();
      }

      currentVao = this;
    }
  },

  /**
   * @private
   */
  bindSystemVao: function bindSystemVao() {
    var gl = this.gl;

    if (currentVao && currentVao.useVao) {
      currentVao.unbind();
    }

    var activeStates = this.activeStates;
    var lastBuffer;
    this.attributes.forEach(function (attributeObject) {
      var buffer = attributeObject.buffer,
          attribute = attributeObject.attribute,
          geometryData = attributeObject.geometryData;

      if (lastBuffer !== buffer) {
        lastBuffer = buffer;
        buffer.bind();
      }

      attribute.enable();
      attribute.pointer(geometryData);

      if (attributeObject.useInstanced) {
        attribute.divisor(1);
      } else {
        attribute.divisor(0);
      }
    });
    globalStates.forEach(function (globalAttributeObject, i) {
      var activeAttributeObject = activeStates[i];

      if (globalAttributeObject && !activeAttributeObject) {
        globalAttributeObject.attribute.divisor(0);
        gl.disableVertexAttribArray(i);
      }
    });

    if (this.indexBuffer) {
      this.indexBuffer.bind();
    }

    globalStates = activeStates;
  },

  /**
   * unbind
   */
  unbind: function unbind() {
    if (this.useVao) {
      this.vaoExtension.bindVertexArrayOES(null);
    }

    currentVao = null;
  },

  /**
   * draw
   */
  draw: function draw() {
    this.bind();
    var gl = this.gl,
        mode = this.mode;

    if (this.indexBuffer) {
      gl.drawElements(mode, this.vertexCount, this.indexType, 0);
    } else {
      gl.drawArrays(mode, 0, this.getVertexCount());
    }
  },

  /**
   * 获取顶点数量
   * @return {Number} 顶点数量
   */
  getVertexCount: function getVertexCount() {
    if (this.vertexCount === null) {
      var attributeObj = this.attributes[0];

      if (attributeObj) {
        this.vertexCount = attributeObj.geometryData.count;
      } else {
        this.vertexCount = 0;
      }
    }

    return this.vertexCount;
  },

  /**
   * drawInstance
   * @param  {Number} [primcount=1]
   */
  drawInstance: function drawInstance() {
    var primcount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    this.bind();
    var gl = this.gl,
        mode = this.mode;

    if (this.useInstanced) {
      if (this.indexBuffer) {
        this.instancedExtension.drawElementsInstancedANGLE(mode, this.vertexCount, gl.UNSIGNED_SHORT, 0, primcount);
      } else {
        this.instancedExtension.drawArraysInstancedANGLE(mode, 0, this.getVertexCount(), primcount);
      }
    }
  },

  /**
   * addIndexBuffer
   * @param {GeometryData} data
   * @param {GLenum} usage gl.STATIC_DRAW|gl.DYNAMIC_DRAW
   * @return {Buffer} Buffer
   */
  addIndexBuffer: function addIndexBuffer(geometryData, usage) {
    this.bind();
    var gl = this.gl;
    var buffer = this.indexBuffer;
    this.indexType = geometryData.type;

    if (!buffer) {
      buffer = renderer_Buffer.createIndexBuffer(gl, geometryData, usage);
      buffer.bind();
      this.indexBuffer = buffer;
      this.vertexCount = geometryData.length;
    } else if (geometryData.isDirty) {
      buffer.uploadGeometryData(geometryData);
      this.vertexCount = geometryData.length;
    }

    return buffer;
  },

  /**
   * addAttribute
   * @param {GeometryData} geometryData
   * @param {Object} attribute
   * @param {GLenum} usage gl.STATIC_DRAW|gl.DYNAMIC_DRAW
   * @param {Function} onInit
   * @return {AttributeObject} attributeObject
   */
  addAttribute: function addAttribute(geometryData, attribute, usage, onInit) {
    this.bind();
    var gl = this.gl;
    var name = attribute.name;
    var attributeObject = this[name];

    if (!attributeObject) {
      var buffer = renderer_Buffer.createVertexBuffer(gl, geometryData, usage);
      buffer.bind();
      attribute.enable();
      attribute.pointer(geometryData);
      attributeObject = {
        attribute: attribute,
        buffer: buffer,
        geometryData: geometryData
      };
      this.attributes.push(attributeObject);
      this[name] = attributeObject;
      attribute.addTo(this.activeStates, attributeObject);

      if (onInit) {
        onInit(attributeObject);
      }
    }

    if (geometryData.isDirty) {
      var _buffer = attributeObject.buffer;

      _buffer.bind();

      attribute.enable();
      attribute.pointer(geometryData);

      _buffer.uploadGeometryData(geometryData);
    }

    return attributeObject;
  },

  /**
   * addInstancedAttribute
   * @param {Object} attribute
   * @param {Array} meshes
   * @param {function} getData
   * @return {AttributeObject} attributeObject
   */
  addInstancedAttribute: function addInstancedAttribute(attribute, meshes, getData) {
    this.bind();
    var gl = this.gl;
    var name = attribute.name,
        glTypeInfo = attribute.glTypeInfo;
    var instancedData = utils_bufferUtil.getTypedArray(Float32Array, meshes.length * glTypeInfo.size);
    meshes.forEach(function (mesh, index) {
      var attributeData = getData(mesh);

      if (attributeData !== undefined) {
        utils_bufferUtil.fillArrayData(instancedData, getData(mesh), index * glTypeInfo.size);
      } else {
        utils_log.warn('no attributeData:' + name + '-' + mesh.name);
      }
    });
    var attributeObject = this[name];
    var geometryData;

    if (attributeObject) {
      geometryData = attributeObject.geometryData;
      geometryData.data = instancedData;
    } else {
      geometryData = new geometry_GeometryData(instancedData, 1);
    }

    return this.addAttribute(geometryData, attribute, gl.DYNAMIC_DRAW, function (attributeObject) {
      attribute.divisor(1);
      attributeObject.useInstanced = true;
    });
  },

  /**
   * 获取资源
   * @param {Object[]} [resources=[]]
   * @return {Object[]}
   */
  getResources: function getResources() {
    var resources = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    this.attributes.forEach(function (attributeObject) {
      resources.push(attributeObject.buffer);
    });

    if (this.indexBuffer) {
      resources.push(this.indexBuffer);
    }

    return resources;
  },

  /**
   * 没有被引用时销毁资源
   * @param  {WebGLRenderer} renderer
   * @return {VertexArrayObject} this
   */
  destroyIfNoRef: function destroyIfNoRef(renderer) {
    var resourceManager = renderer.resourceManager;
    resourceManager.destroyIfNoRef(this);
    return this;
  },

  /**
   * 销毁资源
   * @return {VertexArrayObject} this
   */
  destroy: function destroy() {
    var _this = this;

    if (this._isDestroyed) {
      return this;
    }

    this.instancedExtension = null;

    if (this.useVao) {
      this.vaoExtension.deleteVertexArrayOES(this.vao);
      this.vao = null;
      this.vaoExtension = null;
    }

    this.gl = null;
    this.indexBuffer = null;
    this.attributes.forEach(function (attributeObject) {
      var attribute = attributeObject.attribute || {};
      _this[attribute.name] = null;
    });
    this.attributes = null;
    this.activeStates = null;
    VertexArrayObject_cache.removeObject(this);
    this._isDestroyed = true;
    return this;
  }
});
/* harmony default export */ var renderer_VertexArrayObject = (VertexArrayObject);
/**
 * 顶点对象
 * @typedef {object} AttributeObject
 * @property {Object} attribute
 * @property {WebGLBuffer} buffer
 * @property {GeometryData} geometryData
 * @property {Boolean} useInstanced
 */
// CONCATENATED MODULE: ./src/texture/Texture.js







var TEXTURE_2D = src_constants.TEXTURE_2D,
    RGBA = src_constants.RGBA,
    Texture_LINEAR = src_constants.LINEAR,
    NEAREST = src_constants.NEAREST,
    REPEAT = src_constants.REPEAT,
    CLAMP_TO_EDGE = src_constants.CLAMP_TO_EDGE,
    Texture_UNSIGNED_BYTE = src_constants.UNSIGNED_BYTE;
var Texture_cache = new utils_Cache();
/**
 * 纹理
 * @class
 * @example
 * var loader = new Hilo3d.BasicLoader();
 * loader.load({
 *     src: '//img.alicdn.com/tfs/TB1aNxtQpXXXXX1XVXXXXXXXXXX-1024-1024.jpg',
 *     crossOrigin: true
 * }).then(img => {
 *     return new Hilo3d.Texture({
 *         image: img
 *     });
 * });
 */

var Texture = core_Class.create(
/** @lends Texture.prototype */
{
  Statics: {
    /**
     * 缓存
     * @memberOf Texture
     * @readOnly
     * @type {Object}
     */
    cache: {
      get: function get() {
        return Texture_cache;
      }
    },

    /**
     * 重置
     * @memberOf Texture
     * @param  {WebGLRenderingContext} gl
     */
    reset: function reset(gl) {
      Texture_cache.each(function (glTexture, id) {
        gl.deleteTexture(glTexture);
        Texture_cache.remove(id);
      });
    }
  },

  /**
   * @default true
   * @type {boolean}
   */
  isTexture: true,

  /**
   * @default Texture
   * @type {string}
   */
  className: 'Texture',

  /**
   * 图片资源是否可以释放，可以的话，上传到GPU后将释放图片引用
   * @type {boolean}
   * @default false
   */
  isImageCanRelease: false,
  _isImageReleased: false,
  _image: null,

  /**
   * 图片对象
   * @type {HTMLImageElement}
   * @default null
   */
  image: {
    get: function get() {
      if (this._isImageReleased) {
        utils_log.errorOnce("Read Texture.image(".concat(this.id, ")"), 'Read Texture.image after image released!');
      }

      return this._image;
    },
    set: function set(_img) {
      this._image = _img;
      this._isImageReleased = false;
    }
  },
  _releaseImage: function _releaseImage() {
    this._canvasImage = null;
    this._canvasCtx = null;
    this._originImage = null;
    this._image = null;
    this.mipmaps = null;
    this._isImageReleased = true;
  },

  /**
   * mipmaps
   * @type {HTMLImageElement[]|TypedArray[]}
   * @default null
   */
  mipmaps: null,

  /**
   * Texture Target
   * @default gl.TEXTURE_2D
   * @type {GLenum}
   */
  target: TEXTURE_2D,

  /**
   * Texture Internal Format
   * @default gl.RGBA
   * @type {GLenum}
   */
  internalFormat: RGBA,

  /**
   * 图片 Format
   * @default gl.RGBA
   * @type {GLenum}
   */
  format: RGBA,

  /**
   * 类型
   * @default gl.UNSIGNED_BYTE
   * @type {GLenum}
   */
  type: Texture_UNSIGNED_BYTE,

  /**
   * @default 0
   * @type {number}
   */
  width: 0,

  /**
   * @default 0
   * @type {number}
   */
  height: 0,

  /**
   * @default 0
   * @readOnly
   * @type {Number}
   */
  border: 0,

  /**
   * magFilter
   * @default gl.LINEAR
   * @type {GLenum}
   */
  magFilter: Texture_LINEAR,

  /**
   * minFilter
   * @default gl.LINEAR
   * @type {GLenum}
   */
  minFilter: Texture_LINEAR,

  /**
   * wrapS
   * @default gl.REPEAT
   * @type {GLenum}
   */
  wrapS: REPEAT,

  /**
   * wrapT
   * @default gl.REPEAT
   * @type {GLenum}
   */
  wrapT: REPEAT,

  /**
   * @type {string}
   */
  name: '',

  /**
   * @default false
   * @type {boolean}
   */
  premultiplyAlpha: false,

  /**
   * 是否翻转Texture的Y轴
   * @default false
   * @type {boolean}
   */
  flipY: false,

  /**
   * 是否压缩
   * @default false
   * @type {Boolean}
   */
  compressed: false,

  /**
   * 是否需要更新Texture
   * @default true
   * @type {boolean}
   */
  needUpdate: true,

  /**
   * 是否需要销毁之前的Texture，Texture参数变更之后需要销毁
   * @default false
   * @type {boolean}
   */
  needDestroy: false,

  /**
   * 是否每次都更新Texture
   * @default false
   * @type {boolean}
   */
  autoUpdate: false,

  /**
   * uv
   * @default 0
   * @type {Number}
   */
  uv: 0,

  /**
   * anisotropic
   * @default 1
   * @type {Number}
   */
  anisotropic: 1,

  /**
   * 获取原始图像宽度。
   * @default 0
   * @type {Number}
   */
  origWidth: {
    get: function get() {
      if (this._originImage) {
        return this._originImage.width || this.width;
      }

      if (this.image) {
        return this.image.width || this.width;
      }

      return this.width;
    }
  },

  /**
   * 获取原始图像高度。
   * @default 0
   * @type {Number}
   */
  origHeight: {
    get: function get() {
      if (this.originImage) {
        return this._originImage.height || this.height;
      }

      if (this.image) {
        return this.image.height || this.height;
      }

      return this.height;
    }
  },

  /**
   * 是否使用 mipmap
   * @readOnly
   * @type {Boolean}
   */
  useMipmap: {
    get: function get() {
      return this.minFilter !== Texture_LINEAR && this.minFilter !== NEAREST;
    },
    set: function set() {
      utils_log.warn('texture.useMipmap is readOnly!');
    }
  },

  /**
   * 是否使用 repeat
   * @readOnly
   * @type {Boolean}
   */
  useRepeat: {
    get: function get() {
      return this.wrapS !== CLAMP_TO_EDGE || this.wrapT !== CLAMP_TO_EDGE;
    },
    set: function set() {
      utils_log.warn('texture.useRepeat is readOnly!');
    }
  },

  /**
   * mipmapCount
   * @readOnly
   * @type {Number}
   */
  mipmapCount: {
    get: function get() {
      return Math.floor(Math.log2(Math.max(this.width, this.height)) + 1);
    },
    set: function set() {
      utils_log.warn('texture.mipmapCount is readOnly!');
    }
  },

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    this.id = math_math.generateUUID(this.className);
    Object.assign(this, params);
  },

  /**
   * 是否是 2 的 n 次方
   * @param  {HTMLImageElement}  img
   * @return {Boolean}
   */
  isImgPowerOfTwo: function isImgPowerOfTwo(img) {
    return math_math.isPowerOfTwo(img.width) && math_math.isPowerOfTwo(img.height);
  },

  /**
   * 获取支持的尺寸
   * @param  {HTMLImageElement} img
   * @param  {Boolean} [needPowerOfTwo=false]
   * @return {Object} { width, height }
   */
  getSupportSize: function getSupportSize(img) {
    var needPowerOfTwo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var width = img.width;
    var height = img.height;

    if (needPowerOfTwo && !this.isImgPowerOfTwo(img)) {
      width = math_math.nextPowerOfTwo(width);
      height = math_math.nextPowerOfTwo(height);
    }

    var maxTextureSize = renderer_capabilities.MAX_TEXTURE_SIZE;

    if (maxTextureSize) {
      if (width > maxTextureSize) {
        width = maxTextureSize;
      }

      if (height > maxTextureSize) {
        height = maxTextureSize;
      }
    }

    return {
      width: width,
      height: height
    };
  },

  /**
   * 更新图片大小成为 2 的 n 次方
   * @param  {HTMLImageElement} img
   * @return {HTMLCanvasElement|HTMLImageElement}
   */
  resizeImgToPowerOfTwo: function resizeImgToPowerOfTwo(img) {
    var sizeResult = this.getSupportSize(img, true);
    return this.resizeImg(img, sizeResult.width, sizeResult.height);
  },

  /**
   * 更新图片大小
   * @param  {HTMLImageElement} img
   * @param {Number} width
   * @param {Number} height
   * @return {HTMLCanvasElement|HTMLImageElement}
   */
  resizeImg: function resizeImg(img, width, height) {
    if (img.width === width && img.height === height) {
      return img;
    }

    var canvas = this._canvasImage;

    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      this._canvasImage = canvas;
      this._canvasCtx = canvas.getContext('2d');
    } else {
      canvas.width = width;
      canvas.height = height;
      this._canvasCtx = canvas.getContext('2d');
    }

    this._canvasCtx.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);

    utils_log.warnOnce("Texture.resizeImg(".concat(this.id, ")"), "image size(".concat(img.width, "x").concat(img.height, ") is not support. Resized to ").concat(canvas.width, "x").concat(canvas.height), img.src);
    this._originImage = img;
    return canvas;
  },

  /**
   * GL上传贴图
   * @private
   * @param  {WebGLState} state
   * @param  {GLenum} target
   * @param  {HTMLImageElement|TypedArray} image
   * @param  {HTMLImageElement} [level=0]
   * @param  {Number} [width=this.width]
   * @param  {Number} [height=this.height]
   * @return {Texture}  this
   */
  _glUploadTexture: function _glUploadTexture(state, target, image) {
    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var width = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.width;
    var height = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.height;
    var gl = state.gl;

    if (this.compressed) {
      gl.compressedTexImage2D(target, level, this.internalFormat, width, height, this.border, image);
    } else if (image && image.width !== undefined) {
      gl.texImage2D(target, level, this.internalFormat, this.format, this.type, image);
    } else {
      gl.texImage2D(target, level, this.internalFormat, width, height, this.border, this.format, this.type, image);
    }

    return this;
  },

  /**
   * 上传贴图，子类可重写
   * @private
   * @param  {WebGLState} state
   * @return {Texture} this
   */
  _uploadTexture: function _uploadTexture(state) {
    var _this = this;

    if (this.useMipmap && this.mipmaps) {
      this.mipmaps.forEach(function (mipmap, index) {
        _this._glUploadTexture(state, _this.target, mipmap.data, index, mipmap.width, mipmap.height);
      });
    } else {
      this._glUploadTexture(state, this.target, this.image, 0);
    }

    return this;
  },

  /**
   * 更新 Texture
   * @param  {WebGLState} state
   * @param  {WebGLTexture} glTexture
   * @return {Texture} this
   */
  updateTexture: function updateTexture(state, glTexture) {
    var gl = state.gl;

    if (this.needUpdate || this.autoUpdate) {
      if (this._originImage && this.image === this._canvasImage) {
        this.image = this._originImage;
      }

      var useMipmap = this.useMipmap;
      var useRepeat = this.useRepeat;

      if (this.image && !this.image.length) {
        var needPowerOfTwo = useRepeat || useMipmap;
        var sizeResult = this.getSupportSize(this.image, needPowerOfTwo);
        this.image = this.resizeImg(this.image, sizeResult.width, sizeResult.height);
        this.width = this.image.width;
        this.height = this.image.height;
      }

      state.activeTexture(gl.TEXTURE0 + renderer_capabilities.MAX_TEXTURE_INDEX);
      state.bindTexture(this.target, glTexture);
      state.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
      state.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!this.flipY);
      var textureFilterAnisotropic = renderer_extensions.textureFilterAnisotropic;

      if (textureFilterAnisotropic && this.anisotropic > 1) {
        gl.texParameterf(this.target, textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this.anisotropic, renderer_capabilities.MAX_TEXTURE_MAX_ANISOTROPY));
      }

      this._uploadTexture(state);

      if (useMipmap) {
        if (!this.compressed) {
          gl.generateMipmap(this.target);
        } else if (!this.mipmaps) {
          utils_log.warn("Compressed texture has no mipmips, changed the minFilter from ".concat(this.minFilter, " to Linear!"), this);
          this.minFilter = Texture_LINEAR;
        }
      }

      gl.texParameterf(this.target, gl.TEXTURE_MAG_FILTER, this.magFilter);
      gl.texParameterf(this.target, gl.TEXTURE_MIN_FILTER, this.minFilter);
      gl.texParameterf(this.target, gl.TEXTURE_WRAP_S, this.wrapS);
      gl.texParameterf(this.target, gl.TEXTURE_WRAP_T, this.wrapT);
      this.needUpdate = false;
    }

    if (this._needUpdateSubTexture) {
      this._uploadSubTextures(state, glTexture);

      this._needUpdateSubTexture = false;
    }

    return this;
  },

  /**
   * 跟新所有的局部贴图
   * @private
   * @param  {WebGLState} state
   * @param  {WebGLTexture} glTexture
   */
  _uploadSubTextures: function _uploadSubTextures(state, glTexture) {
    var _this2 = this;

    if (this._subTextureList && this._subTextureList.length > 0) {
      var gl = state.gl;
      state.activeTexture(gl.TEXTURE0 + renderer_capabilities.MAX_TEXTURE_INDEX);
      state.bindTexture(this.target, glTexture);
      state.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
      state.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!this.flipY);

      this._subTextureList.forEach(function (subInfo) {
        var xOffset = subInfo[0];
        var yOffset = subInfo[1];
        var image = subInfo[2];
        gl.texSubImage2D(_this2.target, 0, xOffset, yOffset, _this2.format, _this2.type, image);
      });

      this._subTextureList.length = 0;
    }
  },
  _needUpdateSubTexture: false,
  _subTextureList: null,

  /**
   * 跟新局部贴图
   * @param  {Number} xOffset
   * @param  {Number} yOffset
   * @param  {HTMLImageElement|HTMLCanvasElement|ImageData} image
   */
  updateSubTexture: function updateSubTexture(xOffset, yOffset, image) {
    if (!this._subTextureList) {
      this._subTextureList = [];
    }

    this._subTextureList.push([xOffset, yOffset, image]);

    this._needUpdateSubTexture = true;
  },

  /**
   * 获取 GLTexture
   * @param  {WebGLState} state
   * @return {WebGLTexture}
   */
  getGLTexture: function getGLTexture(state) {
    this.state = state;
    var gl = this.gl = state.gl;
    var id = this.id;

    if (this.needDestroy) {
      this.destroy();
      this.needDestroy = false;
    }

    var glTexture = Texture_cache.get(id);

    if (glTexture) {
      this.updateTexture(state, glTexture);
    } else {
      glTexture = gl.createTexture();
      Texture_cache.add(id, glTexture);
      this.needUpdate = true;
      this.updateTexture(state, glTexture);
    }

    if (this.isImageCanRelease) {
      this._releaseImage();
    }

    return glTexture;
  },

  /**
   * 设置 GLTexture
   * @param {WebGLTexture}  texture
   * @param {Boolean} [needDestroy=false] 是否销毁之前的 GLTexture
   * @return {Texture} this
   */
  setGLTexture: function setGLTexture(texture) {
    var needDestroy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (needDestroy) {
      this.destroy();
    }

    Texture_cache.add(this.id, texture);
    return this;
  },

  /**
   * 销毁当前Texture
   * @return {Texture} this
   */
  destroy: function destroy() {
    var id = this.id;
    var glTexture = Texture_cache.get(id);

    if (glTexture && this.gl) {
      this.gl.deleteTexture(glTexture);
      Texture_cache.remove(id);
    }

    return this;
  },

  /**
   * clone
   * @return {Texture}
   */
  clone: function clone() {
    var option = Object.assign({}, this);
    delete option.id;
    var texture = new this.constructor(option);
    return texture;
  }
});
/* harmony default export */ var texture_Texture = (Texture);
// CONCATENATED MODULE: ./src/renderer/Framebuffer.js














var Framebuffer_TEXTURE_2D = src_constants.TEXTURE_2D,
    Framebuffer_RGBA = src_constants.RGBA,
    Framebuffer_UNSIGNED_BYTE = src_constants.UNSIGNED_BYTE,
    COLOR_ATTACHMENT0 = src_constants.COLOR_ATTACHMENT0,
    DEPTH_STENCIL = src_constants.DEPTH_STENCIL,
    DEPTH_TEST = src_constants.DEPTH_TEST,
    CULL_FACE = src_constants.CULL_FACE,
    TRIANGLE_STRIP = src_constants.TRIANGLE_STRIP,
    Framebuffer_NEAREST = src_constants.NEAREST,
    Framebuffer_CLAMP_TO_EDGE = src_constants.CLAMP_TO_EDGE;
var Framebuffer_cache = new utils_Cache();
/**
 * 帧缓冲
 * @class
 */

var Framebuffer = core_Class.create(
/** @lends Framebuffer.prototype */
{
  Statics: {
    /**
     * 缓存
     * @readOnly
     * @memberOf Framebuffer
     * @type {Cache}
     */
    cache: {
      get: function get() {
        return Framebuffer_cache;
      }
    },

    /**
     * 重置所有framebuffer
     * @memberOf Framebuffer
     * @param  {WebGLRenderingContext} gl
     */
    reset: function reset(gl) {
      // eslint-disable-line no-unused-vars
      Framebuffer_cache.each(function (framebuffer) {
        framebuffer.reset();
      });
    },

    /**
     * 销毁所有 Framebuffer
     * @memberOf Framebuffer
     * @param  {WebGLRenderingContext} gl
     */
    destroy: function destroy(gl) {
      // eslint-disable-line no-unused-vars
      Framebuffer_cache.each(function (framebuffer) {
        framebuffer.destroy();
      });
    }
  },

  /**
   * @default Framebuffer
   * @type {String}
   */
  className: 'Framebuffer',

  /**
   * @default true
   * @type {Boolean}
   */
  isFramebuffer: true,

  /**
   * bufferInternalFormat
   * @type {GLenum}
   * @default gl.DEPTH_STENCIL
   */
  bufferInternalFormat: DEPTH_STENCIL,

  /**
   * texture target
   * @type {GLenum}
   * @default gl.TEXTURE_2D
   */
  target: Framebuffer_TEXTURE_2D,

  /**
   * texture format
   * @type {GLenum}
   * @default gl.RGBA
   */
  format: Framebuffer_RGBA,

  /**
   * texture internalFormat
   * @type {GLenum}
   * @default gl.RGBA
   */
  internalFormat: Framebuffer_RGBA,

  /**
   * texture type
   * @type {GLenum}
   * @default gl.UNSIGNED_BYTE
   */
  type: Framebuffer_UNSIGNED_BYTE,

  /**
   * texture minFilter
   * @type {GLenum}
   * @default gl.NEAREST
   */
  minFilter: Framebuffer_NEAREST,

  /**
   * texture magFilter
   * @type {GLenum}
   * @default gl.NEAREST
   */
  magFilter: Framebuffer_NEAREST,

  /**
   * texture data
   * @type {TypedArray}
   * @default null
   */
  data: null,

  /**
   * attachment
   * @type {GLenum}
   * @default gl.COLOR_ATTACHMENT0
   */
  attachment: COLOR_ATTACHMENT0,

  /**
   * 是否需要renderbuffer
   * @type {Boolean}
   * @default true
   */
  needRenderbuffer: true,

  /**
   * 是否使用VAO
   * @type {Boolean}
   * @default true
   */
  useVao: true,

  /**
   * renderer
   * @type {WebGLRenderer}
   * @default null
   */
  renderer: null,

  /**
   * texture
   * @type {Texture}
   */
  texture: null,

  /**
   * renderbuffer
   * @type {WebGLRenderbuffer}
   */
  renderbuffer: null,

  /**
   * framebuffer
   * @type {WebGLFramebuffer}
   */
  framebuffer: null,
  _isInit: false,

  /**
   * @constructs
   * @param {WebGLRenderer}  renderer
   * @param  {Object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(renderer, params) {
    this.id = math_math.generateUUID(this.className);
    this.renderer = renderer;
    Object.assign(this, params);

    if (!this.width) {
      this.width = renderer.width;
    }

    if (!this.height) {
      this.height = renderer.height;
    }

    Framebuffer_cache.add(this.id, this);
  },

  /**
   * init
   * @private
   */
  init: function init() {
    if (!this._isInit && this.renderer.isInit) {
      this._isInit = true;
      var renderer = this.renderer;
      this.gl = renderer.gl;
      this.state = renderer.state;
      this.reset();
    }
  },

  /**
   * reset
   * @private
   */
  reset: function reset() {
    this.destroyResource();
    var gl = this.gl;
    /**
     * framebuffer
     * @type {WebGLFramebuffer}
     */

    this.framebuffer = gl.createFramebuffer();
    this.bind();

    if (this.needRenderbuffer) {
      this.renderbuffer = this.createRenderbuffer();
    }

    this.texture = this.createTexture();

    if (!this.isComplete()) {
      utils_log.warn('Framebuffer is not complete => ' + gl.checkFramebufferStatus(gl.FRAMEBUFFER));
    }

    this.unbind();
  },

  /**
   * framebuffer 是否完成
   * @return {Boolean}
   */
  isComplete: function isComplete() {
    var gl = this.gl;

    if (gl && gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
      return true;
    }

    return false;
  },

  /**
   * 绑定
   */
  bind: function bind() {
    this.init();

    if (this._isInit) {
      this.state.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
    }
  },

  /**
   * 解绑
   */
  unbind: function unbind() {
    this.init();

    if (this._isInit) {
      var state = this.state;
      state.bindFramebuffer(this.gl.FRAMEBUFFER, state.preFramebuffer);
    }
  },
  clear: function clear() {
    var clearColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new math_Color(0, 0, 0, 0);

    if (this._isInit) {
      var gl = this.gl;
      gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
  },

  /**
   * 渲染当前纹理
   * @param  {Number} [x=0]
   * @param  {Number} [y=0]
   * @param  {Number} [width=1]
   * @param  {Number} [height=1]
   * @param  {Color} clearColor
   */
  render: function render() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var clearColor = arguments.length > 4 ? arguments[4] : undefined;

    if (this._isInit) {
      var gl = this.gl,
          state = this.state;
      state.disable(DEPTH_TEST);
      state.disable(CULL_FACE);

      if (clearColor) {
        this.clear(clearColor);
      }

      var shader = shader_Shader.getCustomShader(screen_default.a, shader_screen_default.a, '', 'FramebufferTextureShader');
      var program = renderer_Program.getProgram(shader, state);
      program.useProgram();
      var vaoId = "".concat(x, "_").concat(y, "_").concat(width, "_").concat(height, "_").concat(program.id);
      var vao = renderer_VertexArrayObject.getVao(gl, vaoId, {
        useVao: this.useVao,
        useInstanced: false,
        mode: TRIANGLE_STRIP
      });

      if (vao.isDirty) {
        vao.isDirty = false;
        x = x * 2 - 1;
        y = 1 - y * 2;
        width *= 2;
        height *= 2;
        var vertices = [x, y, x + width, y, x, y - height, x + width, y - height];
        vao.addAttribute(new geometry_GeometryData(new Float32Array(vertices), 2), program.attributes.a_position);
        vao.addAttribute(new geometry_GeometryData(new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]), 2), program.attributes.a_texcoord0);
      }

      state.activeTexture(gl.TEXTURE0);
      state.bindTexture(gl.TEXTURE_2D, this.texture.getGLTexture(state));
      vao.draw();
    }
  },

  /**
   * 生成 Renderbuffer
   * @private
   * @return {WebGLRenderbuffer}
   */
  createRenderbuffer: function createRenderbuffer() {
    var gl = this.gl,
        width = this.width,
        height = this.height;
    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
    return renderbuffer;
  },

  /**
   * 生成纹理
   * @private
   * @return {Texture}
   */
  createTexture: function createTexture() {
    var state = this.state;
    var gl = state.gl;
    var texture = new texture_Texture({
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      internalFormat: this.internalFormat,
      format: this.format,
      type: this.type,
      width: this.width,
      height: this.height,
      image: this.data,
      wrapS: Framebuffer_CLAMP_TO_EDGE,
      wrapT: Framebuffer_CLAMP_TO_EDGE
    });
    var glTexture = texture.getGLTexture(state);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, this.attachment, this.target, glTexture, 0);
    return texture;
  },

  /**
   * resize
   * @param  {Number} width
   * @param  {Number} height
   * @param  {Boolean} [force=true]
   */
  resize: function resize(width, height, force) {
    if (force || this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;

      if (this._isInit) {
        this.reset();
      }
    }
  },

  /**
   * 读取区域像素
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} [width=1]
   * @param  {Number} [height=1]
   * @return {TypedArray}
   */
  readPixels: function readPixels(x, y) {
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var TypedArray = getTypedArrayClass(this.type);
    var pixels = new TypedArray(width * height * 4);

    if (this._isInit) {
      var gl = this.gl; // convert to webgl coordinate system

      y = this.height - y - height;
      this.bind();
      gl.readPixels(x, y, width, height, this.format, this.type, pixels);
      this.unbind();
    }

    return pixels;
  },
  destroy: function destroy() {
    this.destroyResource();
    this.gl = null;
    Framebuffer_cache.removeObject(this);
  },

  /**
   * 销毁资源
   */
  destroyResource: function destroyResource() {
    var gl = this.gl;

    if (gl) {
      if (this.framebuffer) {
        gl.deleteFramebuffer(this.framebuffer);
        this.framebuffer = null;
      }

      if (this.renderbuffer) {
        gl.deleteRenderbuffer(this.renderbuffer);
        this.renderbuffer = null;
      }

      if (this.texture) {
        this.texture.destroy();
        this.texture = null;
      }
    }
  }
});
/* harmony default export */ var renderer_Framebuffer = (Framebuffer);
// CONCATENATED MODULE: ./src/texture/CubeTexture.js




var TEXTURE_CUBE_MAP = src_constants.TEXTURE_CUBE_MAP,
    RGB = src_constants.RGB,
    CubeTexture_LINEAR = src_constants.LINEAR,
    CubeTexture_CLAMP_TO_EDGE = src_constants.CLAMP_TO_EDGE,
    TEXTURE_CUBE_MAP_POSITIVE_X = src_constants.TEXTURE_CUBE_MAP_POSITIVE_X;
/**
 * 立方体纹理
 * @class
 * @extends Texture
 * @example
 * var loadQueue = new Hilo3d.LoadQueue([{
 *     crossOrigin: 'anonymous',
 *     src: '//gw.alicdn.com/tfs/TB15OJpQFXXXXXgXVXXXXXXXXXX-512-512.png'
 * }, {
 *     crossOrigin: 'anonymous',
 *     src: '//gw.alicdn.com/tfs/TB1gwNqQFXXXXcIXFXXXXXXXXXX-512-512.png'
 * }, {
 *     crossOrigin: 'anonymous',
 *     src: '//gw.alicdn.com/tfs/TB1pyNcQFXXXXb7XVXXXXXXXXXX-512-512.png'
 * }, {
 *     crossOrigin: 'anonymous',
 *     src: '//gw.alicdn.com/tfs/TB1FilNQFXXXXcKXXXXXXXXXXXX-512-512.png'
 * }, {
 *     crossOrigin: 'anonymous',
 *     src: '//gw.alicdn.com/tfs/TB1gIpqQFXXXXcZXFXXXXXXXXXX-512-512.png'
 * }, {
 *     crossOrigin: 'anonymous',
 *     src: '//gw.alicdn.com/tfs/TB1RFXLQFXXXXXEXpXXXXXXXXXX-512-512.png'
 * }]).on('complete', function () {
 *     var result = loadQueue.getAllContent();
 *     var skyboxMap = new Hilo3d.CubeTexture({
 *         image: result
 *     });
 *     var skybox = new Hilo3d.Mesh({
 *         geometry: new Hilo3d.BoxGeometry(),
 *         material: new Hilo3d.BasicMaterial({
 *             lightType: 'NONE',
 *             diffuse: skyboxMap
 *         })
 *     });
 *     stage.addChild(skybox);
 * });
 */

var CubeTexture = core_Class.create(
/** @lends CubeTexture.prototype */
{
  Extends: texture_Texture,

  /**
   * @default true
   * @type {boolean}
   */
  isCubeTexture: true,

  /**
   * @default CubeTexture
   * @type {string}
   */
  className: 'CubeTexture',

  /**
   * @default TEXTURE_CUBE_MAP
   * @type {number}
   */
  target: TEXTURE_CUBE_MAP,

  /**
   * @default RGB
   * @type {number}
   */
  internalFormat: RGB,

  /**
   * @default RGB
   * @type {number}
   */
  format: RGB,

  /**
   * @default LINEAR
   * @type {number}
   */
  magFilter: CubeTexture_LINEAR,

  /**
   * @default LINEAR
   * @type {number}
   */
  minFilter: CubeTexture_LINEAR,

  /**
   * @default CLAMP_TO_EDGE
   * @type {number}
   */
  wrapS: CubeTexture_CLAMP_TO_EDGE,

  /**
   * @default CLAMP_TO_EDGE
   * @type {number}
   */
  wrapT: CubeTexture_CLAMP_TO_EDGE,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   * @param {HTMLImageElement[]} [params.image] 图片列表，共6张
   */
  constructor: function constructor(params) {
    CubeTexture.superclass.constructor.call(this, params);
    this.image = this.image || [];
  },
  _uploadTexture: function _uploadTexture(state) {
    var _this = this;

    var images = this.image;

    if (!Array.isArray(images) || images.length !== 6) {
      utils_log.error('CubeTexture image must be an Array of length 6', images);
      return;
    }

    if (images[0] && images[0].width) {
      this.width = images[0].width;
      this.height = images[0].height;
    }

    images.forEach(function (img, i) {
      _this._glUploadTexture(state, TEXTURE_CUBE_MAP_POSITIVE_X + i, img, 0);
    });
  },

  /**
   * 右侧的图片
   * @type {HTMLImageElement}
   */
  right: {
    get: function get() {
      return this.image[0];
    },
    set: function set(img) {
      this.image[0] = img;
    }
  },

  /**
   * 左侧的图片
   * @type {HTMLImageElement}
   */
  left: {
    get: function get() {
      return this.image[1];
    },
    set: function set(img) {
      this.image[1] = img;
    }
  },

  /**
   * 顶部的图片
   * @type {HTMLImageElement}
   */
  top: {
    get: function get() {
      return this.image[2];
    },
    set: function set(img) {
      this.image[2] = img;
    }
  },

  /**
   * 底部的图片
   * @type {HTMLImageElement}
   */
  bottom: {
    get: function get() {
      return this.image[3];
    },
    set: function set(img) {
      this.image[3] = img;
    }
  },

  /**
   * 朝前的图片
   * @type {HTMLImageElement}
   */
  front: {
    get: function get() {
      return this.image[4];
    },
    set: function set(img) {
      this.image[4] = img;
    }
  },

  /**
   * 朝后的图片
   * @type {HTMLImageElement}
   */
  back: {
    get: function get() {
      return this.image[5];
    },
    set: function set(img) {
      this.image[5] = img;
    }
  }
});
/* harmony default export */ var texture_CubeTexture = (CubeTexture);
// CONCATENATED MODULE: ./src/texture/DataTexture.js





var DataTexture_TEXTURE_2D = src_constants.TEXTURE_2D,
    DataTexture_RGBA = src_constants.RGBA,
    DataTexture_NEAREST = src_constants.NEAREST,
    DataTexture_CLAMP_TO_EDGE = src_constants.CLAMP_TO_EDGE,
    DataTexture_FLOAT = src_constants.FLOAT;
/**
 * 数据纹理
 * @class
 * @extends Texture
 */

var DataTexture = core_Class.create(
/** @lends DataTexture.prototype */
{
  Extends: texture_Texture,

  /**
   * @default true
   * @type {boolean}
   */
  isDataTexture: true,

  /**
   * @default DataTexture
   * @type {string}
   */
  className: 'DataTexture',

  /**
   * @default TEXTURE_2D
   * @type {number}
   */
  target: DataTexture_TEXTURE_2D,

  /**
   * @default RGBA
   * @type {number}
   */
  internalFormat: DataTexture_RGBA,

  /**
   * @default RGBA
   * @type {number}
   */
  format: DataTexture_RGBA,

  /**
   * @default FLOAT
   * @type {number}
   */
  type: DataTexture_FLOAT,

  /**
   * @default NEAREST
   * @type {number}
   */
  magFilter: DataTexture_NEAREST,

  /**
   * @default NEAREST
   * @type {number}
   */
  minFilter: DataTexture_NEAREST,

  /**
   * @default CLAMP_TO_EDGE
   * @type {number}
   */
  wrapS: DataTexture_CLAMP_TO_EDGE,

  /**
   * @default CLAMP_TO_EDGE
   * @type {number}
   */
  wrapT: DataTexture_CLAMP_TO_EDGE,
  dataLength: 0,
  resetSize: function resetSize(dataLen) {
    if (dataLen === this.dataLength) {
      return;
    }

    this.dataLength = dataLen;
    var pixelCount = math_math.nextPowerOfTwo(dataLen / 4);
    var n = Math.max(Math.log2(pixelCount), 4);
    var w = Math.floor(n / 2);
    var h = n - w;
    this.width = Math.pow(2, w);
    this.height = Math.pow(2, h);
    this.DataClass = getTypedArrayClass(this.type);
  },

  /**
   * 数据，改变数据的时候会自动更新Texture
   * @type {Float32Array}
   */
  data: {
    get: function get() {
      return this.image;
    },
    set: function set(_data) {
      if (this.image !== _data) {
        this.resetSize(_data.length);
        var len = this.width * this.height * 4;

        if (len === _data.length && _data instanceof this.DataClass) {
          this.image = _data;
        } else {
          if (!this.image || this.image.length !== len) {
            this.image = new this.DataClass(len);
          }

          this.image.set(_data, 0);
        }

        this.needUpdate = true;
      }
    }
  },

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   * @param {Array|Float32Array} [params.data] 数据
   */
  constructor: function constructor(params) {
    DataTexture.superclass.constructor.call(this, params);
  }
});
/* harmony default export */ var texture_DataTexture = (DataTexture);
// CONCATENATED MODULE: ./src/material/semantic.js
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint no-unused-vars: "off" */






var semantic_tempVector3 = new math_Vector3();
var semantic_tempMatrix3 = new math_Matrix3();
var semantic_tempMatrix4 = new math_Matrix4();
var tempFloat32Array4 = new Float32Array([0.5, 0.5, 0.5, 1]);
var tempFloat32Array2 = new Float32Array([0, 0]);
var blankInfo = {
  get: function get() {
    return undefined;
  }
};
var semantic_camera;
var semantic_gl;
var semantic_lightManager;
var semantic_state;
var semantic_fog;
var semantic_renderer;
/**
 * 语义
 * @namespace semantic
 * @type {Object}
 */

var semantic = {
  /**
   * @type {WebGLState}
   */
  state: null,

  /**
   * @type {Camera}
   */
  camera: null,

  /**
   * @type {LightManager}
   */
  lightManager: null,

  /**
   * @type {Fog}
   */
  fog: null,

  /**
   * @type {WebGLRenderingContext}
   */
  gl: null,

  /**
   * WebGLRenderer
   * @type {WebGLRenderer}
   */
  renderer: null,
  blankInfo: blankInfo,

  /**
   * 初始化
   * @param  {WebGLState} _state
   * @param  {Camera} _camera
   * @param  {LightManager} _lightManager
   * @param  {Fog} _fog
   */
  init: function init(_renderer, _state, _camera, _lightManager, _fog) {
    semantic_renderer = this._renderer = _renderer;
    semantic_state = this.state = _state;
    semantic_camera = this.camera = _camera;
    semantic_lightManager = this.lightManager = _lightManager;
    semantic_fog = this.fog = _fog;
    semantic_gl = this.gl = semantic_state.gl;
  },

  /**
   * 设置相机
   * @param {Camera} _camera
   */
  setCamera: function setCamera(_camera) {
    semantic_camera = this.camera = _camera;
  },
  handlerColorOrTexture: function handlerColorOrTexture(value, textureIndex) {
    if (value && value.isTexture) {
      return this.handlerTexture(value, textureIndex);
    }

    if (value && value.isColor) {
      value.toArray(tempFloat32Array4);
    } else {
      tempFloat32Array4[0] = tempFloat32Array4[1] = tempFloat32Array4[2] = 0.5;
    }

    return tempFloat32Array4;
  },
  handlerTexture: function handlerTexture(value, textureIndex) {
    if (value && value.isTexture) {
      return this.handlerGLTexture(value.target, value.getGLTexture(semantic_state), textureIndex);
    }

    return undefined;
  },
  handlerGLTexture: function handlerGLTexture(target, texture, textureIndex) {
    if (texture) {
      semantic_state.activeTexture(semantic_gl.TEXTURE0 + textureIndex);
      semantic_state.bindTexture(target, texture);
      return textureIndex;
    }

    return undefined;
  },
  handlerUV: function handlerUV(texture) {
    if (texture && texture.isTexture) {
      return texture.uv || 0;
    }

    return 0;
  },
  // attributes

  /**
   * @type {semanticObject}
   */
  POSITION: {
    get: function get(mesh, material, programInfo) {
      return mesh.geometry.vertices;
    }
  },

  /**
   * @type {semanticObject}
   */
  NORMAL: {
    get: function get(mesh, material, programInfo) {
      return mesh.geometry.normals;
    }
  },

  /**
   * @type {semanticObject}
   */
  TANGENT: {
    get: function get(mesh, material, programInfo) {
      var normalMap = material.normalMap;

      if (normalMap && normalMap.isTexture) {
        if (Number(normalMap.uv) === 1) {
          return mesh.geometry.tangents1;
        }

        return mesh.geometry.tangents;
      }

      return undefined;
    }
  },

  /**
   * @type {semanticObject}
   */
  TEXCOORD_0: {
    get: function get(mesh, material, programInfo) {
      if (!mesh.geometry.uvs) {
        return undefined;
      }

      return mesh.geometry.uvs;
    }
  },

  /**
   * @type {semanticObject}
   */
  TEXCOORD_1: {
    get: function get(mesh, material, programInfo) {
      if (!mesh.geometry.uvs1) {
        return undefined;
      }

      return mesh.geometry.uvs1;
    }
  },

  /**
   * @type {semanticObject}
   */
  UVMATRIX_0: {
    get: function get(mesh, material, programInfo) {
      if (!material.uvMatrix) {
        return undefined;
      }

      return material.uvMatrix.elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  UVMATRIX_1: {
    get: function get(mesh, material, programInfo) {
      if (!material.uvMatrix1) {
        return undefined;
      }

      return material.uvMatrix1.elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  CAMERAFAR: {
    get: function get(mesh, material, programInfo) {
      if (semantic_camera.isPerspectiveCamera) {
        return semantic_camera.far;
      }

      return undefined;
    }
  },

  /**
   * @type {semanticObject}
   */
  CAMERANEAR: {
    get: function get(mesh, material, programInfo) {
      if (semantic_camera.isPerspectiveCamera) {
        return semantic_camera.near;
      }

      return undefined;
    }
  },

  /**
   * @type {semanticObject}
   */
  CAMERATYPE: {
    get: function get(mesh, material, programInfo) {
      if (semantic_camera.isPerspectiveCamera) {
        return 1;
      }

      return 0;
    }
  },
  CAMERAPOSITION: {
    get: function get(mesh, material, programInfo) {
      return semantic_camera.worldMatrix.getTranslation(semantic_tempVector3).elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  COLOR_0: {
    get: function get(mesh, material, programInfo) {
      if (!mesh.geometry.colors) {
        return undefined;
      }

      return mesh.geometry.colors;
    }
  },

  /**
   * @type {semanticObject}
   */
  SKININDICES: {
    get: function get(mesh, material, programInfo) {
      return mesh.geometry.skinIndices;
    }
  },

  /**
   * @type {semanticObject}
   */
  SKINWEIGHTS: {
    get: function get(mesh, material, programInfo) {
      return mesh.geometry.skinWeights;
    }
  },
  // uniforms

  /**
   * @type {semanticObject}
   */
  RENDERERSIZE: {
    get: function get(mesh, material, programInfo) {
      tempFloat32Array2[0] = semantic_renderer.width;
      tempFloat32Array2[1] = semantic_renderer.height;
      return tempFloat32Array2;
    }
  },

  /**
   * @type {semanticObject}
   */
  LOCAL: {
    get: function get(mesh, material, programInfo) {
      return mesh.matrix.elements;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  MODEL: {
    get: function get(mesh, material, programInfo) {
      return mesh.worldMatrix.elements;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  VIEW: {
    get: function get(mesh, material, programInfo) {
      return semantic_camera.viewMatrix.elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  PROJECTION: {
    get: function get(mesh, material, programInfo) {
      return semantic_camera.projectionMatrix.elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  VIEWPROJECTION: {
    get: function get(mesh, material, programInfo) {
      return semantic_camera.viewProjectionMatrix.elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  MODELVIEW: {
    get: function get(mesh, material, programInfo) {
      return semantic_camera.getModelViewMatrix(mesh, semantic_tempMatrix4).elements;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  MODELVIEWPROJECTION: {
    get: function get(mesh, material, programInfo) {
      return semantic_camera.getModelProjectionMatrix(mesh, semantic_tempMatrix4).elements;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  MODELINVERSE: {
    get: function get(mesh, material, programInfo) {
      return semantic_tempMatrix4.invert(mesh.worldMatrix).elements;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  VIEWINVERSE: {
    get: function get(mesh, material, programInfo) {
      return semantic_camera.worldMatrix.elements;
    }
  },

  /**
   * @type {semanticObject}
  */
  VIEWINVERSEINVERSETRANSPOSE: {
    get: function get(mesh, material, programInfo) {
      return semantic_tempMatrix3.normalFromMat4(semantic_camera.worldMatrix).elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  PROJECTIONINVERSE: {
    get: function get(mesh, material, programInfo) {
      return semantic_tempMatrix4.invert(semantic_camera.projectionMatrix).elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  MODELVIEWINVERSE: {
    get: function get(mesh, material, programInfo) {
      return semantic_tempMatrix4.invert(semantic_camera.getModelViewMatrix(mesh, semantic_tempMatrix4)).elements;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  MODELVIEWPROJECTIONINVERSE: {
    get: function get(mesh, material, programInfo) {
      return semantic_tempMatrix4.invert(semantic_camera.getModelProjectionMatrix(mesh, semantic_tempMatrix4)).elements;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  MODELINVERSETRANSPOSE: {
    get: function get(mesh, material, programInfo) {
      return semantic_tempMatrix3.normalFromMat4(mesh.worldMatrix).elements;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  MODELVIEWINVERSETRANSPOSE: {
    get: function get(mesh, material, programInfo) {
      return semantic_tempMatrix3.normalFromMat4(semantic_camera.getModelViewMatrix(mesh, semantic_tempMatrix4)).elements;
    },
    isDependMesh: true
  },

  /**
   * 还未实现，不要使用
   * @type {semanticObject}
   * @default undefined
   */
  VIEWPORT: undefined,

  /**
   * @type {semanticObject}
   */
  JOINTMATRIX: {
    get: function get(mesh, material, programInfo) {
      if (mesh.isSkinedMesh) {
        return mesh.getJointMat();
      }

      utils_log.warnOnce("semantic.JOINTMATRIX(".concat(mesh.id, ")"), 'Current mesh is not SkinedMesh!', mesh.id);
      return undefined;
    },
    isDependMesh: true,
    notSupportInstanced: true
  },

  /**
   * @type {semanticObject}
   */
  JOINTMATRIXTEXTURE: {
    get: function get(mesh, material, programInfo) {
      if (mesh.isSkinedMesh) {
        mesh.updateJointMatTexture();
        return semantic.handlerTexture(mesh.jointMatTexture, programInfo.textureIndex);
      }

      utils_log.warnOnce("semantic.JOINTMATRIXTEXTURE(".concat(mesh.id, ")"), 'Current mesh is not SkinedMesh!', mesh.id);
      return undefined;
    },
    isDependMesh: true,
    notSupportInstanced: true
  },

  /**
   * @type {semanticObject}
   */
  JOINTMATRIXTEXTURESIZE: {
    get: function get(mesh, material, programInfo) {
      if (mesh.isSkinedMesh) {
        mesh.initJointMatTexture();
        return [mesh.jointMatTexture.width, mesh.jointMatTexture.height];
      }

      utils_log.warnOnce("semantic.JOINTMATRIXTEXTURESIZE(".concat(mesh.id, ")"), 'Current mesh is not SkinedMesh!', mesh.id);
      return undefined;
    },
    isDependMesh: true,
    notSupportInstanced: true
  },

  /**
   * @type {semanticObject}
   */
  NORMALMAPSCALE: {
    get: function get(mesh, material, programInfo) {
      return material.normalMapScale;
    }
  },

  /**
   * @type {semanticObject}
   */
  OCCLUSIONSTRENGTH: {
    get: function get(mesh, material, programInfo) {
      return material.occlusionStrength;
    }
  },

  /**
   * @type {semanticObject}
   */
  SHININESS: {
    get: function get(mesh, material, programInfo) {
      return material.shininess;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPECULARENVMATRIX: {
    get: function get(mesh, material, programInfo) {
      if (material.specularEnvMatrix && material.specularEnvMap) {
        return material.specularEnvMatrix.elements;
      }

      semantic_tempMatrix4.identity();
      return semantic_tempMatrix4.elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  REFLECTIVITY: {
    get: function get(mesh, material, programInfo) {
      return material.reflectivity;
    }
  },

  /**
   * @type {semanticObject}
   */
  REFRACTRATIO: {
    get: function get(mesh, material, programInfo) {
      return material.refractRatio;
    }
  },

  /**
   * @type {semanticObject}
   */
  REFRACTIVITY: {
    get: function get(mesh, material, programInfo) {
      return material.refractivity;
    }
  },
  LOGDEPTH: {
    get: function get(mesh, material, programInfo) {
      return 2.0 / (Math.log(semantic_camera.far + 1.0) / Math.LN2);
    }
  },
  // light

  /**
   * @type {semanticObject}
   */
  AMBIENTLIGHTSCOLOR: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.ambientInfo;
    }
  },

  /**
   * @type {semanticObject}
   */
  DIRECTIONALLIGHTSCOLOR: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.directionalInfo.colors;
    }
  },

  /**
   * @type {semanticObject}
   */
  DIRECTIONALLIGHTSINFO: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.directionalInfo.infos;
    }
  },

  /**
   * @type {semanticObject}
   */
  DIRECTIONALLIGHTSSHADOWMAP: {
    get: function get(mesh, material, programInfo) {
      var result = semantic_lightManager.directionalInfo.shadowMap.map(function (texture, i) {
        return semantic.handlerTexture(texture, programInfo.textureIndex + i);
      });
      return result;
    }
  },

  /**
   * @type {semanticObject}
   */
  DIRECTIONALLIGHTSSHADOWMAPSIZE: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.directionalInfo.shadowMapSize;
    }
  },

  /**
   * @type {semanticObject}
   */
  DIRECTIONALLIGHTSSHADOWBIAS: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.directionalInfo.shadowBias;
    }
  },

  /**
   * @type {semanticObject}
   */
  DIRECTIONALLIGHTSPACEMATRIX: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.directionalInfo.lightSpaceMatrix;
    }
  },

  /**
   * @type {semanticObject}
   */
  POINTLIGHTSPOS: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.pointInfo.poses;
    }
  },

  /**
   * @type {semanticObject}
   */
  POINTLIGHTSCOLOR: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.pointInfo.colors;
    }
  },

  /**
   * @type {semanticObject}
   */
  POINTLIGHTSINFO: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.pointInfo.infos;
    }
  },

  /**
   * @type {semanticObject}
   */
  POINTLIGHTSRANGE: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.pointInfo.ranges;
    }
  },

  /**
   * @type {semanticObject}
   */
  POINTLIGHTSSHADOWMAP: {
    get: function get(mesh, material, programInfo) {
      var result = semantic_lightManager.pointInfo.shadowMap.map(function (texture, i) {
        return semantic.handlerTexture(texture, programInfo.textureIndex + i);
      });
      return result;
    }
  },

  /**
   * @type {semanticObject}
   */
  POINTLIGHTSSHADOWBIAS: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.pointInfo.shadowBias;
    }
  },

  /**
   * @type {semanticObject}
   */
  POINTLIGHTSPACEMATRIX: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.pointInfo.lightSpaceMatrix;
    }
  },

  /**
   * @type {semanticObject}
   */
  POINTLIGHTCAMERA: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.pointInfo.cameras;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSPOS: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.spotInfo.poses;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSDIR: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.spotInfo.dirs;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSCOLOR: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.spotInfo.colors;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSCUTOFFS: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.spotInfo.cutoffs;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSINFO: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.spotInfo.infos;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSRANGE: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.spotInfo.ranges;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSSHADOWMAP: {
    get: function get(mesh, material, programInfo) {
      var result = semantic_lightManager.spotInfo.shadowMap.map(function (texture, i) {
        return semantic.handlerTexture(texture, programInfo.textureIndex + i);
      });
      return result;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSSHADOWMAPSIZE: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.spotInfo.shadowMapSize;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSSHADOWBIAS: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.spotInfo.shadowBias;
    }
  },

  /**
   * @type {semanticObject}
   */
  SPOTLIGHTSPACEMATRIX: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.spotInfo.lightSpaceMatrix;
    }
  },

  /**
   * @type {semanticObject}
   */
  AREALIGHTSCOLOR: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.areaInfo.colors;
    }
  },

  /**
   * @type {semanticObject}
   */
  AREALIGHTSPOS: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.areaInfo.poses;
    }
  },

  /**
   * @type {semanticObject}
   */
  AREALIGHTSWIDTH: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.areaInfo.width;
    }
  },

  /**
   * @type {semanticObject}
   */
  AREALIGHTSHEIGHT: {
    get: function get(mesh, material, programInfo) {
      return semantic_lightManager.areaInfo.height;
    }
  },

  /**
   * @type {semanticObject}
   */
  AREALIGHTSLTCTEXTURE1: {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerTexture(semantic_lightManager.areaInfo.ltcTexture1, programInfo.textureIndex);
    }
  },

  /**
   * @type {semanticObject}
   */
  AREALIGHTSLTCTEXTURE2: {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerTexture(semantic_lightManager.areaInfo.ltcTexture2, programInfo.textureIndex);
    }
  },
  // fog

  /**
   * @type {semanticObject}
   */
  FOGCOLOR: {
    get: function get(mesh, material, programInfo) {
      if (semantic_fog) {
        return semantic_fog.color.elements;
      }

      return undefined;
    }
  },

  /**
   * @type {semanticObject}
   */
  FOGINFO: {
    get: function get(mesh, material, programInfo) {
      if (semantic_fog) {
        return semantic_fog.getInfo();
      }

      return undefined;
    }
  },
  // unQuantize

  /**
   * @type {semanticObject}
   */
  POSITIONDECODEMAT: {
    get: function get(mesh, material, programInfo) {
      return mesh.geometry.positionDecodeMat;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  NORMALDECODEMAT: {
    get: function get(mesh, material, programInfo) {
      return mesh.geometry.normalDecodeMat;
    },
    isDependMesh: true
  },

  /**
   * @type {semanticObject}
   */
  UVDECODEMAT: {
    get: function get(mesh, material, programInfo) {
      return mesh.geometry.uvDecodeMat;
    },
    isDependMesh: true
  },
  UV1DECODEMAT: {
    get: function get(mesh, material, programInfo) {
      return mesh.geometry.uv1DecodeMat;
    },
    isDependMesh: true
  },
  // pbr

  /**
   * @type {semanticObject}
   */
  BASECOLOR: {
    get: function get(mesh, material, programInfo) {
      return material.baseColor.elements;
    }
  },

  /**
   * @type {semanticObject}
   */
  METALLIC: {
    get: function get(mesh, material, programInfo) {
      return material.metallic;
    }
  },

  /**
   * @type {semanticObject}
   */
  ROUGHNESS: {
    get: function get(mesh, material, programInfo) {
      return material.roughness;
    }
  },

  /**
   * @type {semanticObject}
   */
  DIFFUSEENVMAP: {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerTexture(material.diffuseEnvMap, programInfo.textureIndex);
    }
  },

  /**
   * @type {semanticObject}
   */
  DIFFUSEENVINTENSITY: {
    get: function get(mesh, material, programInfo) {
      return material.diffuseEnvIntensity;
    }
  },
  DIFFUSEENVSPHEREHARMONICS3: {
    get: function get(mesh, material, programInfo) {
      var sphereHarmonics3 = material.diffuseEnvSphereHarmonics3;

      if (sphereHarmonics3) {
        return sphereHarmonics3.toArray();
      }

      return undefined;
    }
  },

  /**
   * @type {semanticObject}
   */
  BRDFLUT: {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerTexture(material.brdfLUT, programInfo.textureIndex);
    }
  },

  /**
   * @type {semanticObject}
   */
  SPECULARENVMAP: {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerTexture(material.specularEnvMap, programInfo.textureIndex);
    }
  },
  SPECULARENVINTENSITY: {
    get: function get(mesh, material, programInfo) {
      return material.specularEnvIntensity;
    }
  },
  SPECULARENVMAPMIPCOUNT: {
    get: function get(mesh, material, programInfo) {
      var specularEnvMap = material.specularEnvMap;

      if (specularEnvMap) {
        return specularEnvMap.mipmapCount;
      }

      return 1;
    }
  },
  GLOSSINESS: {
    get: function get(mesh, material, programInfo) {
      return material.glossiness;
    }
  },
  ALPHACUTOFF: {
    get: function get(mesh, material, programInfo) {
      return material.alphaCutoff;
    }
  },
  EXPOSURE: {
    get: function get(mesh, material, programInfo) {
      return material.exposure;
    }
  },
  GAMMAFACTOR: {
    get: function get(mesh, material, programInfo) {
      return material.gammaFactor;
    }
  },
  // Morph Animation Uniforms
  MORPHWEIGHTS: {
    isDependMesh: true,
    notSupportInstanced: true,
    get: function get(mesh, material, programInfo) {
      var geometry = mesh.geometry;

      if (!geometry.isMorphGeometry || !geometry.weights) {
        return undefined;
      }

      return geometry.weights;
    }
  }
}; // Morph Animation Attributes

[['POSITION', 'vertices'], ['NORMAL', 'normals'], ['TANGENT', 'tangents']].forEach(function (info) {
  for (var i = 0; i < 8; i++) {
    semantic['MORPH' + info[0] + i] = {
      get: function (name, i) {
        return function (mesh, material, programInfo) {
          var geometry = mesh.geometry;

          if (!geometry.isMorphGeometry || !geometry.targets || !geometry.targets[name]) {
            return undefined;
          }

          var idx = geometry._originalMorphIndices ? geometry._originalMorphIndices[i] : i;
          var data = geometry.targets[name][idx];
          var idxCacheKey = "_target_".concat(name, "_").concat(i);

          if (geometry[idxCacheKey] !== idx && data) {
            data.isDirty = true;
            geometry[idxCacheKey] = idx;
          }

          return data;
        };
      }(info[1], i)
    };
  }
}); // Texture or Vector4

[['DIFFUSE', 'diffuse'], ['SPECULAR', 'specular'], ['EMISSION', 'emission'], ['AMBIENT', 'ambient']].forEach(function (info) {
  var _info = _slicedToArray(info, 2),
      semanticName = _info[0],
      textureName = _info[1];

  semantic[semanticName] = {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerColorOrTexture(material[textureName], programInfo.textureIndex);
    }
  };
  semantic["".concat(semanticName, "UV")] = {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerUV(material[textureName]);
    }
  };
}); // Texture

[['NORMALMAP', 'normalMap'], ['PARALLAXMAP', 'parallaxMap'], ['BASECOLORMAP', 'baseColorMap'], ['METALLICMAP', 'metallicMap'], ['ROUGHNESSMAP', 'roughnessMap'], ['METALLICROUGHNESSMAP', 'metallicRoughnessMap'], ['OCCLUSIONMAP', 'occlusionMap'], ['SPECULARGLOSSINESSMAP', 'specularGlossinessMap'], ['LIGHTMAP', 'lightMap']].forEach(function (info) {
  var _info2 = _slicedToArray(info, 2),
      semanticName = _info2[0],
      textureName = _info2[1];

  semantic[semanticName] = {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerTexture(material[textureName], programInfo.textureIndex);
    }
  };
  semantic["".concat(semanticName, "UV")] = {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerUV(material[textureName]);
    }
  };
}); // TRANSPARENCY

[['TRANSPARENCY', 'transparency']].forEach(function (info) {
  var _info3 = _slicedToArray(info, 2),
      semanticName = _info3[0],
      textureName = _info3[1];

  semantic[semanticName] = {
    get: function get(mesh, material, programInfo) {
      var value = material[textureName];

      if (value && value.isTexture) {
        return semantic.handlerTexture(value, programInfo.textureIndex);
      }

      if (value !== undefined && value !== null) {
        return value;
      }

      return 1;
    }
  };
  semantic["".concat(semanticName, "UV")] = {
    get: function get(mesh, material, programInfo) {
      return semantic.handlerUV(material[textureName]);
    }
  };
});
/**
 * semantic 对象
 * @typedef {object} semanticObject
 * @property {Boolean} isDependMesh 是否依赖 mesh
 * @property {Boolean} notSupportInstanced 是否不支持 instanced
 * @property {Function} get 获取数据方法
 */

/* harmony default export */ var material_semantic = (semantic);
// CONCATENATED MODULE: ./src/material/Material.js





var LEQUAL = src_constants.LEQUAL,
    Material_BACK = src_constants.BACK,
    Material_FRONT = src_constants.FRONT,
    Material_FRONT_AND_BACK = src_constants.FRONT_AND_BACK,
    ZERO = src_constants.ZERO,
    FUNC_ADD = src_constants.FUNC_ADD,
    ONE = src_constants.ONE,
    SRC_ALPHA = src_constants.SRC_ALPHA,
    ONE_MINUS_SRC_ALPHA = src_constants.ONE_MINUS_SRC_ALPHA;
var Material_blankInfo = {
  isBlankInfo: true,
  get: function get() {
    return undefined;
  }
};
/**
 * 材质基类，一般不直接使用
 * @class
 */

var Material = core_Class.create(
/** @lends Material.prototype */
{
  /**
   * @default true
   * @type {boolean}
   */
  isMaterial: true,

  /**
   * @default Material
   * @type {string}
   */
  className: 'Material',

  /**
   * name
   * @type {string}
   */
  name: null,

  /**
   * shader cache id
   * @default null
   * @type {String}
   */
  shaderCacheId: null,

  /**
   * 光照类型
   * @default NONE
   * @type {string}
   */
  lightType: 'NONE',

  /**
   * 是否开启网格模式
   * @default false
   * @type {boolean}
   */
  wireframe: false,

  /**
   * 是否开启深度测试
   * @default true
   * @type {boolean}
   */
  depthTest: true,

  /**
   * SAMPLE_ALPHA_TO_COVERAGE
   * @default false
   * @type {Boolean}
   */
  sampleAlphaToCoverage: false,

  /**
   * 是否开启depthMask
   * @default true
   * @type {boolean}
   */
  depthMask: true,

  /**
   * 深度测试Range
   * @default [0, 1]
   * @type {Array}
   */
  depthRange: [0, 1],

  /**
   * 深度测试方法
   * @default LESS
   * @type {GLenum}
   */
  depthFunc: LEQUAL,
  _cullFace: true,

  /**
   * 法线贴图
   * @default null
   * @type {Texture}
   */
  normalMap: null,

  /**
   * 视差贴图
   * @default null
   * @type {Texture}
   */
  parallaxMap: null,

  /**
   * 法线贴图scale
   * @default 1
   * @type {Number}
   */
  normalMapScale: 1,

  /**
   * 是否忽略透明度
   * @type {Boolean}
   * @default false
   */
  ignoreTranparent: false,

  /**
   * 是否开启 gamma 矫正
   * @type {Boolean}
   * @default false
   */
  gammaCorrection: false,

  /**
   * 是否使用物理灯光
   * @type {Boolean}
   * @default false
   */
  usePhysicsLight: false,

  /**
   * 是否环境贴图和环境光同时生效
   * @type {Boolean}
   * @default false
   */
  isDiffuesEnvAndAmbientLightWorkTogether: false,

  /**
   * 渲染顺序数字小的先渲染（透明物体和不透明在不同的队列）
   * @default 0
   * @type {Number}
   */
  renderOrder: 0,
  _premultiplyAlpha: true,

  /**
   * 是否预乘 alpha
   * @type {Boolean}
   * @default true
   */
  premultiplyAlpha: {
    get: function get() {
      return this._premultiplyAlpha;
    },
    set: function set(value) {
      this._premultiplyAlpha = value;

      if (this.transparent) {
        this.setDefaultTransparentBlend();
      }
    }
  },

  /**
   * gammaOutput
   * @type {Boolean}
   * @deprecated
   * @default false
   */
  gammaOutput: {
    get: function get() {
      utils_log.warnOnce('Matrial.gammaOutput', 'material.gammaOutput has deprecated. Use material.gammaCorrection instead.');
      return this.gammaCorrection;
    },
    set: function set(value) {
      utils_log.warnOnce('Matrial.gammaOutput', 'material.gammaOutput has deprecated. Use material.gammaCorrection instead.');
      this.gammaCorrection = value;
    }
  },

  /**
   * gamma值
   * @type {Number}
   * @default 2.2
   */
  gammaFactor: 2.2,

  /**
   * 是否投射阴影
   * @type {Boolean}
   * @default true
   */
  castShadows: true,

  /**
   * 是否接受阴影
   * @type {Boolean}
   * @default true
   */
  receiveShadows: true,

  /**
   * uv transform eg:new Matrix3().fromRotationTranslationScale(Math.PI/2, 0, 0, 2, 2)
   * @type {Matrix3}
   */
  uvMatrix: null,

  /**
   * uv1 transform eg:new Matrix3().fromRotationTranslationScale(Math.PI/2, 0, 0, 2, 2)
   * @type {Matrix3}
   */
  uvMatrix1: null,

  /**
   * 是否开启 CullFace
   * @default true
   * @type {boolean}
   */
  cullFace: {
    get: function get() {
      return this._cullFace;
    },
    set: function set(value) {
      this._cullFace = value;

      if (value) {
        this.cullFaceType = this._cullFaceType;
      } else {
        this._side = Material_FRONT_AND_BACK;
      }
    }
  },
  _cullFaceType: Material_BACK,

  /**
   * CullFace 类型
   * @default BACK
   * @type {GLenum}
   */
  cullFaceType: {
    get: function get() {
      return this._cullFaceType;
    },
    set: function set(value) {
      this._cullFaceType = value;

      if (this._cullFace) {
        if (value === Material_BACK) {
          this._side = Material_FRONT;
        } else if (value === Material_FRONT) {
          this._side = Material_BACK;
        }
      }
    }
  },
  _side: Material_FRONT,

  /**
   * 显示面，可选值 FRONT, BACK, FRONT_AND_BACK
   * @type {GLenum}
   * @default FRONT
   */
  side: {
    get: function get() {
      return this._side;
    },
    set: function set(value) {
      if (this._side !== value) {
        this._side = value;

        if (value === Material_FRONT_AND_BACK) {
          this._cullFace = false;
        } else {
          this._cullFace = true;

          if (value === Material_FRONT) {
            this._cullFaceType = Material_BACK;
          } else if (value === Material_BACK) {
            this._cullFaceType = Material_FRONT;
          }
        }
      }
    }
  },

  /**
   * 是否开启颜色混合
   * @default false
   * @type {boolean}
   */
  blend: false,

  /**
   * 颜色混合方式
   * @default FUNC_ADD
   * @type {GLenum}
   */
  blendEquation: FUNC_ADD,

  /**
   * 透明度混合方式
   * @default FUNC_ADD
   * @type {GLenum}
   */
  blendEquationAlpha: FUNC_ADD,

  /**
   * 颜色混合来源比例
   * @default ONE
   * @type {GLenum}
   */
  blendSrc: ONE,

  /**
   * 颜色混合目标比例
   * @default ZERO
   * @type {GLenum}
   */
  blendDst: ZERO,

  /**
   * 透明度混合来源比例
   * @default ONE
   * @type {GLenum}
   */
  blendSrcAlpha: ONE,

  /**
   * 透明度混合目标比例
   * @default ONE
   * @type {GLenum}
   */
  blendDstAlpha: ZERO,

  /**
   * 当前是否需要强制更新
   * @default false
   * @type {boolean}
   */
  isDirty: false,

  /**
   * 透明度 0~1
   * @default 1
   * @type {number}
   */
  transparency: 1,
  _transparent: false,

  /**
   * 是否需要透明
   * @default false
   * @type {boolean}
   */
  transparent: {
    get: function get() {
      return this._transparent;
    },
    set: function set(value) {
      if (this._transparent !== value) {
        this._transparent = value;

        if (!value) {
          this.blend = false;
          this.depthMask = true;
        } else {
          this.setDefaultTransparentBlend();
        }
      }
    }
  },
  setDefaultTransparentBlend: function setDefaultTransparentBlend() {
    this.blend = true;
    this.depthMask = false;

    if (this.premultiplyAlpha) {
      this.blendSrc = ONE;
      this.blendDst = ONE_MINUS_SRC_ALPHA;
      this.blendSrcAlpha = ONE;
      this.blendDstAlpha = ONE_MINUS_SRC_ALPHA;
    } else {
      this.blendSrc = SRC_ALPHA;
      this.blendDst = ONE_MINUS_SRC_ALPHA;
      this.blendSrcAlpha = SRC_ALPHA;
      this.blendDstAlpha = ONE_MINUS_SRC_ALPHA;
    }
  },

  /**
   * 透明度剪裁，如果渲染的颜色透明度大于等于这个值的话渲染为完全不透明，否则渲染为完全透明
   * @default 0
   * @type {number}
   */
  alphaCutoff: 0,

  /**
   * 是否使用HDR
   * @default false
   * @type {Boolean}
   */
  useHDR: false,

  /**
   * 曝光度，仅在 useHDR 为 true 时生效
   * @default 1
   * @type {Number}
   */
  exposure: 1,

  /**
   * 是否需要加基础 uniforms
   * @type {Boolean}
   * @default true
   */
  needBasicUnifroms: true,

  /**
   * 是否需要加基础 attributes
   * @type {Boolean}
   * @default true
   */
  needBasicAttributes: true,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    /**
     * @type {string}
     */
    this.id = math_math.generateUUID(this.className);
    /**
     * 可以通过指定，semantic来指定值的获取方式，或者自定义get方法
     * @default {}
     * @type {object}
     */

    this.uniforms = {};
    /**
     * 可以通过指定，semantic来指定值的获取方式，或者自定义get方法
     * @default {}
     * @type {object}
     */

    this.attributes = {};
    Object.assign(this, params);

    if (this.needBasicAttributes) {
      this.addBasicAttributes();
    }

    if (this.needBasicUnifroms) {
      this.addBasicUniforms();
    }
  },

  /**
   * 增加基础 attributes
   */
  addBasicAttributes: function addBasicAttributes() {
    var attributes = this.attributes;

    this._copyProps(attributes, {
      a_position: 'POSITION',
      a_normal: 'NORMAL',
      a_tangent: 'TANGENT',
      a_texcoord0: 'TEXCOORD_0',
      a_texcoord1: 'TEXCOORD_1',
      a_color: 'COLOR_0',
      a_skinIndices: 'SKININDICES',
      a_skinWeights: 'SKINWEIGHTS'
    });

    ['POSITION', 'NORMAL', 'TANGENT'].forEach(function (name) {
      var camelName = name.slice(0, 1) + name.slice(1).toLowerCase();

      for (var i = 0; i < 8; i++) {
        var morphAttributeName = 'a_morph' + camelName + i;

        if (attributes[morphAttributeName] === undefined) {
          attributes[morphAttributeName] = 'MORPH' + name + i;
        }
      }
    });
  },

  /**
   * 增加基础 uniforms
   */
  addBasicUniforms: function addBasicUniforms() {
    this._copyProps(this.uniforms, {
      u_modelMatrix: 'MODEL',
      u_viewMatrix: 'VIEW',
      u_projectionMatrix: 'PROJECTION',
      u_modelViewMatrix: 'MODELVIEW',
      u_modelViewProjectionMatrix: 'MODELVIEWPROJECTION',
      u_viewInverseNormalMatrix: 'VIEWINVERSEINVERSETRANSPOSE',
      u_normalMatrix: 'MODELVIEWINVERSETRANSPOSE',
      u_normalWorldMatrix: 'MODELINVERSETRANSPOSE',
      u_cameraPosition: 'CAMERAPOSITION',
      u_rendererSize: 'RENDERERSIZE',
      u_logDepth: 'LOGDEPTH',
      // light
      u_ambientLightsColor: 'AMBIENTLIGHTSCOLOR',
      u_directionalLightsColor: 'DIRECTIONALLIGHTSCOLOR',
      u_directionalLightsInfo: 'DIRECTIONALLIGHTSINFO',
      u_directionalLightsShadowMap: 'DIRECTIONALLIGHTSSHADOWMAP',
      u_directionalLightsShadowMapSize: 'DIRECTIONALLIGHTSSHADOWMAPSIZE',
      u_directionalLightsShadowBias: 'DIRECTIONALLIGHTSSHADOWBIAS',
      u_directionalLightSpaceMatrix: 'DIRECTIONALLIGHTSPACEMATRIX',
      u_pointLightsPos: 'POINTLIGHTSPOS',
      u_pointLightsColor: 'POINTLIGHTSCOLOR',
      u_pointLightsInfo: 'POINTLIGHTSINFO',
      u_pointLightsRange: 'POINTLIGHTSRANGE',
      u_pointLightsShadowBias: 'POINTLIGHTSSHADOWBIAS',
      u_pointLightsShadowMap: 'POINTLIGHTSSHADOWMAP',
      u_pointLightSpaceMatrix: 'POINTLIGHTSPACEMATRIX',
      u_pointLightCamera: 'POINTLIGHTCAMERA',
      u_spotLightsPos: 'SPOTLIGHTSPOS',
      u_spotLightsDir: 'SPOTLIGHTSDIR',
      u_spotLightsColor: 'SPOTLIGHTSCOLOR',
      u_spotLightsCutoffs: 'SPOTLIGHTSCUTOFFS',
      u_spotLightsInfo: 'SPOTLIGHTSINFO',
      u_spotLightsRange: 'SPOTLIGHTSRANGE',
      u_spotLightsShadowMap: 'SPOTLIGHTSSHADOWMAP',
      u_spotLightsShadowMapSize: 'SPOTLIGHTSSHADOWMAPSIZE',
      u_spotLightsShadowBias: 'SPOTLIGHTSSHADOWBIAS',
      u_spotLightSpaceMatrix: 'SPOTLIGHTSPACEMATRIX',
      u_areaLightsPos: 'AREALIGHTSPOS',
      u_areaLightsColor: 'AREALIGHTSCOLOR',
      u_areaLightsWidth: 'AREALIGHTSWIDTH',
      u_areaLightsHeight: 'AREALIGHTSHEIGHT',
      u_areaLightsLtcTexture1: 'AREALIGHTSLTCTEXTURE1',
      u_areaLightsLtcTexture2: 'AREALIGHTSLTCTEXTURE2',
      // joint
      u_jointMat: 'JOINTMATRIX',
      u_jointMatTexture: 'JOINTMATRIXTEXTURE',
      u_jointMatTextureSize: 'JOINTMATRIXTEXTURESIZE',
      // quantization
      u_positionDecodeMat: 'POSITIONDECODEMAT',
      u_normalDecodeMat: 'NORMALDECODEMAT',
      u_uvDecodeMat: 'UVDECODEMAT',
      u_uv1DecodeMat: 'UV1DECODEMAT',
      // morph
      u_morphWeights: 'MORPHWEIGHTS',
      u_normalMapScale: 'NORMALMAPSCALE',
      u_emission: 'EMISSION',
      u_transparency: 'TRANSPARENCY',
      // uv matrix
      u_uvMatrix: 'UVMATRIX_0',
      u_uvMatrix1: 'UVMATRIX_1',
      // other info
      u_fogColor: 'FOGCOLOR',
      u_fogInfo: 'FOGINFO',
      u_alphaCutoff: 'ALPHACUTOFF',
      u_exposure: 'EXPOSURE',
      u_gammaFactor: 'GAMMAFACTOR'
    });

    this.addTextureUniforms({
      u_normalMap: 'NORMALMAP',
      u_parallaxMap: 'PARALLAXMAP',
      u_emission: 'EMISSION',
      u_transparency: 'TRANSPARENCY'
    });
  },

  /**
   * 增加贴图 uniforms
   * @param {Object} textureUniforms textureName:semanticName 键值对
   */
  addTextureUniforms: function addTextureUniforms(textureUniforms) {
    var uniforms = {};

    for (var uniformName in textureUniforms) {
      var semanticName = textureUniforms[uniformName];
      uniforms[uniformName] = semanticName;
      uniforms["".concat(uniformName, ".texture")] = semanticName;
      uniforms["".concat(uniformName, ".uv")] = "".concat(semanticName, "UV");
    }

    this._copyProps(this.uniforms, uniforms);
  },

  /**
   * 获取渲染选项值
   * @param  {Object} [option={}] 渲染选项值
   * @return {Object} 渲染选项值
   */
  getRenderOption: function getRenderOption() {
    var _this = this;

    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var lightType = this.lightType;
    option["LIGHT_TYPE_".concat(lightType)] = 1;
    option.SIDE = this.side;

    if (lightType !== 'NONE') {
      option.HAS_LIGHT = 1;
    }

    if (this.premultiplyAlpha) {
      option.PREMULTIPLY_ALPHA = 1;
    }

    var textureOption = this._textureOption.reset(option);

    if (option.HAS_LIGHT) {
      option.HAS_NORMAL = 1;
      textureOption.add(this.normalMap, 'NORMAL_MAP', function () {
        if (_this.normalMapScale !== 1) {
          option.NORMAL_MAP_SCALE = 1;
        }
      });
    }

    textureOption.add(this.parallaxMap, 'PARALLAX_MAP');
    textureOption.add(this.emission, 'EMISSION_MAP');
    textureOption.add(this.transparency, 'TRANSPARENCY_MAP');

    if (this.ignoreTranparent) {
      option.IGNORE_TRANSPARENT = 1;
    }

    if (this.alphaCutoff > 0) {
      option.ALPHA_CUTOFF = 1;
    }

    if (this.useHDR) {
      option.USE_HDR = 1;
    }

    if (this.gammaCorrection) {
      option.GAMMA_CORRECTION = 1;
    }

    if (this.receiveShadows) {
      option.RECEIVE_SHADOWS = 1;
    }

    if (this.castShadows) {
      option.CAST_SHADOWS = 1;
    }

    if (this.uvMatrix) {
      option.UV_MATRIX = 1;
    }

    if (this.uvMatrix1) {
      option.UV_MATRIX1 = 1;
    }

    if (this.usePhysicsLight) {
      option.USE_PHYSICS_LIGHT = 1;
    }

    if (this.isDiffuesEnvAndAmbientLightWorkTogether) {
      option.IS_DIFFUESENV_AND_AMBIENTLIGHT_WORK_TOGETHER = 1;
    }

    textureOption.update();
    return option;
  },
  _textureOption: {
    uvTypes: null,
    option: null,
    reset: function reset(option) {
      this.option = option;
      this.uvTypes = {};
      return this;
    },
    add: function add(texture, optionName, callback) {
      if (texture && texture.isTexture) {
        var uvTypes = this.uvTypes,
            option = this.option;
        var uv = texture.uv || 0;
        uvTypes[uv] = 1;
        option[optionName] = uv;

        if (texture.isCubeTexture) {
          option["".concat(optionName, "_CUBE")] = 1;
        }

        if (callback) {
          callback(texture);
        }
      }

      return this;
    },
    update: function update() {
      var supportUV = [0, 1];
      var uvTypes = this.uvTypes,
          option = this.option;

      for (var type in uvTypes) {
        if (supportUV.indexOf(Number(type)) !== -1) {
          option["HAS_TEXCOORD".concat(type)] = 1;
        } else {
          utils_log.warnOnce("Material._textureOption.update(".concat(type, ")"), "uv_".concat(type, " not support!"));
          option.HAS_TEXCOORD0 = 1;
        }
      }

      return this;
    }
  },

  /**
   * 获取 instanced uniforms
   * @private
   * @return {Object}
   */
  getInstancedUniforms: function getInstancedUniforms() {
    var instancedUniforms = this._instancedUniforms;

    if (!this._instancedUniforms) {
      var uniforms = this.uniforms;
      instancedUniforms = this._instancedUniforms = [];

      for (var name in uniforms) {
        var info = this.getUniformInfo(name);

        if (info.isDependMesh && !info.notSupportInstanced) {
          instancedUniforms.push({
            name: name,
            info: info
          });
        }
      }
    }

    return instancedUniforms;
  },
  getUniformData: function getUniformData(name, mesh, programInfo) {
    return this.getUniformInfo(name).get(mesh, this, programInfo);
  },
  getAttributeData: function getAttributeData(name, mesh, programInfo) {
    return this.getAttributeInfo(name).get(mesh, this, programInfo);
  },
  getUniformInfo: function getUniformInfo(name) {
    return this.getInfo('uniforms', name);
  },
  getAttributeInfo: function getAttributeInfo(name) {
    return this.getInfo('attributes', name);
  },
  getInfo: function getInfo(dataType, name) {
    var dataDict = this[dataType];
    var info = dataDict[name];

    if (typeof info === 'string') {
      info = material_semantic[info];
    }

    if (!info || !info.get) {
      utils_log.warnOnce('material.getInfo-' + name, 'Material.getInfo: no this semantic:' + name);
      info = Material_blankInfo;
    }

    return info;
  },

  /**
   * clone 当前Material
   * @return {Material} 返回clone的Material
   */
  clone: function clone() {
    var newMaterial = new this.constructor();

    for (var key in this) {
      if (key !== 'id') {
        newMaterial[key] = this[key];
      }
    }

    return newMaterial;
  },

  /**
   * 销毁贴图
   * @return {Material} this
   */
  destroyTextures: function destroyTextures() {
    this.getTextures().forEach(function (texture) {
      texture.destroy();
    });
  },

  /**
   * 获取材质全部贴图
   * @return {Texture[]}
   */
  getTextures: function getTextures() {
    var textures = [];

    for (var propName in this) {
      var texture = this[propName];

      if (texture && texture.isTexture) {
        textures.push(texture);
      }
    }

    return textures;
  },

  /**
   * 复制属性，只有没属性时才会覆盖
   * @private
   * @param  {Object} origin
   * @param  {Object} data
   */
  _copyProps: function _copyProps(origin, data) {
    for (var key in data) {
      if (origin[key] === undefined) {
        origin[key] = data[key];
      }
    }
  }
});
/* harmony default export */ var material_Material = (Material);
// CONCATENATED MODULE: ./src/material/BasicMaterial.js



/**
 * 基础材质，支持 NONE, PHONG, BLINN-PHONG, LAMBERT光照模型
 * @class
 * @extends Material
 * @example
 * const material = new Hilo3d.BasicMaterial({
 *     diffuse: new Hilo3d.Color(1, 0, 0, 1)
 * });
 */

var BasicMaterial = core_Class.create(
/** @lends BasicMaterial.prototype */
{
  Extends: material_Material,

  /**
   * @default true
   * @type {boolean}
   */
  isBasicMaterial: true,

  /**
   * @default BasicMaterial
   * @type {string}
   */
  className: 'BasicMaterial',

  /**
   * 光照类型，支持: NONE, PHONG, BLINN-PHONG, LAMBERT
   * @default BLINN-PHONG
   * @type {string}
   */
  lightType: 'BLINN-PHONG',

  /**
   * 漫反射贴图，或颜色
   * @default Color(.5, .5, .5)
   * @type {Texture|Color}
   */
  diffuse: null,

  /**
   * 环境光贴图，或颜色
   * @default null
   * @type {Texture|Color}
   */
  ambient: null,

  /**
   * 镜面贴图，或颜色
   * @default Color(1, 1, 1)
   * @type {Texture|Color}
   */
  specular: null,

  /**
   * 放射光贴图，或颜色
   * @default Color(0, 0, 0)
   * @type {Texture|Color}
   */
  emission: null,

  /**
   * 环境贴图
   * @default null
   * @type {CubeTexture|Texture}
   */
  specularEnvMap: null,

  /**
   * 环境贴图变化矩阵，如旋转等
   * @default null
   * @type {Matrix4}
   */
  specularEnvMatrix: null,

  /**
   * 反射率
   * @default 0
   * @type {number}
   */
  reflectivity: 0,

  /**
   * 折射比率
   * @default 0
   * @type {number}
   */
  refractRatio: 0,

  /**
   * 折射率
   * @default 0
   * @type {number}
   */
  refractivity: 0,

  /**
   * 高光发光值
   * @default 32
   * @type {number}
   */
  shininess: 32,
  usedUniformVectors: 11,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    this.diffuse = new math_Color(.5, .5, .5);
    this.specular = new math_Color(1, 1, 1);
    this.emission = new math_Color(0, 0, 0);
    BasicMaterial.superclass.constructor.call(this, params);
    Object.assign(this.uniforms, {
      u_diffuse: 'DIFFUSE',
      u_specular: 'SPECULAR',
      u_ambient: 'AMBIENT',
      u_shininess: 'SHININESS',
      u_reflectivity: 'REFLECTIVITY',
      u_refractRatio: 'REFRACTRATIO',
      u_refractivity: 'REFRACTIVITY',
      u_specularEnvMap: 'SPECULARENVMAP',
      u_specularEnvMatrix: 'SPECULARENVMATRIX'
    });
    this.addTextureUniforms({
      u_diffuse: 'DIFFUSE',
      u_specular: 'SPECULAR',
      u_ambient: 'AMBIENT'
    });
  },
  getRenderOption: function getRenderOption() {
    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    BasicMaterial.superclass.getRenderOption.call(this, option);

    var textureOption = this._textureOption.reset(option);

    var lightType = this.lightType;

    if (lightType === 'PHONG' || lightType === 'BLINN-PHONG') {
      option.HAS_SPECULAR = 1;
    }

    var diffuse = this.diffuse;

    if (diffuse && diffuse.isTexture) {
      if (diffuse.isCubeTexture) {
        option.DIFFUSE_CUBE_MAP = 1;
      } else {
        textureOption.add(this.diffuse, 'DIFFUSE_MAP');
      }
    }

    if (option.HAS_LIGHT) {
      textureOption.add(this.specular, 'SPECULAR_MAP');
      textureOption.add(this.ambient, 'AMBIENT_MAP');
      textureOption.add(this.specularEnvMap, 'SPECULAR_ENV_MAP');
    }

    textureOption.update();
    return option;
  }
});
/* harmony default export */ var material_BasicMaterial = (BasicMaterial);
// CONCATENATED MODULE: ./src/material/GeometryMaterial.js



var GeometryMaterial_POSITION = src_constants.POSITION,
    GeometryMaterial_NORMAL = src_constants.NORMAL,
    GeometryMaterial_DEPTH = src_constants.DEPTH,
    GeometryMaterial_DISTANCE = src_constants.DISTANCE,
    NONE = src_constants.NONE;
/**
 * 几何材质，支持 POSITION, NORMAL, DEPTH, DISTANCE 顶点类型
 * @class
 * @extends BasicMaterial
 * @example
 * const material = new Hilo3d.GeometryMaterial({
 *     diffuse: new Hilo3d.Color(1, 0, 0, 1)
 * });
 */

var GeometryMaterial = core_Class.create(
/** @lends GeometryMaterial.prototype */
{
  Extends: material_BasicMaterial,

  /**
   * @default true
   * @type {boolean}
   */
  isGeometryMaterial: true,

  /**
   * @default GeometryMaterial
   * @type {string}
   */
  className: 'GeometryMaterial',

  /**
   * 顶点类型 POSITION, NORMAL, DEPTH, DISTANCE
   * @type {String}
   */
  vertexType: GeometryMaterial_POSITION,
  lightType: NONE,

  /**
   * 是否直接存储
   * @type {Boolean}
   */
  writeOriginData: false,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    GeometryMaterial.superclass.constructor.call(this, params);
    Object.assign(this.uniforms, {
      u_cameraFar: 'CAMERAFAR',
      u_cameraNear: 'CAMERANEAR',
      u_cameraType: 'CAMERATYPE'
    });
  },
  getRenderOption: function getRenderOption() {
    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    GeometryMaterial.superclass.getRenderOption.call(this, option);
    option["VERTEX_TYPE_".concat(this.vertexType)] = 1;

    switch (this.vertexType) {
      case GeometryMaterial_POSITION:
        option.HAS_FRAG_POS = 1;
        break;

      case GeometryMaterial_NORMAL:
        option.HAS_NORMAL = 1;
        break;

      case GeometryMaterial_DEPTH:
        break;

      case GeometryMaterial_DISTANCE:
        option.HAS_FRAG_POS = 1;
        break;
    }

    if (this.writeOriginData) {
      option.WRITE_ORIGIN_DATA = 1;
    }

    return option;
  }
});
/* harmony default export */ var material_GeometryMaterial = (GeometryMaterial);
// CONCATENATED MODULE: ./src/camera/OrthographicCamera.js



/**
 * 正交投影摄像机
 * @class
 * @extends Camera
 */

var OrthographicCamera = core_Class.create(
/** @lends OrthographicCamera.prototype */
{
  Extends: camera_Camera,

  /**
   * @default true
   * @type {boolean}
   */
  isOrthographicCamera: true,

  /**
   * @default OrthographicCamera
   * @type {string}
   */
  className: 'OrthographicCamera',
  _left: -1,

  /**
   * @default -1
   * @type {number}
   */
  left: {
    get: function get() {
      return this._left;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._left = value;
    }
  },
  _right: 1,

  /**
   * @default 1
   * @type {number}
   */
  right: {
    get: function get() {
      return this._right;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._right = value;
    }
  },
  _bottom: -1,

  /**
   * @default -1
   * @type {number}
   */
  bottom: {
    get: function get() {
      return this._bottom;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._bottom = value;
    }
  },
  _top: 1,

  /**
   * @default 1
   * @type {number}
   */
  top: {
    get: function get() {
      return this._top;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._top = value;
    }
  },
  _near: 0.1,

  /**
   * @default 0.1
   * @type {number}
   */
  near: {
    get: function get() {
      return this._near;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._near = value;
    }
  },
  _far: 1,

  /**
   * @default 1
   * @type {number}
   */
  far: {
    get: function get() {
      return this._far;
    },
    set: function set(value) {
      this._needUpdateProjectionMatrix = true;
      this._isGeometryDirty = true;
      this._far = value;
    }
  },

  /**
   * @constructs
   * @param {object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    OrthographicCamera.superclass.constructor.call(this, params);
    this.updateProjectionMatrix();
  },

  /**
   * 更新投影矩阵
   */
  updateProjectionMatrix: function updateProjectionMatrix() {
    this.projectionMatrix.ortho(this.left, this.right, this.bottom, this.top, this.near, this.far);
  },
  getGeometry: function getGeometry(forceUpdate) {
    if (forceUpdate || !this._geometry || this._isGeometryDirty) {
      this._isGeometryDirty = false;
      var geometry = new geometry_Geometry();
      var p1 = [this.left, this.bottom, -this.near];
      var p2 = [this.right, this.bottom, -this.near];
      var p3 = [this.right, this.top, -this.near];
      var p4 = [this.left, this.top, -this.near];
      var p5 = [this.left, this.bottom, -this.far];
      var p6 = [this.right, this.bottom, -this.far];
      var p7 = [this.right, this.top, -this.far];
      var p8 = [this.left, this.top, -this.far];
      geometry.addRect(p5, p6, p7, p8); // front

      geometry.addRect(p6, p2, p3, p7); // right

      geometry.addRect(p2, p1, p4, p3); // back

      geometry.addRect(p1, p5, p8, p4); // left

      geometry.addRect(p8, p7, p3, p4); // top

      geometry.addRect(p1, p2, p6, p5); // bottom

      this._geometry = geometry;
    }

    return this._geometry;
  }
});
/* harmony default export */ var camera_OrthographicCamera = (OrthographicCamera);
// CONCATENATED MODULE: ./src/light/LightShadow.js










var LightShadow_DEPTH = src_constants.DEPTH,
    LightShadow_BACK = src_constants.BACK;
var shadowMaterial = null;
var LightShadow_clearColor = new math_Color(1, 1, 1);
var LightShadow_tempMatrix4 = new math_Matrix4();

var isNeedRenderMesh = function isNeedRenderMesh(mesh) {
  return mesh.material.castShadows;
};
/**
 * @class
 * @private
 */


var LightShadow = core_Class.create(
/** @lends LightShadow.prototype */
{
  isLightShadow: true,
  className: 'LightShadow',
  light: null,
  renderer: null,
  framebuffer: null,
  camera: null,
  width: 1024,
  height: 1024,
  maxBias: 0.05,
  minBias: 0.005,
  cameraInfo: null,
  debug: false,
  constructor: function constructor(params) {
    this.id = math_math.generateUUID(this.className);
    Object.assign(this, params);
  },
  createFramebuffer: function createFramebuffer() {
    if (this.framebuffer) {
      return;
    }

    this.framebuffer = new renderer_Framebuffer(this.renderer, {
      width: this.width,
      height: this.height
    });

    if (this.debug) {
      this.showShadowMap();
    }
  },
  updateLightCamera: function updateLightCamera(currentCamera) {
    if (this.light.isDirectionalLight) {
      this.updateDirectionalLightCamera(currentCamera);
    } else if (this.light.isSpotLight) {
      this.updateSpotLightCamera(currentCamera);
    }
  },
  updateDirectionalLightCamera: function updateDirectionalLightCamera(currentCamera) {
    var light = this.light;
    this.camera.lookAt(light.direction);

    if (this.cameraInfo) {
      this.updateCustumCamera(this.cameraInfo);
    } else {
      var geometry = currentCamera.getGeometry();

      if (geometry) {
        this.camera.updateViewMatrix();
        LightShadow_tempMatrix4.multiply(this.camera.viewMatrix, currentCamera.worldMatrix);
        var bounds = geometry.getBounds(LightShadow_tempMatrix4);
        this.camera.near = -bounds.zMax;
        this.camera.far = -bounds.zMin;
        this.camera.left = bounds.xMin;
        this.camera.right = bounds.xMax;
        this.camera.bottom = bounds.yMin;
        this.camera.top = bounds.yMax;
      }
    }

    this.camera.updateViewMatrix();
  },
  updateCustumCamera: function updateCustumCamera(cameraInfo) {
    for (var name in cameraInfo) {
      this.camera[name] = cameraInfo[name];
    }
  },
  updateSpotLightCamera: function updateSpotLightCamera(currentCamera) {
    var light = this.light;
    this.camera.lookAt(light.direction);

    if (this.cameraInfo) {
      this.updateCustumCamera(this.cameraInfo);
    } else {
      this.camera.fov = light.outerCutoff * 2;
      this.camera.near = 0.01;
      this.camera.far = currentCamera.far;
      this.camera.aspect = 1;
    }

    this.camera.updateViewMatrix();
  },
  createCamera: function createCamera(currentCamera) {
    if (!this.camera) {
      if (this.light.isDirectionalLight) {
        this.camera = new camera_OrthographicCamera();
      } else if (this.light.isSpotLight) {
        this.camera = new camera_PerspectiveCamera();
      }

      this.camera.addTo(this.light);
    }

    if (this._cameraMatrixVersion !== currentCamera.matrixVersion) {
      this.updateLightCamera(currentCamera);
      this._cameraMatrixVersion = currentCamera.matrixVersion;
    }
  },
  createShadowMap: function createShadowMap(currentCamera) {
    this.createFramebuffer();
    this.createCamera(currentCamera);
    var renderer = this.renderer,
        framebuffer = this.framebuffer,
        camera = this.camera;

    if (!shadowMaterial) {
      shadowMaterial = new material_GeometryMaterial({
        vertexType: LightShadow_DEPTH,
        side: LightShadow_BACK,
        writeOriginData: true
      });
    }

    framebuffer.bind();
    renderer.state.viewport(0, 0, this.width, this.height);
    renderer.clear(LightShadow_clearColor);
    camera.updateViewProjectionMatrix();
    material_semantic.setCamera(camera);
    renderer.forceMaterial = shadowMaterial;
    this.renderShadowScene(renderer);
    delete renderer.forceMaterial;
    framebuffer.unbind();
    material_semantic.setCamera(currentCamera);
    renderer.viewport();
  },
  renderShadowScene: function renderShadowScene(renderer) {
    var renderList = renderer.renderList;
    renderList.traverse(function (mesh) {
      if (isNeedRenderMesh(mesh)) {
        renderer.renderMesh(mesh);
      }
    }, function (instancedMeshes) {
      renderer.renderInstancedMeshes(instancedMeshes.filter(function (mesh) {
        return isNeedRenderMesh(mesh);
      }));
    });
  },
  showShadowMap: function showShadowMap() {
    var _this = this;

    this.renderer.on('afterRender', function () {
      _this.framebuffer.render(0, 0.7, 0.3, 0.3);
    });
  }
});
/* harmony default export */ var light_LightShadow = (LightShadow);
// CONCATENATED MODULE: ./src/light/CubeLightShadow.js












var CubeLightShadow_DISTANCE = src_constants.DISTANCE,
    CubeLightShadow_BACK = src_constants.BACK,
    CubeLightShadow_TEXTURE_CUBE_MAP = src_constants.TEXTURE_CUBE_MAP,
    TEXTURE0 = src_constants.TEXTURE0,
    CubeLightShadow_TEXTURE_CUBE_MAP_POSITIVE_X = src_constants.TEXTURE_CUBE_MAP_POSITIVE_X,
    CubeLightShadow_NEAREST = src_constants.NEAREST,
    FRAMEBUFFER = src_constants.FRAMEBUFFER,
    FRAMEBUFFER_COMPLETE = src_constants.FRAMEBUFFER_COMPLETE;
var CubeLightShadow_shadowMaterial = null;
var CubeLightShadow_clearColor = new math_Color(0, 0, 0, 0);
var CubeLightShadow_tempVector3 = new math_Vector3();
var LookAtMap = [[1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, -1, 0, 0, -1, 0]];

var CubeLightShadow_isNeedRenderMesh = function isNeedRenderMesh(mesh, camera) {
  if (mesh.material.castShadows) {
    if (!mesh.frustumTest) {
      return true;
    }

    if (camera.isMeshVisible(mesh)) {
      return true;
    }
  }

  return false;
};
/**
 * @class
 * @private
 */


var CubeLightShadow = core_Class.create(
/** @lends CubeLightShadow.prototype */
{
  isLightShadow: true,
  className: 'CubeLightShadow',
  Extends: light_LightShadow,
  light: null,
  renderer: null,
  framebuffer: null,
  camera: null,
  width: 1024,
  height: 1024,
  maxBias: 0.05,
  minBias: 0.005,
  debug: false,
  constructor: function constructor(params) {
    CubeLightShadow.superclass.constructor.call(this, params);
  },
  createFramebuffer: function createFramebuffer() {
    if (this.framebuffer) {
      return;
    }

    var size = 1024;
    this.framebuffer = new renderer_Framebuffer(this.renderer, {
      target: CubeLightShadow_TEXTURE_CUBE_MAP,
      width: size,
      height: size,
      createTexture: function createTexture() {
        var state = this.state;
        var gl = state.gl;
        var texture = new texture_CubeTexture({
          image: [null, null, null, null, null, null],
          type: this.type,
          format: this.format,
          internalFormat: this.internalFormat,
          magFilter: CubeLightShadow_NEAREST,
          minFilter: CubeLightShadow_NEAREST,
          width: size,
          height: size
        });

        if (gl.checkFramebufferStatus(FRAMEBUFFER) !== FRAMEBUFFER_COMPLETE) {
          utils_log.warn('Framebuffer is not complete', gl.checkFramebufferStatus(FRAMEBUFFER));
        }

        return texture;
      },
      bindTexture: function bindTexture(index) {
        index = index || 0;
        var state = this.state;
        var gl = state.gl;
        var glTexture = this.texture.getGLTexture(state);
        state.activeTexture(TEXTURE0 + renderer_capabilities.MAX_TEXTURE_INDEX);
        state.bindTexture(this.target, glTexture);
        gl.framebufferTexture2D(FRAMEBUFFER, this.attachment, CubeLightShadow_TEXTURE_CUBE_MAP_POSITIVE_X + index, glTexture, 0);
      }
    });
  },
  updateLightCamera: function updateLightCamera(currentCamera) {
    this.camera.fov = 90;
    this.camera.near = currentCamera.near;
    this.camera.far = currentCamera.far;
    this.camera.aspect = 1;
    this.camera.updateViewMatrix();
  },
  createCamera: function createCamera(currentCamera) {
    if (this.camera) {
      return;
    }

    this.camera = new camera_PerspectiveCamera();
    this.updateLightCamera(currentCamera);
  },
  createShadowMap: function createShadowMap(currentCamera) {
    this.createFramebuffer();
    this.createCamera(currentCamera);
    var renderer = this.renderer,
        framebuffer = this.framebuffer,
        camera = this.camera;

    if (!CubeLightShadow_shadowMaterial) {
      CubeLightShadow_shadowMaterial = new material_GeometryMaterial({
        vertexType: CubeLightShadow_DISTANCE,
        side: CubeLightShadow_BACK,
        writeOriginData: false
      });
    }

    framebuffer.bind();
    renderer.state.viewport(0, 0, framebuffer.width, framebuffer.height);
    this.light.worldMatrix.getTranslation(camera.position);

    for (var i = 0; i < 6; i++) {
      framebuffer.bindTexture(i);
      CubeLightShadow_tempVector3.fromArray(LookAtMap[0], i * 3).add(camera.position);
      camera.up.fromArray(LookAtMap[1], i * 3);
      camera.lookAt(CubeLightShadow_tempVector3);
      camera.updateViewProjectionMatrix();
      renderer.clear(CubeLightShadow_clearColor);
      material_semantic.setCamera(camera);
      renderer.forceMaterial = CubeLightShadow_shadowMaterial;
      this.renderShadowScene(renderer);
    }

    camera.matrix.identity();
    camera.updateViewProjectionMatrix();
    delete renderer.forceMaterial;
    framebuffer.unbind();
    material_semantic.setCamera(currentCamera);
    renderer.viewport();
  },
  renderShadowScene: function renderShadowScene(renderer) {
    var renderList = renderer.renderList;
    var camera = this.camera;
    renderList.traverse(function (mesh) {
      if (CubeLightShadow_isNeedRenderMesh(mesh, camera)) {
        renderer.renderMesh(mesh);
      }
    }, function (instancedMeshes) {
      var needRenderMeshes = instancedMeshes.filter(function (mesh) {
        return CubeLightShadow_isNeedRenderMesh(mesh, camera);
      });
      renderer.renderInstancedMeshes(needRenderMeshes);
    });
  }
});
/* harmony default export */ var light_CubeLightShadow = (CubeLightShadow);
// CONCATENATED MODULE: ./src/light/PointLight.js



/**
 * 点光源
 * @class
 * @extends Light
 */

var PointLight = core_Class.create(
/** @lends PointLight.prototype */
{
  Extends: light_Light,

  /**
   * @default true
   * @type {boolean}
   */
  isPointLight: true,

  /**
   * @default PointLight
   * @type {string}
   */
  className: 'PointLight',

  /**
   * @constructs
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    PointLight.superclass.constructor.call(this, params);
  },
  createShadowMap: function createShadowMap(renderer, camera) {
    if (!this.shadow) {
      return;
    }

    if (!this.lightShadow) {
      this.lightShadow = new light_CubeLightShadow({
        light: this,
        renderer: renderer
      });

      if ('minBias' in this.shadow) {
        this.lightShadow.minBias = this.shadow.minBias;
      }

      if ('maxBias' in this.shadow) {
        this.lightShadow.maxBias = this.shadow.maxBias;
      }
    }

    this.lightShadow.createShadowMap(camera);
  }
});
/* harmony default export */ var light_PointLight = (PointLight);
// CONCATENATED MODULE: ./src/light/DirectionalLight.js





var DirectionalLight_tempMatrix4 = new math_Matrix4();
var DirectionalLight_tempVector3 = new math_Vector3();
/**
 * 平行光
 * @class
 * @extends Light
 */

var DirectionalLight = core_Class.create(
/** @lends DirectionalLight.prototype */
{
  Extends: light_Light,

  /**
   * @default true
   * @type {boolean}
   */
  isDirectionalLight: true,

  /**
   * @default DirectionalLight
   * @type {string}
   */
  className: 'DirectionalLight',

  /**
   * @constructs
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    /**
     * 光方向
     * @type {Vector3}
     * @default new Vector3(0, 0, 1)
     */
    this.direction = new math_Vector3(0, 0, 1);
    DirectionalLight.superclass.constructor.call(this, params);
  },
  createShadowMap: function createShadowMap(renderer, camera) {
    if (!this.shadow) {
      return;
    }

    if (!this.lightShadow) {
      this.lightShadow = new light_LightShadow({
        light: this,
        renderer: renderer,
        width: this.shadow.width || renderer.width,
        height: this.shadow.height || renderer.height,
        debug: this.shadow.debug,
        cameraInfo: this.shadow.cameraInfo
      });

      if ('minBias' in this.shadow) {
        this.lightShadow.minBias = this.shadow.minBias;
      }

      if ('maxBias' in this.shadow) {
        this.lightShadow.maxBias = this.shadow.maxBias;
      }
    }

    this.lightShadow.createShadowMap(camera);
  },
  getWorldDirection: function getWorldDirection() {
    DirectionalLight_tempVector3.copy(this.direction).transformDirection(this.worldMatrix).normalize();
    return DirectionalLight_tempVector3;
  },
  getViewDirection: function getViewDirection(camera) {
    var modelViewMatrix = camera.getModelViewMatrix(this, DirectionalLight_tempMatrix4);
    DirectionalLight_tempVector3.copy(this.direction).transformDirection(modelViewMatrix).normalize();
    return DirectionalLight_tempVector3;
  }
});
/* harmony default export */ var light_DirectionalLight = (DirectionalLight);
// CONCATENATED MODULE: ./src/light/SpotLight.js






var SpotLight_tempMatrix4 = new math_Matrix4();
var SpotLight_tempVector3 = new math_Vector3();
/**
 * 聚光灯
 * @class
 * @extends Light
 */

var SpotLight = core_Class.create(
/** @lends SpotLight.prototype */
{
  Extends: light_Light,

  /**
   * @default true
   * @type {boolean}
   */
  isSpotLight: true,

  /**
   * @default SpotLight
   * @type {string}
   */
  className: 'SpotLight',
  _cutoffCos: 0.9763,
  _cutoff: 12.5,

  /**
   * 切光角(角度)，落在这个角度之内的光亮度为1
   * @default 12.5
   * @type {number}
   */
  cutoff: {
    get: function get() {
      return this._cutoff;
    },
    set: function set(value) {
      this._cutoff = value;
      this._cutoffCos = Math.cos(math_math.degToRad(value));
    }
  },
  _outerCutoffCos: 0.9537,
  _outerCutoff: 17.5,

  /**
   * 外切光角(角度)，在切光角合外切光角之间的光亮度渐变到0
   * @default 17.5
   * @type {number}
   */
  outerCutoff: {
    get: function get() {
      return this._outerCutoff;
    },
    set: function set(value) {
      this._outerCutoff = value;
      this._outerCutoffCos = Math.cos(math_math.degToRad(value));
    }
  },

  /**
   * @constructs
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    /**
     * 光方向
     * @type {Vector3}
     * @default new Vector3(0, 0, 1)
     */
    this.direction = new math_Vector3(0, 0, 1);
    SpotLight.superclass.constructor.call(this, params);
  },
  createShadowMap: function createShadowMap(renderer, camera) {
    if (!this.shadow) {
      return;
    }

    if (!this.lightShadow) {
      this.lightShadow = new light_LightShadow({
        light: this,
        renderer: renderer,
        width: this.shadow.width || renderer.width,
        height: this.shadow.height || renderer.height,
        debug: this.shadow.debug,
        cameraInfo: this.shadow.cameraInfo
      });

      if ('minBias' in this.shadow) {
        this.lightShadow.minBias = this.shadow.minBias;
      }

      if ('maxBias' in this.shadow) {
        this.lightShadow.maxBias = this.shadow.maxBias;
      }
    }

    this.lightShadow.createShadowMap(camera);
  },
  getWorldDirection: function getWorldDirection() {
    SpotLight_tempVector3.copy(this.direction).transformDirection(this.worldMatrix).normalize();
    return SpotLight_tempVector3;
  },
  getViewDirection: function getViewDirection(camera) {
    var modelViewMatrix = camera.getModelViewMatrix(this, SpotLight_tempMatrix4);
    SpotLight_tempVector3.copy(this.direction).transformDirection(modelViewMatrix).normalize();
    return SpotLight_tempVector3;
  }
});
/* harmony default export */ var light_SpotLight = (SpotLight);
// CONCATENATED MODULE: ./src/material/ShaderMaterial.js


/**
 * Shader材质
 * @class
 * @extends Material
 * @example
 * const material = new Hilo3d.ShaderMaterial({
 *     attributes:{
 *         a_pos: 'POSITION'
 *     },
 *     uniforms:{
 *         u_mat:'MODELVIEWPROJECTION',
 *         u_color_b:{
 *             get:function(mesh, material, programInfo){
 *                 return Math.random();
 *             }
 *         }
 *     },
 *     vs:`
 *         precision HILO_MAX_VERTEX_PRECISION float;
 *         attribute vec3 a_pos;
 *         uniform mat4 u_mat;
 *
 *         void main(void) {
 *             gl_Position = u_mat * vec4(a_pos, 1.0);
 *         }
 *     `,
 *     fs:`
 *         precision HILO_MAX_FRAGMENT_PRECISION float;
 *         uniform float u_color_b;
 *
 *         void main(void) {
 *             gl_FragColor = vec4(0.6, 0.8, u_color_b, 1);
 *         }
 *     `
 * });
 */

var ShaderMaterial = core_Class.create(
/** @lends ShaderMaterial.prototype */
{
  Extends: material_Material,

  /**
   * @default true
   * @type {boolean}
   */
  isShaderMaterial: true,

  /**
   * @default ShaderMaterial
   * @type {string}
   */
  className: 'ShaderMaterial',

  /**
   * vertex shader 代码
   * @type {string}
   */
  vs: '',

  /**
   * fragment shader 代码
   * @type {string}
   */
  fs: '',

  /**
   * 是否使用 header cache shader
   * @default true
   * @type {Boolean}
   */
  useHeaderCache: false,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    ShaderMaterial.superclass.constructor.call(this, params);
  },
  getRenderOption: function getRenderOption() {
    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    ShaderMaterial.superclass.getRenderOption.call(this, option);

    if (this.getCustomRenderOption) {
      var custumOption = this.getCustomRenderOption({});

      for (var name in custumOption) {
        option["HILO_CUSTUM_OPTION_".concat(name)] = custumOption[name];
      }
    }

    return option;
  },

  /**
   * 获取定制的渲染参数
   * @default null
   * @type {Function}
   */
  getCustomRenderOption: null
});
/* harmony default export */ var material_ShaderMaterial = (ShaderMaterial);
// EXTERNAL MODULE: ./node_modules/_amc@1.0.6@amc/build/amd.js
var amd = __webpack_require__("./node_modules/_amc@1.0.6@amc/build/amd.js");
var amd_default = /*#__PURE__*/__webpack_require__.n(amd);

// CONCATENATED MODULE: ./src/geometry/MorphGeometry.js



/**
 * Morph几何体
 * @class
 * @extends Geometry
 */

var MorphGeometry = core_Class.create(
/** @lends MorphGeometry.prototype */
{
  Extends: geometry_Geometry,

  /**
   * @default true
   * @type {boolean}
   */
  isMorphGeometry: true,

  /**
   * @default MorphGeometry
   * @type {string}
   */
  className: 'MorphGeometry',
  isStatic: false,

  /**
   * morph animation weights
   * @type {Array.<number>}
   */
  weights: [],

  /**
   * like:
   * {
   *     vertices: [[], []],
   *     normals: [[], []],
   *     tangents: [[], []]
   * }
   * @default null
   * @type {Object}
   */
  targets: null,

  /**
   * @constructs
   * @param {object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    MorphGeometry.superclass.constructor.call(this, params);
    this.weights = this.weights || [];
  },
  update: function update(weights, originalWeightIndices) {
    this.weights = weights;
    this._originalMorphIndices = originalWeightIndices;
  },
  clone: function clone() {
    return geometry_Geometry.prototype.clone.call(this, {
      targets: this.targets,
      weights: this.weights
    });
  },
  getRenderOption: function getRenderOption() {
    var _this = this;

    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    MorphGeometry.superclass.getRenderOption.call(this, opt);

    if (this.targets) {
      if (!this._maxMorphTargetCount) {
        this._maxMorphTargetCount = Math.floor(8 / Object.keys(this.targets).length);
      }

      util_each(this.targets, function (list, name) {
        opt.MORPH_TARGET_COUNT = Math.min(list.length, _this._maxMorphTargetCount);

        if (name === 'vertices') {
          opt.MORPH_HAS_POSITION = 1;
        } else if (name === 'normals') {
          opt.MORPH_HAS_NORMAL = 1;
        } else if (name === 'tangents') {
          opt.MORPH_HAS_TANGENT = 1;
        }
      });
    }

    return opt;
  }
});
/* harmony default export */ var geometry_MorphGeometry = (MorphGeometry);
// CONCATENATED MODULE: ./src/loader/AliAMCExtension.js




var glTFAttrToGeometry = {
  POSITION: {
    name: 'vertices',
    decodeMatName: 'positionDecodeMat'
  },
  TEXCOORD_0: {
    name: 'uvs',
    decodeMatName: 'uvDecodeMat'
  },
  TEXCOORD_1: {
    name: 'uvs1',
    decodeMatName: 'uv1DecodeMat'
  },
  NORMAL: {
    name: 'normals',
    decodeMatName: 'normalDecodeMat'
  },
  JOINT: {
    name: 'skinIndices'
  },
  JOINTS_0: {
    name: 'skinIndices'
  },
  WEIGHT: {
    name: 'skinWeights'
  },
  WEIGHTS_0: {
    name: 'skinWeights'
  },
  TANGENT: {
    name: 'tangents'
  },
  COLOR_0: {
    name: 'colors'
  }
};
var mockHilo3d = {
  Geometry: geometry_Geometry,
  GeometryData: geometry_GeometryData
};

function fixMorphGeometry(info, amcGeometry, destGeometry) {
  if (!destGeometry.isMorphGeometry) {
    var morphGeometry = new geometry_MorphGeometry();

    for (var name in destGeometry) {
      if (Object.prototype.hasOwnProperty.call(destGeometry, name) && name !== 'id') {
        morphGeometry[name] = destGeometry[name];
      }
    }

    morphGeometry.targets = {};
    destGeometry = morphGeometry;
  }

  var targets = destGeometry.targets;

  for (var i = 0; i < info.targets.length; i++) {
    var target = info.targets[i];

    for (var _name in target) {
      if (_name in glTFAttrToGeometry) {
        var amcAttrIndex = target[_name];
        var hilo3dName = glTFAttrToGeometry[_name].name;

        if (!targets[hilo3dName]) {
          targets[hilo3dName] = [];
        }

        var attr = amcGeometry.attrs[amcAttrIndex];
        targets[hilo3dName].push(new geometry_GeometryData(attr.data, attr.itemCount));
      }
    }
  }

  if (info.weights) {
    destGeometry.weights = info.weights;
  } else {
    destGeometry.weights = new Float32Array(info.targets.length);
  }

  return destGeometry;
}

var AliAMCExtension = {
  _decodeTotalTime: 0,
  wasmURL: '',
  workerURL: '',
  useWASM: true,
  useWebWorker: true,
  useAuto: true,
  init: function init() {
    if (AliAMCExtension.useAuto) {
      return amd_default.a.initWASM(AliAMCExtension.wasmURL, AliAMCExtension.memPages);
    }

    if (AliAMCExtension.useWebWorker) {
      return amd_default.a.initWorker(AliAMCExtension.workerURL);
    }

    if (AliAMCExtension.useWASM) {
      return amd_default.a.initWASM(AliAMCExtension.wasmURL, AliAMCExtension.memPages);
    }

    return Promise.resolve();
  },
  parse: function parse(info, parser, result, options) {
    var st = Date.now();
    var bufferView = parser.bufferViews[info.bufferView];
    var wasmURL = AliAMCExtension.wasmURL,
        workerURL = AliAMCExtension.workerURL,
        useAuto = AliAMCExtension.useAuto,
        useWASM = AliAMCExtension.useWASM,
        useWebWorker = AliAMCExtension.useWebWorker;
    var amcGeometry;
    var data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);

    function done(amcGeometry) {
      AliAMCExtension._decodeTotalTime += Date.now() - st;
      var destGeometry = amcGeometry.toHilo3dGeometry(mockHilo3d, options.primitive._geometry);

      if (info.targets) {
        destGeometry = fixMorphGeometry(info, amcGeometry, destGeometry);
      }

      return destGeometry;
    }

    if (useAuto) {
      return amd_default.a.decompress(data, wasmURL, workerURL).then(done);
    }

    if (useWebWorker) {
      return amd_default.a.decompressWithWorker(data, useWASM, wasmURL, workerURL).then(done);
    }

    if (useWASM) {
      amcGeometry = amd_default.a.decompressWithWASM(data, wasmURL);
    } else {
      amcGeometry = amd_default.a.decompressWithJS(data);
    }

    return done(amcGeometry);
  },
  freeMemory: function freeMemory() {
    amd_default.a.destory();
  }
};
/* harmony default export */ var loader_AliAMCExtension = (AliAMCExtension);
// CONCATENATED MODULE: ./src/loader/GLTFExtensions.js
/* eslint camelcase: "off" */










var SAMPLER_2D = src_constants.SAMPLER_2D;

/**
 * GLTFExtension Handler 接口
 * @interface IGLTFExtensionHandler
 */

/**
 * 解析元素扩展
 * @function
 * @name IGLTFExtensionHandler#[parse]
 * @param {Object} [extensionData] 扩展数据
 * @param {GLTFParser} [parser] parser
 * @param {Object} [element] parse的元素，e.g. material, mesh, geometry
 * @param {Object} [options]
 * @return {Object} [result] 一般需要返回原始元素或者替换的新的元素
 */

/**
 * 解析全局扩展，在资源加载后执行
 * @function
 * @name IGLTFExtensionHandler#[parseOnLoad]
 * @param {Object} [extensionData] 扩展数据
 * @param {GLTFParser} [parser] parser
 * @param {Object} [element] parse的元素，这里为 null
 * @param {Object} [options]
 */

/**
 * 解析全局扩展，在所有元素解析结束后执行
 * @function
 * @name IGLTFExtensionHandler#[parseOnEnd]
 * @param {Object} [extensionData] 扩展数据
 * @param {GLTFParser} [parser] parser
 * @param {GLTFModel} [element] parse的元素，这里为加载后的model，{node, scene, meshes, json, cameras, lights, textures, materials}
 * @param {Object} [options]
 */

/**
 * 初始化全局扩展，在加载前执行，可进行添加需要加载的资源
 * @function
 * @name IGLTFExtensionHandler#[init]
 * @param {GLTFLoader} [gltfLoader]
 * @param {GLTFParser} [parser]
 */

/**
 * 获取扩展用到的贴图信息, parser.isLoadAllTextures 为 false 时生效
 * @function
 * @name IGLTFExtensionHandler#[getUsedTextureNameMap]
 * @param {Object} [extensionData] 扩展数据
 * @param {Object} [map] used texture map
 * @example
 * getUsedTextureNameMap(extension, map) {
 *     if (extension.diffuseTexture) {
 *         map[extension.diffuseTexture.index] = true;
 *     }
 * }
 */

var WEB3D_quantized_attributes = {
  unQuantizeData: function unQuantizeData(data, decodeMat) {
    if (!decodeMat) {
      return data;
    }

    var matSize = Math.sqrt(decodeMat.length);
    var itemLen = matSize - 1;
    var result = new Float32Array(data.length);
    var tempArr = [];
    data.traverse(function (d, i) {
      if (d.toArray) {
        d.toArray(tempArr);
      } else {
        tempArr[0] = d;
      }

      var idx = i * itemLen;

      for (var j = 0; j < matSize; j++) {
        result[idx + j] = 0;

        for (var k = 0; k < matSize; k++) {
          var v = k === itemLen ? 1 : tempArr[k];
          result[idx + j] += decodeMat[k * matSize + j] * v;
        }
      }
    });
    data.data = result;
    data.stride = 0;
    data.offset = 0;
    return data;
  },
  parse: function parse(quantizeInfo, parser, result, options) {
    var decodeMat = quantizeInfo.decodeMatrix;

    if (options.isDecode) {
      result = WEB3D_quantized_attributes.unQuantizeData(result, decodeMat);
    } else {
      result.decodeMat = decodeMat;
    }

    return result;
  }
};
var HILO_animation_clips = {
  parseOnEnd: function parseOnEnd(animClips, parser, model) {
    if (!model.anim || parser.isMultiAnim) {
      return model;
    }

    for (var name in animClips) {
      var clip = animClips[name];
      model.anim.addClip(name, clip[0], clip[1]);
    }

    return model;
  }
};
var ALI_animation_clips = HILO_animation_clips;
var ALI_bounding_box = {
  parse: function parse(bounds, parser, model) {
    bounds.center = bounds.max.map(function (a, i) {
      return (a + bounds.min[i]) / 2;
    });
    bounds.width = bounds.max[0] - bounds.min[0];
    bounds.height = bounds.max[1] - bounds.min[1];
    bounds.depth = bounds.max[2] - bounds.min[2];
    bounds.size = Math.sqrt(Math.pow(bounds.width, 2) + Math.pow(bounds.height, 2) + Math.pow(bounds.depth, 2));
    model.bounds = bounds;
    return model;
  }
};
var KHR_materials_pbrSpecularGlossiness = {
  getUsedTextureNameMap: function getUsedTextureNameMap(extension, map) {
    if (extension.diffuseTexture) {
      map[extension.diffuseTexture.index] = true;
    }

    if (extension.specularGlossinessTexture) {
      map[extension.specularGlossinessTexture.index] = true;
    }
  },
  parse: function parse(info, parser, material) {
    if (info.diffuseFactor) {
      material.baseColor.fromArray(info.diffuseFactor);
    }

    if (info.diffuseTexture) {
      material.baseColorMap = parser.getTexture(info.diffuseTexture);
    }

    if (info.specularFactor) {
      material.specular.fromArray(info.specularFactor);
      material.specular.a = 1;
    }

    if ('glossinessFactor' in info) {
      material.glossiness = info.glossinessFactor;
    }

    if (info.specularGlossinessTexture) {
      material.specularGlossinessMap = parser.getTexture(info.specularGlossinessTexture);
    }

    material.isSpecularGlossiness = true;
    return material;
  }
};
var KHR_lights_punctual = {
  parse: function parse(info, parser, node) {
    if (!parser.isUseExtension(parser.json, 'KHR_lights_punctual') || !parser.json.extensions.KHR_lights_punctual.lights) {
      return node;
    }

    var lightInfo = parser.json.extensions.KHR_lights_punctual.lights[info.light];

    if (!lightInfo) {
      return node;
    }

    var light;
    var color = new math_Color(1, 1, 1, 1);

    if (lightInfo.color) {
      color.r = lightInfo.color[0];
      color.g = lightInfo.color[1];
      color.b = lightInfo.color[2];
    }

    var amount = lightInfo.intensity !== undefined ? lightInfo.intensity : 1;
    var name = lightInfo.name || ''; // spot light

    var spotInfo = lightInfo.spot || {};
    var cutoff = spotInfo.innerConeAngle !== undefined ? math_math.radToDeg(spotInfo.innerConeAngle) : 0;
    var outerCutoff = spotInfo.outerConeAngle !== undefined ? math_math.radToDeg(spotInfo.outerConeAngle) : 45;
    var range = lightInfo.range || 0;

    switch (lightInfo.type) {
      case 'directional':
        light = new light_DirectionalLight({
          color: color,
          amount: amount,
          name: name,
          range: range
        });
        light.direction.set(0, 0, -1);
        break;

      case 'point':
        light = new light_PointLight({
          color: color,
          amount: amount,
          name: name,
          range: range
        });
        break;

      case 'spot':
        light = new light_SpotLight({
          color: color,
          amount: amount,
          name: name,
          range: range,
          cutoff: cutoff,
          outerCutoff: outerCutoff
        });
        light.direction.set(0, 0, -1);
        break;

      default:
        return node;
    }

    if (light) {
      node.addChild(light);
      parser.lights.push(light);
    }

    return node;
  }
};
var GLTFExtensions_KHR_techniques_webgl = {
  init: function init(loader, parser) {
    var actions = [];
    var extensions = parser.json.extensions || {};
    var KHR_techniques_webgl = extensions.KHR_techniques_webgl || {};
    var programs = KHR_techniques_webgl.programs || [];
    var shaders = KHR_techniques_webgl.shaders || [];
    var techniques = KHR_techniques_webgl.techniques || [];
    parser.shaders = {};
    shaders.forEach(function (shader, index) {
      var uri = getRelativePath(parser.src, shader.uri);

      if (parser.preHandlerShaderURI) {
        uri = parser.preHandlerShaderURI(uri, index, shader);
      }

      actions.push(loader.loadRes(uri).then(function (shaderText) {
        parser.shaders[index] = shaderText;
      }));
    });
    parser.programs = {};
    programs.forEach(function (program, index) {
      parser.programs[index] = Object.assign({}, program);
    });
    parser.techniques = {};
    techniques.forEach(function (technique, index) {
      var newTechnique = parser.techniques[index] = Object.assign({}, technique);
      var textureInfos = newTechnique.textureInfos = {};
      var uniforms = technique.uniforms || {};

      for (var name in uniforms) {
        var uniform = uniforms[name];

        if (uniform.type === SAMPLER_2D) {
          textureInfos[name] = uniform.value || {};
        }
      }
    });
    return Promise.all(actions);
  },
  getUsedTextureNameMap: function getUsedTextureNameMap(extension, map, parser) {
    var techniques = parser.techniques;
    var technique = techniques[extension.technique];
    var values = extension.values || {};

    if (technique) {
      var textureInfos = technique.textureInfos;

      for (var name in textureInfos) {
        var imageIndex = void 0;

        if (values[name] && values[name].index !== undefined) {
          imageIndex = values[name].index;
        } else if (textureInfos[name].index !== undefined) {
          imageIndex = textureInfos[name].index;
        }

        if (imageIndex !== undefined) {
          map[textureInfos[name].index] = true;
        }
      }
    }
  },
  parse: function parse(info, parser, material) {
    var textures = parser.textures || [];
    var techniqueInfo = parser.techniques[info.technique];

    if (!techniqueInfo) {
      return material;
    }

    var programInfo = parser.programs[techniqueInfo.program];

    if (!programInfo) {
      return material;
    }

    var fragmentText = parser.shaders[programInfo.fragmentShader];
    var vertexText = parser.shaders[programInfo.vertexShader];
    var uniformsInfo = techniqueInfo.uniforms || {};
    var attributesInfo = techniqueInfo.attributes || {};
    var valuesInfo = info.values || {};
    var attributes = {};
    var uniforms = {};

    var _loop = function _loop(uniformName) {
      var uniformDef = uniformsInfo[uniformName] || {};
      var uniformValue = valuesInfo[uniformName];

      if (uniformValue === undefined) {
        uniformValue = uniformDef.value;
      }

      var uniformObject = void 0;

      if (uniformValue !== undefined) {
        if (uniformDef.type === SAMPLER_2D) {
          var textureIndex = uniformValue.index || 0;
          uniformObject = {
            get: function get(mesh, material, programInfo) {
              return material_semantic.handlerTexture(textures[textureIndex], programInfo.textureIndex);
            }
          };
        } else {
          uniformObject = {
            get: function get() {
              return uniformValue;
            }
          };
        }
      } else if (uniformDef.semantic && material_semantic[uniformDef.semantic]) {
        var semanticFunc = material_semantic[uniformDef.semantic];
        var nodeIndex = uniformDef.node;
        var node;

        if (nodeIndex !== undefined) {
          uniformObject = {
            get: function get(mesh, material, programInfo) {
              if (node === undefined) {
                node = parser.node.getChildByFn(function (node) {
                  return node.animationId === nodeIndex;
                }) || mesh;
              }

              return semanticFunc.get(node, material, programInfo);
            }
          };
        } else {
          uniformObject = uniformDef.semantic;
        }
      } else {
        utils_log.warn("KHR_techniques_webgl: no ".concat(uniformName, " value found!"));
        uniformObject = material_semantic.blankInfo;
      }

      uniforms[uniformName] = uniformObject;
    };

    for (var uniformName in uniformsInfo) {
      _loop(uniformName);
    }

    for (var attributeName in attributesInfo) {
      var attributeValue = attributesInfo[attributeName] || {};

      if (attributeValue.semantic) {
        attributes[attributeName] = attributeValue.semantic;
      }
    }

    var shaderMaterial = new material_ShaderMaterial({
      needBasicUnifroms: false,
      needBasicAttributes: false,
      vs: vertexText,
      fs: fragmentText,
      attributes: attributes,
      uniforms: uniforms
    });
    return shaderMaterial;
  }
};
// CONCATENATED MODULE: ./src/core/Fog.js



var tempFloat32Array = new Float32Array(2);
/**
 * 雾
 * @class
 */

var Fog = core_Class.create(
/** @lends Fog.prototype */
{
  /**
   * @default true
   * @type {Boolean}
   */
  isFog: true,

  /**
   * @default Fog
   * @type {String}
   */
  className: 'Fog',

  /**
   * 雾模式, 可选 LINEAR, EXP, EXP2
   * @type {String}
   * @default LINEAR
   */
  mode: 'LINEAR',

  /**
   * 雾影响起始值, 只在 mode 为 LINEAR 时生效
   * @type {Number}
   * @default 5
   */
  start: 5,

  /**
   * 雾影响终点值, 只在 mode 为 LINEAR 时生效
   * @type {Number}
   * @default 10
   */
  end: 10,

  /**
   * 雾密度, 只在 mode 为 EXP, EXP2 时生效
   * @type {Number}
   * @default 0.1
   */
  density: 0.1,

  /**
   * @constructs
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    /**
     * id
     * @default math.generateUUID('Fog')
     * @type {String}
     */
    this.id = math_math.generateUUID(this.className);
    /**
     * 雾颜色
     * @type {Color}
     * @default  new Color(1, 1, 1, 1)
     */

    this.color = new math_Color(1, 1, 1, 1);
    Object.assign(this, params);
  },

  /**
   * 获取雾信息
   * @return {Array} res
   */
  getInfo: function getInfo() {
    if (this.mode === 'LINEAR') {
      tempFloat32Array[0] = this.start;
      tempFloat32Array[1] = this.end;
      return tempFloat32Array;
    }

    return this.density;
  },
  getRenderOption: function getRenderOption() {
    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    option["FOG_".concat(this.mode)] = 1;
    return option;
  }
});
/* harmony default export */ var core_Fog = (Fog);
// EXTERNAL MODULE: ./node_modules/_ray-3d@1.1.1@ray-3d/index.js
var _ray_3d_1_1_1_ray_3d = __webpack_require__("./node_modules/_ray-3d@1.1.1@ray-3d/index.js");
var _ray_3d_1_1_1_ray_3d_default = /*#__PURE__*/__webpack_require__.n(_ray_3d_1_1_1_ray_3d);

// CONCATENATED MODULE: ./src/math/Ray.js



/**
 * 射线
 * @class
 * @example
 * var ray = new Hilo3d.Ray();
 * ray.fromCamera(camera, 10, 10, stage.width, stage.height);
 */

var Ray = core_Class.create(
/** @lends Ray.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default Ray
   */
  className: 'Ray',

  /**
   * 是否是射线
   * @type {Boolean}
   * @default true
   */
  isRay: true,

  /**
   * 原点
   * @type {Vector3}
   */
  origin: {
    get: function get() {
      return this._origin;
    },
    set: function set(value) {
      this._origin = value;
      this._ray.origin = value.elements;
    }
  },

  /**
   * 方向
   * @type {Vector3}
   */
  direction: {
    get: function get() {
      return this._direction;
    },
    set: function set(value) {
      this._direction = value;
      this._ray.direction = value.elements;
    }
  },

  /**
   * @constructs
   * @param {Object} [params]
   * @param {Vector3} [params.origin=new Vector3(0, 0, 0)] 原点
   * @param {Vector3} [params.direction=new Vector3(0, 0, -1)] 方向
   */
  constructor: function constructor() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._ray = new _ray_3d_1_1_1_ray_3d_default.a();
    this.origin = params.origin || new math_Vector3(0, 0, 0);
    this.direction = params.direction || new math_Vector3(0, 0, -1);
  },

  /**
   * set
   * @param {Vector3} origin
   * @param {Vector3} direction
   * @return {Ray} this
   */
  set: function set(origin, direction) {
    this.origin = origin;
    this.direction = direction;
    return this;
  },

  /**
   * copy
   * @param  {Vector3} other
   * @return {Ray}
   */
  copy: function copy(other) {
    this.origin.copy(other.origin);
    this.direction.copy(other.direction);
  },

  /**
   * clone
   * @return {Ray}
   */
  clone: function clone() {
    return new this.constructor({
      origin: this.origin.clone(),
      direction: this.direction.clone()
    });
  },

  /**
   * 从摄像机设置
   * @param  {Camera} camera
   * @param  {Number} x 屏幕x
   * @param  {Number} y 屏幕y
   * @param  {Number} width   屏幕宽
   * @param  {Number} height  屏幕高
   */
  fromCamera: function fromCamera(camera, x, y, width, height) {
    if (camera.isPerspectiveCamera) {
      camera.worldMatrix.getTranslation(this.origin);
      this.direction.set(x, y, 0);
      this.direction.copy(camera.unprojectVector(this.direction, width, height));
      this.direction.sub(this.origin).normalize();
    } else if (camera.isOrthographicCamera) {
      this.origin.set(x, y, (camera.near + camera.far) / (camera.near - camera.far));
      this.origin.copy(camera.unprojectVector(this.origin, width, height));
      this.direction.set(0, 0, -1).transformDirection(camera.worldMatrix).normalize();
    }
  },

  /**
   * Transforms the ray with a mat4
   * @param  {Matrix4} mat4
   */
  transformMat4: function transformMat4(mat4) {
    this.origin.transformMat4(mat4);
    this.direction.transformDirection(mat4).normalize();
  },

  /**
   * 排序碰撞点
   * @param  {Vector3[]|raycastInfo[]} points
   * @param  {String} [pointName='']
   */
  sortPoints: function sortPoints(points, pointName) {
    var _this = this;

    if (pointName) {
      points.sort(function (a, b) {
        return _this.squaredDistance(a[pointName]) - _this.squaredDistance(b[pointName]);
      });
    } else {
      points.sort(function (a, b) {
        return _this.squaredDistance(a) - _this.squaredDistance(b);
      });
    }
  },

  /**
   * squaredDistance
   * @param  {Vector3} point
   * @return {Number}
   */
  squaredDistance: function squaredDistance(point) {
    return this.origin.squaredDistance(point);
  },

  /**
   * distance
   * @param  {Vector3} point
   * @return {Number}
   */
  distance: function distance(point) {
    return this.origin.distance(point);
  },

  /**
   * intersectsSphere
   * @param  {Number[]} center [x, y, z]
   * @param  {Number} radius
   * @return {Vector3}  碰撞点，如果没有碰撞返回 null
   */
  intersectsSphere: function intersectsSphere(center, radius) {
    var res = this._ray.intersectsSphere(center, radius);

    return this._getRes(res);
  },

  /**
   * intersectsPlane
   * @param  {Number[]} normal [x, y, z]
   * @param  {Number} distance
   * @return {Vector3}  碰撞点，如果没有碰撞返回 null
   */
  intersectsPlane: function intersectsPlane(normal, distance) {
    var res = this._ray.intersectsPlane(normal, distance);

    return this._getRes(res);
  },

  /**
   * intersectsTriangle
   * @param  {Array} triangle [[a.x, a.y, a.z], [b.x, b.y, b.z],[c.x, c.y, c.z]]
   * @return {Vector3}  碰撞点，如果没有碰撞返回 null
   */
  intersectsTriangle: function intersectsTriangle(triangle) {
    var res = this._ray.intersectsTriangle(triangle);

    return this._getRes(res);
  },

  /**
   * intersectsBox
   * @param  {Array} aabb [[min.x, min.y, min.z], [max.x, max.y, max.z]]
   * @return {Vector3}  碰撞点，如果没有碰撞返回 null
   */
  intersectsBox: function intersectsBox(aabb) {
    var res = this._ray.intersectsBox(aabb);

    return this._getRes(res);
  },

  /**
   * intersectsTriangleCell
   * @param  {Array} cell
   * @param  {Array} positions
   * @return {Vector3}  碰撞点，如果没有碰撞返回 null
   */
  intersectsTriangleCell: function intersectsTriangleCell(cell, positions) {
    var res = this._ray.intersectsTriangleCell(cell, positions);

    return this._getRes(res);
  },

  /**
   * _getRes
   * @private
   */
  _getRes: function _getRes(res) {
    if (res) {
      return new math_Vector3(res[0], res[1], res[2]);
    }

    return null;
  }
});
/* harmony default export */ var math_Ray = (Ray);
// CONCATENATED MODULE: ./src/core/Mesh.js




var tempRay = new math_Ray();
var Mesh_tempMatrix4 = new math_Matrix4();
/**
 * Mesh
 * @class
 * @extends Node
 * @example
 * const mesh = new Hilo3d.Mesh({
 *     geometry: new Hilo3d.BoxGeometry(),
 *     material: new Hilo3d.BasicMaterial({
 *         diffuse: new Hilo3d.Color(0.8, 0, 0)
 *     }),
 *     x:100,
 *     rotationX:30
 * });
 * stage.addChild(mesh);
 */

var Mesh = core_Class.create(
/** @lends Mesh.prototype */
{
  Extends: core_Node,

  /**
   * @default true
   * @type {boolean}
   */
  isMesh: true,

  /**
   * @default Mesh
   * @type {string}
   */
  className: 'Mesh',

  /**
   * @type {Geometry}
   */
  geometry: null,

  /**
   * @type {Material}
   */
  material: null,

  /**
   * 是否使用 Instanced
   * @default false
   * @type {boolean}
   */
  useInstanced: false,

  /**
   * 是否开启视锥体裁剪
   * @default true
   * @type {Boolean}
   */
  frustumTest: true,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    Mesh.superclass.constructor.call(this, params);
  },

  /**
   * clone 当前mesh
   * @param {boolean} isChild 是否子元素
   * @return {Mesh} 返回clone的实例
   */
  clone: function clone(isChild) {
    var node = core_Node.prototype.clone.call(this, isChild);
    Object.assign(node, {
      geometry: this.geometry,
      material: this.material
    });
    return node;
  },

  /**
   * raycast
   * @param  {Ray} ray
   * @param {Boolean} [sort=true] 是否按距离排序
   * @return {Vector3[]|null}
   */
  raycast: function raycast(ray) {
    var sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (!this.visible) {
      return null;
    }

    var geometry = this.geometry;
    var material = this.material;
    var worldMatrix = this.worldMatrix;

    if (geometry && material) {
      Mesh_tempMatrix4.invert(worldMatrix);
      tempRay.copy(ray);
      tempRay.transformMat4(Mesh_tempMatrix4);
      var res = geometry.raycast(tempRay, material.side, sort);

      if (res) {
        res.forEach(function (point) {
          point.transformMat4(worldMatrix);
        });
        return res;
      }
    }

    return null;
  },
  getRenderOption: function getRenderOption() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.geometry.getRenderOption(opt);
    return opt;
  },

  /**
   * 是否被销毁
   * @readOnly
   * @type {Boolean}
   */
  isDestroyed: {
    get: function get() {
      return this._isDestroyed;
    }
  },

  /**
   * 销毁 Mesh 资源
   * @param {WebGLRenderer} renderer
   * @param {Boolean} [destroyTextures=false] 是否销毁材质的贴图，默认不销毁
   * @return {Mesh} this
   */
  destroy: function destroy(renderer) {
    var needDestroyTextures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (this._isDestroyed) {
      return this;
    }

    this.removeFromParent();
    var resourceManager = renderer.resourceManager;
    resourceManager.destroyMesh(this);

    if (this.material && needDestroyTextures) {
      this.material.destroyTextures();
    }

    this.off();
    this.geometry = null;
    this.material = null;
    this._isDestroyed = true;
    return this;
  }
});
/* harmony default export */ var core_Mesh = (Mesh);
// CONCATENATED MODULE: ./src/core/SkinedMesh.js







var tempMatrix1 = new math_Matrix4();
var tempMatrix2 = new math_Matrix4();
/**
 * 蒙皮Mesh
 * @class
 * @extends Mesh
 */

var SkinedMesh = core_Class.create(
/** @lends SkinedMesh.prototype */
{
  Extends: core_Mesh,

  /**
   * @default true
   * @type {boolean}
   */
  isSkinedMesh: true,

  /**
   * @default SkinedMesh
   * @type {string}
   */
  className: 'SkinedMesh',

  /**
   * 是否支持 Instanced
   * @default false
   * @type {boolean}
   */
  useInstanced: false,

  /**
   * 骨骼矩阵DataTexture
   * @default null
   * @type {DataTexture}
   */
  jointMatTexture: null,

  /**
   * 是否开启视锥体裁剪
   * @default false
   * @type {Boolean}
   */
  frustumTest: false,

  /**
   * 骨架
   * @default null
   * @type {Skeleton}
   */
  skeleton: null,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    SkinedMesh.superclass.constructor.call(this, params);
  },

  /**
   * 获取每个骨骼对应的矩阵数组
   * @return {Float32Array} 返回矩阵数组
   */
  getJointMat: function getJointMat() {
    var _this = this;

    if (!this.skeleton || this.skeleton.jointCount <= 0) {
      return undefined;
    }

    var jointNodeList = this.skeleton.jointNodeList;
    var inverseBindMatrices = this.skeleton.inverseBindMatrices;
    var jointMatLength = this.skeleton.jointCount * 16;

    if (!this.jointMat || this.jointMat.length !== jointMatLength) {
      this.jointMat = new Float32Array(jointMatLength);
    }

    if (!this.clonedFrom) {
      tempMatrix2.invert(this.worldMatrix);
    } else {
      tempMatrix2.invert(this.clonedFrom.worldMatrix);
    }

    jointNodeList.forEach(function (node, i) {
      tempMatrix1.copy(tempMatrix2);
      tempMatrix1.multiply(node.worldMatrix);
      tempMatrix1.multiply(inverseBindMatrices[i]);
      tempMatrix1.toArray(_this.jointMat, i * 16);
    });
    return this.jointMat;
  },

  /**
   * 用新骨骼的 node name 重设 jointNames
   * @param  {Skeleton} skeleton 新骨架
   */
  resetJointNamesByNodeName: function resetJointNamesByNodeName(skeleton) {
    this.skeleton.resetJointNamesByNodeName(skeleton);
  },

  /**
   * 用新骨骼重置skinIndices
   * @param  {Skeleton} skeleton
   */
  resetSkinIndices: function resetSkinIndices(skeleton) {
    var currentSkeleton = this.skeleton;

    if (currentSkeleton) {
      var geometry = this.geometry;
      var skinIndices = geometry.skinIndices;

      if (skinIndices) {
        this.material.isDirty = true;
        geometry.isDirty = true;
        skinIndices.isDirty = true;
        var tempIndices = new math_Vector4();
        skinIndices.traverse(function (attribute, index, offset) {
          attribute.elements.forEach(function (value, elementIndex) {
            var jointName = currentSkeleton.jointNames[value];
            var jointIndex = skeleton.jointNames.indexOf(jointName);

            if (jointIndex >= 0) {
              tempIndices.elements[elementIndex] = jointIndex;
            } else {
              utils_log.warnOnce('SkinedMesh.resetSkinIndices', 'SkinedMesh.resetSkinIndices: no jointName found!', jointName);
            }
          });
          skinIndices.setByOffset(offset, tempIndices);
        });
      }
    }
  },

  /**
   * 根据当前骨骼数来生成骨骼矩阵的 jointMatTexture
   * @return {DataTexture}
   */
  initJointMatTexture: function initJointMatTexture() {
    if (!this.jointMatTexture) {
      var jointMat = this.getJointMat();
      this.jointMatTexture = new texture_DataTexture({
        data: jointMat
      });
    }

    return this.jointMatTexture;
  },

  /**
   * 将 getJointMat 获取的骨骼矩阵数组更新到 jointMatTexture 中
   */
  updateJointMatTexture: function updateJointMatTexture() {
    if (!this.jointMatTexture) {
      this.initJointMatTexture();
    } else {
      var jointMat = this.getJointMat();
      this.jointMatTexture.data.set(jointMat, 0);
      this.jointMatTexture.needUpdate = true;
    }
  },
  clone: function clone(isChild) {
    var mesh = core_Mesh.prototype.clone.call(this, isChild);
    Object.assign(mesh, {
      useInstanced: this.useInstanced,
      skeleton: this.skeleton.clone()
    });
    mesh.clonedFrom = this;
    return mesh;
  },
  getRenderOption: function getRenderOption() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    SkinedMesh.superclass.getRenderOption.call(this, opt);
    var jointCount = this.skeleton.jointCount;

    if (jointCount) {
      opt.JOINT_COUNT = jointCount;

      if (renderer_capabilities.VERTEX_TEXTURE_FLOAT) {
        var maxJointCount = (renderer_capabilities.MAX_VERTEX_UNIFORM_VECTORS - 22) / 4;

        if (jointCount > maxJointCount) {
          opt.JOINT_MAT_MAP = 1;
        }
      }
    }

    return opt;
  }
});
/* harmony default export */ var core_SkinedMesh = (SkinedMesh);
// CONCATENATED MODULE: ./src/core/Skeleton.js


/**
 * 骨架
 * @class
 */

var Skeleton = core_Class.create(
/** @lends Skeleton.prototype */
{
  /**
   * @default true
   * @type {Boolean}
   */
  isSkeleton: true,

  /**
   * @default Skeleton
   * @type {String}
   */
  className: 'Skeleton',

  /**
   * @constructs
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    /**
     * id
     * @default math.generateUUID('Skeleton')
     * @type {String}
     */
    this.id = math_math.generateUUID(this.className);
    /**
     * @default []
     * @type {Node[]}
     */

    this.jointNodeList = [];
    /**
     * @default []
     * @type {String[]}
     */

    this.jointNames = [];
    /**
     * @default []
     * @type {Matrix4[]}
     */

    this.inverseBindMatrices = [];
    Object.assign(this, params);
  },

  /**
   * 关节数量
   * @readOnly
   * @type {Number}
   */
  jointCount: {
    get: function get() {
      return this.jointNodeList.length;
    }
  },

  /**
   * @private
   * @type {Node}
   */
  _rootNode: null,

  /**
   * 设置根节点
   * @type {Node}
   */
  rootNode: {
    get: function get() {
      return this._rootNode;
    },
    set: function set(rootNode) {
      this._rootNode = rootNode;

      if (rootNode) {
        this._initJointNodeList();
      }
    }
  },

  /**
   * @private
   */
  _initJointNodeList: function _initJointNodeList() {
    var map = {};
    this.rootNode.traverse(function (node) {
      map[node.jointName] = node;
    });
    this.jointNodeList = this.jointNames.map(function (name) {
      return map[name];
    });
  },

  /**
   * 用新骨骼的 node name 重设 jointNames
   * @param  {Skeleton} skeleton 新骨架
   */
  resetJointNamesByNodeName: function resetJointNamesByNodeName(skeleton) {
    var jointNames = this.jointNames;
    this.jointNodeList.forEach(function (jointNode, index) {
      var mainJointNode = skeleton.rootNode.getChildByName(jointNode.name);

      if (mainJointNode) {
        jointNames[index] = mainJointNode.jointName;
      }
    });
  },

  /**
   * clone
   * @param {Node} [rootNode]
   * @return {Skeleton}
   */
  clone: function clone(rootNode) {
    var skeleton = new Skeleton();
    skeleton.copy(this, rootNode);
    return skeleton;
  },

  /**
   * copy
   * @param  {Skeleton} skeleton
   * @param {Node} [rootNode]
   * @return {Skeleton} this
   */
  copy: function copy(skeleton, rootNode) {
    this.inverseBindMatrices = skeleton.inverseBindMatrices;
    this.jointNames = skeleton.jointNames;

    if (rootNode === undefined) {
      rootNode = skeleton.rootNode;
    }

    this.rootNode = rootNode;
    return this;
  }
});
/* harmony default export */ var core_Skeleton = (Skeleton);
// CONCATENATED MODULE: ./src/core/version.js
/* global HILO3D_VERSION */
/* harmony default export */ var core_version = ("1.15.2");
// CONCATENATED MODULE: ./src/renderer/RenderInfo.js

/**
 * 渲染信息
 * @class
 */

var RenderInfo = core_Class.create(
/** @lends RenderInfo.prototype */
{
  /**
   * @default RenderInfo
   * @type {String}
   */
  className: 'RenderInfo',

  /**
   * @default true
   * @type {Boolean}
   */
  isRenderInfo: true,

  /**
   * @constructs
   */
  constructor: function constructor() {
    this.reset();
  },

  /**
   * 增加面数
   * @param {Number} num
   */
  addFaceCount: function addFaceCount(num) {
    this._currentFaceCount += num;
  },

  /**
   * 增加绘图数
   * @param {Number} num
   */
  addDrawCount: function addDrawCount(num) {
    this._currentDrawCount += num;
  },

  /**
   * 重置信息
   */
  reset: function reset() {
    /**
     * 面数
     * @type {Number}
     * @readOnly
     */
    this.faceCount = Math.floor(this._currentFaceCount);
    /**
     * 绘图数
     * @type {Number}
     * @readOnly
     */

    this.drawCount = Math.floor(this._currentDrawCount);
    /**
     * 当前面数
     * @type {Number}
     * @private
     */

    this._currentFaceCount = 0;
    /**
     * 当前绘图数
     * @private
     * @type {Number}
     */

    this._currentDrawCount = 0;
  }
});
/* harmony default export */ var renderer_RenderInfo = (RenderInfo);
// CONCATENATED MODULE: ./src/renderer/RenderList.js



var RenderList_tempVector3 = new math_Vector3();

var opaqueSort = function opaqueSort(meshA, meshB) {
  // sort by material renderOrder
  var renderOrderA = meshA.material.renderOrder;
  var renderOrderB = meshB.material.renderOrder;

  if (renderOrderA !== renderOrderB) {
    return renderOrderA - renderOrderB;
  } // sort by shader id


  var shaderNumIdA = meshA.material._shaderNumId || 0;
  var shaderNumIdB = meshB.material._shaderNumId || 0;

  if (shaderNumIdA !== shaderNumIdB) {
    return shaderNumIdA - shaderNumIdB;
  } // sort by render z


  return meshA._sortRenderZ - meshB._sortRenderZ;
};

var transparentSort = function transparentSort(meshA, meshB) {
  // sort by material renderOrder
  var renderOrderA = meshA.material.renderOrder;
  var renderOrderB = meshB.material.renderOrder;

  if (renderOrderA !== renderOrderB) {
    return renderOrderA - renderOrderB;
  } // sort by inverse render z


  return meshB._sortRenderZ - meshA._sortRenderZ;
};
/**
 * 渲染列表
 * @class
 */


var RenderList = core_Class.create(
/** @lends RenderList.prototype */
{
  /**
   * @default RenderList
   * @type {String}
   */
  className: 'RenderList',

  /**
   * @default true
   * @type {Boolean}
   */
  isRenderList: true,

  /**
   * 使用 instanced
   * @type {Boolean}
   * @default false
   */
  useInstanced: false,

  /**
   * @constructs
   */
  constructor: function constructor() {
    /**
     * 不透明物体列表
     * @type {Array}
     */
    this.opaqueList = [];
    /**
     * 透明物体列表
     * @type {Array}
     */

    this.transparentList = [];
    /**
     * instanced物体字典
     * @type {Object}
     */

    this.instancedDict = {};
  },

  /**
   * 重置列表
   */
  reset: function reset() {
    this.opaqueList.length = 0;
    this.transparentList.length = 0;
    this.instancedDict = {};
  },

  /**
   * 遍历列表执行回调
   * @param  {RenderListTraverseCallback} callback callback(mesh)
   * @param  {RenderListInstancedTraverseCallback} [instancedCallback=null] instancedCallback(instancedMeshes)
   */
  traverse: function traverse(callback, instancedCallback) {
    this.opaqueList.forEach(function (mesh) {
      callback(mesh);
    });
    var instancedDict = this.instancedDict;

    for (var instancedId in instancedDict) {
      var instancedList = instancedDict[instancedId];

      if (instancedList.length > 2 && instancedCallback) {
        instancedCallback(instancedList);
      } else {
        instancedList.forEach(function (mesh) {
          callback(mesh);
        });
      }
    }

    this.transparentList.forEach(function (mesh) {
      callback(mesh);
    });
  },
  sort: function sort() {
    this.transparentList.sort(transparentSort);
    this.opaqueList.sort(opaqueSort);
  },

  /**
   * 增加 mesh
   * @param {Mesh} mesh
   * @param {Camera} camera
   */
  addMesh: function addMesh(mesh, camera) {
    var material = mesh.material;
    var geometry = mesh.geometry;

    if (material && geometry) {
      if (mesh.frustumTest && !camera.isMeshVisible(mesh)) {
        return;
      }

      if (this.useInstanced && mesh.useInstanced) {
        var instancedDict = this.instancedDict;
        var instancedId = material.id + '_' + geometry.id;
        var instancedList = instancedDict[instancedId];

        if (!instancedDict[instancedId]) {
          instancedList = instancedDict[instancedId] = [];
        }

        instancedList.push(mesh);
      } else {
        mesh.worldMatrix.getTranslation(RenderList_tempVector3);
        RenderList_tempVector3.transformMat4(camera.viewProjectionMatrix);
        mesh._sortRenderZ = RenderList_tempVector3.z;

        if (material.transparent) {
          this.transparentList.push(mesh);
        } else {
          this.opaqueList.push(mesh);
        }
      }
    } else {
      utils_log.warnOnce("RenderList.addMesh(".concat(mesh.id, ")"), 'Mesh must have material and geometry', mesh);
    }
  }
});
/* harmony default export */ var renderer_RenderList = (RenderList);
/**
 * @callback RenderListTraverseCallback
 * @param {Mesh} mesh
 */

/**
 * @callback RenderListInstancedTraverseCallback
 * @param {Mesh[]} meshes
 */
// CONCATENATED MODULE: ./src/renderer/WebGLState.js

/**
 * WebGL 状态管理，减少 api 调用
 * @class
 */

var WebGLState = core_Class.create(
/** @lends WebGLState.prototype */
{
  /**
   * @default WebGLState
   * @type {String}
   */
  className: 'WebGLState',

  /**
   * @default true
   * @type {Boolean}
   */
  isWebGLState: true,

  /**
   * 系统framebuffer
   * @default true
   * @type {null}
   */
  systemFramebuffer: null,

  /**
   * @constructs
   * @param  {WebGLRenderingContext} gl
   */
  constructor: function constructor(gl) {
    /**
     * gl
     * @type {WebGLRenderingContext}
     */
    this.gl = gl;
    this.reset();
  },

  /**
   * 重置状态
   */
  reset: function reset() {
    this._dict = {};
    this.activeTextureIndex = null;
    this.textureUnitDict = {};
    this.currentFramebuffer = null;
    this.preFramebuffer = null;
    this._pixelStorei = {};
  },

  /**
   * enable
   * @param  {GLenum} capability
   */
  enable: function enable(capability) {
    var value = this._dict[capability];

    if (value !== true) {
      this._dict[capability] = true;
      this.gl.enable(capability);
    }
  },

  /**
   * disable
   * @param  {GLenum} capability
   */
  disable: function disable(capability) {
    var value = this._dict[capability];

    if (value !== false) {
      this._dict[capability] = false;
      this.gl.disable(capability);
    }
  },

  /**
   * bindFramebuffer
   * @param  {GLenum} target
   * @param  {WebGLFramebuffer} framebuffer
   */
  bindFramebuffer: function bindFramebuffer(target, framebuffer) {
    if (this.currentFramebuffer !== framebuffer) {
      this.preFramebuffer = this.currentFramebuffer;
      this.currentFramebuffer = framebuffer;
      this.gl.bindFramebuffer(target, framebuffer);
    }
  },

  /**
   * 绑定系统framebuffer
   */
  bindSystemFramebuffer: function bindSystemFramebuffer() {
    this.bindFramebuffer(this.gl.FRAMEBUFFER, this.systemFramebuffer);
  },

  /**
   * useProgram
   * @param  { WebGLProgram} program
   */
  useProgram: function useProgram(program) {
    this.set1('useProgram', program);
  },

  /**
   * depthFunc
   * @param  {GLenum } func
   */
  depthFunc: function depthFunc(func) {
    this.set1('depthFunc', func);
  },

  /**
   * depthMask
   * @param  {GLenum } flag
   */
  depthMask: function depthMask(flag) {
    this.set1('depthMask', flag);
  },

  /**
   * clear
   * @param  {Number} mask
   */
  clear: function clear(mask) {
    this.gl.clear(mask);
  },

  /**
   * depthRange
   * @param  {Number} zNear
   * @param  {Number} zFar
   */
  depthRange: function depthRange(zNear, zFar) {
    this.set2('depthRange', zNear, zFar);
  },

  /**
   * stencilFunc
   * @param  {GLenum} func
   * @param  {Number} ref
   * @param  {Number} mask
   */
  stencilFunc: function stencilFunc(func, ref, mask) {
    this.set3('stencilFunc', func, ref, mask);
  },

  /**
   * stencilMask
   * @param  {Number} mask
   */
  stencilMask: function stencilMask(mask) {
    this.set1('stencilMask', mask);
  },

  /**
   * stencilOp
   * @param  {GLenum} fail
   * @param  {GLenum} zfail
   * @param  {GLenum} zpass
   */
  stencilOp: function stencilOp(fail, zfail, zpass) {
    this.set3('stencilOp', fail, zfail, zpass);
  },

  /**
   * colorMask
   * @param  {Boolean} red
   * @param  {Boolean} green
   * @param  {Boolean} blue
   * @param  {Boolean} alpha
   */
  colorMask: function colorMask(red, green, blue, alpha) {
    this.set4('colorMask', red, green, blue, alpha);
  },

  /**
   * cullFace
   * @param  {GLenum} mode
   */
  cullFace: function cullFace(mode) {
    this.set1('cullFace', mode);
  },

  /**
   * frontFace
   * @param  {GLenum} mode
   */
  frontFace: function frontFace(mode) {
    this.set1('frontFace', mode);
  },

  /**
   * blendFuncSeparate
   * @param  {GLenum} srcRGB
   * @param  {GLenum} dstRGB
   * @param  {GLenum} srcAlpha
   * @param  {GLenum} dstAlpha
   */
  blendFuncSeparate: function blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
    this.set4('blendFuncSeparate', srcRGB, dstRGB, srcAlpha, dstAlpha);
  },

  /**
   * blendEquationSeparate
   * @param  {GLenum} modeRGB
   * @param  {GLenum} modeAlpha
   */
  blendEquationSeparate: function blendEquationSeparate(modeRGB, modeAlpha) {
    this.set2('blendEquationSeparate', modeRGB, modeAlpha);
  },

  /**
   * pixelStorei
   * @param  {GLenum} pname
   * @param  {GLenum} param
   */
  pixelStorei: function pixelStorei(pname, param) {
    var currentParam = this._pixelStorei[pname];

    if (currentParam !== param) {
      this._pixelStorei[pname] = param;
      this.gl.pixelStorei(pname, param);
    }
  },

  /**
   * viewport
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} width
   * @param  {Number} height
   */
  viewport: function viewport(x, y, width, height) {
    this.set4('viewport', x, y, width, height);
  },

  /**
   * activeTexture
   * @param  {GLenum} texture
   */
  activeTexture: function activeTexture(texture) {
    if (this.activeTextureIndex !== texture) {
      this.activeTextureIndex = texture;
      this.gl.activeTexture(texture);
    }
  },

  /**
   * bindTexture
   * @param  {GLenum} target
   * @param  {WebGLTexture } texture
   */
  bindTexture: function bindTexture(target, texture) {
    var textureUnit = this.getActiveTextureUnit();

    if (textureUnit[target] !== texture) {
      textureUnit[target] = texture;
      this.gl.bindTexture(target, texture);
    }
  },

  /**
   * 获取当前激活的纹理对象
   * @return {GLenum}
   */
  getActiveTextureUnit: function getActiveTextureUnit() {
    var textureUnit = this.textureUnitDict[this.activeTextureIndex];

    if (!textureUnit) {
      textureUnit = this.textureUnitDict[this.activeTextureIndex] = {};
    }

    return textureUnit;
  },

  /**
   * 调 gl 1参数方法
   * @private
   * @param  {String} name  方法名
   * @param  {Number|Object} param 方法参数
   */
  set1: function set1(name, param) {
    var value = this._dict[name];

    if (value !== param) {
      this._dict[name] = param;
      this.gl[name](param);
    }
  },

  /**
   * 调 gl 2参数方法
   * @private
   * @param  {String} name  方法名
   * @param  {Number|Object} param0 方法参数
   * @param  {Number|Object} param1 方法参数
   */
  set2: function set2(name, param0, param1) {
    var value = this._dict[name];

    if (!value) {
      value = this._dict[name] = [];
    }

    if (value[0] !== param0 || value[1] !== param1) {
      value[0] = param0;
      value[1] = param1;
      this.gl[name](param0, param1);
    }
  },

  /**
   * 调 gl 3参数方法
   * @private
   * @param  {String} name  方法名
   * @param  {Number|Object} param0 方法参数
   * @param  {Number|Object} param1 方法参数
   * @param  {Number|Object} param2 方法参数
   */
  set3: function set3(name, param0, param1, param2) {
    var value = this._dict[name];

    if (!value) {
      value = this._dict[name] = [];
    }

    if (value[0] !== param0 || value[1] !== param1 || value[2] !== param2) {
      value[0] = param0;
      value[1] = param1;
      value[2] = param2;
      this.gl[name](param0, param1, param2);
    }
  },

  /**
   * 调 gl 4参数方法
   * @private
   * @param  {String} name  方法名
   * @param  {Number|Object} param0 方法参数
   * @param  {Number|Object} param1 方法参数
   * @param  {Number|Object} param2 方法参数
   * @param  {Number|Object} param3 方法参数
   */
  set4: function set4(name, param0, param1, param2, param3) {
    var value = this._dict[name];

    if (!value) {
      value = this._dict[name] = [];
    }

    if (value[0] !== param0 || value[1] !== param1 || value[2] !== param2 || value[3] !== param3) {
      value[0] = param0;
      value[1] = param1;
      value[2] = param2;
      value[3] = param3;
      this.gl[name](param0, param1, param2, param3);
    }
  },
  get: function get(name) {
    return this._dict[name];
  }
});
/* harmony default export */ var renderer_WebGLState = (WebGLState);
// CONCATENATED MODULE: ./src/renderer/WebGLResourceManager.js


/**
 * WebGLResourceManager 资源管理器
 * @mixes EventMixin
 * @fires destroyResource 销毁资源
 * @class
 */

var WebGLResourceManager = core_Class.create(
/** @lends WebGLResourceManager.prototype */
{
  Mixes: core_EventMixin,

  /**
   * 类名
   * @type {String}
   * @default WebGLResourceManager
   */
  className: 'WebGLResourceManager',

  /**
   * @type {Boolean}
   * @default true
   */
  isWebGLResourceManager: true,

  /**
   * 是否有需要销毁的资源
   * @type {Boolean}
   * @default false
   */
  hasNeedDestroyResource: false,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    this._needDestroyResources = [];
    Object.assign(this, params);
  },
  destroyMesh: function destroyMesh(mesh) {
    var _this = this;

    var resources = this.getMeshResources(mesh);
    resources.forEach(function (resource) {
      _this.destroyIfNoRef(resource);
    });
    mesh._vao = mesh._program = mesh._shader = null;
  },
  getMeshResources: function getMeshResources(mesh) {
    var resources = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (mesh._shader) {
      resources.push(mesh._shader);
    }

    if (mesh._vao) {
      resources.push(mesh._vao);

      mesh._vao.getResources(resources);
    }

    if (mesh._program) {
      resources.push(mesh._program);
    }

    return resources;
  },

  /**
   * 没有引用时销毁资源
   * @param  {Object} res
   * @return {WebGLResourceManager} this
   */
  destroyIfNoRef: function destroyIfNoRef(res) {
    var _needDestroyResources = this._needDestroyResources;

    if (res && _needDestroyResources.indexOf(res) < 0) {
      _needDestroyResources.push(res);
    }

    return this;
  },

  /**
   * 获取 rootNode 用到的资源
   * @param  {Node} [rootNode] 根节点，不传返回空数组
   * @return {Object[]}
   */
  getUsedResources: function getUsedResources(rootNode) {
    var _this2 = this;

    var resources = [];

    if (rootNode) {
      rootNode.traverse(function (node) {
        if (node.isMesh && !node.isDestroyed) {
          _this2.getMeshResources(node, resources);
        }
      });
    }

    return resources;
  },

  /**
   * 销毁没被 rootNode 使用的资源，通常传 stage。
   * @param {Node} [rootNode] 根节点，不传代表所有资源都没被使用过。
   * @return {WebGLResourceManager} this
   */
  destroyUnsuedResource: function destroyUnsuedResource(rootNode) {
    var _this3 = this;

    var needDestroyResources = this._needDestroyResources;

    if (needDestroyResources.length === 0) {
      return this;
    }

    var usedResources = this.getUsedResources(rootNode);
    needDestroyResources.forEach(function (resource) {
      if (usedResources.indexOf(resource) < 0) {
        if (resource && resource.destroy && !resource.alwaysUse) {
          _this3.fire('destroyResource', resource.id);

          resource.destroy();
        }
      }
    });
    this.reset();
    return this;
  },

  /**
   * 重置
   * @return {WebGLResourceManager} this
   */
  reset: function reset() {
    this._needDestroyResources.length = 0;
    return this;
  }
});
/* harmony default export */ var renderer_WebGLResourceManager = (WebGLResourceManager);
// CONCATENATED MODULE: ./src/light/LightManager.js





var LightManager_tempMatrix4 = new math_Matrix4();
var LightManager_tempVector3 = new math_Vector3();
var LightManager_tempFloat32Array = new Float32Array([0, 0, 0]);
/**
 * 光管理类
 * @class
 */

var LightManager = core_Class.create(
/** @lends LightManager.prototype */
{
  /**
   * @default true
   * @type {boolean}
   */
  isLightManager: true,

  /**
   * @default DirectionalLight
   * @type {string}
   */
  className: 'LightManager',

  /**
   * @constructs
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    this.ambientLights = [];
    this.directionalLights = [];
    this.pointLights = [];
    this.spotLights = [];
    this.areaLights = [];
    this.lightInfo = {
      AMBIENT_LIGHTS: 0,
      POINT_LIGHTS: 0,
      DIRECTIONAL_LIGHTS: 0,
      SPOT_LIGHTS: 0,
      AREA_LIGHTS: 0,
      uid: 0
    };
    Object.assign(this, params);
  },
  getRenderOption: function getRenderOption() {
    var _this = this;

    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    util_each(this.lightInfo, function (count, name) {
      if (name === 'uid' || !count) {
        return;
      }

      option[name] = count;

      var shadowMapCount = _this.getShadowMapCount(name);

      if (shadowMapCount) {
        option[name + '_SMC'] = shadowMapCount;
      }
    });
    return option;
  },

  /**
   * 增加光
   * @param {Light} light 光源
   * @return {LightManager} this
   */
  addLight: function addLight(light) {
    var lights = null;

    if (!light.enabled) {
      return this;
    }

    if (light.isAmbientLight) {
      lights = this.ambientLights;
    } else if (light.isDirectionalLight) {
      lights = this.directionalLights;
    } else if (light.isPointLight) {
      lights = this.pointLights;
    } else if (light.isSpotLight) {
      lights = this.spotLights;
    } else if (light.isAreaLight) {
      lights = this.areaLights;
    } else {
      utils_log.warnOnce("LightManager.addLight(".concat(light.id, ")"), 'Not support this light:', light);
    }

    if (lights) {
      if (light.shadow) {
        lights.unshift(light);
      } else {
        lights.push(light);
      }
    }

    return this;
  },

  /**
   * 获取方向光信息
   * @param  {Camera} camera 摄像机
   * @return {Object}
   */
  getDirectionalInfo: function getDirectionalInfo(camera) {
    var colors = [];
    var infos = [];
    var shadowMap = [];
    var shadowMapSize = [];
    var lightSpaceMatrix = [];
    var shadowBias = [];
    this.directionalLights.forEach(function (light, index) {
      var offset = index * 3;
      light.getRealColor().toRGBArray(colors, offset);
      light.getViewDirection(camera).toArray(infos, offset);

      if (light.shadow && light.lightShadow) {
        shadowMap.push(light.lightShadow.framebuffer.texture);
        shadowMapSize.push(light.lightShadow.width);
        shadowMapSize.push(light.lightShadow.height);
        shadowBias.push(light.lightShadow.minBias, light.lightShadow.maxBias);
        LightManager_tempMatrix4.copy(camera.worldMatrix);
        LightManager_tempMatrix4.premultiply(light.lightShadow.camera.viewProjectionMatrix);
        LightManager_tempMatrix4.toArray(lightSpaceMatrix, index * 16);
      }
    });
    var result = {
      colors: new Float32Array(colors),
      infos: new Float32Array(infos)
    };

    if (shadowMap.length) {
      result.shadowMap = shadowMap;
      result.shadowMapSize = new Float32Array(shadowMapSize);
      result.shadowBias = new Float32Array(shadowBias);
      result.lightSpaceMatrix = new Float32Array(lightSpaceMatrix);
    }

    return result;
  },

  /**
   * 获取聚光灯信息
   * @param {Camera} camera 摄像机
   * @return {Object}
   */
  getSpotInfo: function getSpotInfo(camera) {
    var colors = [];
    var infos = [];
    var poses = [];
    var dirs = [];
    var cutoffs = [];
    var shadowMap = [];
    var shadowMapSize = [];
    var lightSpaceMatrix = [];
    var shadowBias = [];
    var ranges = [];
    this.spotLights.forEach(function (light, index) {
      var offset = index * 3;
      light.getRealColor().toRGBArray(colors, offset);
      light.toInfoArray(infos, offset);
      light.getViewDirection(camera).toArray(dirs, offset);
      ranges.push(light.range);
      cutoffs.push(light._cutoffCos, light._outerCutoffCos);
      camera.getModelViewMatrix(light, LightManager_tempMatrix4);
      LightManager_tempMatrix4.getTranslation(LightManager_tempVector3);
      LightManager_tempVector3.toArray(poses, offset);

      if (light.shadow && light.lightShadow) {
        shadowMap.push(light.lightShadow.framebuffer.texture);
        shadowMapSize.push(light.lightShadow.width);
        shadowMapSize.push(light.lightShadow.height);
        shadowBias.push(light.lightShadow.minBias, light.lightShadow.maxBias);
        LightManager_tempMatrix4.multiply(light.lightShadow.camera.viewProjectionMatrix, camera.worldMatrix);
        LightManager_tempMatrix4.toArray(lightSpaceMatrix, index * 16);
      }
    });
    var result = {
      colors: new Float32Array(colors),
      infos: new Float32Array(infos),
      poses: new Float32Array(poses),
      dirs: new Float32Array(dirs),
      cutoffs: new Float32Array(cutoffs),
      ranges: new Float32Array(ranges)
    };

    if (shadowMap.length) {
      result.shadowMap = shadowMap;
      result.shadowMapSize = new Float32Array(shadowMapSize);
      result.shadowBias = new Float32Array(shadowBias);
      result.lightSpaceMatrix = new Float32Array(lightSpaceMatrix);
    }

    return result;
  },

  /**
   * 获取点光源信息
   * @param  {Camera} camera 摄像机
   * @return {Object}
   */
  getPointInfo: function getPointInfo(camera) {
    var colors = [];
    var infos = [];
    var poses = [];
    var shadowMap = [];
    var lightSpaceMatrix = [];
    var shadowBias = [];
    var cameras = [];
    var ranges = [];
    this.pointLights.forEach(function (light, index) {
      var offset = index * 3;
      light.getRealColor().toRGBArray(colors, offset);
      light.toInfoArray(infos, offset);
      ranges.push(light.range);
      camera.getModelViewMatrix(light, LightManager_tempMatrix4);
      LightManager_tempMatrix4.getTranslation(LightManager_tempVector3);
      LightManager_tempVector3.toArray(poses, offset);

      if (light.shadow && light.lightShadow) {
        shadowMap.push(light.lightShadow.framebuffer.texture);
        shadowBias.push(light.lightShadow.minBias, light.lightShadow.maxBias);
        camera.worldMatrix.toArray(lightSpaceMatrix, index * 16);
        cameras[index * 2] = light.lightShadow.camera.near;
        cameras[index * 2 + 1] = light.lightShadow.camera.far;
      }
    });
    var result = {
      colors: new Float32Array(colors),
      infos: new Float32Array(infos),
      poses: new Float32Array(poses),
      ranges: new Float32Array(ranges)
    };

    if (shadowMap.length) {
      result.shadowMap = shadowMap;
      result.shadowBias = new Float32Array(shadowBias);
      result.lightSpaceMatrix = new Float32Array(lightSpaceMatrix);
      result.cameras = new Float32Array(cameras);
    }

    return result;
  },

  /**
   * 获取面光源信息
   * @param  {Camera} camera 摄像机
   * @return {Object}
   */
  getAreaInfo: function getAreaInfo(camera) {
    var colors = [];
    var poses = [];
    var width = [];
    var height = [];
    var ltcTexture1;
    var ltcTexture2;
    this.areaLights.forEach(function (light, index) {
      var offset = index * 3;
      light.getRealColor().toRGBArray(colors, offset);
      camera.getModelViewMatrix(light, LightManager_tempMatrix4);
      LightManager_tempMatrix4.getTranslation(LightManager_tempVector3);
      LightManager_tempVector3.toArray(poses, offset);
      var quat = LightManager_tempMatrix4.getRotation();
      LightManager_tempMatrix4.fromQuat(quat);
      LightManager_tempVector3.set(light.width * 0.5, 0, 0);
      LightManager_tempVector3.transformMat4(LightManager_tempMatrix4);
      LightManager_tempVector3.toArray(width, offset);
      LightManager_tempVector3.set(0.0, light.height * 0.5, 0.0);
      LightManager_tempVector3.transformMat4(LightManager_tempMatrix4);
      LightManager_tempVector3.toArray(height, offset);
      ltcTexture1 = light.ltcTexture1;
      ltcTexture2 = light.ltcTexture2;
    });
    var result = {
      colors: new Float32Array(colors),
      poses: new Float32Array(poses),
      width: new Float32Array(width),
      height: new Float32Array(height),
      ltcTexture1: ltcTexture1,
      ltcTexture2: ltcTexture2
    };
    return result;
  },

  /**
   * 获取环境光信息
   * @return {Object}
   */
  getAmbientInfo: function getAmbientInfo() {
    LightManager_tempFloat32Array[0] = LightManager_tempFloat32Array[1] = LightManager_tempFloat32Array[2] = 0;
    this.ambientLights.forEach(function (light) {
      var realColor = light.getRealColor();
      LightManager_tempFloat32Array[0] += realColor.r;
      LightManager_tempFloat32Array[1] += realColor.g;
      LightManager_tempFloat32Array[2] += realColor.b;
    });
    LightManager_tempFloat32Array[0] = Math.min(1, LightManager_tempFloat32Array[0]);
    LightManager_tempFloat32Array[1] = Math.min(1, LightManager_tempFloat32Array[1]);
    LightManager_tempFloat32Array[2] = Math.min(1, LightManager_tempFloat32Array[2]);
    return LightManager_tempFloat32Array;
  },

  /**
   * 更新所有光源信息
   * @param  {Camera} camera 摄像机
   */
  updateInfo: function updateInfo(camera) {
    var lightInfo = this.lightInfo,
        ambientLights = this.ambientLights,
        directionalLights = this.directionalLights,
        pointLights = this.pointLights,
        spotLights = this.spotLights,
        areaLights = this.areaLights;
    lightInfo.AMBIENT_LIGHTS = ambientLights.length;
    lightInfo.POINT_LIGHTS = pointLights.length;
    lightInfo.DIRECTIONAL_LIGHTS = directionalLights.length;
    lightInfo.SPOT_LIGHTS = spotLights.length;
    lightInfo.AREA_LIGHTS = areaLights.length;

    var shadowFilter = function shadowFilter(light) {
      return !!light.shadow;
    };

    lightInfo.SHADOW_POINT_LIGHTS = pointLights.filter(shadowFilter).length;
    lightInfo.SHADOW_SPOT_LIGHTS = spotLights.filter(shadowFilter).length;
    lightInfo.SHADOW_DIRECTIONAL_LIGHTS = directionalLights.filter(shadowFilter).length;
    lightInfo.uid = [lightInfo.AMBIENT_LIGHTS, lightInfo.POINT_LIGHTS, lightInfo.SHADOW_POINT_LIGHTS, lightInfo.DIRECTIONAL_LIGHTS, lightInfo.SHADOW_DIRECTIONAL_LIGHTS, lightInfo.SPOT_LIGHTS, lightInfo.SHADOW_SPOT_LIGHTS, lightInfo.AREA_LIGHTS].join('_');
    this.directionalInfo = this.getDirectionalInfo(camera);
    this.pointInfo = this.getPointInfo(camera);
    this.spotInfo = this.getSpotInfo(camera);
    this.areaInfo = this.getAreaInfo(camera);
    this.ambientInfo = this.getAmbientInfo();
  },

  /**
   * 获取光源信息
   * @return {Object}
   */
  getInfo: function getInfo() {
    return this.lightInfo;
  },

  /**
   * 重置所有光源
   */
  reset: function reset() {
    this.ambientLights.length = 0;
    this.directionalLights.length = 0;
    this.pointLights.length = 0;
    this.spotLights.length = 0;
    this.areaLights.length = 0;
  },
  getShadowMapCount: function getShadowMapCount(type) {
    var lights = [];

    if (type === 'POINT_LIGHTS') {
      lights = this.pointLights;
    } else if (type === 'DIRECTIONAL_LIGHTS') {
      lights = this.directionalLights;
    } else if (type === 'SPOT_LIGHTS') {
      lights = this.spotLights;
    } else if (type === 'AREA_LIGHTS') {
      lights = this.spotLights;
    }

    var count = 0;
    lights.forEach(function (light) {
      count += light.shadow ? 1 : 0;
    });
    return count;
  },
  createShadowMap: function createShadowMap(renderer, camera) {
    this.directionalLights.forEach(function (light) {
      light.createShadowMap(renderer, camera);
    });
    this.spotLights.forEach(function (light) {
      light.createShadowMap(renderer, camera);
    });
    this.pointLights.forEach(function (light) {
      light.createShadowMap(renderer, camera);
    });
    this.areaLights.forEach(function (light) {
      light.createShadowMap(renderer, camera);
    });
  }
});
/* harmony default export */ var light_LightManager = (LightManager);
// CONCATENATED MODULE: ./src/renderer/WebGLRenderer.js




















var WebGLRenderer_DEPTH_TEST = src_constants.DEPTH_TEST,
    SAMPLE_ALPHA_TO_COVERAGE = src_constants.SAMPLE_ALPHA_TO_COVERAGE,
    WebGLRenderer_CULL_FACE = src_constants.CULL_FACE,
    WebGLRenderer_FRONT_AND_BACK = src_constants.FRONT_AND_BACK,
    BLEND = src_constants.BLEND,
    WebGLRenderer_LINES = src_constants.LINES,
    WebGLRenderer_STATIC_DRAW = src_constants.STATIC_DRAW,
    DYNAMIC_DRAW = src_constants.DYNAMIC_DRAW;
/**
 * WebGL渲染器
 * @class
 * @fires init 初始化事件
 * @fires beforeRender 渲染前事件
 * @fires beforeRenderScene 渲染场景前事件
 * @fires afterRender 渲染后事件
 * @fires initFailed 初始化失败事件
 * @fires webglContextLost webglContextLost 事件
 * @fires webglContextRestored webglContextRestored 事件
 * @mixes EventMixin
 */

var WebGLRenderer = core_Class.create(
/** @lends WebGLRenderer.prototype */
{
  Mixes: core_EventMixin,

  /**
   * @default WebGLRenderer
   * @type {String}
   */
  className: 'WebGLRenderer',

  /**
   * @default true
   * @type {Boolean}
   */
  isWebGLRenderer: true,

  /**
   * gl
   * @default null
   * @type {WebGLRenderingContext}
   */
  gl: null,

  /**
   * 宽
   * @type {Number}
   * @default 0
   */
  width: 0,

  /**
   * 高
   * @type {Number}
   * @default 0
   */
  height: 0,

  /**
   * 像素密度
   * @type {Number}
   * @default 1
   */
  pixelRatio: 1,

  /**
   * dom元素
   * @type {HTMLCanvasElement}
   * @default null
   */
  domElement: null,

  /**
   * 是否使用instanced
   * @type {Boolean}
   * @default false
   */
  useInstanced: false,

  /**
   * 是否使用VAO
   * @type {Boolean}
   * @default true
   */
  useVao: true,

  /**
   * 是否开启透明背景
   * @type {Boolean}
   * @default false
   */
  alpha: false,

  /**
   * @type {Boolean}
   * @default true
   */
  depth: true,

  /**
   * @type {Boolean}
   * @default false
   */
  stencil: false,

  /**
   * 是否开启抗锯齿
   * @type {Boolean}
   * @default true
   */
  antialias: true,

  /**
   * Boolean that indicates that the page compositor will assume the drawing buffer contains colors with pre-multiplied alpha.
   * @type {Boolean}
   * @default true
   */
  premultipliedAlpha: true,

  /**
   * If the value is true the buffers will not be cleared and will preserve their values until cleared or overwritten by the author.
   * @type {Boolean}
   * @default false
   */
  preserveDrawingBuffer: false,

  /**
   * Boolean that indicates if a context will be created if the system performance is low.
   * @type {Boolean}
   * @default false
   */
  failIfMajorPerformanceCaveat: false,

  /**
   * 游戏模式, UC浏览器专用
   * @default false
   * @type {Boolean}
   */
  gameMode: false,

  /**
   * 是否使用framebuffer
   * @type {Boolean}
   * @default false
   */
  useFramebuffer: false,

  /**
   * framebuffer配置
   * @type {Object}
   * @default {}
   */
  framebufferOption: {},

  /**
   * 是否使用对数深度
   * @type {Boolean}
   * @default false
   */
  useLogDepth: false,

  /**
   * 顶点着色器精度, 可以是以下值：highp, mediump, lowp
   * @type {String}
   * @default highp
   */
  vertexPrecision: 'highp',

  /**
   * 片段着色器精度, 可以是以下值：highp, mediump, lowp
   * @type {String}
   * @default mediump
   */
  fragmentPrecision: 'highp',

  /**
   * 雾
   * @type {Fog}
   * @default null
   */
  fog: null,

  /**
   * 偏移值
   * @type {Number}
   * @default 0
   */
  offsetX: 0,

  /**
   * 偏移值
   * @type {Number}
   * @default 0
   */
  offsetY: 0,

  /**
   * 是否初始化失败
   * @default false
   * @type {Boolean}
   */
  isInitFailed: false,

  /**
   * 是否初始化
   * @type {Boolean}
   * @default false
   * @private
   */
  _isInit: false,

  /**
   * 是否lost context
   * @type {Boolean}
   * @default false
   * @private
   */
  _isContextLost: false,

  /**
   * @constructs
   * @param  {Object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    /**
     * 背景色
     * @type {Color}
     * @default new Color(1, 1, 1, 1)
     */
    this.clearColor = new math_Color(1, 1, 1);
    Object.assign(this, params);
    /**
     * 渲染信息
     * @type {RenderInfo}
     * @default new RenderInfo
     */

    this.renderInfo = new renderer_RenderInfo();
    /**
     * 渲染列表
     * @type {RenderList}
     * @default new RenderList
     */

    this.renderList = new renderer_RenderList();
    /**
     * 灯光管理器
     * @type {LightManager}
     * @default new LightManager
     */

    this.lightManager = new light_LightManager();
    /**
     * 资源管理器
     * @type {WebGLResourceManager}
     * @default new WebGLResourceManager
     */

    this.resourceManager = new renderer_WebGLResourceManager();
  },

  /**
   * 改变大小
   * @param  {Number} width  宽
   * @param  {Number} height  高
   * @param  {Boolean} [force=false] 是否强制刷新
   */
  resize: function resize(width, height, force) {
    if (force || this.width !== width || this.height !== height) {
      var canvas = this.domElement;
      this.width = width;
      this.height = height;
      canvas.width = width;
      canvas.height = height;

      if (this.framebuffer) {
        this.framebuffer.resize(this.width, this.height, force);
      }

      this.viewport();
    }
  },

  /**
   * 设置viewport偏移值
   * @param {Number} x x
   * @param {Number} y y
   */
  setOffset: function setOffset(x, y) {
    if (this.offsetX !== x || this.offsetY !== y) {
      this.offsetX = x;
      this.offsetY = y;
      this.viewport();
    }
  },

  /**
   * 设置viewport
   * @param  {Number} [x=this.offsetX]  x
   * @param  {Number} [y=this.offsetY] y
   * @param  {Number} [width=this.gl.drawingBufferWidth]  width
   * @param  {Number} [height=this.gl.drawingBufferHeight]  height
   */
  viewport: function viewport(x, y, width, height) {
    var state = this.state,
        gl = this.gl;

    if (state) {
      if (x === undefined) {
        x = this.offsetX;
      } else {
        this.offsetX = x;
      }

      if (y === undefined) {
        y = this.offsetY;
      } else {
        this.offsetY = y;
      }

      if (width === undefined) {
        width = gl.drawingBufferWidth;
      }

      if (height === undefined) {
        height = gl.drawingBufferHeight;
      }

      state.viewport(x, y, width, height);
    }
  },

  /**
   * 是否初始化
   * @type {Boolean}
   * @default false
   * @readOnly
   */
  isInit: {
    get: function get() {
      return this._isInit && !this.isInitFailed;
    }
  },

  /**
   * 初始化回调
   * @return {WebGLRenderer} this
   */
  onInit: function onInit(callback) {
    var _this = this;

    if (this._isInit) {
      callback(this);
    } else {
      this.on('init', function () {
        callback(_this);
      }, true);
    }
  },

  /**
   * 初始化 context
   */
  initContext: function initContext() {
    if (!this._isInit) {
      this._isInit = true;

      try {
        this._initContext();

        this.fire('init');
      } catch (e) {
        this.isInitFailed = true;
        this.fire('initFailed', e);
      }
    }
  },
  _initContext: function _initContext() {
    var _this2 = this;

    var contextAttributes = {
      alpha: this.alpha,
      depth: this.depth,
      stencil: this.stencil,
      antialias: this.antialias,
      premultipliedAlpha: this.premultipliedAlpha,
      failIfMajorPerformanceCaveat: this.failIfMajorPerformanceCaveat
    }; // fix ios bug...

    if (this.preserveDrawingBuffer === true) {
      contextAttributes.preserveDrawingBuffer = true;
    }

    if (this.gameMode === true) {
      contextAttributes.gameMode = true;
    }

    var gl = this.gl = this.domElement.getContext('webgl', contextAttributes);
    gl.viewport(0, 0, this.width, this.height);
    renderer_glType.init(gl);
    renderer_extensions.init(gl);
    renderer_capabilities.init(gl);
    shader_Shader.init(this);
    /**
     * state，初始化后生成。
     * @type {WebGLState}
     * @default null
     */

    this.state = new renderer_WebGLState(gl);

    if (!renderer_extensions.instanced) {
      this.useInstanced = false;
    }

    if (!renderer_extensions.vao) {
      this.useVao = false;
    }

    if (this.useFramebuffer) {
      /**
       * framebuffer，只在 useFramebuffer 为 true 时初始化后生成
       * @type {Framebuffer}
       * @default null
       */
      this.framebuffer = new renderer_Framebuffer(this, Object.assign({
        useVao: this.useVao,
        width: this.width,
        height: this.height
      }, this.framebufferOption));
    }

    this.domElement.addEventListener('webglcontextlost', function (e) {
      _this2._onContextLost(e);
    }, false);
    this.domElement.addEventListener('webglcontextrestored', function (e) {
      _this2._onContextRestore(e);
    }, false);
  },
  _onContextLost: function _onContextLost(e) {
    this.fire('webglContextLost');
    var gl = this.gl;
    this._isContextLost = true;
    e.preventDefault();
    renderer_Program.reset(gl);
    shader_Shader.reset(gl);
    texture_Texture.reset(gl);
    renderer_Buffer.reset(gl);
    renderer_VertexArrayObject.reset(gl);
    this.state.reset(gl);
    this._lastMaterial = null;
    this._lastProgram = null;
  },
  _onContextRestore: function _onContextRestore(e) {
    // eslint-disable-line no-unused-vars
    this.fire('webglContextRestored');
    var gl = this.gl;
    this._isContextLost = false;
    renderer_extensions.reset(gl);
    renderer_Framebuffer.reset(gl);
  },

  /**
   * 设置深度检测
   * @param  {Material} material
   */
  setupDepthTest: function setupDepthTest(material) {
    var state = this.state;

    if (material.depthTest) {
      state.enable(WebGLRenderer_DEPTH_TEST);
      state.depthFunc(material.depthFunc);
      state.depthMask(material.depthMask);
      state.depthRange(material.depthRange[0], material.depthRange[1]);
    } else {
      state.disable(WebGLRenderer_DEPTH_TEST);
    }
  },

  /**
   * 设置alphaToCoverage
   * @param  {Material} material
   */
  setupSampleAlphaToCoverage: function setupSampleAlphaToCoverage(material) {
    var state = this.state;

    if (material.sampleAlphaToCoverage) {
      state.enable(SAMPLE_ALPHA_TO_COVERAGE);
    } else {
      state.disable(SAMPLE_ALPHA_TO_COVERAGE);
    }
  },

  /**
   * 设置背面剔除
   * @param  {Material} material
   */
  setupCullFace: function setupCullFace(material) {
    var state = this.state;

    if (material.cullFace && material.cullFaceType !== WebGLRenderer_FRONT_AND_BACK) {
      state.enable(WebGLRenderer_CULL_FACE);
      state.cullFace(material.cullFaceType);
    } else {
      state.disable(WebGLRenderer_CULL_FACE);
    }
  },

  /**
   * 设置混合
   * @param  {Material} material
   */
  setupBlend: function setupBlend(material) {
    var state = this.state;

    if (material.blend) {
      state.enable(BLEND);
      state.blendFuncSeparate(material.blendSrc, material.blendDst, material.blendSrcAlpha, material.blendDstAlpha);
      state.blendEquationSeparate(material.blendEquation, material.blendEquationAlpha);
    } else {
      state.disable(BLEND);
    }
  },

  /**
   * 设置通用的 uniform
   * @param  {Program} program
   * @param  {Mesh} mesh
   * @param  {Boolean} [force=false] 是否强制更新
   */
  setupUniforms: function setupUniforms(program, mesh, useInstanced, force) {
    var material = this.forceMaterial || mesh.material;

    for (var name in program.uniforms) {
      var uniformInfo = material.getUniformInfo(name);
      var programUniformInfo = program.uniforms[name];

      if (!uniformInfo.isBlankInfo) {
        if (force || uniformInfo.isDependMesh && !useInstanced) {
          var uniformData = uniformInfo.get(mesh, material, programUniformInfo);

          if (uniformData !== undefined && uniformData !== null) {
            program[name] = uniformData;
          }
        }
      }
    }
  },

  /**
   * 设置vao
   * @param  {VertexArrayObject} vao
   * @param  {Program} program
   * @param  {Mesh} mesh
   */
  setupVao: function setupVao(vao, program, mesh) {
    var geometry = mesh.geometry;
    var isStatic = geometry.isStatic;

    if (vao.isDirty || !isStatic || geometry.isDirty) {
      vao.isDirty = false;
      var material = this.forceMaterial || mesh.material;
      var materialAttributes = material.attributes;
      var usage = isStatic ? WebGLRenderer_STATIC_DRAW : DYNAMIC_DRAW;

      for (var name in materialAttributes) {
        var programAttribute = program.attributes[name];

        if (programAttribute) {
          var data = material.getAttributeData(name, mesh, programAttribute);

          if (data !== undefined && data !== null) {
            vao.addAttribute(data, programAttribute, usage);
          }
        }
      }

      if (geometry.indices) {
        vao.addIndexBuffer(geometry.indices, usage);
      }

      geometry.isDirty = false;
    }

    if (geometry.vertexCount) {
      vao.vertexCount = geometry.vertexCount;
    }
  },

  /**
   * 设置材质
   * @param  {Program} program
   * @param  {Mesh} mesh
   */
  setupMaterial: function setupMaterial(program, mesh, useInstanced) {
    var needForceUpdateUniforms = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var material = this.forceMaterial || mesh.material;

    if (material.isDirty || this._lastMaterial !== material) {
      this.setupDepthTest(material);
      this.setupSampleAlphaToCoverage(material);
      this.setupCullFace(material);
      this.setupBlend(material);
      needForceUpdateUniforms = true;
    }

    this.setupUniforms(program, mesh, useInstanced, needForceUpdateUniforms);
    material.isDirty = false;
    this._lastMaterial = material;
  },

  /**
   * 设置mesh
   * @param  {Mesh} mesh
   * @param  {Boolean} useInstanced
   * @return {Object} res
   * @return {VertexArrayObject} res.vao
   * @return {Program} res.program
   * @return {Geometry} res.geometry
   */
  setupMesh: function setupMesh(mesh, useInstanced) {
    var gl = this.gl;
    var state = this.state;
    var lightManager = this.lightManager;
    var geometry = mesh.geometry;
    var material = this.forceMaterial || mesh.material;
    var shader = shader_Shader.getShader(mesh, material, useInstanced, lightManager, this.fog, this.useLogDepth);
    var program = renderer_Program.getProgram(shader, state);
    program.useProgram();
    this.setupMaterial(program, mesh, useInstanced, this._lastProgram !== program);
    this._lastProgram = program;

    if (mesh.material.wireframe && geometry.mode !== WebGLRenderer_LINES) {
      geometry.convertToLinesMode();
    }

    var vaoId = geometry.id + program.id;
    var vao = renderer_VertexArrayObject.getVao(gl, vaoId, {
      useInstanced: useInstanced,
      useVao: this.useVao,
      mode: geometry.mode
    });
    this.setupVao(vao, program, mesh);
    mesh._vao = vao;
    mesh._shader = shader;
    mesh._program = program;
    return {
      vao: vao,
      program: program,
      geometry: geometry
    };
  },

  /**
   * 增加渲染信息
   * @param {Number} faceCount 面数量
   * @param {Number} drawCount 绘图数量
   */
  addRenderInfo: function addRenderInfo(faceCount, drawCount) {
    var renderInfo = this.renderInfo;
    renderInfo.addFaceCount(faceCount);
    renderInfo.addDrawCount(drawCount);
  },

  /**
   * 渲染
   * @param  {Stage} stage
   * @param  {Camera} camera
   * @param  {Boolean} [fireEvent=false] 是否发送事件
   */
  render: function render(stage, camera) {
    var fireEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    this.initContext();

    if (this.isInitFailed || this._isContextLost) {
      return;
    }

    var renderList = this.renderList,
        renderInfo = this.renderInfo,
        lightManager = this.lightManager,
        resourceManager = this.resourceManager,
        state = this.state;
    this.fog = stage.fog;
    lightManager.reset();
    renderInfo.reset();
    renderList.reset();
    material_semantic.init(this, state, camera, lightManager, this.fog);
    stage.updateMatrixWorld();
    camera.updateViewProjectionMatrix();
    stage.traverse(function (node) {
      if (!node.visible) {
        return core_Node.TRAVERSE_STOP_CHILDREN;
      }

      if (node.isMesh) {
        renderList.addMesh(node, camera);
      } else if (node.isLight) {
        lightManager.addLight(node);
      }

      return core_Node.TRAVERSE_STOP_NONE;
    });
    renderList.sort();
    lightManager.createShadowMap(this, camera);
    lightManager.updateInfo(camera);

    if (fireEvent) {
      this.fire('beforeRender');
    }

    if (this.useFramebuffer) {
      this.framebuffer.bind();
    }

    this.clear();

    if (fireEvent) {
      this.fire('beforeRenderScene');
    }

    this.renderScene();

    if (this.useFramebuffer) {
      this.renderToScreen(this.framebuffer);
    }

    if (fireEvent) {
      this.fire('afterRender');
    }

    resourceManager.destroyUnsuedResource(stage);
  },

  /**
   * 渲染场景
   */
  renderScene: function renderScene() {
    var _this3 = this;

    var renderList = this.renderList;
    renderList.traverse(function (mesh) {
      _this3.renderMesh(mesh);
    }, function (instancedMeshes) {
      _this3.renderInstancedMeshes(instancedMeshes);
    });

    this._gameModeSumbit();
  },
  _gameModeSumbit: function _gameModeSumbit() {
    var gl = this.gl;

    if (this.gameMode && gl && gl.submit) {
      gl.submit();
    }
  },

  /**
   * 清除背景
   * @param  {Color} [clearColor=this.clearColor]
   */
  clear: function clear(clearColor) {
    var gl = this.gl,
        state = this.state;
    clearColor = clearColor || this.clearColor;
    state.depthMask(true);
    this._lastMaterial = null;
    this._lastProgram = null;
    gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  },

  /**
   * 清除深度
   */
  clearDepth: function clearDepth() {
    var gl = this.gl,
        state = this.state;
    state.depthMask(true);
    gl.clear(gl.DEPTH_BUFFER_BIT);
  },

  /**
   * 将framebuffer渲染到屏幕
   * @param  {Framebuffer} framebuffer
   */
  renderToScreen: function renderToScreen(framebuffer) {
    this.state.bindSystemFramebuffer();
    framebuffer.render(0, 0, 1, 1, this.clearColor);
  },

  /**
   * 渲染一个mesh
   * @param  {Mesh} mesh
   */
  renderMesh: function renderMesh(mesh) {
    var vao = this.setupMesh(mesh, false).vao;
    vao.draw();
    this.addRenderInfo(vao.vertexCount / 3, 1);
  },

  /**
   * 渲染一组 instanced mesh
   * @param  {Mesh[]} meshes
   */
  renderInstancedMeshes: function renderInstancedMeshes(meshes) {
    var mesh = meshes[0];

    if (!mesh) {
      return;
    }

    var material = this.forceMaterial || mesh.material;

    var _this$setupMesh = this.setupMesh(mesh, true),
        vao = _this$setupMesh.vao,
        program = _this$setupMesh.program;

    var instancedUniforms = material.getInstancedUniforms();
    instancedUniforms.forEach(function (uniformObj) {
      var name = uniformObj.name;
      var info = uniformObj.info;
      var attribute = program.attributes[name];

      if (attribute) {
        vao.addInstancedAttribute(attribute, meshes, function (mesh) {
          return info.get(mesh);
        });
      }
    });
    vao.drawInstance(meshes.length);
    this.addRenderInfo(vao.vertexCount / 3 * meshes.length, 1);
  },

  /**
   * 渲染一组普通mesh
   * @param  {Mesh[]} meshes
   */
  renderMultipleMeshes: function renderMultipleMeshes(meshes) {
    var _this4 = this;

    meshes.forEach(function (mesh) {
      _this4.renderMesh(mesh);
    });
  },

  /**
   * 销毁 WebGL 资源
   */
  releaseGLResource: function releaseGLResource() {
    var gl = this.gl;

    if (gl) {
      renderer_Program.reset(gl);
      shader_Shader.reset(gl);
      renderer_Buffer.reset(gl);
      renderer_VertexArrayObject.reset(gl);
      this.state.reset(gl);
      texture_Texture.reset(gl);
      renderer_Framebuffer.destroy(gl);
    }
  }
});
/* harmony default export */ var renderer_WebGLRenderer = (WebGLRenderer);
// EXTERNAL MODULE: ./node_modules/_hilojs@2.0.0@hilojs/util/browser.js
var browser = __webpack_require__("./node_modules/_hilojs@2.0.0@hilojs/util/browser.js");
var browser_default = /*#__PURE__*/__webpack_require__.n(browser);

// CONCATENATED MODULE: ./src/utils/browser.js
/**
 * 浏览器特性集合
 * @namespace
 * @see  {@link http://hiloteam.github.io/Hilo/docs/api-zh/symbols/browser.html}
 */

/* harmony default export */ var utils_browser = (browser_default.a);
// CONCATENATED MODULE: ./src/core/Stage.js









/**
 * 舞台类
 * @class
 * @extends Node
 * @example
 * const stage = new Hilo3d.Stage({
 *     container:document.body,
 *     width:innerWidth,
 *     height:innerHeight
 * });
 */

var Stage = core_Class.create(
/** @lends Stage.prototype */
{
  Extends: core_Node,
  isStage: true,
  className: 'Stage',

  /**
   * 渲染器
   * @type {WebGLRenderer}
   */
  renderer: null,

  /**
   * 摄像机
   * @type {Camera}
   */
  camera: null,

  /**
   * 像素密度
   * @type {Number}
   * @default 根据设备自动判断
   */
  pixelRatio: null,

  /**
   * 偏移值
   * @type {Number}
   * @default 0
   */
  offsetX: 0,

  /**
   * 偏移值
   * @type {Number}
   * @default 0
   */
  offsetY: 0,

  /**
   * canvas
   * @type {HTMLCanvasElement}
   * @default null
   */
  canvas: null,

  /**
   * @constructs
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性，所有属性会透传给 Renderer。
   * @param {HTMLElement} [params.container] stage的容器
   * @param {Number} [params.pixelRatio=根据设备自动判断] 像素密度。
   * @param {Color} [params.clearColor=new Color(1, 1, 1, 1)] 背景色。
   * @param {Boolean} [params.useFramebuffer=false] 是否使用Framebuffer，有后处理需求时需要。
   * @param {Object} [params.framebufferOption={}] framebufferOption Framebuffer的配置，useFramebuffer为true时生效。
   * @param {Boolean} [params.useLogDepth=false] 是否使用对数深度，处理深度冲突。
   * @param {Boolean} [params.alpha=false] 是否背景透明。
   * @param {Boolean} [params.depth=true] 是否需要深度缓冲区。
   * @param {Boolean} [params.stencil=false] 是否需要模版缓冲区。
   * @param {Boolean} [params.antialias=true] 是否抗锯齿。
   * @param {Boolean} [params.premultipliedAlpha=true] 是否需要 premultipliedAlpha。
   * @param {Boolean} [params.preserveDrawingBuffer=false] 是否需要 preserveDrawingBuffer。
   * @param {Boolean} [params.failIfMajorPerformanceCaveat=false] 是否需要 failIfMajorPerformanceCaveat。
   * @param {Boolean} [params.gameMode=false] 是否开启游戏模式，UC 浏览器专用
   */
  constructor: function constructor(params) {
    if (!params.width) {
      params.width = window.innerWidth;
    }

    if (!params.height) {
      params.height = window.innerHeight;
    }

    if (!params.pixelRatio) {
      var pixelRatio = window.devicePixelRatio || 1;
      pixelRatio = Math.min(pixelRatio, 1024 / Math.max(params.width, params.height), 2);
      pixelRatio = Math.max(pixelRatio, 1);
      params.pixelRatio = pixelRatio;
    }

    Stage.superclass.constructor.call(this, params);
    this.initRenderer(params);
    utils_log.log("Hilo3d version: ".concat(core_version));
  },

  /**
   * 初始化渲染器
   * @private
   * @param  {Object} params
   */
  initRenderer: function initRenderer(params) {
    var canvas = this.canvas = this.createCanvas(params);
    this.renderer = new renderer_WebGLRenderer(Object.assign(params, {
      domElement: canvas
    }));
    this.resize(this.width, this.height, this.pixelRatio, true);
  },

  /**
   * 生成canvas
   * @private
   * @param  {Object} params
   * @return {HTMLCanvasElement}
   */
  createCanvas: function createCanvas(params) {
    var canvas;

    if (params.canvas) {
      canvas = params.canvas;
    } else {
      canvas = document.createElement('canvas');
    }

    if (params.container) {
      params.container.appendChild(canvas);
    }

    return canvas;
  },

  /**
   * 缩放舞台
   * @param  {Number} width 舞台宽
   * @param  {Number} height 舞台高
   * @param  {Number} [pixelRatio=this.pixelRatio] 像素密度
   * @param  {Boolean} [force=false] 是否强制刷新
   * @return {Stage} 舞台本身。链式调用支持。
   */
  resize: function resize(width, height, pixelRatio, force) {
    if (pixelRatio === undefined) {
      pixelRatio = this.pixelRatio;
    }

    if (force || this.width !== width || this.height !== height || this.pixelRatio !== pixelRatio) {
      this.width = width;
      this.height = height;
      this.pixelRatio = pixelRatio;
      this.rendererWidth = width * pixelRatio;
      this.rendererHeight = height * pixelRatio;
      var canvas = this.canvas;
      var renderer = this.renderer;
      renderer.resize(this.rendererWidth, this.rendererHeight, force);
      canvas.style.width = this.width + 'px';
      canvas.style.height = this.height + 'px';
      this.updateDomViewport();
    }

    return this;
  },

  /**
   * 设置舞台偏移值
   * @param {Number} x x
   * @param {Number} y y
   * @return {Stage} 舞台本身。链式调用支持。
   */
  setOffset: function setOffset(x, y) {
    if (this.offsetX !== x || this.offsetY !== y) {
      this.offsetX = x;
      this.offsetY = y;
      var pixelRatio = this.pixelRatio;
      this.renderer.setOffset(x * pixelRatio, y * pixelRatio);
    }

    return this;
  },

  /**
   * 改viewport
   * @param  {Number} x      x
   * @param  {Number} y      y
   * @param  {Number} width  width
   * @param  {Number} height height
   * @return {Stage} 舞台本身。链式调用支持。
   */
  viewport: function viewport(x, y, width, height) {
    this.resize(width, height, this.pixelRatio, true);
    this.setOffset(x, y);
    return this;
  },

  /**
   * 渲染一帧
   * @param  {Number} dt 间隔时间
   * @return {Stage} 舞台本身。链式调用支持。
   */
  tick: function tick(dt) {
    this.traverseUpdate(dt);

    if (this.camera) {
      this.renderer.render(this, this.camera, true);
    }

    return this;
  },

  /**
   * 开启/关闭舞台的DOM事件响应。要让舞台上的可视对象响应用户交互，必须先使用此方法开启舞台的相应事件的响应。
   * @param {String|Array} type 要开启/关闭的事件名称或数组。
   * @param {Boolean} enabled 指定开启还是关闭。如果不传此参数，则默认为开启。
   * @return {Stage} 舞台本身。链式调用支持。
   */
  enableDOMEvent: function enableDOMEvent(types) {
    var _this = this;

    var enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var canvas = this.canvas;

    var handler = this._domListener || (this._domListener = function (e) {
      _this._onDOMEvent(e);
    });

    types = typeof types === 'string' ? [types] : types;
    types.forEach(function (type) {
      if (enabled) {
        canvas.addEventListener(type, handler, false);
      } else {
        canvas.removeEventListener(type, handler);
      }
    });
    return this;
  },

  /**
   * DOM事件处理函数。此方法会把事件调度到事件的坐标点所对应的可视对象。
   * @private
   */
  _onDOMEvent: function _onDOMEvent(event) {
    var canvas = this.canvas;
    var target = this._eventTarget;
    var type = event.type;
    var isTouch = type.indexOf('touch') === 0; // calculate stageX/stageY

    var posObj = event;

    if (isTouch) {
      var touches = event.touches;
      var changedTouches = event.changedTouches;

      if (touches && touches.length) {
        posObj = touches[0];
      } else if (changedTouches && changedTouches.length) {
        posObj = changedTouches[0];
      }
    }

    var domViewport = this.domViewport || this.updateDomViewport();
    var x = (posObj.pageX || posObj.clientX) - domViewport.left;
    var y = (posObj.pageY || posObj.clientY) - domViewport.top;
    event.stageX = x;
    event.stageY = y; // 鼠标事件需要阻止冒泡方法 Prevent bubbling on mouse events.

    event.stopPropagation = function () {
      this._stopPropagationed = true;
    };

    var meshResult = this.getMeshResultAtPoint(x, y, true);
    var obj = meshResult.mesh;
    event.hitPoint = meshResult.point; // fire mouseout/touchout event for last event target

    var leave = type === 'mouseout'; // 当obj和target不同 且obj不是target的子元素时才触发out事件 fire out event when obj and target isn't the same as well as obj is not a child element to target.

    if (target && (target !== obj && (!target.contains || !target.contains(obj)) || leave)) {
      var out = false;

      if (type === 'touchmove') {
        out = 'touchout';
      } else if (type === 'mousemove' || leave || !obj) {
        out = 'mouseout';
      }

      if (out) {
        var outEvent = Object.assign({}, event);
        outEvent.type = out;
        outEvent.eventTarget = target;

        target._fireMouseEvent(outEvent);
      }

      event.lastEventTarget = target;
      this._eventTarget = null;
    } // fire event for current view


    if (obj && obj.pointerEnabled && type !== 'mouseout') {
      event.eventTarget = this._eventTarget = obj;

      obj._fireMouseEvent(event);
    } // set cursor for current view


    if (!isTouch) {
      var cursor = obj && obj.pointerEnabled && obj.useHandCursor ? 'pointer' : '';
      canvas.style.cursor = cursor;
    } // fix android: `touchmove` fires only once


    if (utils_browser.android && type === 'touchmove') {
      event.preventDefault();
    }
  },

  /**
   * 更新 DOM viewport
   * @return {Object} DOM viewport, {left, top, right, bottom}
   */
  updateDomViewport: function updateDomViewport() {
    var canvas = this.canvas;
    var domViewport = null;

    if (canvas.parentNode) {
      domViewport = this.domViewport = getElementRect(canvas);
    }

    return domViewport;
  },

  /**
   * 获取指定点的 mesh
   * @param  {Number}  x
   * @param  {Number}  y
   * @param  {Boolean} [eventMode=false]
   * @return {Mesh|null}
   */
  getMeshResultAtPoint: function getMeshResultAtPoint(x, y) {
    var eventMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var camera = this.camera;
    var ray = this._ray;

    if (!ray) {
      ray = this._ray = new math_Ray();
    }

    ray.fromCamera(camera, x, y, this.width, this.height);
    var hitResult = this.raycast(ray, true, eventMode);

    if (hitResult) {
      return hitResult[0];
    }

    if (!this._stageResultAtPoint) {
      this._stageResultAtPoint = {
        mesh: this,
        point: new math_Vector3()
      };
    }

    var point = this._stageResultAtPoint.point;
    point.copy(camera.unprojectVector(point.set(x, y, 0), this.width, this.height));
    return this._stageResultAtPoint;
  },

  /**
   * 释放 WebGL 资源
   * @return {Stage} this
   */
  releaseGLResource: function releaseGLResource() {
    this.renderer.releaseGLResource();
    return this;
  },

  /**
   * 销毁
   * @override
   * @return {Stage} this
   */
  destroy: function destroy() {
    Stage.superclass.destroy.call(this, this.renderer);
    this.releaseGLResource();
    this.traverse(function (child) {
      child.off();
      child.parent = null;
    });
    this.children.length = 0;
    this.renderer.off();
    return this;
  }
});
/* harmony default export */ var core_Stage = (Stage);
// EXTERNAL MODULE: ./node_modules/_hilojs@2.0.0@hilojs/tween/Tween.js
var Tween = __webpack_require__("./node_modules/_hilojs@2.0.0@hilojs/tween/Tween.js");
var Tween_default = /*#__PURE__*/__webpack_require__.n(Tween);

// EXTERNAL MODULE: ./node_modules/_hilojs@2.0.0@hilojs/tween/Ease.js
var Ease = __webpack_require__("./node_modules/_hilojs@2.0.0@hilojs/tween/Ease.js");
var Ease_default = /*#__PURE__*/__webpack_require__.n(Ease);

// CONCATENATED MODULE: ./src/core/Tween.js
/**
 * Tween类提供缓动功能。
 * @class  Tween
 * @param {Object} target 缓动对象。
 * @param {Object} fromProps 对象缓动的起始属性集合。
 * @param {Object} toProps 对象缓动的目标属性集合。
 * @param {TweenParams} params 缓动参数。可包含Tween类所有可写属性。
 * @property {Object} target 缓动目标。只读属性。
 * @property {Number} duration 缓动总时长。单位毫秒。
 * @property {Number} delay 缓动延迟时间。单位毫秒。
 * @property {Boolean} paused 缓动是否暂停。默认为false。
 * @property {Boolean} loop 缓动是否循环。默认为false。
 * @property {Boolean} reverse 缓动是否反转播放。默认为false。
 * @property {Number} repeat 缓动重复的次数。默认为0。
 * @property {Number} repeatDelay 缓动重复的延迟时长。单位为毫秒。
 * @property {Function} ease 缓动变化函数。默认为null。
 * @property {Number} time 缓动已进行的时长。单位毫秒。只读属性。
 * @property {Function} onStart 缓动开始回调函数。它接受1个参数：tween。默认值为null。
 * @property {Function} onUpdate 缓动更新回调函数。它接受2个参数：ratio和tween。默认值为null。
 * @property {Function} onComplete 缓动结束回调函数。它接受1个参数：tween。默认值为null。
 * @see {@link https://hiloteam.github.io/Hilo/docs/api-zh/symbols/Tween.html}
 * @example
 * Hilo.Tween.to(node, {
 *     x:100,
 *     y:20
 * }, {
 *     duration:1000,
 *     delay:500,
 *     ease:Hilo3d.Tween.Ease.Quad.EaseIn,
 *     onComplete:function(){
 *         console.log('complete');
 *     }
 * });
 */


/**
 * Ease类包含为Tween类提供各种缓动功能的函数。
 * @memberOf Tween
 * @property {TweenEaseObject} Back
 * @property {TweenEaseObject} Bounce
 * @property {TweenEaseObject} Circ
 * @property {TweenEaseObject} Cubic
 * @property {TweenEaseObject} Elastic
 * @property {TweenEaseObject} Expo
 * @property {TweenEaseObject} Linear
 * @property {TweenEaseObject} Quad
 * @property {TweenEaseObject} Quart
 * @property {TweenEaseObject} Quint
 * @property {TweenEaseObject} Sine
 * @see  {@link https://hiloteam.github.io/Hilo/docs/api-zh/symbols/Ease.html}
 */

Tween_default.a.Ease = Ease_default.a;
/* harmony default export */ var core_Tween = (Tween_default.a);
/**
 * 长方体几何体
 * @class
 * @extends Geometry
 */

var BoxGeometry = core_Class.create(
/** @lends BoxGeometry.prototype */
{
  Extends: geometry_Geometry,

  /**
   * @default true
   * @type {boolean}
   */
  isBoxGeometry: true,

  /**
   * @default BoxGeometry
   * @type {string}
   */
  className: 'BoxGeometry',

  /**
   * box的宽度
   * @default 1
   * @type {number}
   */
  width: 1,

  /**
   * box的高度
   * @default 1
   * @type {number}
   */
  height: 1,

  /**
   * box的深度
   * @default 1
   * @type {number}
   */
  depth: 1,

  /**
   * 水平分割面的数量
   * @default 1
   * @type {number}
   */
  widthSegments: 1,

  /**
   * 垂直分割面的数量
   * @default 1
   * @type {number}
   */
  heightSegments: 1,

  /**
   * 深度分割面的数量
   * @default 1
   * @type {number}
   */
  depthSegments: 1,

  /**
   * @constructs
   * @param {object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    BoxGeometry.superclass.constructor.call(this, params);

    if (this.isSegments()) {
      this.buildWithSegments();
    } else {
      this.build();
    }
  },
  buildWithSegments: function buildWithSegments() {
    var width = this.width,
        height = this.height,
        depth = this.depth,
        widthSegments = this.widthSegments,
        heightSegments = this.heightSegments,
        depthSegments = this.depthSegments;
    var xVertexCount = (heightSegments + 1) * (depthSegments + 1);
    var yVertexCount = (widthSegments + 1) * (depthSegments + 1);
    var zVertexCount = (widthSegments + 1) * (heightSegments + 1);
    var xIndexCount = heightSegments * depthSegments * 6;
    var yIndexCount = widthSegments * depthSegments * 6;
    var zIndexCount = widthSegments * heightSegments * 6;
    var verticesCount = (xVertexCount + yVertexCount + zVertexCount) * 2;
    var vertices = new Float32Array(verticesCount * 3);
    var normals = new Float32Array(verticesCount * 3);
    var uvs = new Float32Array(verticesCount * 2);
    var indices = new Uint16Array((xIndexCount + yIndexCount + zIndexCount) * 2);
    this.vertices = new geometry_GeometryData(vertices, 3);
    this.normals = new geometry_GeometryData(normals, 3);
    this.uvs = new geometry_GeometryData(uvs, 2);
    this.indices = new geometry_GeometryData(indices, 1);
    var idxInfo = [0, 0]; // x right

    this.buildPlane(idxInfo, 2, 1, 0, -1, 1, depth, height, width / 2, depthSegments, heightSegments); // -x left

    this.buildPlane(idxInfo, 2, 1, 0, 1, 1, depth, height, -width / 2, depthSegments, heightSegments); // y top

    this.buildPlane(idxInfo, 0, 2, 1, 1, -1, width, depth, height / 2, widthSegments, depthSegments); // -y bottom

    this.buildPlane(idxInfo, 0, 2, 1, 1, 1, width, depth, -height / 2, widthSegments, depthSegments); // z front

    this.buildPlane(idxInfo, 0, 1, 2, 1, 1, width, height, depth / 2, widthSegments, heightSegments); // -z back

    this.buildPlane(idxInfo, 0, 1, 2, -1, 1, width, height, -depth / 2, widthSegments, heightSegments);
  },
  buildPlane: function buildPlane(idxInfo, u, v, w, uDir, vDir, uLength, vLength, wValue, uSegments, vSegments) {
    var uDiff = uLength / uSegments;
    var vDiff = vLength / vSegments;
    var uHalf = uLength / 2;
    var vHalf = vLength / 2;
    var idx = idxInfo[0];
    var currentIndicesIdx = idxInfo[1];
    var vertices = this.vertices.data;
    var normals = this.normals.data;
    var uvs = this.uvs.data;
    var indices = this.indices.data;

    for (var vi = 0; vi <= vSegments; vi++) {
      var vValue = (vi * vDiff - vHalf) * vDir;

      for (var ui = 0; ui <= uSegments; ui++) {
        vertices[idx * 3 + u] = (ui * uDiff - uHalf) * uDir;
        vertices[idx * 3 + v] = vValue;
        vertices[idx * 3 + w] = wValue;
        normals[idx * 3 + u] = 0;
        normals[idx * 3 + v] = 0;
        normals[idx * 3 + w] = wValue < 0 ? -1 : 1;
        uvs[idx * 2] = ui / uSegments;
        uvs[idx * 2 + 1] = 1 - vi / vSegments;

        if (ui < uSegments && vi < vSegments) {
          var lb = idxInfo[0] + (vi + 1) * (uSegments + 1) + ui;
          indices[currentIndicesIdx++] = lb;
          indices[currentIndicesIdx++] = idx;
          indices[currentIndicesIdx++] = lb + 1;
          indices[currentIndicesIdx++] = lb + 1;
          indices[currentIndicesIdx++] = idx;
          indices[currentIndicesIdx++] = idx + 1;
        }

        idx++;
      }
    }

    idxInfo[0] = idx;
    idxInfo[1] = currentIndicesIdx;
  },
  build: function build() {
    var vertices = new Float32Array(72);
    var indices = new Uint16Array(36);
    this.vertices = new geometry_GeometryData(vertices, 3);
    this.indices = new geometry_GeometryData(indices, 1);
    var halfWidth = this.width / 2;
    var halfHeight = this.height / 2;
    var halfDepth = this.depth / 2;
    var p1 = [-halfWidth, -halfHeight, -halfDepth];
    var p2 = [halfWidth, -halfHeight, -halfDepth];
    var p3 = [halfWidth, halfHeight, -halfDepth];
    var p4 = [-halfWidth, halfHeight, -halfDepth];
    var p5 = [-halfWidth, -halfHeight, halfDepth];
    var p6 = [halfWidth, -halfHeight, halfDepth];
    var p7 = [halfWidth, halfHeight, halfDepth];
    var p8 = [-halfWidth, halfHeight, halfDepth];
    this.addRect(p6, p2, p3, p7); // right

    this.addRect(p1, p5, p8, p4); // left

    this.addRect(p8, p7, p3, p4); // top

    this.addRect(p1, p2, p6, p5); // bottom

    this.addRect(p5, p6, p7, p8); // front

    this.addRect(p2, p1, p4, p3); // back
  },
  isSegments: function isSegments() {
    return this.widthSegments > 1 || this.heightSegments > 1 || this.depthSegments > 1;
  },

  /**
   * 设置朝前面的uv，不支持设置带有 widthSegments heightSegments depthSegments 的实例
   * @param {number[][]} uv uv数据，如 [[0, 1], [1, 1], [1, 0], [0, 0]]
   */
  setFrontUV: function setFrontUV(uv) {
    if (this.isSegments()) {
      utils_log.warn('segmented BoxGeometry dont support setFrontUV!');
      return;
    }

    this.setVertexUV(32, uv);
  },

  /**
   * 设置右侧面的uv，不支持设置带有 widthSegments heightSegments depthSegments 的实例
   * @param {number[][]} uv uv数据，如 [[0, 1], [1, 1], [1, 0], [0, 0]]
   */
  setRightUV: function setRightUV(uv) {
    if (this.isSegments()) {
      utils_log.warn('segmented BoxGeometry dont support setRightUV!');
      return;
    }

    this.setVertexUV(0, uv);
  },

  /**
   * 设置朝后面的uv，不支持设置带有 widthSegments heightSegments depthSegments 的实例
   * @param {number[][]} uv uv数据，如 [[0, 1], [1, 1], [1, 0], [0, 0]]
   */
  setBackUV: function setBackUV(uv) {
    if (this.isSegments()) {
      utils_log.warn('segmented BoxGeometry dont support setBackUV!');
      return;
    }

    this.setVertexUV(40, uv);
  },

  /**
   * 设置左侧面的uv，不支持设置带有 widthSegments heightSegments depthSegments 的实例
   * @param {number[][]} uv uv数据，如 [[0, 1], [1, 1], [1, 0], [0, 0]]
   */
  setLeftUV: function setLeftUV(uv) {
    if (this.isSegments()) {
      utils_log.warn('segmented BoxGeometry dont support setLeftUV!');
      return;
    }

    this.setVertexUV(8, uv);
  },

  /**
   * 设置顶部面的uv，不支持设置带有 widthSegments heightSegments depthSegments 的实例
   * @param {number[][]} uv uv数据，如 [[0, 1], [1, 1], [1, 0], [0, 0]]
   */
  setTopUV: function setTopUV(uv) {
    if (this.isSegments()) {
      utils_log.warn('segmented BoxGeometry dont support setTopUV!');
      return;
    }

    this.setVertexUV(16, uv);
  },

  /**
   * 设置底部面的uv，不支持设置带有 widthSegments heightSegments depthSegments 的实例
   * @param {number[][]} uv uv数据，如 [[0, 1], [1, 1], [1, 0], [0, 0]]
   */
  setBottomUV: function setBottomUV(uv) {
    if (this.isSegments()) {
      utils_log.warn('segmented BoxGeometry dont support setBottomUV!');
      return;
    }

    this.setVertexUV(24, uv);
  },

  /**
   * 设置所有面的uv，不支持设置带有 widthSegments heightSegments depthSegments 的实例
   * @param {number[][][]} uv uv数据，如
   * [<br>
   *     [[0, 1], [1, 1], [1, 0], [0, 0]],<br>
   *     [[0, 1], [1, 1], [1, 0], [0, 0]],<br>
   *     [[0, 1], [1, 1], [1, 0], [0, 0]],<br>
   *     [[0, 1], [1, 1], [1, 0], [0, 0]],<br>
   *     [[0, 1], [1, 1], [1, 0], [0, 0]],<br>
   *     [[0, 1], [1, 1], [1, 0], [0, 0]]<br>
   * ]
   */
  setAllRectUV: function setAllRectUV(uv) {
    if (this.isSegments()) {
      utils_log.warn('segmented BoxGeometry dont support setAllRectUV!');
      return null;
    }

    for (var i = 0; i < 6; i++) {
      this.setVertexUV(i * 8, uv);
    }

    return this;
  },
  _raycast: function _raycast(ray, side) {
    // TODO:optimize
    return BoxGeometry.superclass._raycast.call(this, ray, side);
  }
});
/* harmony default export */ var geometry_BoxGeometry = (BoxGeometry);
// CONCATENATED MODULE: ./src/geometry/PlaneGeometry.js




var PlaneGeometry_FRONT = src_constants.FRONT,
    PlaneGeometry_BACK = src_constants.BACK;
var normalData = [0, 0, 1];
/**
 * 平面几何体
 * @class
 * @extends Geometry
 */

var PlaneGeometry = core_Class.create(
/** @lends PlaneGeometry.prototype */
{
  Extends: geometry_Geometry,

  /**
   * @default true
   * @type {boolean}
   */
  isPlaneGeometry: true,

  /**
   * @default PlaneGeometry
   * @type {string}
   */
  className: 'PlaneGeometry',

  /**
   * 宽度
   * @default 1
   * @type {number}
   */
  width: 1,

  /**
   * 高度
   * @default 1
   * @type {number}
   */
  height: 1,

  /**
   * 水平分割面的数量
   * @default 1
   * @type {number}
   */
  widthSegments: 1,

  /**
   * 垂直分割面的数量
   * @default 1
   * @type {number}
   */
  heightSegments: 1,

  /**
   * @constructs
   * @param {object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    PlaneGeometry.superclass.constructor.call(this, params);
    this.build();
  },
  build: function build() {
    var widthSegments = this.widthSegments,
        heightSegments = this.heightSegments;
    var count = (widthSegments + 1) * (heightSegments + 1);
    var diffW = this.width / widthSegments;
    var diffH = this.height / heightSegments;
    var vertices = new Float32Array(count * 3);
    var normals = new Float32Array(count * 3);
    var uvs = new Float32Array(count * 2);
    var indices = new Uint16Array(widthSegments * heightSegments * 6);
    var indicesIdx = 0;

    for (var h = 0; h <= heightSegments; h++) {
      for (var w = 0; w <= widthSegments; w++) {
        var idx = h * (widthSegments + 1) + w;
        vertices[idx * 3] = w * diffW - this.width / 2;
        vertices[idx * 3 + 1] = this.height / 2 - h * diffH;
        normals[idx * 3] = 0;
        normals[idx * 3 + 1] = 0;
        normals[idx * 3 + 2] = 1;
        uvs[idx * 2] = w / widthSegments;
        uvs[idx * 2 + 1] = 1 - h / heightSegments;

        if (h < heightSegments && w < widthSegments) {
          var lb = (h + 1) * (widthSegments + 1) + w;
          indices[indicesIdx++] = idx;
          indices[indicesIdx++] = lb;
          indices[indicesIdx++] = lb + 1;
          indices[indicesIdx++] = idx;
          indices[indicesIdx++] = lb + 1;
          indices[indicesIdx++] = idx + 1;
        }
      }
    }

    this.vertices = new geometry_GeometryData(vertices, 3);
    this.indices = new geometry_GeometryData(indices, 1);
    this.normals = new geometry_GeometryData(normals, 3);
    this.uvs = new geometry_GeometryData(uvs, 2);
  },
  _raycast: function _raycast(ray, side) {
    var originZ = ray.origin.z;
    var directionZ = ray.direction.z;

    if (side === PlaneGeometry_FRONT && (directionZ > 0 || originZ < 0)) {
      return null;
    }

    if (side === PlaneGeometry_BACK && (directionZ < 0 || originZ > 0)) {
      return null;
    }

    var point = ray.intersectsPlane(normalData, 0);

    if (point) {
      var x = point.x;
      var y = point.y;
      var halfWidth = this.width * .5;
      var halfHeight = this.height * .5;

      if (x >= -halfWidth && x <= halfWidth && y >= -halfHeight && y <= halfHeight) {
        return [point];
      }
    }

    return null;
  }
});
/* harmony default export */ var geometry_PlaneGeometry = (PlaneGeometry);

/**
 * 球形几何体
 * @class
 * @extends Geometry
 */

var SphereGeometry = core_Class.create(
/** @lends SphereGeometry.prototype */
{
  Extends: geometry_Geometry,

  /**
   * @default true
   * @type {boolean}
   */
  isSphereGeometry: true,

  /**
   * @default SphereGeometry
   * @type {string}
   */
  className: 'SphereGeometry',

  /**
   * 半径
   * @default 1
   * @type {number}
   */
  radius: 1,

  /**
   * 垂直分割面的数量
   * @default 16
   * @type {number}
   */
  heightSegments: 16,

  /**
   * 水平分割面的数量
   * @default 32
   * @type {number}
   */
  widthSegments: 32,

  /**
   * @constructs
   * @param {object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    SphereGeometry.superclass.constructor.call(this, params);
    this.build();
  },
  build: function build() {
    var radius = this.radius;
    var heightSegments = this.heightSegments;
    var widthSegments = this.widthSegments;
    var count = (widthSegments + 1) * (heightSegments + 1);
    var gridCount = widthSegments * heightSegments;
    var vertices = new Float32Array(count * 3);
    var tangents = new Float32Array(count * 4);
    var uvs = new Float32Array(count * 2);
    var indices = new Uint16Array(gridCount * 6);
    var indexId = 0;
    var vertexId = 0;
    var tangentId = 0;
    var uvId = 0;
    var pointId = 0;
    var ANGLE_360 = Math.PI * 2;
    var ANGLE_180 = Math.PI;

    for (var h = 0; h <= heightSegments; h++) {
      var v = h / heightSegments;
      var pitchAngle = ANGLE_180 * v;
      var y = Math.cos(pitchAngle) * radius;
      var yawRadius = Math.sin(pitchAngle) * radius;

      for (var w = 0; w <= widthSegments; w++) {
        var u = w / widthSegments;
        var yawAngle = ANGLE_360 * u;
        var yawCos = Math.cos(yawAngle);
        var yawSin = Math.sin(yawAngle);
        var x = yawCos * yawRadius;
        var z = yawSin * yawRadius;
        var tangentX = yawSin;
        var tangentY = 0;
        var tangentZ = -yawCos;
        tangents[tangentId++] = tangentX;
        tangents[tangentId++] = tangentY;
        tangents[tangentId++] = tangentZ;
        tangents[tangentId++] = 1;
        vertices[vertexId++] = x;
        vertices[vertexId++] = y;
        vertices[vertexId++] = z;
        uvs[uvId++] = u;
        uvs[uvId++] = v;

        if (h > 0 && w > 0) {
          var a = pointId;
          var b = a - 1;
          var c = b - widthSegments - 1;
          var d = a - widthSegments - 1;
          indices[indexId++] = c;
          indices[indexId++] = d;
          indices[indexId++] = a;
          indices[indexId++] = c;
          indices[indexId++] = a;
          indices[indexId++] = b;
        }

        pointId++;
      }
    }

    this.vertices = new geometry_GeometryData(vertices, 3);
    this.indices = new geometry_GeometryData(indices, 1);
    this.uvs = new geometry_GeometryData(uvs, 2);
    this.tangents = new geometry_GeometryData(tangents, 4);
    this.normals = new geometry_GeometryData(new Float32Array(vertices), 3);
  },
  _raycast: function _raycast(ray, side) {
    // TODO:optimize
    return SphereGeometry.superclass._raycast.call(this, ray, side);
  }
});
/* harmony default export */ var geometry_SphereGeometry = (SphereGeometry);
// CONCATENATED MODULE: ./src/renderer/logGLResource.js






var resourceList = [shader_Shader, renderer_Program, renderer_Buffer, renderer_VertexArrayObject, texture_Texture];

var logGLResource_logGLResource = function logGLResource() {
  var msg = '';
  resourceList.forEach(function (ResourceClass) {
    msg += "".concat(ResourceClass.prototype.className, ":").concat(Object.keys(ResourceClass.cache._cache).length, " ");
  });
  utils_log.log(msg);
};

/* harmony default export */ var renderer_logGLResource = (logGLResource_logGLResource);
// CONCATENATED MODULE: ./src/loader/LoadCache.js


/**
 * 加载缓存类
 * @class
 * @mixes EventMixin
 * @fires update 更新事件
 * @ignore
 */

var LoadCache = core_Class.create(
/** @lends LoadCache.prototype */
{
  Mixes: core_EventMixin,

  /**
   * @default true
   * @type {Boolean}
   */
  isLoadCache: true,

  /**
   * @default LoadCache
   * @type {String}
   */
  className: 'LoadCache',
  Statics: {
    PENDING: 1,
    LOADED: 2,
    FAILED: 3
  },
  enabled: true,

  /**
   * @constructs
   */
  constructor: function constructor() {
    this._files = {};
  },
  update: function update(key, state, data) {
    if (!this.enabled) {
      return;
    }

    var file = {
      key: key,
      state: state,
      data: data
    };
    this._files[key] = file;
    this.fire('update', file);
    this.fire("update:".concat(file.key), file);
  },
  get: function get(key) {
    if (!this.enabled) {
      return null;
    }

    return this._files[key];
  },
  remove: function remove(key) {
    delete this._files[key];
  },
  clear: function clear() {
    this._files = {};
  },
  wait: function wait(file) {
    var _this = this;

    if (!file) {
      return Promise.reject();
    }

    if (file.state === LoadCache.LOADED) {
      return Promise.resolve(file.data);
    }

    if (file.state === LoadCache.FAILED) {
      return Promise.reject();
    }

    return new Promise(function (resolve, reject) {
      _this.on("update:".concat(file.key), function (evt) {
        var file = evt.detail;

        if (file.state === LoadCache.LOADED) {
          resolve(file.data);
        } else if (file.state === LoadCache.FAILED) {
          reject(file.data);
        }
      }, true);
    });
  }
});
/* harmony default export */ var loader_LoadCache = (LoadCache);
// CONCATENATED MODULE: ./src/loader/BasicLoader.js





var BasicLoader_cache = new loader_LoadCache();
/**
 * 基础的资源加载类
 * @class
 * @fires beforeload loaded failed
 * @mixes EventMixin
 * @borrows EventMixin#on as #on
 * @borrows EventMixin#off as #off
 * @borrows EventMixin#fire as #fire
 * @fires beforeload 加载前事件
 * @fires loaded 加载事件
 * @fires failed 失败事件
 * @fires progress 进度事件
 * @example
 * var loader = new Hilo3d.BasicLoader();
 * loader.load({
 *     src: '//img.alicdn.com/tfs/TB1aNxtQpXXXXX1XVXXXXXXXXXX-1024-1024.jpg',
 *     crossOrigin: true
 * }).then(img => {
 *     return new Hilo3d.Texture({
 *         image: img
 *     });
 * }, err => {
 *     return new Hilo3d.Color(1, 0, 0);
 * }).then(diffuse => {
 *     return new Hilo3d.BasicMaterial({
 *         diffuse: diffuse
 *     });
 * });
 */

var BasicLoader = core_Class.create(
/** @lends BasicLoader.prototype */
{
  Mixes: core_EventMixin,

  /**
   * @default true
   * @type {boolean}
   */
  isBasicLoader: true,

  /**
   * @default BasicLoader
   * @type {string}
   */
  className: 'BasicLoader',
  Statics: {
    _cache: BasicLoader_cache,
    enalbeCache: function enalbeCache() {
      BasicLoader_cache.enabled = true;
    },
    disableCache: function disableCache() {
      BasicLoader_cache.enabled = false;
    },
    deleteCache: function deleteCache(key) {
      BasicLoader_cache.remove(key);
    },
    clearCache: function clearCache() {
      BasicLoader_cache.clear();
    },
    cache: {
      get: function get() {
        return BasicLoader_cache;
      },
      set: function set() {
        utils_log.warn('BasicLoader.cache is readonly!');
      }
    }
  },

  /**
   * 加载资源，这里会自动调用 loadImg 或者 loadRes
   * @param {object} data 参数
   * @param {string} data.src 资源地址
   * @param {string} [data.type] 资源类型(img, json, buffer)，不提供将根据 data.src 来判断类型
   * @return {Promise.<any, Error>} 返回加载完的资源对象
   */
  load: function load(data) {
    var src = data.src;
    var type = data.type;

    if (!type) {
      var ext = getExtension(src);

      if (/^(?:png|jpe?g|gif|webp|bmp)$/i.test(ext)) {
        type = 'img';
      }

      if (!type) {
        type = data.defaultType;
      }
    }

    if (type === 'img') {
      return this.loadImg(src, data.crossOrigin);
    }

    return this.loadRes(src, type);
  },

  /**
   * 判断链接是否跨域，无法处理二级域名，及修改 document.domain 的情况
   * @param {string} url 需要判断的链接
   * @return {boolean} 是否跨域
   */
  isCrossOrigin: function isCrossOrigin(url) {
    var loc = window.location;
    var a = document.createElement('a');
    a.href = url;
    return a.hostname !== loc.hostname || a.port !== loc.port || a.protocol !== loc.protocol;
  },
  isBase64: function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
  },
  Uint8ArrayFrom: function Uint8ArrayFrom(source, mapFn) {
    if (Uint8Array.from) {
      return Uint8Array.from(source, mapFn);
    }

    var len = source.length;
    var result = new Uint8Array(len);

    for (var i = 0; i < len; i++) {
      result[i] = mapFn(source[i]);
    }

    return result;
  },

  /**
   * 加载图片
   * @param {string} url 图片地址
   * @param {boolean} [crossOrigin=false] 是否跨域
   * @return {Promise.<HTMLImageElement, Error>} 返回加载完的图片
   */
  loadImg: function loadImg(url, crossOrigin) {
    var _this = this;

    var file = BasicLoader_cache.get(url);

    if (file) {
      return BasicLoader_cache.wait(file);
    }

    return new Promise(function (resolve, reject) {
      var img = new Image();
      BasicLoader_cache.update(url, loader_LoadCache.PENDING);

      img.onload = function () {
        img.onerror = null;
        img.onabort = null;
        img.onload = null;
        BasicLoader_cache.update(url, loader_LoadCache.LOADED, img);
        resolve(img);
      };

      img.onerror = function () {
        img.onerror = null;
        img.onabort = null;
        img.onload = null;
        var err = new Error("Image load failed for ".concat(url.slice(0, 100)));
        BasicLoader_cache.update(url, loader_LoadCache.FAILED, err);
        reject(err);
      };

      img.onabort = img.onerror;

      if (crossOrigin || _this.isCrossOrigin(url)) {
        if (!_this.isBase64(url)) {
          img.crossOrigin = 'anonymous';
        }
      }

      img.src = url;
    });
  },

  /**
   * 使用XHR加载其他资源
   * @param {string} url 资源地址
   * @param {string} [type=text] 资源类型(json, buffer, text)
   * @return {Promise.<Object, Error>} 返回加载完的内容对象(Object, ArrayBuffer, String)
   */
  loadRes: function loadRes(url, type) {
    var _this2 = this;

    if (this.isBase64(url)) {
      var mime = RegExp.$1;
      var base64Str = url.slice(13 + mime.length);
      var result = atob(base64Str);

      if (type === 'json') {
        result = JSON.parse(result);
      } else if (type === 'buffer') {
        result = this.Uint8ArrayFrom(result, function (c) {
          return c.charCodeAt(0);
        }).buffer;
      }

      return Promise.resolve(result);
    }

    var file = BasicLoader_cache.get(url);

    if (file) {
      return BasicLoader_cache.wait(file);
    }

    BasicLoader_cache.update(url, loader_LoadCache.PENDING);
    this.fire('beforeload');
    return this.request({
      url: url,
      type: type
    }).then(function (data) {
      _this2.fire('loaded');

      BasicLoader_cache.update(url, loader_LoadCache.LOADED, data);
      return data;
    }, function (err) {
      _this2.fire('failed', err);

      BasicLoader_cache.update(url, loader_LoadCache.FAILED);
      throw new Error("Resource load failed for ".concat(url, ", ").concat(err));
    });
  },

  /**
   * XHR资源请求
   * @param {object} opt 请求参数
   * @param {string} opt.url 资源地址
   * @param {string} [opt.type=text] 资源类型(json, buffer, text)
   * @param {string} [opt.method=GET] 请求类型(GET, POST ..)
   * @param {object} [opt.headers] 请求头参数
   * @param {string} [opt.body] POST请求发送的数据
   * @return {Promise.<Object, Error>} 返回加载完的内容对象(Object, ArrayBuffer, String)
   */
  request: function request(opt) {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      var xhr = new XMLHttpRequest();

      xhr.onload = function () {
        if (xhr.status < 200 || xhr.status >= 300) {
          reject(new TypeError("Network request failed for ".concat(xhr.status)));
          return;
        }

        var result = 'response' in xhr ? xhr.response : xhr.responseText;

        if (opt.type === 'json') {
          try {
            result = JSON.parse(result);
          } catch (err) {
            reject(new TypeError('JSON.parse error' + err));
            return;
          }
        }

        resolve(result);
      };

      xhr.onprogress = function (evt) {
        _this3.fire('progress', {
          url: opt.url,
          loaded: evt.loaded,
          total: evt.total
        });
      };

      xhr.onerror = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function () {
        reject(new TypeError('Network request timed out'));
      };

      xhr.open(opt.method || 'GET', opt.url, true);

      if (opt.credentials === 'include') {
        xhr.withCredentials = true;
      }

      if (opt.type === 'buffer') {
        xhr.responseType = 'arraybuffer';
      }

      util_each(opt.headers, function (value, name) {
        xhr.setRequestHeader(name, value);
      });
      xhr.send(opt.body || null);
    });
  }
});
/* harmony default export */ var loader_BasicLoader = (BasicLoader);
// CONCATENATED MODULE: ./src/loader/Loader.js



/**
 * @class
 */

var Loader = core_Class.create(
/** @lends Loader.prototype */
{
  /**
   * @default true
   * @type {boolean}
   */
  isLoader: true,

  /**
   * @default Loader
   * @type {string}
   */
  className: 'Loader',
  maxConnections: 2,
  Statics: {
    _loaderClassMap: {},
    _loaders: {},

    /**
     * 给Loader类添加扩展Loader
     * @memberOf Loader
     * @static
     * @param {string} ext 资源扩展，如gltf, png 等
     * @param {BasicLoader} LoaderClass 用于加载的类，需要继承BasicLoader
     */
    addLoader: function addLoader(ext, LoaderClass) {
      Loader._loaderClassMap[ext] = LoaderClass;
    },
    getLoader: function getLoader(ext) {
      if (!Loader._loaders[ext]) {
        var LoaderClass = Loader._loaderClassMap[ext] ? Loader._loaderClassMap[ext] : loader_BasicLoader;
        Loader._loaders[ext] = new LoaderClass();
      }

      return Loader._loaders[ext];
    }
  },

  /**
   * load
   * @param  {Object|Array} data
   * @return {Promise<any>}
   */
  load: function load(data) {
    var _this = this;

    if (data instanceof Array) {
      return Promise.all(data.map(function (d) {
        return _this.load(d);
      }));
    }

    var type = data.type || getExtension(data.src);
    var loader = Loader.getLoader(type);
    return loader.load(data);
  }
});
/* harmony default export */ var loader_Loader = (Loader);
// CONCATENATED MODULE: ./src/loader/CubeTextureLoader.js





/**
 * CubeTexture加载类
 * @class
 * @extends {BasicLoader}
 * @example
 * var loader = new Hilo3d.CubeTextureLoader();
 * loader.load({
 *     crossOrigin: true,
 *     images: [
 *         '//gw.alicdn.com/tfs/TB1Ss.ORpXXXXcNXVXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1YhUDRpXXXXcyaXXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1Y1MORpXXXXcpXVXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1ZgAqRpXXXXa0aFXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1IVZNRpXXXXaNXFXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1M3gyRpXXXXb9apXXXXXXXXXX-2048-2048.jpg_960x960.jpg'
 *     ]
 * }).then(function (skybox) {
 *     var material = new Hilo3d.BasicMaterial({
 *         diffuse: skybox
 *     });
 *     ...
 * });
 */

var CubeTextureLoader = core_Class.create(
/** @lends CubeTextureLoader.prototype */
{
  Extends: loader_BasicLoader,

  /**
   * @default true
   * @type {boolean}
   */
  isCubeTextureLoader: true,

  /**
   * @default CubeTextureLoader
   * @type {string}
   */
  className: 'CubeTextureLoader',

  /**
   * @constructs
   */
  constructor: function constructor() {
    CubeTextureLoader.superclass.constructor.call(this);
  },

  /**
   * 加载CubeTexture
   * @param {object} params 加载参数
   * @param {boolean} params.crossOrigin 是否跨域，不传将自动判断
   * @param {Array.<string>} params.images 纹理图片地址数组，顺序为 right, left, top, bottom, front, back
   * @param {string} params.right 右面的图片地址
   * @param {string} params.left 左面的图片地址
   * @param {string} params.top 上面的图片地址
   * @param {string} params.bottom 下面的图片地址
   * @param {string} params.front 前面的图片地址
   * @param {string} params.back 背面的图片地址
   * @async
   * @return {Promise<CubeTexture, Error>} 返回加载完的CubeTexture对象
   */
  load: function load(params) {
    var _this = this;

    var images;

    if (params.images && Array.isArray(params.images)) {
      images = params.images;
    } else {
      images = [params.right, params.left, params.top, params.bottom, params.front, params.back];
    }

    return Promise.all(images.map(function (img) {
      return _this.loadImg(img, params.crossOrigin);
    })).then(function (images) {
      var args = Object.assign({}, params);
      delete args.images;
      delete args.type;
      delete args.right;
      delete args.left;
      delete args.top;
      delete args.bottom;
      delete args.front;
      delete args.back;
      args.image = images;
      return new texture_CubeTexture(args);
    })["catch"](function (err) {
      utils_log.error('load CubeTexture failed', err.message, err.stack);
      throw err;
    });
  }
});
loader_Loader.addLoader('CubeTexture', CubeTextureLoader);
/* harmony default export */ var loader_CubeTextureLoader = (CubeTextureLoader);
// CONCATENATED MODULE: ./src/material/PBRMaterial.js




/**
 * PBR材质
 * @class
 * @extends Material
 * @example
 * const material = new Hilo3d.PBRMaterial();
 */

var PBRMaterial = core_Class.create(
/** @lends PBRMaterial.prototype */
{
  Extends: material_Material,

  /**
   * @default true
   * @type {boolean}
   */
  isPBRMaterial: true,

  /**
   * @default PBRMaterial
   * @type {string}
   */
  className: 'PBRMaterial',

  /**
   * 光照类型，只能为 PBR
   * @default PBR
   * @readOnly
   * @type {string}
   */
  lightType: 'PBR',

  /**
   * gammaCorrection
   * @type {Boolean}
   * @default true
   */
  gammaCorrection: true,

  /**
   * 是否使用物理灯光
   * @type {Boolean}
   * @default true
   */
  usePhysicsLight: true,

  /**
   * 基础颜色
   * @default null
   * @type {Color}
   */
  baseColor: null,

  /**
   * 基础颜色贴图(sRGB空间)
   * @default null
   * @type {Texture}
   */
  baseColorMap: null,

  /**
   * 金属度
   * @default 1
   * @type {Number}
   */
  metallic: 1,

  /**
   * 金属度贴图
   * @default null
   * @type {Texture}
   */
  metallicMap: null,

  /**
   * 粗糙度
   * @default 1
   * @type {Number}
   */
  roughness: 1,

  /**
   * 粗糙度贴图
   * @default null
   * @type {Texture}
   */
  roughnessMap: null,

  /**
   * 金属度及粗糙度贴图，金属度为B通道，粗糙度为G通道，可以指定R通道作为环境光遮蔽
   * @default null
   * @type {Texture}
   */
  metallicRoughnessMap: null,

  /**
   * 环境光遮蔽贴图
   * @default null
   * @type {Texture}
   */
  occlusionMap: null,

  /**
   * 环境光遮蔽强度
   * @default 1
   * @type {Number}
   */
  occlusionStrength: 1,

  /**
   * 环境光遮蔽贴图(occlusionMap)包含在 metallicRoughnessMap 的R通道中
   * @default false
   * @type {boolean}
   */
  isOcclusionInMetallicRoughnessMap: false,

  /**
   * 漫反射辐照(Diffuse IBL)贴图
   * @default null
   * @type {CubeTexture|Texture}
   */
  diffuseEnvMap: null,

  /**
   * 漫反射 SphericalHarmonics3
   * @type {SphericalHarmonics3}
   */
  diffuseEnvSphereHarmonics3: null,

  /**
   * 漫反射环境强度
   * @default 1
   * @type {Number}
   */
  diffuseEnvIntensity: 1,

  /**
   * BRDF贴图，跟环境反射贴图一起使用 [示例]{@link https://gw.alicdn.com/tfs/TB1EvwBRFXXXXbNXpXXXXXXXXXX-256-256.png}
   * @default null
   * @type {Texture}
   */
  brdfLUT: null,

  /**
   * 环境反射(Specular IBL)贴图
   * @default 1
   * @type {Number}
   */
  specularEnvIntensity: 1,

  /**
   * 环境反射(Specular IBL)贴图
   * @default null
   * @type {CubeTexture|Texture}
   */
  specularEnvMap: null,

  /**
   * 放射光贴图(sRGB 空间)，或颜色
   * @default Color(0, 0, 0)
   * @type {Texture|Color}
   */
  emission: null,

  /**
   * 是否基于反射光泽度的 PBR，具体见 [KHR_materials_pbrSpecularGlossiness]{@link https://github.com/KhronosGroup/glTF/tree/master/extensions/Khronos/KHR_materials_pbrSpecularGlossiness}
   * @default false
   * @type {boolean}
   */
  isSpecularGlossiness: false,

  /**
   * 镜面反射率，针对 isSpecularGlossiness 渲染
   * @default Color(1, 1, 1)
   * @type {Color}
   */
  specular: null,

  /**
   * 光泽度，针对 isSpecularGlossiness 渲染，默认PBR无效
   * @default 1
   * @type {number}
   */
  glossiness: 1,

  /**
   * 镜面反射即光泽度贴图，RGB 通道为镜面反射率，A 通道为光泽度
   * @default null
   * @type {Texture}
   */
  specularGlossinessMap: null,
  usedUniformVectors: 11,

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   */
  constructor: function constructor(params) {
    this.baseColor = new math_Color(1, 1, 1);
    this.specular = new math_Color(1, 1, 1);
    PBRMaterial.superclass.constructor.call(this, params);
    Object.assign(this.uniforms, {
      u_baseColor: 'BASECOLOR',
      u_metallic: 'METALLIC',
      u_roughness: 'ROUGHNESS',
      u_specular: 'SPECULAR',
      u_glossiness: 'GLOSSINESS',
      u_brdfLUT: 'BRDFLUT',
      u_diffuseEnvMap: 'DIFFUSEENVMAP',
      u_diffuseEnvIntensity: 'DIFFUSEENVINTENSITY',
      u_occlusionStrength: 'OCCLUSIONSTRENGTH',
      u_specularEnvMap: 'SPECULARENVMAP',
      u_specularEnvIntensity: 'SPECULARENVINTENSITY',
      u_specularEnvMapMipCount: 'SPECULARENVMAPMIPCOUNT',
      u_diffuseEnvSphereHarmonics3: 'DIFFUSEENVSPHEREHARMONICS3'
    });
    this.addTextureUniforms({
      u_baseColorMap: 'BASECOLORMAP',
      u_metallicMap: 'METALLICMAP',
      u_roughnessMap: 'ROUGHNESSMAP',
      u_metallicRoughnessMap: 'METALLICROUGHNESSMAP',
      u_occlusionMap: 'OCCLUSIONMAP',
      u_specularGlossinessMap: 'SPECULARGLOSSINESSMAP',
      u_lightMap: 'LIGHTMAP'
    });
  },
  getRenderOption: function getRenderOption() {
    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    PBRMaterial.superclass.getRenderOption.call(this, option);

    var textureOption = this._textureOption.reset(option);

    textureOption.add(this.baseColorMap, 'BASE_COLOR_MAP');
    textureOption.add(this.metallicMap, 'METALLIC_MAP');
    textureOption.add(this.roughnessMap, 'ROUGHNESS_MAP');
    textureOption.add(this.metallicRoughnessMap, 'METALLIC_ROUGHNESS_MAP');
    textureOption.add(this.diffuseEnvMap, 'DIFFUSE_ENV_MAP');
    textureOption.add(this.occlusionMap, 'OCCLUSION_MAP');
    textureOption.add(this.lightMap, 'LIGHT_MAP');

    if (this.brdfLUT) {
      textureOption.add(this.specularEnvMap, 'SPECULAR_ENV_MAP');

      if (renderer_capabilities.SHADER_TEXTURE_LOD && this.specularEnvMap) {
        option.USE_SHADER_TEXTURE_LOD = 1;
      }
    }

    if (this.isSpecularGlossiness) {
      option.PBR_SPECULAR_GLOSSINESS = 1;
      textureOption.add(this.specularGlossinessMap, 'SPECULAR_GLOSSINESS_MAP');
    }

    if (this.isOcclusionInMetallicRoughnessMap) {
      option.IS_OCCLUSION_MAP_IN_METALLIC_ROUGHNESS_MAP = 1;
    }

    if (this.occlusionStrength !== 1) {
      option.OCCLUSION_STRENGTH = 1;
    }

    if (this.diffuseEnvSphereHarmonics3) {
      option.HAS_NORMAL = 1;
      option.DIFFUSE_ENV_SPHERE_HARMONICS3 = 1;
    }

    if (this.specularEnvMap || this.diffuseEnvSphereHarmonics3 || this.specularEnvMap) {
      option.NEED_WORLD_NORMAL = 1;
    }

    textureOption.update();
    return option;
  }
});
/* harmony default export */ var material_PBRMaterial = (PBRMaterial);
// CONCATENATED MODULE: ./src/texture/LazyTexture.js





var placeHolder = new Image();
placeHolder.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
/**
 * 懒加载纹理
 * @class
 * @extends Texture
 * @fires load 加载成功事件
 * @fires error 加载失败事件
 * @example
 * var material = new Hilo3d.BasicMaterial({
 *     diffuse: new Hilo3d.LazyTexture({
 *         crossOrigin: true,
 *         src: '//img.alicdn.com/tfs/TB1aNxtQpXXXXX1XVXXXXXXXXXX-1024-1024.jpg'
 *     });
 * });
 */

var LazyTexture = core_Class.create(
/** @lends LazyTexture.prototype */
{
  Extends: texture_Texture,
  Mixes: core_EventMixin,

  /**
   * @default true
   * @type {boolean}
   */
  isLazyTexture: true,

  /**
   * @default LazyTexture
   * @type {string}
   */
  className: 'LazyTexture',
  _src: '',

  /**
   * 图片是否跨域
   * @default false
   * @type {boolean}
   */
  crossOrigin: false,

  /**
   * 是否在设置src后立即加载图片
   * @default true
   * @type {boolean}
   */
  autoLoad: true,

  /**
   * 资源类型，用于加载时判断
   * @type {string}
   */
  resType: '',

  /**
   * 图片地址
   * @type {string}
   */
  src: {
    get: function get() {
      return this._src;
    },
    set: function set(src) {
      if (this._src !== src) {
        this._src = src;

        if (this.autoLoad) {
          this.load();
        }
      }
    }
  },

  /**
   * @constructs
   * @param {object} [params] 初始化参数，所有params都会复制到实例上
   * @param {boolean} [params.crossOrigin=false] 是否跨域
   * @param {HTMLImageElement} [params.placeHolder] 占位图片，默认为1像素的透明图片
   * @param {boolean} [params.autoLoad=true] 是否自动加载
   * @param {string} [params.src] 图片地址
   */
  constructor: function constructor(params) {
    if (params) {
      // 必须在src设置前赋值
      if ('crossOrigin' in params) {
        this.crossOrigin = params.crossOrigin;
      }

      if ('autoLoad' in params) {
        this.autoLoad = params.autoLoad;
      }
    }

    LazyTexture.superclass.constructor.call(this, params);
    this.image = this.placeHolder || placeHolder;
  },

  /**
   * 加载图片
   * @param {boolean} [throwError=false] 是否 throw error
   * @return {Promise<void>} 返回加载的Promise
   */
  load: function load(throwError) {
    var _this = this;

    LazyTexture.loader = LazyTexture.loader || new loader_Loader();
    return LazyTexture.loader.load({
      src: this.src,
      crossOrigin: this.crossOrigin,
      type: this.resType,
      defaultType: 'img'
    }).then(function (img) {
      if (img.isTexture) {
        Object.assign(_this, img);
        _this.needUpdate = true;
        _this.needDestroy = true;

        _this.fire('load');
      } else {
        _this.image = img;
        _this.needUpdate = true;

        _this.fire('load');
      }
    }, function (err) {
      _this.fire('error');

      if (throwError) {
        throw new Error("LazyTexture Failed ".concat(err));
      } else {
        utils_log.warn("LazyTexture Failed ".concat(err));
      }
    });
  },
  _releaseImage: function _releaseImage() {
    if (this._src && typeof this._src !== 'string') {
      this._src = '';
    }

    LazyTexture.superclass._releaseImage.call(this);
  }
});
/* harmony default export */ var texture_LazyTexture = (LazyTexture);
// CONCATENATED MODULE: ./src/animation/AnimationStates.js
function AnimationStates_slicedToArray(arr, i) { return AnimationStates_arrayWithHoles(arr) || AnimationStates_iterableToArrayLimit(arr, i) || AnimationStates_unsupportedIterableToArray(arr, i) || AnimationStates_nonIterableRest(); }

function AnimationStates_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function AnimationStates_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AnimationStates_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AnimationStates_arrayLikeToArray(o, minLen); }

function AnimationStates_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function AnimationStates_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function AnimationStates_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







var tempQuat1 = new math_Quaternion();
var tempQuat2 = new math_Quaternion();
var tempQuat3 = new math_Quaternion();
var tempQuat4 = new math_Quaternion();
var tempQuat5 = new math_Quaternion();
var tempQuat6 = new math_Quaternion();
var tempEuler = new math_Euler();
var tempArr = [];

function ascCompare(a, b) {
  return a - b;
}
/**
 * 元素动画状态序列处理
 * @class
 */


var AnimationStates = core_Class.create(
/** @lends AnimationStates.prototype */
{
  Statics: {
    interpolation: {
      LINEAR: function LINEAR(a, b, t) {
        if (b === undefined) {
          return a;
        }

        if (a.slerp) {
          return a.slerp(b, t);
        }

        if (a.lerp) {
          return a.lerp(b, t);
        }

        if (isArrayLike(a)) {
          tempArr.length = 0;

          for (var i = a.length - 1; i >= 0; i--) {
            tempArr[i] = a[i] + t * (b[i] - a[i]);
          }

          return tempArr;
        }

        return a + t * (b - a);
      },
      STEP: function STEP(a, b, t) {
        // eslint-disable-line no-unused-vars
        return a;
      },
      CUBICSPLINE: function CUBICSPLINE(a, b, t, tr) {
        // eslint-disable-line no-unused-vars
        var itemLen = a.length / 3;

        if (b === undefined) {
          if (itemLen === 1) {
            return a[1];
          }

          return a.slice(itemLen, -itemLen);
        }

        var p0 = a[1];
        var m0 = a[2];
        var p1 = b[1];
        var m1 = b[0];

        if (itemLen > 1) {
          p0 = a.slice(itemLen, -itemLen);
          m0 = a.slice(-itemLen);
          p1 = b.slice(itemLen, -itemLen);
          m1 = b.slice(0, itemLen);
        }

        if (p0.hermite) {
          p0.hermite(p0, m0.scale(tr), p1, m1.scale(tr), t);
        } else if (p0.isQuaternion) {
          p0.fromArray(this._cubicSpline(p0.elements, m0.elements, p1.elements, m1.elements, tr, t), 0, true);
          p0.normalize(true);
        } else {
          if (!isArrayLike(p0)) {
            p0 = [p0];
            m0 = [m0];
            p1 = [p1];
            m1 = [m1];
          }

          p0 = this._cubicSpline(p0, m0, p1, m1, tr, t);
        }

        return p0;
      },
      _cubicSpline: function _cubicSpline(p0, m0, p1, m1, tr, t) {
        var t2 = t * t;
        var t3 = t2 * t;
        var x1 = 2 * t3 - 3 * t2 + 1;
        var x2 = t3 - 2 * t2 + t;
        var x3 = -2 * t3 + 3 * t2;
        var x4 = t3 - t2;
        tempArr.length = 0;

        for (var i = p0.length - 1; i >= 0; i--) {
          tempArr[i] = p0[i] * x1 + x2 * m0[i] * tr + p1[i] * x3 + x4 * m1[i] * tr;
        }

        return tempArr;
      }
    },

    /**
     * 状态类型
     * @memberOf AnimationStates
     * @static
     * @enum {string}
     */
    StateType: {
      TRANSLATE: 'Translation',
      POSITION: 'Translation',
      TRANSLATION: 'Translation',
      SCALE: 'Scale',
      ROTATE: 'Rotation',
      ROTATION: 'Rotation',
      QUATERNION: 'Quaternion',
      WEIGHTS: 'Weights'
    },

    /**
     * 根据名字获取状态类型
     * @memberOf AnimationStates
     * @static
     * @param {string} name 名字，忽略大小写，如 translate => StateType.TRANSLATE
     * @return {AnimationStates.StateType} 返回获取的状态名
     */
    getType: function getType(name) {
      name = String(name).toUpperCase();
      return AnimationStates.StateType[name] || AnimationStates._extraStateHandlers.type[name];
    },
    _extraStateHandlers: {
      type: {},
      handler: {}
    },

    /**
     * 注册属性处理器
     * @memberOf AnimationStates
     * @param {string} name 属性名
     * @param {Function} handler 属性处理方法
     */
    registerStateHandler: function registerStateHandler(name, handler) {
      AnimationStates._extraStateHandlers.type[String(name).toUpperCase()] = name;
      AnimationStates._extraStateHandlers.handler[name] = handler;
    }
  },

  /**
   * @default true
   * @type {boolean}
   */
  isAnimationStates: true,

  /**
   * @default AnimationStates
   * @type {string}
   */
  className: 'AnimationStates',

  /**
   * 对应的node名字(动画是根据名字关联的)
   * @type {string}
   */
  nodeName: '',

  /**
   * 状态类型
   * @type {AnimationStates.StateType}
   */
  type: '',

  /**
   * 插值算法
   * @default LINEAR
   * @type {string}
   */
  interpolationType: 'LINEAR',

  /**
   * @constructs
   * @param {Object} parmas 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(parmas) {
    /**
     * @type {string}
     */
    this.id = math_math.generateUUID(this.className);
    /**
     * 时间序列
     * @default []
     * @type {number[]}
     */

    this.keyTime = [];
    /**
     * 对应时间上的状态，数组长度应该跟keyTime一致，即每一帧上的状态信息
     * @default []
     * @type {Array.<Array>}
     */

    this.states = [];
    Object.assign(this, parmas);
  },

  /**
   * 查找指定时间在 keyTime 数组中的位置
   * @param {number} time 指定的时间
   * @return {number[]} 返回找到的位置，如: [low, high]
   */
  findIndexByTime: function findIndexByTime(time) {
    var indexArr = getIndexFromSortedArray(this.keyTime, time, ascCompare); // if (indexArr[0] < 0) {
    //     indexArr[0] = 0;
    // }
    // if (indexArr[1] >= this.keyTime.length) {
    //     indexArr[1] = this.keyTime.length - 1;
    // }

    return indexArr;
  },
  getStateByIndex: function getStateByIndex(index) {
    var len = this.states.length / this.keyTime.length;

    if (len === 1) {
      return this.states[index];
    }

    return this.states.slice(index * len, index * len + len);
  },

  /**
   * 获取指定时间上对应的状态，这里会进行插值计算
   * @param {number} time 指定的时间
   * @return {number[]} 返回插值后的状态数据
   */
  getState: function getState(time) {
    var _this$findIndexByTime = this.findIndexByTime(time),
        _this$findIndexByTime2 = AnimationStates_slicedToArray(_this$findIndexByTime, 2),
        index1 = _this$findIndexByTime2[0],
        index2 = _this$findIndexByTime2[1];

    if (index1 < 0 || index2 >= this.keyTime.length) {
      // do nothing if time is out of range
      return null;
    }

    var time1 = this.keyTime[index1];
    var time2 = this.keyTime[index2];
    var state1 = this.getStateByIndex(index1);

    if (this.interpolationType === 'STEP') {
      return state1;
    }

    if (index1 === index2) {
      var _result = this.interpolation(state1);

      if (this.type === AnimationStates.StateType.ROTATION) {
        _result = tempQuat1.fromEuler(tempEuler.fromArray(_result));
      }

      return _result.elements || _result;
    }

    var state2 = this.getStateByIndex(index2);
    var timeRange = time2 - time1;
    var ratio = (time - time1) / timeRange;

    if (this.type === AnimationStates.StateType.ROTATION) {
      if (isArrayLike(state1[0])) {
        state1[0] = tempQuat1.fromEuler(tempEuler.fromArray(state1[0]));
        state1[1] = tempQuat2.fromEuler(tempEuler.fromArray(state1[1]));
        state1[2] = tempQuat3.fromEuler(tempEuler.fromArray(state1[2]));
        state2[0] = tempQuat4.fromEuler(tempEuler.fromArray(state2[0]));
        state2[1] = tempQuat5.fromEuler(tempEuler.fromArray(state2[1]));
        state2[2] = tempQuat6.fromEuler(tempEuler.fromArray(state2[2]));
      } else {
        state1 = tempQuat1.fromEuler(tempEuler.fromArray(state1));
        state2 = tempQuat2.fromEuler(tempEuler.fromArray(state2));
      }
    } else if (this.type === AnimationStates.StateType.QUATERNION) {
      if (isArrayLike(state1[0])) {
        state1[0] = tempQuat1.fromArray(state1[0]);
        state1[1] = tempQuat2.fromArray(state1[1]);
        state1[2] = tempQuat3.fromArray(state1[2]);
        state2[0] = tempQuat4.fromArray(state2[0]);
        state2[1] = tempQuat5.fromArray(state2[1]);
        state2[2] = tempQuat6.fromArray(state2[2]);
      } else {
        state1 = tempQuat1.fromArray(state1);
        state2 = tempQuat2.fromArray(state2);
      }
    }

    var result = this.interpolation(state1, state2, ratio, timeRange);
    return result.elements || result;
  },
  interpolation: function interpolation(a, b, t, tr) {
    return AnimationStates.interpolation[this.interpolationType](a, b, t, tr);
  },

  /**
   * 更新指定元素的位置
   * @param {Node} node 需要更新的元素
   * @param {number[]} value 位置信息，[x, y, z]
   */
  updateNodeTranslation: function updateNodeTranslation(node, value) {
    node.x = value[0];
    node.y = value[1];
    node.z = value[2];
  },

  /**
   * 更新指定元素的缩放
   * @param {Node} node 需要更新的元素
   * @param {number[]} value 缩放信息，[scaleX, scaleY, scaleZ]
   */
  updateNodeScale: function updateNodeScale(node, value) {
    node.scaleX = value[0];
    node.scaleY = value[1];
    node.scaleZ = value[2];
  },

  /**
   * 更新指定元素的旋转(四元数)
   * @param {Node} node 需要更新的元素
   * @param {number[]} value 四元数的旋转信息，[x, y, z, w]
   */
  updateNodeQuaternion: function updateNodeQuaternion(node, value) {
    node.quaternion.fromArray(value);
  },
  updateNodeWeights: function updateNodeWeights(node, weights) {
    var originalWeightIndices = this._originalWeightIndices = this._originalWeightIndices || [];
    var len = weights.length;
    weights = weights.slice();

    for (var i = 0; i < len; i++) {
      originalWeightIndices[i] = i;
    }

    for (var _i2 = 0; _i2 < len; _i2++) {
      for (var j = _i2 + 1; j < len; j++) {
        if (weights[j] > weights[_i2]) {
          var t = weights[_i2];
          weights[_i2] = weights[j];
          weights[j] = t;
          t = originalWeightIndices[_i2];
          originalWeightIndices[_i2] = originalWeightIndices[j];
          originalWeightIndices[j] = t;
        }
      }
    }

    node.traverse(function (mesh) {
      if (mesh.isMesh && mesh.geometry && mesh.geometry.isMorphGeometry) {
        mesh.geometry.update(weights, originalWeightIndices);
      }
    });
  },

  /**
   * 更新指定元素的状态
   * @param {number} time 时间，从keyTime中查找到状态然后更新
   * @param {Node} node 需要更新的元素
   */
  updateNodeState: function updateNodeState(time, node) {
    if (!node) {
      return;
    }

    var type = this.type;

    if (type === AnimationStates.StateType.ROTATION) {
      type = AnimationStates.StateType.QUATERNION;
    }

    var state = this.getState(time);

    if (!state) {
      return;
    }

    var fnName = 'updateNode' + type;

    if (this[fnName]) {
      this[fnName](node, state);
    } else if (AnimationStates._extraStateHandlers.handler[type]) {
      AnimationStates._extraStateHandlers.handler[type].call(this, node, state);
    } else {
      utils_log.warnOnce(fnName, 'updateNodeState failed unknow type(%s)', type);
    }
  },

  /**
   * clone
   * @return {AnimationStates} 返回clone的实例
   */
  clone: function clone() {
    return new this.constructor({
      keyTime: this.keyTime,
      states: this.states,
      type: this.type,
      nodeName: this.nodeName
    });
  }
});
/* harmony default export */ var animation_AnimationStates = (AnimationStates);
// CONCATENATED MODULE: ./src/animation/Animation.js




/**
 * 动画类
 * @class
 * @mixes EventMixin
 * @fires end 动画完全结束事件
 * @fires loopEnd 动画每次循环结束事件
 */

var Animation = core_Class.create(
/** @lends Animation.prototype */
{
  Statics: {
    _anims: [],

    /**
     * tick
     * @memberOf Animation
     * @method tick
     * @param {Number} dt 一帧时间
     */
    tick: function tick(dt) {
      this._anims.forEach(function (anim) {
        return anim.tick(dt);
      });
    }
  },
  Mixes: core_EventMixin,

  /**
   * @default true
   * @type {boolean}
   */
  isAnimation: true,

  /**
   * @default Animation
   * @type {string}
   */
  className: 'Animation',

  /**
   * 动画是否暂停
   * @default false
   * @type {boolean}
   */
  paused: false,

  /**
   * 动画当前播放次数
   * @default 0
   * @type {number}
   */
  currentLoopCount: 0,

  /**
   * 动画需要播放的次数，默认值为 Infinity 表示永远循环
   * @default Infinity
   * @type {number}
   */
  loop: Infinity,

  /**
   * 动画当前时间
   * @default 0
   * @type {number}
   */
  currentTime: 0,

  /**
   * 动画播放速度
   * @default 1
   * @type {number}
   */
  timeScale: 1,

  /**
   * 动画开始时间
   * @default 0
   * @type {number}
   */
  startTime: 0,

  /**
   * 动画结束时间，初始化后会根据 AnimationStates 来自动获取，也可以通过 play 来改变
   * @default 0
   * @type {number}
   */
  endTime: 0,

  /**
   * 动画整体的最小时间，初始化后会根据 AnimationStates 来自动获取
   * @default 0
   * @type {number}
   */
  clipStartTime: 0,

  /**
   * 动画整体的最大时间，初始化后会根据 AnimationStates 来自动获取
   * @default 0
   * @type {number}
   */
  clipEndTime: 0,
  nodeNameMap: null,
  _rootNode: null,

  /**
   * 动画根节点，不指定根节点将无法正常播放动画
   * @default null
   * @type {Node}
   */
  rootNode: {
    get: function get() {
      return this._rootNode;
    },
    set: function set(value) {
      this._rootNode = value;
      this.initNodeNameMap();
    }
  },

  /**
   * AnimationId集合
   * @type {Object}
   */
  validAnimationIds: null,

  /**
   * @constructs
   * @param {Object} [parmas] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(parmas) {
    /**
     * @type {string}
     */
    this.id = math_math.generateUUID(this.className);
    /**
     * 动画状态列表
     * @default []
     * @type {AnimationStates[]}
     */

    this.animStatesList = [];
    /**
     * 动画剪辑列表，{ name: { start: 0, end: 1} }，play的时候可以通过name来播放某段剪辑
     * @default {}
     * @type {Object}
     */

    this.clips = {};
    Object.assign(this, parmas);
    this.initClipTime();
  },

  /**
   * 添加动画剪辑
   * @param {string} name 剪辑名字
   * @param {number} start 动画开始时间
   * @param {number} end 动画结束时间
   * @param {AnimationStates[]} animStatesList 动画帧列表
   */
  addClip: function addClip(name, start, end, animStatesList) {
    this.clips[name] = {
      start: start,
      end: end,
      animStatesList: animStatesList
    };
  },

  /**
   * 移除动画剪辑
   * @param {string} name 需要移除的剪辑名字
   */
  removeClip: function removeClip(name) {
    this.clips[name] = null;
  },

  /**
   * 获取动画列表的时间信息
   * @param  {AnimationStates[]} animStatesList 动画列表
   * @return {Object} result {startTime, endTime} 时间信息
   */
  getAnimStatesListTimeInfo: function getAnimStatesListTimeInfo(animStatesList) {
    var endTime = 0;
    var startTime = Infinity;
    animStatesList.forEach(function (animStates) {
      endTime = Math.max(animStates.keyTime[animStates.keyTime.length - 1], endTime);
      startTime = Math.min(animStates.keyTime[0], startTime);
    });
    return {
      startTime: startTime,
      endTime: endTime
    };
  },
  initClipTime: function initClipTime() {
    var timeInfo = this.getAnimStatesListTimeInfo(this.animStatesList);
    this.clipStartTime = timeInfo.startTime;
    this.clipEndTime = timeInfo.endTime;
  },
  initNodeNameMap: function initNodeNameMap() {
    if (this._rootNode) {
      var map = this.nodeNameMap = {};

      this._rootNode.traverse(function (child) {
        map[child.animationId] = child; // fix smd animation bug

        var originName = child.name;

        if (originName !== undefined && !map[originName]) {
          map[originName] = child;
        }
      }, false);
    }
  },

  /**
   * tick
   * @param  {Number} dt
   */
  tick: function tick(dt) {
    if (this.paused) {
      return;
    }

    this.currentTime += dt / 1000 * this.timeScale; // 当前动画结束

    if (this.currentTime >= this.endTime) {
      this.currentLoopCount++; // 渲染最后一帧

      this.currentTime = this.endTime;
      this.updateAnimStates();
      this.fire('loopEnd'); // 动画完全结束

      if (!this.loop || this.currentLoopCount >= this.loop) {
        this.stop();
        this.fire('end');
      } else {
        this.currentTime = this.startTime;
      }
    } else {
      this.updateAnimStates();
    }
  },

  /**
   * 更新动画状态
   * @return {Animation} this
   */
  updateAnimStates: function updateAnimStates() {
    var _this = this;

    this.animStatesList.forEach(function (animStates) {
      animStates.updateNodeState(_this.currentTime, _this.nodeNameMap[animStates.nodeName]);
    });
    return this;
  },

  /**
   * 播放动画(剪辑)
   * @param {number|string} [startOrClipName=0] 动画开始时间，或者动画剪辑名字
   * @param {number} [end=this.clipEndTime] 动画结束时间，如果是剪辑的话不需要传
   */
  play: function play(startOrClipName, end) {
    var start;

    if (typeof startOrClipName === 'string') {
      var clip = this.clips[startOrClipName];

      if (clip) {
        start = clip.start;
        end = clip.end;

        if (clip.animStatesList) {
          this.animStatesList = clip.animStatesList;
          this.initClipTime();
        }
      } else {
        utils_log.warn('no this animation clip name:' + startOrClipName);
      }
    } else {
      start = startOrClipName;
    }

    if (start === undefined) {
      start = this.clipStartTime;
    }

    if (end === undefined) {
      end = this.clipEndTime;
    }

    this.endTime = Math.min(end, this.clipEndTime);
    this.startTime = Math.min(start, this.endTime);
    this.currentTime = this.startTime;
    this.currentLoopCount = 0; // 先移除，然后再插入

    this.stop();
    this.paused = false;

    Animation._anims.push(this);
  },

  /**
   * 停止动画，这个会将动画从Ticker中移除，需要重新调用play才能再次播放
   */
  stop: function stop() {
    this.paused = true;
    var anims = Animation._anims;
    var index = anims.indexOf(this);

    if (index !== -1) {
      anims.splice(index, 1);
    }
  },

  /**
   * 暂停动画，这个不会将动画从Ticker中移除
   */
  pause: function pause() {
    this.paused = true;
  },

  /**
   * 恢复动画播放，只能针对 pause 暂停后恢复
   */
  resume: function resume() {
    this.paused = false;
  },

  /**
   * clone动画
   * @param {Node} rootNode 目标动画根节点
   * @return {Animation} clone的动画对象
   */
  clone: function clone(rootNode) {
    var anim = new this.constructor({
      rootNode: rootNode,
      animStatesList: this.animStatesList,
      timeScale: this.timeScale,
      loop: this.loop,
      paused: this.paused,
      currentTime: this.currentTime,
      startTime: this.startTime,
      endTime: this.endTime,
      clips: this.clips
    });

    if (!this.paused) {
      anim.play();
    }

    return anim;
  }
});
/* harmony default export */ var animation_Animation = (Animation);
// CONCATENATED MODULE: ./src/loader/GLTFParser.js
function GLTFParser_slicedToArray(arr, i) { return GLTFParser_arrayWithHoles(arr) || GLTFParser_iterableToArrayLimit(arr, i) || GLTFParser_unsupportedIterableToArray(arr, i) || GLTFParser_nonIterableRest(); }

function GLTFParser_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function GLTFParser_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return GLTFParser_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return GLTFParser_arrayLikeToArray(o, minLen); }

function GLTFParser_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function GLTFParser_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function GLTFParser_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
























var GLTFParser_BLEND = src_constants.BLEND,
    GLTFParser_DEPTH_TEST = src_constants.DEPTH_TEST,
    GLTFParser_CULL_FACE = src_constants.CULL_FACE,
    GLTFParser_FRONT = src_constants.FRONT,
    GLTFParser_BACK = src_constants.BACK,
    GLTFParser_FRONT_AND_BACK = src_constants.FRONT_AND_BACK;
var ComponentTypeMap = {
  5120: [1, Int8Array],
  5121: [1, Uint8Array],
  5122: [2, Int16Array],
  5123: [2, Uint16Array],
  5125: [4, Uint32Array],
  5126: [4, Float32Array]
};
var ComponentNumberMap = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var GLTFParser_glTFAttrToGeometry = {
  POSITION: {
    name: 'vertices',
    decodeMatName: 'positionDecodeMat'
  },
  TEXCOORD_0: {
    name: 'uvs',
    decodeMatName: 'uvDecodeMat'
  },
  TEXCOORD_1: {
    name: 'uvs1',
    decodeMatName: 'uv1DecodeMat'
  },
  NORMAL: {
    name: 'normals',
    decodeMatName: 'normalDecodeMat'
  },
  JOINT: {
    name: 'skinIndices'
  },
  JOINTS_0: {
    name: 'skinIndices'
  },
  WEIGHT: {
    name: 'skinWeights'
  },
  WEIGHTS_0: {
    name: 'skinWeights'
  },
  TANGENT: {
    name: 'tangents'
  },
  COLOR_0: {
    name: 'colors'
  }
};
/**
 * @class
 */

var GLTFParser = core_Class.create(
/** @lends GLTFParser.prototype */
{
  /**
   * @default true
   * @type {boolean}
   */
  isGLTFParser: true,

  /**
   * @default GLTFParser
   * @type {string}
   */
  className: 'GLTFParser',
  Statics:
  /** @lends GLTFParser */
  {
    MAGIC: 'glTF',

    /**
     * 扩展接口
     * @type {Object}
     */
    extensionHandlers: GLTFExtensions_namespaceObject,

    /**
     * 注册扩展接口
     * @param  {String} extensionName 接口名称
     * @param  {IGLTFExtensionHandler} handler 接口
     */
    registerExtensionHandler: function registerExtensionHandler(extensionName, handler) {
      this.extensionHandlers[extensionName] = handler;
    },

    /**
     * 取消注册扩展接口
     * @param  {String} extensionName 接口名称
     */
    unregisterExtensionHandler: function unregisterExtensionHandler(extensionName) {
      if (this.extensionHandlers[extensionName]) {
        delete this.extensionHandlers[extensionName];
      }
    }
  },
  isMultiAnim: true,
  isProgressive: false,
  isUnQuantizeInShader: true,
  isLoadAllTextures: false,
  preHandlerImageURI: null,
  preHandlerBufferURI: null,
  customMaterialCreator: null,
  ignoreTextureError: false,
  forceCreateNewBuffer: false,
  src: '',

  /**
   * @constructs
   * @param  {ArrayBuffer|String} content
   * @param  {Object} params
   */
  constructor: function constructor(content, params) {
    Object.assign(this, params);
    this.content = content;
  },
  parse: function parse(loader) {
    var _this = this;

    if (this.content instanceof ArrayBuffer) {
      var buffer = this.content;
      var magic = convertUint8ArrayToString(new Uint8Array(buffer, 0, 4));

      if (magic === GLTFParser.MAGIC) {
        this.parseBinary(buffer);
      } else {
        var content = convertUint8ArrayToString(new Uint8Array(buffer), true);
        this.json = JSON.parse(content);
      }
    } else {
      this.json = JSON.parse(this.content);
    }

    this.glTFVersion = parseFloat(this.json.asset.version);

    if (this.glTFVersion >= 2) {
      this.isGLTF2 = true;
    }

    this.parseExtensionUsed();
    return this.loadResources(loader).then(function () {
      _this.parseExtensions(_this.json.extensions, null, {
        isGlobal: true,
        methodName: 'parseOnLoad'
      });

      return Promise.resolve();
    }).then(function () {
      return _this.parseGeometries();
    }).then(function () {
      return _this.parseScene();
    });
  },
  parseExtensionUsed: function parseExtensionUsed() {
    var _this2 = this;

    this.extensionsUsed = {};
    util_each(this.json.extensionsUsed, function (name) {
      _this2.extensionsUsed[name] = true;
    });

    if (!this.extensionsUsed.WEB3D_quantized_attributes) {
      // this glTF model havn't use quantize!
      this.isUnQuantizeInShader = false;
    }
  },
  getExtensionHandler: function getExtensionHandler(name) {
    return this.extensionHandlers && this.extensionHandlers[name] || GLTFParser.extensionHandlers[name];
  },
  parseExtension: function parseExtension(extensions, name, result) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var info = extensions[name];
    var extension = this.getExtensionHandler(name);

    if (extension && extension.parse) {
      return extension.parse(info, this, result, options);
    }

    return result;
  },
  parseExtensions: function parseExtensions(extensions, result) {
    var _this3 = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    util_each(extensions, function (info, name) {
      if (options.ignoreExtensions && options.ignoreExtensions[name]) {
        return;
      }

      var extension = _this3.getExtensionHandler(name);

      var methodName = options.methodName || 'parse';

      if (extension && extension[methodName]) {
        result = extension[methodName](info, _this3, result, options);
      }
    });
    return result;
  },
  isUseExtension: function isUseExtension(data, extensionName) {
    return !!(data && data.extensions && data.extensions[extensionName]);
  },
  parseBinary: function parseBinary(buffer) {
    this.isBinary = true;
    var infoDataView = new DataView(buffer);
    var version = infoDataView.getUint32(4, true);
    var totalLength = infoDataView.getUint32(8, true);
    var content;
    var start = 12;

    if (version < 2) {
      var contentLength = infoDataView.getUint32(start, true);
      content = new Uint8Array(buffer, 20, contentLength);
      content = convertUint8ArrayToString(content, true);
      this.json = JSON.parse(content);
      this.binaryBody = buffer.slice(20 + contentLength);
    } else if (version === 2) {
      while (start < totalLength) {
        var chunkLength = infoDataView.getUint32(start, true);
        var chunkType = infoDataView.getUint32(start + 4, true);

        if (chunkType === 0x4E4F534A) {
          // JSON...
          content = new Uint8Array(buffer, start + 8, chunkLength);
          content = convertUint8ArrayToString(content, true);
          this.json = JSON.parse(content);
        } else if (chunkType === 0x004E4942) {
          // binary
          this.binaryBody = buffer.slice(start + 8, start + 8 + chunkLength);
        }

        start += 8 + chunkLength;
      }
    } else {
      throw new Error("Dont support glTF version ".concat(version));
    }
  },
  loadResources: function loadResources(loader) {
    var _this4 = this;

    var actions = [];

    for (var extensionName in this.extensionsUsed) {
      var extension = this.getExtensionHandler(extensionName);

      if (extension && extension.init) {
        actions.push(extension.init(loader, this));
      }
    }

    if (this.isBinary) {
      actions.push(this.loadBuffers(loader).then(function () {
        return _this4.loadTextures(loader);
      }));
    } else {
      actions.push(this.loadBuffers(loader));
      actions.push(this.loadTextures(loader));
    }

    return Promise.all(actions);
  },
  getBufferUri: function getBufferUri(bufferName) {
    var uri = getRelativePath(this.src, this.json.buffers[bufferName].uri);

    if (this.preHandlerBufferURI) {
      uri = this.preHandlerBufferURI(uri, this.json.buffers[bufferName]);
    }

    return uri;
  },
  loadBuffers: function loadBuffers(loader) {
    var _this5 = this;

    this.buffers = {};

    if (this.isBinary) {
      if (this.isGLTF2) {
        this.buffers[0] = this.binaryBody;
      } else {
        this.buffers.binary_glTF = this.binaryBody;
      }

      this.parseBufferViews();
      return Promise.resolve();
    }

    return Promise.all(Object.keys(this.json.buffers || []).map(function (bufferName) {
      var uri = _this5.getBufferUri(bufferName);

      return loader.loadRes(uri, 'buffer').then(function (buffer) {
        _this5.buffers[bufferName] = buffer;
      });
    })).then(function () {
      _this5.parseBufferViews();
    });
  },
  getImageUri: function getImageUri(imageName) {
    var imgData = this.json.images[imageName];
    var uri = imgData.uri;

    if (this.isUseExtension(imgData, 'KHR_binary_glTF')) {
      var binaryInfo = imgData.extensions.KHR_binary_glTF;
      var bufferView = this.bufferViews[binaryInfo.bufferView];
      var data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
      uri = getBlobUrl(binaryInfo.mimeType, data);
    } else if (uri) {
      uri = getRelativePath(this.src, uri);
    } else if ('bufferView' in imgData) {
      var _bufferView = this.bufferViews[imgData.bufferView];

      var _data = new Uint8Array(_bufferView.buffer, _bufferView.byteOffset, _bufferView.byteLength);

      if (imgData.mimeType === 'image/ktx') {
        uri = _data;
      } else {
        uri = getBlobUrl(imgData.mimeType, _data);
      }
    }

    if (this.preHandlerImageURI) {
      uri = this.preHandlerImageURI(uri, imgData);
    }

    return uri;
  },
  getImageType: function getImageType(imageName) {
    var imgData = this.json.images[imageName];
    var type = '';

    if (imgData && /^image\/(.*)$/.test(imgData.mimeType)) {
      type = RegExp.$1;
    }

    if (['ktx'].indexOf(type) < 0) {
      // clear type if type is not valid
      type = '';
    }

    return type;
  },
  getUsedTextureNameMap: function getUsedTextureNameMap() {
    var _this6 = this;

    var map = {};
    util_each(this.json.materials, function (material) {
      var values = material;
      var isKMC = false;

      if (_this6.isUseExtension(material, 'KHR_materials_common')) {
        isKMC = true;
        values = material.extensions.KHR_materials_common.values;
      }

      if (_this6.isGLTF2 && !isKMC) {
        // glTF 2.0
        if (values.normalTexture) {
          map[values.normalTexture.index] = true;
        }

        if (values.occlusionTexture) {
          map[values.occlusionTexture.index] = true;
        }

        if (values.emissiveTexture) {
          map[values.emissiveTexture.index] = true;
        }

        if (values.transparencyTexture) {
          map[values.transparencyTexture.index] = true;
        }

        if (_this6.isUseExtension(values, 'KHR_materials_pbrSpecularGlossiness')) {
          var subValues = values.extensions.KHR_materials_pbrSpecularGlossiness;

          var extensionHandler = _this6.getExtensionHandler('KHR_materials_pbrSpecularGlossiness');

          extensionHandler.getUsedTextureNameMap(subValues, map, _this6);
        } else if (_this6.isUseExtension(values, 'KHR_techniques_webgl')) {
          var _subValues = values.extensions.KHR_techniques_webgl;

          var _extensionHandler = _this6.getExtensionHandler('KHR_techniques_webgl');

          _extensionHandler.getUsedTextureNameMap(_subValues, map, _this6);
        } else if (values.pbrMetallicRoughness) {
          var _subValues2 = values.pbrMetallicRoughness;

          if (_subValues2.baseColorTexture) {
            map[_subValues2.baseColorTexture.index] = true;
          }

          if (_subValues2.metallicRoughnessTexture) {
            map[_subValues2.metallicRoughnessTexture.index] = true;
          }
        }
      } else {
        // glTF 1.0
        if (!isKMC) {
          values = material.values;
        }

        ['diffuse', 'specular', 'emission', 'ambient', 'transparency', 'normalMap'].forEach(function (name) {
          var value = values[name];

          if (value instanceof Object && 'index' in value) {
            value = value.index;
          }

          if (isStrOrNumber(value) && _this6.json.textures[value]) {
            map[value] = true;
          }
        });
      }
    });
    return map;
  },
  loadTextures: function loadTextures() {
    var _this7 = this;

    this.textures = {};

    if (!this.json.textures) {
      return Promise.resolve();
    }

    var needLoadTextures = Object.keys(this.json.textures);

    if (!this.isLoadAllTextures) {
      var usedTextures = this.getUsedTextureNameMap();
      needLoadTextures = needLoadTextures.filter(function (textureName) {
        return usedTextures[textureName];
      });
    }

    return Promise.all(needLoadTextures.map(function (textureName) {
      var textureData = _this7.json.textures[textureName];

      var uri = _this7.getImageUri(textureData.source);

      var texture = new texture_LazyTexture(textureData);
      texture.uv = undefined;
      texture.autoLoad = _this7.isProgressive;
      texture.crossOrigin = true;
      texture.resType = _this7.getImageType(textureData.source);
      texture.src = uri;
      texture.name = textureData.name || textureName;

      if (isBlobUrl(uri)) {
        var onTextureLoad = function onTextureLoad() {
          revokeBlobUrl(uri);
          texture.off('load', onTextureLoad);
          texture.off('error', onTextureLoad);
        };

        texture.on('load', onTextureLoad, true);
        texture.on('error', onTextureLoad, true);
      }

      if (_this7.json.samplers) {
        Object.assign(texture, _this7.json.samplers[textureData.sampler]);
      }

      if (textureData.extensions) {
        texture = _this7.parseExtensions(textureData.extensions, texture);
      }

      _this7.textures[textureName] = texture;

      if (!_this7.isProgressive) {
        return texture.load(!_this7.ignoreTextureError);
      }

      return Promise.resolve();
    }));
  },
  parseBufferViews: function parseBufferViews() {
    var _this8 = this;

    this.bufferViews = {};
    util_each(this.json.bufferViews, function (data, name) {
      var buffer = _this8.buffers[data.buffer];
      var byteOffset = data.byteOffset || 0;
      var byteLength = data.byteLength;
      _this8.bufferViews[name] = {
        id: math_math.generateUUID('bufferView'),
        byteOffset: byteOffset,
        byteLength: byteLength,
        buffer: buffer,
        byteStride: data.byteStride
      };
    });

    if (!this.isBinary) {
      delete this.buffers;
    }
  },
  // get Texture for glTF 2.0
  getTexture: function getTexture(textureInfo) {
    var texture = this.textures[textureInfo.index];

    if (!texture) {
      return null;
    }

    var texCoord = textureInfo.texCoord || 0;
    var key = textureInfo.index + '_' + texCoord;

    if (this.textures[key]) {
      texture = this.textures[key];
    } else if (typeof texture.uv === 'number' && texture.uv !== texCoord) {
      texture = texture.clone();
      this.textures[key] = texture;
    }

    texture.uv = texCoord;
    texture.__gltfTextureInfo = textureInfo;
    return texture;
  },
  getColorOrTexture: function getColorOrTexture(value) {
    if (Array.isArray(value)) {
      return new math_Color(value[0], value[1], value[2]);
    }

    if (value instanceof Object && 'index' in value) {
      value = value.index;
    }

    return this.textures[value];
  },
  parseMaterialCommonProps: function parseMaterialCommonProps(material, materialData) {
    switch (materialData.alphaMode) {
      case 'BLEND':
        material.transparent = true;
        break;

      case 'MASK':
        if ('alphaCutoff' in materialData) {
          material.alphaCutoff = materialData.alphaCutoff;
        } else {
          material.alphaCutoff = 0.5;
        }

        break;

      case 'OPAQUE':
      default:
        material.ignoreTranparent = true;
        break;
    }

    if (!materialData.doubleSided) {
      material.side = GLTFParser_FRONT;
    } else {
      material.side = GLTFParser_FRONT_AND_BACK;
    }

    if (materialData.transparencyTexture) {
      material.transparency = this.getTexture(materialData.transparencyTexture);
    }
  },
  createPBRMaterial: function createPBRMaterial(materialData) {
    var material = new material_PBRMaterial();
    var values = materialData;
    var needLight = !this.isUseExtension(values, 'KHR_materials_unlit');

    if (needLight) {
      var normalTexture = values.normalTexture;

      if (normalTexture) {
        material.normalMap = this.getTexture(normalTexture);

        if (normalTexture.scale !== undefined) {
          material.normalMapScale = normalTexture.scale;
        } else {
          material.normalMapScale = 1;
        }
      }

      var occlusionTexture = values.occlusionTexture;

      if (occlusionTexture) {
        material.occlusionMap = this.getTexture(occlusionTexture);

        if (occlusionTexture.strength !== undefined) {
          material.occlusionStrength = occlusionTexture.strength;
        } else {
          material.occlusionStrength = 1;
        }
      }

      var emissiveTexture = values.emissiveTexture;

      if (emissiveTexture) {
        material.emission = this.getTexture(emissiveTexture);
      }
    } else {
      material.lightType = 'NONE';
    }

    if (this.isUseExtension(values, 'KHR_materials_pbrSpecularGlossiness')) {
      this.parseExtension(values.extensions, 'KHR_materials_pbrSpecularGlossiness', material);
    } else if (values.pbrMetallicRoughness) {
      var subValues = values.pbrMetallicRoughness;

      if (subValues.baseColorFactor) {
        material.baseColor.fromArray(subValues.baseColorFactor);
      }

      if (subValues.baseColorTexture) {
        material.baseColorMap = this.getTexture(subValues.baseColorTexture);
      }

      if (needLight) {
        if (subValues.metallicRoughnessTexture) {
          material.metallicRoughnessMap = this.getTexture(subValues.metallicRoughnessTexture);

          if (material.occlusionMap === material.metallicRoughnessMap) {
            material.occlusionMap = null;
            material.isOcclusionInMetallicRoughnessMap = true;
          }
        }

        if ('roughnessFactor' in subValues) {
          material.roughness = subValues.roughnessFactor;
        }

        if ('metallicFactor' in subValues) {
          material.metallic = subValues.metallicFactor;
        }
      }
    }

    if (material.baseColorMap) {
      this._parseTextureTransform(material, material.baseColorMap);
    }

    return material;
  },
  _parseTextureTransform: function _parseTextureTransform(material, texture) {
    var textureInfo = texture.__gltfTextureInfo;

    if (this.isUseExtension(textureInfo, 'KHR_texture_transform')) {
      var transformInfo = textureInfo.extensions.KHR_texture_transform;

      if (transformInfo.texCoord !== undefined) {
        texture.uv = transformInfo.texCoord;
      }

      if (transformInfo.offset || transformInfo.rotation || transformInfo.scale) {
        var offset = transformInfo.offset || [0, 0];
        var rotation = transformInfo.rotation || 0;
        var scale = transformInfo.scale || [1, 1];
        var uvMatrix = new math_Matrix3().fromRotationTranslationScale(rotation, offset[0], offset[1], scale[0], scale[1]);

        if (texture.uv === 0) {
          material.uvMatrix = uvMatrix;
        } else if (texture.uv === 1) {
          material.uvMatrix1 = uvMatrix;
        }
      }
    }
  },
  createKMCMaterial: function createKMCMaterial(materialData, kmc) {
    var material = new material_BasicMaterial();
    var values;

    if (kmc) {
      values = kmc.values;
      material.lightType = kmc.technique;
    } else {
      values = materialData.values;
    } // glTF 1.0 or KMC


    material.diffuse = this.getColorOrTexture(values.diffuse) || material.diffuse;
    material.specular = this.getColorOrTexture(values.specular) || material.specular;
    material.emission = this.getColorOrTexture(values.emission) || material.emission;
    material.ambient = this.getColorOrTexture(values.ambient) || material.ambient;

    if (values.normalMap) {
      material.normalMap = this.getColorOrTexture(values.normalMap);
    }

    if (typeof values.transparency === 'number') {
      material.transparency = values.transparency;

      if (material.transparency < 1) {
        material.transparent = true;
      }
    } else if (typeof values.transparency === 'string') {
      material.transparency = this.getColorOrTexture(values.transparency);
      material.transparent = true;
    }

    if (values.transparent === true) {
      material.transparent = true;
    }

    if ('shininess' in values) {
      material.shininess = values.shininess;
    }

    this._parseTextureTransform(material, material.diffuse);

    return material;
  },
  parseMaterials: function parseMaterials() {
    var _this9 = this;

    this.materials = {};
    util_each(this.json.materials, function (materialData, name) {
      if (_this9.customMaterialCreator) {
        var _material = _this9.customMaterialCreator(name, materialData, _this9.json, _this9);

        if (_material) {
          _this9.materials[name] = _material;
          return;
        }
      }

      var kmc = null;

      if (_this9.isUseExtension(materialData, 'KHR_materials_common')) {
        kmc = materialData.extensions.KHR_materials_common;
      }

      var material;

      if (_this9.isGLTF2 && !kmc) {
        if (_this9.isUseExtension(materialData, 'KHR_techniques_webgl')) {
          material = _this9.parseExtension(materialData.extensions, 'KHR_techniques_webgl');
        } else {
          material = _this9.createPBRMaterial(materialData);
        }

        _this9.parseMaterialCommonProps(material, materialData);
      } else {
        material = _this9.createKMCMaterial(materialData, kmc);
      }

      material = _this9.parseExtensions(materialData.extensions, material, {
        ignoreExtensions: {
          KHR_techniques_webgl: 1,
          KHR_materials_common: 1,
          KHR_materials_pbrSpecularGlossiness: 1
        },
        isMaterial: true
      });
      material.name = materialData.name || name;
      _this9.materials[name] = material;

      _this9.parseTechnique(materialData, material);
    });
  },
  sparseAccessorHandler: function sparseAccessorHandler(data, sparse) {
    if (!sparse) {
      return data;
    }

    var count = sparse.count; // if dont create a new TpyedArray here, it will change the origin data in buffer

    var TypedArray = data.data.constructor;
    var newArray = new TypedArray(data.realLength);
    newArray.set(data.data);
    data.data = newArray; // values

    var buffer = this.bufferViews[sparse.values.bufferView];
    var values = new TypedArray(buffer.buffer, buffer.byteOffset + (sparse.values.byteOffset || 0), count * data.size); // indices

    TypedArray = ComponentTypeMap[sparse.indices.componentType][1];
    buffer = this.bufferViews[sparse.indices.bufferView];
    var indices = new TypedArray(buffer.buffer, buffer.byteOffset + (sparse.indices.byteOffset || 0), count); // change it

    for (var i = 0; i < count; i++) {
      copyArrayData(newArray, values, indices[i] * data.size, i * data.size, data.size);
    }

    return data;
  },
  getAccessorData: function getAccessorData(name, isDecode) {
    var accessor = this.json.accessors[name];

    if (accessor.data) {
      return accessor.data;
    }

    var _ComponentTypeMap$acc = GLTFParser_slicedToArray(ComponentTypeMap[accessor.componentType], 2),
        TypedArray = _ComponentTypeMap$acc[1];

    var number = ComponentNumberMap[accessor.type];
    var bufferView = this.bufferViews[accessor.bufferView];
    var count = accessor.count * number;
    var result;

    if (bufferView) {
      if (bufferView.byteStride && bufferView.byteStride > number * TypedArray.BYTES_PER_ELEMENT) {
        bufferView.array = new TypedArray(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength / TypedArray.BYTES_PER_ELEMENT);
        result = new geometry_GeometryData(bufferView.array, number, {
          offset: accessor.byteOffset || 0,
          stride: bufferView.byteStride,
          bufferViewId: bufferView.id
        });
      } else {
        var offset = (accessor.byteOffset || 0) + bufferView.byteOffset;
        var array;

        if (offset % TypedArray.BYTES_PER_ELEMENT || this.forceCreateNewBuffer) {
          var buffer = bufferView.buffer.slice(offset, offset + count * TypedArray.BYTES_PER_ELEMENT);
          array = new TypedArray(buffer);
        } else {
          array = new TypedArray(bufferView.buffer, offset, count);
        }

        result = new geometry_GeometryData(array, number);
      }
    }

    if (accessor.sparse) {
      if (!result) {
        result = new geometry_GeometryData(new TypedArray(count), number);
      }

      result = this.sparseAccessorHandler(result, accessor.sparse);
    }

    result = this.parseExtensions(accessor.extensions, result, {
      isDecode: isDecode,
      isAccessor: true
    });
    accessor.data = result;

    if (accessor.normalized) {
      result.normalized = true;
    }

    return result;
  },
  getArrayByAccessor: function getArrayByAccessor(name, isDecode) {
    var accessor = this.json.accessors[name];

    if (accessor.array) {
      return accessor.array;
    }

    var data = this.getAccessorData(name, isDecode);

    if (!data.stride && !data.offset && data.size === 1) {
      return data.data;
    }

    var result = [];
    data.traverse(function (d) {
      result.push(d.toArray ? d.toArray() : d);
    });
    accessor.array = result;
    return result;
  },
  parseTechnique: function parseTechnique(materialData, material) {
    var technique = null;

    if (this.json.techniques) {
      technique = this.json.techniques[materialData.technique];
    }

    if (!technique) {
      return;
    }

    if (!technique.states) {
      return;
    }

    technique.states.enable.forEach(function (flag) {
      switch (flag) {
        case GLTFParser_BLEND:
          material.blend = true;
          break;

        case GLTFParser_DEPTH_TEST:
          material.depthTest = true;
          break;

        case GLTFParser_CULL_FACE:
          material.cullFace = true;
          break;
      }
    });
    util_each(technique.states.functions, function (value, fnName) {
      switch (fnName) {
        case 'blendEquationSeparate':
          material.blendEquation = value[0];
          material.blendEquationAlpha = value[1];
          break;

        case 'blendFuncSeparate':
          material.blendSrc = value[0];
          material.blendDst = value[1];
          material.blendSrcAlpha = value[2];
          material.blendDstAlpha = value[3];
          break;

        case 'depthMask':
          material.depthMask = value[0];
          break;

        case 'cullFace':
          material.cullFaceType = value[0];
          break;

        default:
          material[fnName] = value;
          break;
      }
    });

    if (material.cullFace) {
      material.side = material.cullFaceType === GLTFParser_FRONT ? GLTFParser_BACK : GLTFParser_FRONT;
    } else {
      material.side = GLTFParser_FRONT_AND_BACK;
    }
  },
  createMorphGeometry: function createMorphGeometry(primitive, weights) {
    var _this10 = this;

    // MorphGeometry
    var geometry = new geometry_MorphGeometry();
    var targets = geometry.targets = {};
    util_each(primitive.targets, function (target) {
      util_each(target, function (accessorName, name) {
        var geometryName = GLTFParser_glTFAttrToGeometry[name].name;

        if (!targets[geometryName]) {
          targets[geometryName] = [];
        }

        var data = _this10.getAccessorData(accessorName, true);

        targets[geometryName].push(data);
      });
    });

    if (weights) {
      geometry.weights = weights;
    } else {
      geometry.weights = new Float32Array(primitive.targets.length);
    }

    return geometry;
  },
  handlerGeometry: function handlerGeometry(geometry, primitive) {
    var mode = primitive.mode === undefined ? 4 : primitive.mode;

    if (primitive.extensions) {
      var extensionGeometry = this.parseExtensions(primitive.extensions, null, {
        primitive: primitive,
        isPrimitive: true
      });

      if (extensionGeometry) {
        extensionGeometry.mode = mode;
        return extensionGeometry;
      }
    }

    if (!geometry) {
      geometry = new geometry_Geometry({
        mode: mode
      });
    }

    if ('indices' in primitive) {
      geometry.indices = this.getAccessorData(primitive.indices);
    }

    var attr = primitive.attributes;

    for (var name in attr) {
      var info = GLTFParser_glTFAttrToGeometry[name];

      if (!info) {
        utils_log.warn("Unknow attribute named ".concat(name, "!"));
        continue;
      }

      var isDecode = !(this.isUnQuantizeInShader && info.decodeMatName);
      geometry[info.name] = this.getAccessorData(attr[name], isDecode);

      if (!isDecode) {
        geometry[info.decodeMatName] = geometry[info.name].decodeMat;
        delete geometry[info.name].decodeMat;
      }
    }

    return geometry;
  },
  handlerSkinedMesh: function handlerSkinedMesh(mesh, skeleton) {
    if (!skeleton) {
      return;
    }

    mesh.skeleton = skeleton;

    if (this.useInstanced) {
      mesh.useInstanced = true;
    }
  },
  fixProgressiveGeometry: function fixProgressiveGeometry(primitive, geometry) {
    primitive._geometry = geometry;

    if (this.isProgressive && primitive._meshes) {
      primitive._meshes.forEach(function (mesh) {
        mesh.visible = true;
        mesh.geometry = geometry;
      });
    }
  },
  parseGeometries: function parseGeometries() {
    var _this11 = this;

    var promise = serialRun(this.json.meshes, function (meshData) {
      return serialRun(meshData.primitives, function (primitive) {
        var geometry;

        if (primitive.targets && primitive.targets.length) {
          geometry = _this11.createMorphGeometry(primitive, meshData.weights);
        }

        primitive._geometry = geometry;

        var result = _this11.handlerGeometry(geometry, primitive);

        if (result && result.then) {
          return result.then(function (geometry) {
            _this11.fixProgressiveGeometry(primitive, geometry);
          }, function (err) {
            utils_log.error('geometry parse error', err);
          });
        }

        _this11.fixProgressiveGeometry(primitive, result);

        return result;
      });
    });
    return this.isProgressive ? null : promise;
  },
  parseMesh: function parseMesh(meshName, node, nodeData) {
    var _this12 = this;

    var meshData = this.json.meshes[meshName];
    meshData.primitives.forEach(function (primitive) {
      var mesh;
      var skin = _this12.skins && _this12.skins[nodeData.skin];

      if (primitive.meshNode) {
        mesh = primitive.meshNode.clone();
      } else {
        var material = _this12.materials[primitive.material] || new material_BasicMaterial();
        var MeshClass = skin ? core_SkinedMesh : core_Mesh;
        mesh = new MeshClass({
          geometry: primitive._geometry,
          material: material,
          name: 'mesh-' + (meshData.name || meshName)
        });
        primitive.meshNode = mesh;
      }

      _this12.handlerSkinedMesh(mesh, skin);

      if (_this12.isProgressive && !mesh.geometry) {
        mesh.visible = false;
        primitive._meshes = primitive._meshes || [];

        primitive._meshes.push(mesh);
      }

      node.addChild(mesh);

      _this12.meshes.push(mesh);
    });
  },
  parseCameras: function parseCameras() {
    var _this13 = this;

    this.cameras = {};
    var defaultAspect = window.innerWidth / window.innerHeight;
    util_each(this.json.cameras, function (cameraData, name) {
      var camera;

      if (cameraData.type === 'perspective' && cameraData.perspective) {
        camera = new camera_PerspectiveCamera();
        camera.fov = math_math.radToDeg(cameraData.perspective.yfov);
        camera.near = cameraData.perspective.znear;
        camera.far = cameraData.perspective.zfar;

        if (cameraData.aspectRatio) {
          camera.aspect = cameraData.aspectRatio;
        } else {
          camera.aspect = defaultAspect;
        }
      } else if (cameraData.type === 'orthographic' && cameraData.orthographic) {
        camera = new camera_OrthographicCamera();
        camera.near = cameraData.orthographic.znear;
        camera.far = cameraData.orthographic.zfar;
        camera.right = cameraData.orthographic.xmag;
        camera.left = camera.right * -1;
        camera.top = cameraData.orthographic.ymag;
        camera.bottom = camera.top * -1;
      }

      camera = _this13.parseExtensions(cameraData.extensions, camera, {
        isCamera: true
      });

      if (camera) {
        camera.name = cameraData.name || name;
        _this13.cameras[name] = camera;
      }
    });
  },
  handlerNodeTransform: function handlerNodeTransform(node, data) {
    if (data.matrix) {
      node.matrix.fromArray(data.matrix);
    } else {
      if (data.rotation) {
        node.quaternion.fromArray(data.rotation);
      }

      if (data.scale) {
        node.setScale(data.scale[0], data.scale[1], data.scale[2]);
      }

      if (data.translation) {
        node.x = data.translation[0];
        node.y = data.translation[1];
        node.z = data.translation[2];
      }
    }
  },
  parseNode: function parseNode(nodeName, parentNode) {
    var _this14 = this;

    var node;
    var data = this.json.nodes[nodeName];

    if (!data) {
      utils_log.warn("GLTFParser.parseNode: nodes[".concat(nodeName, "] has nothing."));
    }

    node = new core_Node({
      name: data.name,
      animationId: nodeName
    });
    node = this.parseExtensions(data.extensions, node, {
      isNode: true
    });

    if ('camera' in data && this.cameras[data.camera]) {
      node.addChild(this.cameras[data.camera]);
    }

    this.handlerNodeTransform(node, data);

    if (data.jointName) {
      node.jointName = data.jointName;
      this.jointMap[node.jointName] = node;
    } else if (this.isGLTF2) {
      node.jointName = nodeName;
      this.jointMap[nodeName] = node;
    }

    if (data.meshes) {
      data.meshes.forEach(function (meshName) {
        return _this14.parseMesh(meshName, node, data);
      });
    } else if ('mesh' in data) {
      this.parseMesh(data.mesh, node, data);
    }

    if (data.children) {
      data.children.forEach(function (name) {
        return _this14.parseNode(name, node);
      });
    }

    parentNode.addChild(node);
  },
  parseAnimations: function parseAnimations() {
    var _this15 = this;

    if (!this.json.animations) {
      return null;
    }

    var isMultiAnim = this.isMultiAnim;
    var clips = {};
    var animStatesList = [];
    var validAnimationIds = {};
    util_each(this.json.animations, function (info) {
      info.channels.forEach(function (channel) {
        var path = channel.target.path;
        var nodeId = channel.target.id;

        if (_this15.isGLTF2) {
          nodeId = channel.target.node;
        }

        var sampler = info.samplers[channel.sampler];
        var inputAccessName = _this15.isGLTF2 ? sampler.input : info.parameters[sampler.input];
        var outputAccessName = _this15.isGLTF2 ? sampler.output : info.parameters[path];

        var keyTime = _this15.getArrayByAccessor(inputAccessName, true);

        var states = _this15.getArrayByAccessor(outputAccessName, true);

        if (path === 'rotation') {
          path = 'quaternion';
        }

        var animStates = new animation_AnimationStates({
          interpolationType: sampler.interpolation || 'LINEAR',
          nodeName: nodeId,
          keyTime: keyTime,
          states: states,
          type: animation_AnimationStates.getType(path)
        });
        animStatesList.push(animStates);
        validAnimationIds[nodeId] = true;
      });

      if (isMultiAnim && animStatesList.length) {
        clips[info.name] = {
          animStatesList: animStatesList
        };
        animStatesList = [];
      }
    });

    if (isMultiAnim && Object.keys(clips).length > 0) {
      animStatesList = Object.values(clips)[0].animStatesList;
    }

    if (animStatesList.length) {
      return new animation_Animation({
        rootNode: this.node,
        animStatesList: animStatesList,
        validAnimationIds: validAnimationIds,
        clips: clips
      });
    }

    return null;
  },
  parseScene: function parseScene() {
    var _this16 = this;

    this.parseMaterials();
    this.jointMap = {};
    this.meshes = [];
    this.lights = [];
    this.node = new core_Node({
      needCallChildUpdate: false
    });
    this.parseCameras();
    var scene = this.json.scenes[this.getDefaultSceneName()];

    if (!scene) {
      utils_log.warn('GLTFParser:no scene!');
      return {
        node: this.node,
        meshes: [],
        cameras: [],
        lights: [],
        textures: [],
        materials: []
      };
    }

    var nodes = scene.nodes;
    this.parseSkins();
    nodes.forEach(function (node) {
      return _this16.parseNode(node, _this16.node);
    });
    this.resetSkinInfo(this.node);
    var model = {
      node: this.node,
      scene: this.node,
      meshes: this.meshes,
      json: this.json,
      cameras: Object.values(this.cameras),
      lights: this.lights,
      textures: Object.values(this.textures),
      materials: Object.values(this.materials)
    };
    var anim = this.parseAnimations();

    if (anim) {
      this.node.setAnim(anim);
      anim.play();
      model.anim = anim;
    }

    this.parseExtensions(scene.extensions, null, {
      isScene: true
    });
    this.parseExtensions(this.json.extensions, model, {
      isGlobal: true,
      methodName: 'parseOnEnd'
    });
    return model;
  },
  getDefaultSceneName: function getDefaultSceneName() {
    if (this.defaultScene !== undefined) {
      return this.defaultScene;
    }

    if (this.json.scenes) {
      return Object.keys(this.json.scenes)[0];
    }

    return null;
  },
  parseSkins: function parseSkins() {
    var _this17 = this;

    this.skins = [];
    var skins = this.json.skins;

    if (skins && skins.length) {
      this.skins = skins.map(function (skin) {
        var skeleton = new core_Skeleton();
        var jointCount = skin.joints.length;

        var inverseBindMatrices = _this17.getArrayByAccessor(skin.inverseBindMatrices, true);

        for (var i = 0; i < jointCount; i++) {
          var inverseBindMatrice = new math_Matrix4().fromArray(inverseBindMatrices[i]);
          skeleton.inverseBindMatrices.push(inverseBindMatrice);
        }

        skeleton.jointNames = skin.joints;
        return skeleton;
      });
    }
  },

  /**
   * 重设 jointName，使其保持唯一性。
   * @private
   * @param  {Node} rootNode
   */
  resetSkinInfo: function resetSkinInfo(rootNode) {
    var jointNameMap = {};
    rootNode.traverse(function (node) {
      var newJointName = "".concat(node.id, "_").concat(node.name);
      jointNameMap[node.jointName] = newJointName;
      node.jointName = newJointName;
    });
    this.skins.forEach(function (skin) {
      skin.jointNames = skin.jointNames.map(function (jointName) {
        return jointNameMap[jointName];
      });
    });
    rootNode.resetSkinedMeshRootNode();
  }
});
/* harmony default export */ var loader_GLTFParser = (GLTFParser);
// CONCATENATED MODULE: ./src/loader/GLTFLoader.js





/**
 * glTF模型加载类
 * @class
 * @extends {BasicLoader}
 * @example
 * var loader = new Hilo3d.GLTFLoader();
 * loader.load({
 *     src: '//ossgw.alicdn.com/tmall-c3/tmx/a9bedc04da498b95c57057d6a5d29fe7.gltf'
 * }).then(function (model) {
 *     stage.addChild(model.node);
 * });
 */

var GLTFLoader = core_Class.create(
/** @lends GLTFLoader.prototype */
{
  Extends: loader_BasicLoader,

  /**
   * @default true
   * @type {boolean}
   */
  isGLTFLoader: true,

  /**
   * @default GLTFLoader
   * @type {string}
   */
  className: 'GLTFLoader',

  /**
   * @constructs
   */
  constructor: function constructor() {
    GLTFLoader.superclass.constructor.call(this);
  },

  /**
   * 加载glTF模型
   * @param {object} params 加载参数
   * @param {string} params.src glTF模型地址
   * @param {number|string} [params.defaultScene] 加载后要展示的场景，默认读模型里的
   * @param {boolean} [params.isMultiAnim=false] 模型是否多动画，如果是的话会返回 anims 对象保存多个动画对象
   * @param {boolean} [params.isProgressive=false] 是否渐进式加载，图片加载完前使用占位图片
   * @param {boolean} [params.isUnQuantizeInShader=true] 是否在shader中进行量化解压数据
   * @param {boolean} [params.ignoreTextureError=false] 是否忽略图片加载错误
   * @param {boolean} [params.forceCreateNewBuffer=false] 解析模型数据的时候是否强制创建新buffer，以防内存被引用导致无法释放
   * @param {function} [params.preHandlerImageURI=null] 图片URL预处理函数
   * @param {function} [params.preHandlerBufferURI=null] Buffer URL预处理函数
   * @param {function} [params.customMaterialCreator=null] 是否使用自定义的Material创建器
   * @param {function} [params.isLoadAllTextures=false] 是否加载所有的贴图，默认只加载用到的贴图
   * @async
   * @return {Promise<GLTFModel, Error>} 返回加载完的模型对象
   */
  load: function load(params) {
    var _this = this;

    return this.loadRes(params.src, 'buffer').then(function (buffer) {
      var parser = new loader_GLTFParser(buffer, params);
      return parser.parse(_this);
    })["catch"](function (err) {
      utils_log.error('load gltf failed', err.message, err.stack);
      throw err;
    });
  }
});
loader_Loader.addLoader('gltf', GLTFLoader);
loader_Loader.addLoader('glb', GLTFLoader);
/* harmony default export */ var loader_GLTFLoader = (GLTFLoader);
/**
 * GLTFLoader 模型加载完返回的对象格式
 * @typedef {object} GLTFModel
 * @property {Object} json 原始数据
 * @property {Node} [node] 模型的根节点
 * @property {Mesh[]} [meshes] 模型的所有Mesh对象数组
 * @property {Animation} [anim] 模型的动画对象数组，没有动画的话为null
 * @property {Camera[]} [cameras] 模型中的所有Camera对象数组
 * @property {Light[]} [lights] 模型中的所有Light对象数组
 * @property {Texture[]} [textures] 模型中的所有Texture对象数组
 * @property {BasicMaterial[]} [materials] 模型中的所有Material对象数组
 * @property {Skeleton[]} [skins] 模型中的所有Skeleton对象数组
 */
// EXTERNAL MODULE: ./node_modules/_parse-hdr@1.0.0@parse-hdr/index.js
var _parse_hdr_1_0_0_parse_hdr = __webpack_require__("./node_modules/_parse-hdr@1.0.0@parse-hdr/index.js");
var _parse_hdr_1_0_0_parse_hdr_default = /*#__PURE__*/__webpack_require__.n(_parse_hdr_1_0_0_parse_hdr);

// CONCATENATED MODULE: ./src/loader/HDRLoader.js







var HDRLoader_RGBA = src_constants.RGBA,
    HDRLoader_NEAREST = src_constants.NEAREST,
    HDRLoader_CLAMP_TO_EDGE = src_constants.CLAMP_TO_EDGE,
    HDRLoader_FLOAT = src_constants.FLOAT;
/**
 * @class
 */

var HDRLoader = core_Class.create(
/** @lends HDRLoader.prototype */
{
  Extends: loader_BasicLoader,

  /**
   * @default true
   * @type {boolean}
   */
  isHDRLoader: true,

  /**
   * @default HDRLoader
   * @type {string}
   */
  className: 'HDRLoader',
  constructor: function constructor() {
    HDRLoader.superclass.constructor.call(this);
  },

  /**
   * load
   * @param  {Object} params
   * @return {Promise<Texture>}
   */
  load: function load(params) {
    return this.loadRes(params.src, 'buffer').then(function (buffer) {
      try {
        var img = _parse_hdr_1_0_0_parse_hdr_default()(buffer);
        var shape = img.shape;
        var pixels = img.data;
        var texture = new texture_Texture({
          width: shape[0],
          height: shape[1],
          flipY: params.flipY || false,
          image: pixels,
          type: HDRLoader_FLOAT,
          magFilter: HDRLoader_NEAREST,
          minFilter: HDRLoader_NEAREST,
          wrapS: HDRLoader_CLAMP_TO_EDGE,
          wrapT: HDRLoader_CLAMP_TO_EDGE,
          internalFormat: HDRLoader_RGBA,
          format: HDRLoader_RGBA
        });
        Object.assign(texture, params);
        return texture;
      } catch (e) {
        utils_log.error('HDRLoader:parse error => ', e);
      }

      return null;
    });
  }
});
loader_Loader.addLoader('hdr', HDRLoader);
/* harmony default export */ var loader_HDRLoader = (HDRLoader);
// CONCATENATED MODULE: ./src/loader/KTXLoader.js
/**
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 * ported from https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/js/loaders/KTXLoader.js
 */






/**
 * @class
 * @private
 */

var KhronosTextureContainer = core_Class.create(
/** @lends KhronosTextureContainer.prototype */
{
  Statics: {
    HEADER_LEN: 12 + 13 * 4,
    // identifier + header elements (not including key value meta-data pairs)
    COMPRESSED_2D: 0,
    // uses a gl.compressedTexImage2D()
    COMPRESSED_3D: 1,
    // uses a gl.compressedTexImage3D()
    TEX_2D: 2,
    // uses a gl.texImage2D()
    TEX_3D: 3 // uses a gl.texImage3D()

  },
  isKhronosTextureContainer: true,
  className: 'KhronosTextureContainer',

  /**
   * @constructs
   * @param {ArrayBuffer} arrayBuffer contents of the KTX container file
   * @param {number} facesExpected should be either 1 or 6, based whether a cube texture or or
   */
  constructor: function constructor(arrayBuffer, facesExpected) {
    var baseOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    this.arrayBuffer = arrayBuffer;
    this.baseOffset = baseOffset; // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:
    // '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\r', '\n', '\x1A', '\n'
    // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A

    var identifier = new Uint8Array(this.arrayBuffer, this.baseOffset, 12);

    if (identifier[0] !== 0xAB || identifier[1] !== 0x4B || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 || identifier[6] !== 0x31 || identifier[7] !== 0xBB || identifier[8] !== 0x0D || identifier[9] !== 0x0A || identifier[10] !== 0x1A || identifier[11] !== 0x0A) {
      utils_log.error('texture missing KTX identifier');
      return;
    } // load the reset of the header in native 32 bit uint


    var dataSize = Uint32Array.BYTES_PER_ELEMENT;
    var headerDataView = new DataView(this.arrayBuffer, this.baseOffset + 12, 13 * dataSize);
    var endianness = headerDataView.getUint32(0, true);
    var littleEndian = endianness === 0x04030201;
    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures

    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures

    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures

    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)

    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)

    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)

    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)

    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)

    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays

    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6

    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures

    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data
    // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.

    this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);

    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {
      utils_log.warn('only 2D textures currently supported');
      return;
    }

    if (this.numberOfArrayElements !== 0) {
      utils_log.warn('texture arrays not currently supported');
      return;
    }

    if (this.numberOfFaces !== facesExpected) {
      utils_log.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);
      return;
    } // we now have a completely validated file, so could use existence of loadType as success
    // would need to make this more elaborate & adjust checks above to support more than one load type


    if (this.glType === 0) {
      this.loadType = KhronosTextureContainer.COMPRESSED_2D;
    } else {
      this.loadType = KhronosTextureContainer.TEX_2D;
    }
  },
  // return mipmaps
  mipmaps: function mipmaps(loadMipmaps) {
    var mipmaps = []; // initialize width & height for level 1

    var dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;
    var width = this.pixelWidth;
    var height = this.pixelHeight;
    var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;

    for (var level = 0; level < mipmapCount; level++) {
      var imageSize = new Int32Array(this.arrayBuffer, this.baseOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps

      for (var face = 0; face < this.numberOfFaces; face++) {
        var byteArray = new Uint8Array(this.arrayBuffer, this.baseOffset + dataOffset + 4, imageSize);
        mipmaps.push({
          data: byteArray,
          width: width,
          height: height
        });
        dataOffset += imageSize + 4; // size of the image + 4 for the imageSize field

        dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
      }

      width = Math.max(1.0, width * 0.5);
      height = Math.max(1.0, height * 0.5);
    }

    return mipmaps;
  }
});
/**
 * KTX 加载器
 * @class
 */

var KTXLoader = core_Class.create(
/** @lends KTXLoader.prototype */
{
  Extends: loader_BasicLoader,
  Statics: {
    /**
     * astc
     * @memberOf KTXLoader
     * @type {String}
     * @readOnly
     * @default WEBGL_compressed_texture_astc
     */
    astc: 'WEBGL_compressed_texture_astc',

    /**
     * etc
     * @memberOf KTXLoader
     * @type {String}
     * @readOnly
     * @default WEBGL_compressed_texture_etc
     */
    etc: 'WEBGL_compressed_texture_etc',

    /**
     * etc1
     * @memberOf KTXLoader
     * @type {String}
     * @readOnly
     * @default WEBGL_compressed_texture_etc1
     */
    etc1: 'WEBGL_compressed_texture_etc1',

    /**
     * pvrtc
     * @memberOf KTXLoader
     * @type {String}
     * @readOnly
     * @default WEBGL_compressed_texture_pvrtc
     */
    pvrtc: 'WEBGL_compressed_texture_pvrtc',

    /**
     * s3tc
     * @memberOf KTXLoader
     * @type {String}
     * @readOnly
     * @default WEBGL_compressed_texture_s3tc
     */
    s3tc: 'WEBGL_compressed_texture_s3tc'
  },

  /**
   * @type {boolean}
   * @default true
   */
  isKTXLoader: true,

  /**
   * 类名
   * @type {string}
   * @default KTXLoader
   */
  className: 'KTXLoader',
  constructor: function constructor() {
    renderer_extensions.use(KTXLoader.astc);
    renderer_extensions.use(KTXLoader.atc);
    renderer_extensions.use(KTXLoader.etc);
    renderer_extensions.use(KTXLoader.etc1);
    renderer_extensions.use(KTXLoader.pvrtc);
    renderer_extensions.use(KTXLoader.s3tc);
    renderer_extensions.use(KTXLoader.s3tc_srgb);
    KTXLoader.superclass.constructor.call(this);
  },

  /**
   * load
   * @param  {Object} params
   */
  load: function load(params) {
    var _this = this;

    if (params.src instanceof ArrayBuffer) {
      return Promise.resolve(this.createTexture(params, params.src));
    }

    if (ArrayBuffer.isView(params.src)) {
      return Promise.resolve(this.createTexture(params, params.src.buffer, params.src.byteOffset));
    }

    return this.loadRes(params.src, 'buffer').then(function (buffer) {
      return _this.createTexture(params, buffer);
    });
  },
  createTexture: function createTexture(params, buffer) {
    var baseOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var ktx = new KhronosTextureContainer(buffer, 1, baseOffset);
    var data = {
      compressed: ktx.glType === 0,
      type: ktx.glType,
      width: ktx.pixelWidth,
      height: ktx.pixelHeight,
      internalFormat: ktx.glInternalFormat,
      format: ktx.glFormat,
      isCubemap: ktx.numberOfFaces === 6
    };

    if (ktx.numberOfMipmapLevels >= Math.floor(Math.log2(Math.max(data.width, data.height)) + 1)) {
      data.mipmaps = ktx.mipmaps(true);
      data.image = data.mipmaps[0].data;
    } else {
      data.mipmaps = null;
      data.image = ktx.mipmaps(false)[0].data;
    }

    return new texture_Texture(data);
  }
});
loader_Loader.addLoader('ktx', KTXLoader);
/* harmony default export */ var loader_KTXLoader = (KTXLoader);
// CONCATENATED MODULE: ./src/loader/LoadQueue.js




/**
 * 队列加载器，用于批量加载
 * @class
 * @mixes EventMixin
 * @fires complete 完成事件
 * @fires load 加载事件
 * @fires error 错误事件
 * @example
 * var loadQueue = new Hilo3d.LoadQueue([{
 *     type: 'CubeTexture',
 *     images: [
 *         '//gw.alicdn.com/tfs/TB1Ss.ORpXXXXcNXVXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1YhUDRpXXXXcyaXXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1Y1MORpXXXXcpXVXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1ZgAqRpXXXXa0aFXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1IVZNRpXXXXaNXFXXXXXXXXXX-2048-2048.jpg_960x960.jpg',
 *         '//gw.alicdn.com/tfs/TB1M3gyRpXXXXb9apXXXXXXXXXX-2048-2048.jpg_960x960.jpg'
 *     ]
 * }, {
 *     src: '//ossgw.alicdn.com/tmall-c3/tmx/0356679fd543809bba95dfaea32e1d45.gltf'
 * }]).on('complete', function () {
 *     var result = loadQueue.getAllContent();
 *     var box = new Hilo3d.Mesh({
 *         geometry: geometry,
 *         material: new Hilo3d.BasicMaterial({
 *             lightType: 'NONE',
 *             cullFaceType: Hilo3d.constants.FRONT,
 *             diffuse: result[0]
 *         })
 *     }).addTo(stage);
 *     box.setScale(20);
 *     var material = new Hilo3d.BasicMaterial({
 *         diffuse: new Hilo3d.Color(0, 0, 0),
 *         skyboxMap: result[0],
 *         refractRatio: 1/1.5,
 *         refractivity: 0.8,
 *         reflectivity: 0.2
 *     });
 *     var model = result[1];
 *     model.node.setScale(0.001);
 *     model.meshes.forEach(function (m) {
 *         m.material = material;
 *     });
 *     stage.addChild(model.node);
 * }).start();
 */

var LoadQueue = core_Class.create(
/** @lends LoadQueue.prototype */
{
  Mixes: core_EventMixin,

  /**
   * @default true
   * @type {boolean}
   */
  isLoadQueue: true,

  /**
   * @default LoadQueue
   * @type {string}
   */
  className: 'LoadQueue',
  Statics: {
    /**
     * 给LoadQueue类添加扩展Loader
     * @memberOf LoadQueue
     * @static
     * @param {string} ext 资源扩展，如gltf, png 等
     * @param {BasicLoader} LoaderClass 用于加载的类，需要继承BasicLoader
     */
    addLoader: function addLoader(ext, LoaderClass) {
      utils_log.warn('LoadQueue.addLoader is duplicated, please use Loader.addLoader');
      loader_Loader.addLoader(ext, LoaderClass);
    }
  },

  /**
   * @constructs
   * @param {Array} [source] 需要加载的资源列表
   */
  constructor: function constructor(source) {
    this._source = [];
    this.add(source);
  },

  /**
   * 最大并发连接数
   * @default 2
   * @type {number}
   */
  maxConnections: 2,
  _source: null,
  _loaded: 0,
  _connections: 0,
  _currentIndex: -1,

  /**
   * 添加需要加载的资源
   *
   * @param {object} source 资源信息
   * @param {string} source.src 资源地址
   * @param {string} [source.id] 资源id
   * @param {string} [source.type] 资源类型，对应ext，不传的话自动根据src来获取
   * @param {number} [source.size] 资源大小，用于精确计算当前加载进度
   */
  add: function add(source) {
    if (source) {
      source = Array.isArray(source) ? source : [source];
      this._source = this._source.concat(source);
    }

    return this;
  },

  /**
   * 获取指定id的资源
   *
   * @param {string} id id
   * @return {object} 返回对应的资源信息
   */
  get: function get(id) {
    if (!id) {
      return null;
    }

    var source = this._source;

    for (var i = 0; i < source.length; i++) {
      var item = source[i];

      if (item.id === id || item.src === id) {
        return item;
      }
    }

    return null;
  },

  /**
   * 获取指定id加载完后的数据
   *
   * @param {string} id id
   * @return {object} 加载完的结果
   */
  getContent: function getContent(id) {
    var item = this.get(id);
    return item && item.content;
  },

  /**
   * 开始加载资源
   * @return {LoadQueue} 返回this
   */
  start: function start() {
    if (!this._loader) {
      this._loader = new loader_Loader();
    }

    this._loadNext();

    return this;
  },
  _loadNext: function _loadNext() {
    var _this = this;

    var source = this._source;
    var len = source.length; // all items loaded

    if (this._loaded >= len) {
      this.fire('complete');
      return;
    }

    if (this._currentIndex < len - 1 && this._connections < this.maxConnections) {
      var index = ++this._currentIndex;
      var item = source[index];
      this._connections++;

      this._loader.load(item).then(function (data) {
        _this._onItemLoad(index, data);
      }, function (err) {
        _this._onItemError(index, err);
      });
    }
  },
  _onItemLoad: function _onItemLoad(index, content) {
    var item = this._source[index];
    item.loaded = true;
    item.content = content;
    this._connections--;
    this._loaded++;
    this.fire('load', item);

    this._loadNext();
  },
  _onItemError: function _onItemError(index, e) {
    var item = this._source[index];
    item.error = e;
    this._connections--;
    this._loaded++;
    this.fire('error', item);

    this._loadNext();
  },
  getSize: function getSize(loaded) {
    var size = 0;
    var source = this._source;

    for (var i = 0; i < source.length; i++) {
      var item = source[i];
      size += (loaded ? item.loaded && item.size : item.size) || 0;
    }

    return size;
  },

  /**
   * 获取当前已经加载完的资源数量
   * @return {number}
   */
  getLoaded: function getLoaded() {
    return this._loaded;
  },

  /**
   * 获取需要加载的资源总数
   * @return {number}
   */
  getTotal: function getTotal() {
    return this._source.length;
  },

  /**
   * 获取加载的所有资源结果
   *
   * @return {Array} 加载的所有资源结果
   */
  getAllContent: function getAllContent() {
    return this._source.map(function (r) {
      return r.content;
    });
  }
});
/* harmony default export */ var loader_LoadQueue = (LoadQueue);
// CONCATENATED MODULE: ./src/loader/ShaderMaterialLoader.js




/**
 * ShaderMaterial加载类
 * @class
 * @extends {BasicLoader}
 * @example
 * var loader = new Hilo3d.ShaderMaterialLoader();
 * loader.load({
 *     fs: './test.frag',
 *     vs: './test.vert',
 *     attributes: {
 *         a_pos: {
 *             semantic: 'POSITION'
 *         },
 *         a_uv: {
 *             semantic: 'TEXCOORD_0'
 *         }
 *     },
 *     uniforms: {
 *         u_mat: {
 *             semantic:'MODELVIEWPROJECTION'
 *         },
 *         u_diffuse: {
 *             semantic: 'DIFFUSE'
 *         }
 *     },
 *     diffuse: new Hilo3d.LazyTexture({
 *         crossOrigin: true,
 *         src: '//img.alicdn.com/tfs/TB1va2xQVXXXXaFapXXXXXXXXXX-1024-710.jpg'
 *     })
 * }).then(material => {
 *     var geometry = new Hilo3d.PlaneGeometry();
 *     var plane = new Hilo3d.Mesh({
 *         material: material,
 *         geometry: geometry
 *     });
 *     stage.addChild(plane);
 * });
 */

var ShaderMaterialLoader = core_Class.create(
/** @lends  ShaderMaterialLoader.prototype */
{
  Extends: loader_BasicLoader,

  /**
   * @default true
   * @type {boolean}
   */
  isShaderMaterialLoader: true,

  /**
   * @default ShaderMaterialLoader
   * @type {string}
   */
  className: 'ShaderMaterialLoader',
  constructor: function constructor() {
    ShaderMaterialLoader.superclass.constructor.call(this);
  },

  /**
   * 加载ShaderMaterial
   *
   * @memberOf ShaderMaterialLoader
   * @instance
   *
   * @param {object} params 加载参数，所有参数均会传递给 ShaderMaterial 的构造器
   * @param {string} params.fs fragment shader 文件的地址
   * @param {string} params.vs vertex shader 文件的地址
   * @return {Promise.<ShaderMaterial, Error>} 返回加载完的ShaderMaterial实例
   */
  load: function load(params) {
    var list = [this.loadRes(params.fs), this.loadRes(params.vs)];
    var args = Object.assign({}, params);
    return Promise.all(list).then(function (result) {
      args.fs = result[0];
      args.vs = result[1];
      return new material_ShaderMaterial(args);
    }, function (err) {
      utils_log.warn("ShaderMaterial Loader Failed for ".concat(err));
    });
  }
});
/* harmony default export */ var loader_ShaderMaterialLoader = (ShaderMaterialLoader);
// CONCATENATED MODULE: ./src/loader/TextureLoader.js





/**
 * Texture加载类
 * @class
 * @extends {BasicLoader}
 * @example
 * var loader = new Hilo3d.TextureLoader();
 * loader.load({
 *     crossOrigin: true,
 *     src: '//gw.alicdn.com/tfs/TB1iNtERXXXXXcBaXXXXXXXXXXX-600-600.png'
 * }).then(function (diffuse) {
 *     var material = new Hilo3d.BasicMaterial({
 *         diffuse: diffuse
 *     });
 *     ...
 * });
 */

var TextureLoader = core_Class.create(
/** @lends TextureLoader.prototype */
{
  Extends: loader_BasicLoader,

  /**
   * @default true
   * @type {boolean}
   */
  isTextureLoader: true,

  /**
   * @default TextureLoader
   * @type {string}
   */
  className: 'TextureLoader',

  /**
   * @constructs
   */
  constructor: function constructor() {
    TextureLoader.superclass.constructor.call(this);
  },

  /**
   * 加载Texture
   * @param {object} params 加载参数
   * @param {string} params.src 纹理图片地址
   * @param {boolean} params.crossOrigin 是否跨域，不传将自动判断
   * @async
   * @return {Promise<Texture, Error>} 返回加载完的Texture对象
   */
  load: function load(params) {
    return this.loadImg(params.src, params.crossOrigin).then(function (img) {
      var args = Object.assign({}, params);
      args.image = img;
      delete args.type;
      return new texture_Texture(args);
    })["catch"](function (err) {
      utils_log.error('load Texture failed', err.message, err.stack);
      throw err;
    });
  }
});
loader_Loader.addLoader('Texture', TextureLoader);
/* harmony default export */ var loader_TextureLoader = (TextureLoader);
// CONCATENATED MODULE: ./src/helper/AxisHelper.js








var AxisHelper_LINES = src_constants.LINES;
var axisMap = {
  x: [0, 0, 0, 1, 0, 0],
  y: [0, 0, 0, 0, 1, 0],
  z: [0, 0, 0, 0, 0, 1]
};
/**
 * 坐标轴帮助类
 * @class
 * @extends Node
 * @example
 * stage.addChild(new Hilo3d.AxisHelper());
 */

var AxisHelper = core_Class.create(
/** @lends AxisHelper.prototype */
{
  Extends: core_Node,

  /**
   * @default true
   * @type {boolean}
   */
  isAxisHelper: true,

  /**
   * @default AxisHelper
   * @type {string}
   */
  className: 'AxisHelper',

  /**
   * 坐标轴的长度，不可变更，需要变可以通过设置 scale
   * @default 1
   * @type {number}
   */
  size: 1,

  /**
   * @constructs
   * @param {object} [params] 初始化参数
   */
  constructor: function constructor(params) {
    AxisHelper.superclass.constructor.call(this, params);
    this.init();
  },
  addAxis: function addAxis(direction) {
    var mesh = new core_Mesh({
      name: 'AxisHelper_' + direction,
      geometry: new geometry_Geometry({
        mode: AxisHelper_LINES,
        vertices: new geometry_GeometryData(new Float32Array(axisMap[direction]), 3),
        indices: new geometry_GeometryData(new Uint16Array([0, 1]), 1)
      }),
      material: new material_BasicMaterial({
        diffuse: new math_Color(axisMap[direction][3], axisMap[direction][4], axisMap[direction][5]),
        lightType: 'NONE'
      })
    });
    this.addChild(mesh);
  },
  init: function init() {
    this.setScale(this.size);
    this.addAxis('x');
    this.addAxis('y');
    this.addAxis('z');
  }
});
/* harmony default export */ var helper_AxisHelper = (AxisHelper);
// CONCATENATED MODULE: ./src/helper/AxisNetHelper.js






var AxisNetHelper_LINES = src_constants.LINES;
/**
 * 网格帮助类
 * @class
 * @extends Mesh
 * @example
 * stage.addChild(new Hilo3d.AxisNetHelper({ size: 5 }));
 */

var AxisNetHelper = core_Class.create(
/** @lends AxisNetHelper.prototype */
{
  Extends: core_Mesh,

  /**
   * @default true
   * @type {boolean}
   */
  isAxisNetHelper: true,

  /**
   * @default AxisNetHelper
   * @type {string}
   */
  className: 'AxisNetHelper',

  /**
   * 网格线数量的一半(类似圆的半径)
   * @default 5
   * @type {number}
   */
  size: 5,

  /**
   * @constructs
   * @param {object} [params] 初始化参数
   */
  constructor: function constructor(params) {
    AxisNetHelper.superclass.constructor.call(this, params);
    /**
     * 颜色
     * @default new Color(.5, .5, .5)
     * @type {Color}
     */

    this.color = this.color || new math_Color(.5, .5, .5);
    var geometry = new geometry_Geometry({
      mode: AxisNetHelper_LINES
    });
    var size = this.size;
    var max = size * 2 + 1;

    for (var i = 0; i < max; i++) {
      var x = i / size - 1;
      geometry.addLine([x, 0, -1], [x, 0, 1]);
      geometry.addLine([-1, 0, x], [1, 0, x]);
    }

    this.geometry = geometry;
    this.material = new material_BasicMaterial({
      diffuse: this.color,
      lightType: 'NONE'
    });
  }
});
/* harmony default export */ var helper_AxisNetHelper = (AxisNetHelper);
// CONCATENATED MODULE: ./src/helper/CameraHelper.js








var CameraHelper_LINES = src_constants.LINES;
var CameraHelper_tempVector3 = new math_Vector3();
/**
 * 摄像机帮助类
 * @class
 * @extends Mesh
 * @example
 * stage.addChild(new Hilo3d.CameraHelper());
 */

var CameraHelper = core_Class.create(
/** @lends CameraHelper.prototype */
{
  Extends: core_Mesh,

  /**
   * @default true
   * @type {boolean}
   */
  isCameraHelper: true,

  /**
   * @default CameraHelper
   * @type {string}
   */
  className: 'CameraHelper',
  camera: null,

  /**
   * 颜色
   * @default new Color(0.3, 0.9, 0.6)
   * @type {Color}
   */
  color: null,

  /**
   * @constructs
   * @param {object} [params] 初始化参数
   */
  constructor: function constructor(params) {
    CameraHelper.superclass.constructor.call(this, params);

    if (!this.color) {
      this.color = new math_Color(0.3, 0.9, 0.6);
    }

    this.material = new material_BasicMaterial({
      lightType: 'NONE',
      diffuse: this.color || new math_Color(0.5, 0.5, 0.5, 1)
    });
    this.geometry = new geometry_Geometry({
      mode: CameraHelper_LINES,
      isStatic: false,
      vertices: new geometry_GeometryData(new Float32Array(9 * 3), 3),
      indices: new geometry_GeometryData(new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7, 8, 4, 8, 5, 8, 6, 8, 7]), 1)
    });
  },
  onUpdate: function onUpdate() {
    if (this.camera) {
      this.camera.updateViewProjectionMatrix();

      this._buildGeometry();
    }
  },
  _buildGeometry: function _buildGeometry() {
    var camera = this.camera;
    var geometry = this.geometry;
    var width = 1;
    var height = 1;
    var depth = 1;
    geometry.vertices.set(0, camera.unprojectVector(CameraHelper_tempVector3.set(-width, -height, depth)));
    geometry.vertices.set(1, camera.unprojectVector(CameraHelper_tempVector3.set(-width, height, depth)));
    geometry.vertices.set(2, camera.unprojectVector(CameraHelper_tempVector3.set(width, height, depth)));
    geometry.vertices.set(3, camera.unprojectVector(CameraHelper_tempVector3.set(width, -height, depth)));
    geometry.vertices.set(4, camera.unprojectVector(CameraHelper_tempVector3.set(-width, -height, -depth)));
    geometry.vertices.set(5, camera.unprojectVector(CameraHelper_tempVector3.set(-width, height, -depth)));
    geometry.vertices.set(6, camera.unprojectVector(CameraHelper_tempVector3.set(width, height, -depth)));
    geometry.vertices.set(7, camera.unprojectVector(CameraHelper_tempVector3.set(width, -height, -depth)));
    geometry.vertices.set(8, camera.worldMatrix.getTranslation(CameraHelper_tempVector3));
  }
});
/* harmony default export */ var helper_CameraHelper = (CameraHelper);
// CONCATENATED MODULE: ./src/light/AmbientLight.js


/**
 * 环境光
 * @class
 * @extends Light
 */

var AmbientLight = core_Class.create(
/** @lends AmbientLight.prototype */
{
  Extends: light_Light,

  /**
   * @type {Boolean}
   * @readOnly
   * @default true
   */
  isAmbientLight: true,

  /**
   * @type {String}
   * @readOnly
   * @default AmbientLight
   */
  className: 'AmbientLight',
  autoUpdateWorldMatrix: false,

  /**
   * @constructs
   * @override
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    AmbientLight.superclass.constructor.call(this, params);
  }
});
/* harmony default export */ var light_AmbientLight = (AmbientLight);
// CONCATENATED MODULE: ./src/light/AreaLight.js




/**
 * 面光源
 * @class
 * @extends Light
 */

var AreaLight = core_Class.create(
/** @lends AreaLight.prototype */
{
  Statics: {
    /**
     * ltcTexture1
     * @memberOf AreaLight
     * @type {DataTexture}
     * @default null
     */
    ltcTexture1: null,

    /**
     * ltcTexture2
     * @memberOf AreaLight
     * @type {DataTexture}
     * @default null
     */
    ltcTexture2: null,

    /**
     * ltcTexture 是否加载完成
     * @memberOf AreaLight
     * @type {Boolean}
     * @default false
     */
    ltcTextureReady: false,

    /**
     * ltcTexture 地址
     * @memberOf AreaLight
     * @type {String}
     */
    ltcTextureUrl: '//g.alicdn.com/tmapp/static/4.0.63/ltcTexture.js',

    /**
     * 初始化 ltcTexture
     * @memberOf AreaLight
     */
    loadLtcTexture: function loadLtcTexture() {
      var _this = this;

      if (this.ltcTextureReady) {
        return;
      }

      if (this._loader !== undefined) {
        return;
      }

      this._loader = new loader_Loader();

      this._loader.load({
        type: 'json',
        src: this.ltcTextureUrl
      }).then(function (data) {
        _this._loader = null;
        _this.ltcTexture1 = new texture_DataTexture({
          data: data.ltcTexture1
        });
        _this.ltcTexture2 = new texture_DataTexture({
          data: data.ltcTexture2
        });
        _this.ltcTextureReady = true;
      });
    }
  },
  Extends: light_Light,

  /**
   * @default true
   * @type {boolean}
   */
  isAreaLight: true,

  /**
   * @default AreaLight
   * @type {string}
   */
  className: 'AreaLight',

  /**
   * width
   * @default 10
   * @type {Number}
   */
  width: 10,

  /**
   * height
   * @default 10
   * @type {Number}
   */
  height: 10,
  _enabled: true,
  enabled: {
    get: function get() {
      return this._enabled && AreaLight.ltcTextureReady;
    },
    set: function set(value) {
      this._enabled = value;
    }
  },

  /**
   * @constructs
   * @param {Object} [params] 创建对象的属性参数。可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    AreaLight.superclass.constructor.call(this, params);
    AreaLight.loadLtcTexture();
  },

  /**
   * ltcTexture1
   * @type {DataTexture}
   */
  ltcTexture1: {
    get: function get() {
      return AreaLight.ltcTexture1;
    },
    set: function set(texture) {
      AreaLight.ltcTexture1 = texture;
    }
  },

  /**
   * ltcTexture1
   * @type {DataTexture}
   */
  ltcTexture2: {
    get: function get() {
      return AreaLight.ltcTexture2;
    },
    set: function set(texture) {
      AreaLight.ltcTexture2 = texture;
    }
  }
});
/* harmony default export */ var light_AreaLight = (AreaLight);
// CONCATENATED MODULE: ./src/utils/MeshPicker.js





var meshPickerMaterial = new material_BasicMaterial({
  lightType: 'NONE'
});
var MeshPicker_clearColor = new math_Color(1, 1, 1);
var MeshPicker_tempColor = new math_Color();
/**
 * Mesh 选择工具，可以获取画布中某个区域内的Mesh
 * @class
 * @example
 * const picker = new Hilo3d.MeshPicker({
 *     renderer: stage.renderer
 * });
 * picker.getSelection(20, 20, 1, 1);
 */

var MeshPicker = core_Class.create(
/** @lends MeshPicker.prototype */
{
  /**
   * @default true
   * @type {boolean}
   */
  isMeshPicker: true,

  /**
   * @default MeshPicker
   * @type {string}
   */
  className: 'MeshPicker',

  /**
   * 是否开启debug，开启后会将mesh以不同的颜色绘制在左下角
   * @default false
   * @type {boolean}
   */
  debug: false,

  /**
   * WebGLRenderer 的实例
   * @default null
   * @type {WebGLRenderer}
   */
  renderer: null,
  colorMeshMap: null,

  /**
   * @constructs
   * @param {object} [params] 创建对象的属性参数，可包含此类的所有属性。
   */
  constructor: function constructor(params) {
    Object.assign(this, params);
    this.colorMeshMap = {};
    this.init();
  },
  createFramebuffer: function createFramebuffer() {
    if (this.framebuffer) {
      return;
    }

    var renderer = this.renderer;
    this.framebuffer = new renderer_Framebuffer(renderer, {
      useVao: renderer.useVao,
      width: renderer.width,
      height: renderer.height
    });
  },
  renderDebug: function renderDebug() {
    this.framebuffer.render(0, 0.7, 0.3, 0.3);
  },
  createMeshNumberId: function createMeshNumberId(mesh) {
    if (!('numberId' in mesh)) {
      mesh.numberId = Number(mesh.id.replace(/^.*_(\d+)$/, '$1')) * 10;
      mesh.color = padLeft(mesh.numberId.toString(16), 6);
      this.colorMeshMap[mesh.color] = mesh;
    }
  },
  renderColoredMeshes: function renderColoredMeshes() {
    var _this = this;

    var renderer = this.renderer,
        framebuffer = this.framebuffer;
    framebuffer.bind();
    renderer.clear(MeshPicker_clearColor);
    var currentForceMaterial = renderer.forceMaterial;
    renderer.forceMaterial = meshPickerMaterial;
    renderer.renderList.traverse(function (mesh) {
      _this.createMeshNumberId(mesh);

      meshPickerMaterial.diffuse.fromHEX(mesh.color);
      meshPickerMaterial.isDirty = true;
      renderer.renderMesh(mesh);
    });
    renderer.forceMaterial = currentForceMaterial;
    framebuffer.unbind();
  },

  /**
   * 获取指定区域内的Mesh，注意无法获取被遮挡的Mesh
   * @param {number} x 左上角的x坐标
   * @param {number} y 左上角的y坐标
   * @param {number} [width=1] 区域的宽
   * @param {number} [height=1] 区域的高
   * @return {Mesh[]} 返回获取的Mesh数组
   */
  getSelection: function getSelection(x, y) {
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var pixelRatio = this.renderer.pixelRatio;
    var meshes = [];
    var pixels = this.framebuffer.readPixels(x * pixelRatio, y * pixelRatio, width * pixelRatio, height * pixelRatio);

    for (var i = 0; i < pixels.length; i += 4) {
      var color = MeshPicker_tempColor.fromUintArray(pixels, i).toHEX();

      if (this.colorMeshMap[color]) {
        meshes.push(this.colorMeshMap[color]);
      }
    }

    return meshes;
  },
  init: function init() {
    var _this2 = this;

    this.createFramebuffer();
    this.renderer.on('afterRender', function () {
      _this2.renderColoredMeshes();

      if (_this2.debug) {
        _this2.renderDebug();
      }
    });
  }
});
/* harmony default export */ var utils_MeshPicker = (MeshPicker);
// EXTERNAL MODULE: ./node_modules/_hilojs@2.0.0@hilojs/util/Ticker.js
var Ticker = __webpack_require__("./node_modules/_hilojs@2.0.0@hilojs/util/Ticker.js");
var Ticker_default = /*#__PURE__*/__webpack_require__.n(Ticker);

// CONCATENATED MODULE: ./src/utils/Ticker.js
/**
 * Ticker是一个定时器类。它可以按指定帧率重复运行，从而按计划执行代码。
 * @class  Ticker
 * @see  {@link http://hiloteam.github.io/Hilo/docs/api-zh/symbols/Ticker.html}
 */

/* harmony default export */ var utils_Ticker = (Ticker_default.a);
// CONCATENATED MODULE: ./src/utils/WebGLSupport.js
/**
 * WebGL支持检测
 * @namespace WebGLSupport
 * @type {Object}
 */
var WebGLSupport = {
  /**
   * 是否支持 WebGL
   * @return {Boolean}
   */
  get: function get() {
    if (this._isWebGLSupport === undefined) {
      try {
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl');
        gl.clearColor(0, 1, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        var pixels = new Uint8Array(4);
        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        if (pixels[0] === 0 && pixels[1] === 255 && pixels[2] === 0 && pixels[3] === 255) {
          this._isWebGLSupport = true;
        } else {
          this._isWebGLSupport = false;
        }

        canvas = null;
        gl = null;
        pixels = null;
      } catch (e) {
        this._isWebGLSupport = false;
      }
    }

    return this._isWebGLSupport;
  }
};
/* harmony default export */ var utils_WebGLSupport = (WebGLSupport);
// CONCATENATED MODULE: ./src/math/SphericalHarmonics3.js


var tempArray = new Float32Array(27);
/**
 * SphericalHarmonics3
 * @class
 */

var SphericalHarmonics3 = core_Class.create(
/** @lends SphericalHarmonics3.prototype */
{
  /**
   * 类名
   * @type {String}
   * @default SphericalHarmonics3
   */
  className: 'SphericalHarmonics3',

  /**
   * @type {boolean}
   * @default true
   */
  isSphericalHarmonics3: true,
  Statics: {
    SH3_SCALE: [Math.sqrt(1 / (4 * Math.PI)), -Math.sqrt(3 / (4 * Math.PI)), Math.sqrt(3 / (4 * Math.PI)), -Math.sqrt(3 / (4 * Math.PI)), Math.sqrt(15 / (4 * Math.PI)), -Math.sqrt(15 / (4 * Math.PI)), Math.sqrt(5 / (16 * Math.PI)), -Math.sqrt(15 / (4 * Math.PI)), Math.sqrt(15 / (16 * Math.PI))]
  },

  /**
   * @constructs
   */
  constructor: function constructor() {
    this.coefficients = [];

    for (var i = 0; i < 9; i++) {
      this.coefficients.push(new math_Vector3());
    }
  },

  /**
   * scale
   * @param  {Number} scale
   * @return {SphericalHarmonics3} this
   */
  scale: function scale(_scale) {
    this.coefficients.forEach(function (coefficient) {
      coefficient.scale(_scale);
    });
    return this;
  },

  /**
   * fromArray
   * @param {Number[][]|Number[]} coefficients
   * @return {SphericalHarmonics3} this
   */
  fromArray: function fromArray(data) {
    if (data.length === 9) {
      this.coefficients.forEach(function (coefficient, index) {
        coefficient.fromArray(data[index]);
      });
    } else if (data.length === 27) {
      this.coefficients.forEach(function (coefficient, index) {
        coefficient.fromArray(data, index * 3);
      });
    }

    return this;
  },

  /**
   * scaleForRender
   * @return {SphericalHarmonics3} this
   */
  scaleForRender: function scaleForRender() {
    var SH3_SCALE = SphericalHarmonics3.SH3_SCALE;
    this.coefficients.forEach(function (coefficient, index) {
      coefficient.scale(SH3_SCALE[index]);
    });
    this.scale(1 / Math.PI);
    return this;
  },

  /**
   * toArray
   * @returns {Float32Array}
   */
  toArray: function toArray() {
    this.coefficients.forEach(function (coefficient, index) {
      coefficient.toArray(tempArray, index * 3);
    });
    return tempArray;
  },

  /**
   * 克隆
   * @return {SphericalHarmonics3}
   */
  clone: function clone() {
    var sphericalHarmonics3 = new this.constructor();
    sphericalHarmonics3.copy(this);
    return sphericalHarmonics3;
  },

  /**
   * 复制
   * @param  {SphericalHarmonics3} other
   * @return {SphericalHarmonics3} this
   */
  copy: function copy(other) {
    var otherCoefficients = other.coefficients;
    this.coefficients.forEach(function (coefficient, index) {
      coefficient.copy(otherCoefficients[index]);
    });
    return this;
  }
});
/* harmony default export */ var math_SphericalHarmonics3 = (SphericalHarmonics3);
// CONCATENATED MODULE: ./src/math/index.js

















// CONCATENATED MODULE: ./src/Hilo3d.js


















































































/***/ }),

/***/ "./src/polyfill.js":
/*!*************************!*\
  !*** ./src/polyfill.js ***!
  \*************************/
/*! no exports provided */
/*! ModuleConcatenation bailout: Module is referenced from these modules with unsupported syntax: multi ./src/polyfill.js ./src/Hilo3d.js (referenced with single entry) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! object-assign */ "./node_modules/_object-assign@4.1.1@object-assign/index.js");
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var object_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! object.keys */ "./node_modules/_object.keys@0.1.0@object.keys/index.js");
/* harmony import */ var object_keys__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(object_keys__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var object_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! object-values */ "./node_modules/_object-values@2.0.0@object-values/index.js");
/* harmony import */ var object_values__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(object_values__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var pinkie_promise__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pinkie-promise */ "./node_modules/_pinkie-promise@2.0.1@pinkie-promise/index.js");
/* harmony import */ var pinkie_promise__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pinkie_promise__WEBPACK_IMPORTED_MODULE_3__);





if (!Object.assign) {
  Object.assign = object_assign__WEBPACK_IMPORTED_MODULE_0___default.a;
}

if (!Object.keys) {
  Object.keys = object_keys__WEBPACK_IMPORTED_MODULE_1___default.a;
}

if (!Object.values) {
  Object.values = object_values__WEBPACK_IMPORTED_MODULE_2___default.a;
}

if (typeof Promise === 'undefined') {
  window.Promise = pinkie_promise__WEBPACK_IMPORTED_MODULE_3___default.a;
}

/***/ }),

/***/ "./src/shader/basic.frag":
/*!*******************************!*\
  !*** ./src/shader/basic.frag ***!
  \*******************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n" + __webpack_require__(/*! ./chunk/extensions.frag */ "./src/shader/chunk/extensions.frag") + "\n" + __webpack_require__(/*! ./chunk/baseDefine.glsl */ "./src/shader/chunk/baseDefine.glsl") + "\n" + __webpack_require__(/*! ./chunk/precision.frag */ "./src/shader/chunk/precision.frag") + "\n\n" + __webpack_require__(/*! ./chunk/color.frag */ "./src/shader/chunk/color.frag") + "\n" + __webpack_require__(/*! ./chunk/uv.frag */ "./src/shader/chunk/uv.frag") + "\n" + __webpack_require__(/*! ./chunk/normal.frag */ "./src/shader/chunk/normal.frag") + "\n" + __webpack_require__(/*! ./chunk/lightFog.frag */ "./src/shader/chunk/lightFog.frag") + "\n" + __webpack_require__(/*! ./chunk/diffuse.frag */ "./src/shader/chunk/diffuse.frag") + "\n" + __webpack_require__(/*! ./chunk/light.frag */ "./src/shader/chunk/light.frag") + "\n" + __webpack_require__(/*! ./chunk/phong.frag */ "./src/shader/chunk/phong.frag") + "\n" + __webpack_require__(/*! ./chunk/transparency.frag */ "./src/shader/chunk/transparency.frag") + "\n" + __webpack_require__(/*! ./chunk/fog.frag */ "./src/shader/chunk/fog.frag") + "\n" + __webpack_require__(/*! ./chunk/logDepth.frag */ "./src/shader/chunk/logDepth.frag") + "\n\nvoid main(void) {\nvec4 diffuse = vec4(0., 0., 0., 1.);\nvec4 color = vec4(0., 0., 0., 1.);\n\n" + __webpack_require__(/*! ./chunk/normal_main.frag */ "./src/shader/chunk/normal_main.frag") + "\n" + __webpack_require__(/*! ./chunk/lightFog_main.frag */ "./src/shader/chunk/lightFog_main.frag") + "\n" + __webpack_require__(/*! ./chunk/diffuse_main.frag */ "./src/shader/chunk/diffuse_main.frag") + "\n" + __webpack_require__(/*! ./chunk/phong_main.frag */ "./src/shader/chunk/phong_main.frag") + "\n" + __webpack_require__(/*! ./chunk/transparency_main.frag */ "./src/shader/chunk/transparency_main.frag") + "\n" + __webpack_require__(/*! ./chunk/frag_color.frag */ "./src/shader/chunk/frag_color.frag") + "\n" + __webpack_require__(/*! ./chunk/logDepth_main.frag */ "./src/shader/chunk/logDepth_main.frag") + "\n}";

/***/ }),

/***/ "./src/shader/basic.vert":
/*!*******************************!*\
  !*** ./src/shader/basic.vert ***!
  \*******************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n" + __webpack_require__(/*! ./chunk/extensions.vert */ "./src/shader/chunk/extensions.vert") + "\n" + __webpack_require__(/*! ./chunk/baseDefine.glsl */ "./src/shader/chunk/baseDefine.glsl") + "\n" + __webpack_require__(/*! ./chunk/precision.vert */ "./src/shader/chunk/precision.vert") + "\n\nattribute vec3 a_position;\nuniform mat4 u_modelViewProjectionMatrix;\n\n" + __webpack_require__(/*! ./chunk/unQuantize.vert */ "./src/shader/chunk/unQuantize.vert") + "\n" + __webpack_require__(/*! ./chunk/joint.vert */ "./src/shader/chunk/joint.vert") + "\n" + __webpack_require__(/*! ./chunk/uv.vert */ "./src/shader/chunk/uv.vert") + "\n" + __webpack_require__(/*! ./chunk/normal.vert */ "./src/shader/chunk/normal.vert") + "\n" + __webpack_require__(/*! ./chunk/lightFog.vert */ "./src/shader/chunk/lightFog.vert") + "\n" + __webpack_require__(/*! ./chunk/morph.vert */ "./src/shader/chunk/morph.vert") + "\n" + __webpack_require__(/*! ./chunk/color.vert */ "./src/shader/chunk/color.vert") + "\n" + __webpack_require__(/*! ./chunk/logDepth.vert */ "./src/shader/chunk/logDepth.vert") + "\nvoid main(void) {\nvec4 pos = vec4(a_position, 1.0);\n#ifdef HILO_HAS_TEXCOORD0\nvec2 uv = a_texcoord0;\n#endif\n#ifdef HILO_HAS_TEXCOORD1\nvec2 uv1 = a_texcoord1;\n#endif\n#ifdef HILO_HAS_NORMAL\nvec3 normal = a_normal;\n#endif\n\n#ifdef HILO_NORMAL_MAP\nvec4 tangent = a_tangent;\n#endif\n\n" + __webpack_require__(/*! ./chunk/color_main.vert */ "./src/shader/chunk/color_main.vert") + "\n" + __webpack_require__(/*! ./chunk/unQuantize_main.vert */ "./src/shader/chunk/unQuantize_main.vert") + "\n" + __webpack_require__(/*! ./chunk/morph_main.vert */ "./src/shader/chunk/morph_main.vert") + "\n" + __webpack_require__(/*! ./chunk/joint_main.vert */ "./src/shader/chunk/joint_main.vert") + "\n" + __webpack_require__(/*! ./chunk/uv_main.vert */ "./src/shader/chunk/uv_main.vert") + "\n" + __webpack_require__(/*! ./chunk/normal_main.vert */ "./src/shader/chunk/normal_main.vert") + "\n" + __webpack_require__(/*! ./chunk/lightFog_main.vert */ "./src/shader/chunk/lightFog_main.vert") + "\n\ngl_Position = u_modelViewProjectionMatrix * pos;\n\n" + __webpack_require__(/*! ./chunk/logDepth_main.vert */ "./src/shader/chunk/logDepth_main.vert") + "\n}";

/***/ }),

/***/ "./src/shader/chunk/baseDefine.glsl":
/*!******************************************!*\
  !*** ./src/shader/chunk/baseDefine.glsl ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#define HILO_FRONT_SIDE 1028\n#define HILO_BACK_SIDE 1029\n#define HILO_FRONT_AND_BACK_SIDE 1032\n#define HILO_PI 3.141592653589793\n#define HILO_INVERSE_PI 0.3183098861837907";

/***/ }),

/***/ "./src/shader/chunk/color.frag":
/*!*************************************!*\
  !*** ./src/shader/chunk/color.frag ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_COLOR\nvarying vec4 v_color;\n#endif\n\n#ifdef HILO_USE_HDR\nuniform float u_exposure;\n#endif\n\n#ifdef HILO_GAMMA_CORRECTION\nuniform float u_gammaFactor;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/color.vert":
/*!*************************************!*\
  !*** ./src/shader/chunk/color.vert ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_COLOR\n#if HILO_COLOR_SIZE == 3\nattribute vec3 a_color;\n#elif HILO_COLOR_SIZE == 4\nattribute vec4 a_color;\n#endif\nvarying vec4 v_color;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/color_main.vert":
/*!******************************************!*\
  !*** ./src/shader/chunk/color_main.vert ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_COLOR\n#if HILO_COLOR_SIZE == 3\nv_color = vec4(a_color, 1.0);\n#elif HILO_COLOR_SIZE == 4\nv_color = a_color;\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/diffuse.frag":
/*!***************************************!*\
  !*** ./src/shader/chunk/diffuse.frag ***!
  \***************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#if defined(HILO_DIFFUSE_MAP)\nuniform HILO_SAMPLER_2D u_diffuse;\n#elif defined(HILO_DIFFUSE_CUBE_MAP)\nuniform samplerCube u_diffuse;\n#else\nuniform vec4 u_diffuse;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/diffuse_main.frag":
/*!********************************************!*\
  !*** ./src/shader/chunk/diffuse_main.frag ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#if defined(HILO_DIFFUSE_MAP)\ndiffuse = HILO_TEXTURE_2D(u_diffuse);\n#elif defined(HILO_DIFFUSE_CUBE_MAP)\ndiffuse = textureCube(u_diffuse, v_position);\n#elif defined(HILO_HAS_COLOR)\ndiffuse = v_color;\n#else\ndiffuse = u_diffuse;\n#endif\ncolor.a = diffuse.a;";

/***/ }),

/***/ "./src/shader/chunk/extensions.frag":
/*!******************************************!*\
  !*** ./src/shader/chunk/extensions.frag ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#ifdef HILO_USE_SHADER_TEXTURE_LOD\n#extension GL_EXT_shader_texture_lod: enable\n#endif\n\n#ifdef HILO_USE_EXT_FRAG_DEPTH\n#extension GL_EXT_frag_depth: enable\n#define GLSLIFY 1\n#endif";

/***/ }),

/***/ "./src/shader/chunk/extensions.vert":
/*!******************************************!*\
  !*** ./src/shader/chunk/extensions.vert ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n";

/***/ }),

/***/ "./src/shader/chunk/fixMathCrash.glsl":
/*!********************************************!*\
  !*** ./src/shader/chunk/fixMathCrash.glsl ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_FIX_MAX_BUG\nfloat hilo_max(float a, float b){\nif (a > b) {\nreturn a;\n}\nreturn b;\n}\n#define HILO_MAX(a, b) hilo_max(a, b);\n#else\n#define HILO_MAX(a, b) max(a, b);\n#endif";

/***/ }),

/***/ "./src/shader/chunk/fog.frag":
/*!***********************************!*\
  !*** ./src/shader/chunk/fog.frag ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_FOG\nvarying float v_dist;\nuniform vec4 u_fogColor;\n\n#ifdef HILO_FOG_LINEAR\nuniform vec2 u_fogInfo;\n#else\nuniform float u_fogInfo;\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/fog_main.frag":
/*!****************************************!*\
  !*** ./src/shader/chunk/fog_main.frag ***!
  \****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_FOG\nfloat fogFactor = 1.0;\n\n#ifdef HILO_FOG_LINEAR\nfogFactor = (u_fogInfo.y - v_dist)/(u_fogInfo.y - u_fogInfo.x);\n#elif defined(HILO_FOG_EXP)\nfogFactor = exp(-abs(u_fogInfo * v_dist));\n#elif defined(HILO_FOG_EXP2)\nfogFactor = exp(-(u_fogInfo * v_dist) * (u_fogInfo * v_dist)); \n#endif\n\nfogFactor = clamp(fogFactor, 0.0, 1.0);\ncolor = mix(u_fogColor, color, fogFactor);\n#endif";

/***/ }),

/***/ "./src/shader/chunk/frag_color.frag":
/*!******************************************!*\
  !*** ./src/shader/chunk/frag_color.frag ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_IGNORE_TRANSPARENT\ncolor.a = 1.0;\n#endif\n\n#ifdef HILO_USE_HDR\ncolor.rgb = vec3(1.0) - exp(-color.rgb * u_exposure);\n#endif\n\n#ifdef HILO_GAMMA_CORRECTION\ncolor.rgb = pow(color.rgb, vec3(1.0 / u_gammaFactor));\n#endif\n\n" + __webpack_require__(/*! ./fog_main.frag */ "./src/shader/chunk/fog_main.frag") + "\n\n#ifdef HILO_PREMULTIPLY_ALPHA\ncolor.rgb *= color.a;\n#endif\n\ngl_FragColor = color;";

/***/ }),

/***/ "./src/shader/chunk/joint.vert":
/*!*************************************!*\
  !*** ./src/shader/chunk/joint.vert ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_JOINT_COUNT\nattribute vec4 a_skinIndices;\nattribute vec4 a_skinWeights;\n#ifdef HILO_JOINT_MAT_MAP\nuniform sampler2D u_jointMatTexture;\nuniform vec2 u_jointMatTextureSize;\nmat4 getJointMat(float index) {\nindex *= 4.0;\nfloat x = float(mod(index, u_jointMatTextureSize.x));\nfloat y = float(floor(index / u_jointMatTextureSize.x));\nfloat dx = 1.0 / float(u_jointMatTextureSize.x);\nfloat dy = 1.0 / float(u_jointMatTextureSize.y);\ny = dy * (y + 0.5);\nvec4 v1 = texture2D(u_jointMatTexture, vec2(dx * (x + 0.5), y));\nvec4 v2 = texture2D(u_jointMatTexture, vec2(dx * (x + 1.5), y));\nvec4 v3 = texture2D(u_jointMatTexture, vec2(dx * (x + 2.5), y));\nvec4 v4 = texture2D(u_jointMatTexture, vec2(dx * (x + 3.5), y));\nmat4 mat = mat4(v1, v2, v3, v4);\nreturn mat;\n}\n\nmat4 getJointMat(vec4 weights, vec4 indices) {\nmat4 mat = weights.x * getJointMat(indices.x);\nmat += weights.y * getJointMat(indices.y);\nmat += weights.z * getJointMat(indices.z);\nmat += weights.w * getJointMat(indices.w);\nreturn mat;\n}\n#else\nuniform mat4 u_jointMat[HILO_JOINT_COUNT];\n\nmat4 getJointMat(vec4 weights, vec4 indices) {\nmat4 mat = weights.x * u_jointMat[int(indices.x)];\nmat += weights.y * u_jointMat[int(indices.y)];\nmat += weights.z * u_jointMat[int(indices.z)];\nmat += weights.w * u_jointMat[int(indices.w)];\nreturn mat;\n}\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/joint_main.vert":
/*!******************************************!*\
  !*** ./src/shader/chunk/joint_main.vert ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_JOINT_COUNT\nmat4 skinMat = getJointMat(a_skinWeights, a_skinIndices);\npos = skinMat * pos;\n\n#ifdef HILO_HAS_NORMAL\nnormal = mat3(skinMat) * normal;\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/light.frag":
/*!*************************************!*\
  !*** ./src/shader/chunk/light.frag ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_DIRECTIONAL_LIGHTS\nuniform vec3 u_directionalLightsColor[HILO_DIRECTIONAL_LIGHTS];\nuniform vec3 u_directionalLightsInfo[HILO_DIRECTIONAL_LIGHTS];\n#ifdef HILO_DIRECTIONAL_LIGHTS_SMC\nuniform sampler2D u_directionalLightsShadowMap[HILO_DIRECTIONAL_LIGHTS_SMC];\nuniform vec2 u_directionalLightsShadowMapSize[HILO_DIRECTIONAL_LIGHTS_SMC];\nuniform mat4 u_directionalLightSpaceMatrix[HILO_DIRECTIONAL_LIGHTS_SMC];\nuniform vec2 u_directionalLightsShadowBias[HILO_DIRECTIONAL_LIGHTS_SMC];\n#endif\n#endif\n\n#ifdef HILO_SPOT_LIGHTS\nuniform vec3 u_spotLightsPos[HILO_SPOT_LIGHTS];\nuniform vec3 u_spotLightsDir[HILO_SPOT_LIGHTS];\nuniform vec3 u_spotLightsColor[HILO_SPOT_LIGHTS];\nuniform vec2 u_spotLightsCutoffs[HILO_SPOT_LIGHTS];\nuniform vec3 u_spotLightsInfo[HILO_SPOT_LIGHTS];\nuniform float u_spotLightsRange[HILO_SPOT_LIGHTS];\n#ifdef HILO_SPOT_LIGHTS_SMC\nuniform sampler2D u_spotLightsShadowMap[HILO_SPOT_LIGHTS_SMC];\nuniform vec2 u_spotLightsShadowMapSize[HILO_SPOT_LIGHTS_SMC];\nuniform mat4 u_spotLightSpaceMatrix[HILO_SPOT_LIGHTS_SMC];\nuniform vec2 u_spotLightsShadowBias[HILO_SPOT_LIGHTS_SMC];\n#endif\n#endif\n\n#ifdef HILO_POINT_LIGHTS\nuniform vec3 u_pointLightsPos[HILO_POINT_LIGHTS];\nuniform vec3 u_pointLightsColor[HILO_POINT_LIGHTS];\nuniform vec3 u_pointLightsInfo[HILO_POINT_LIGHTS];\nuniform float u_pointLightsRange[HILO_POINT_LIGHTS];\n#ifdef HILO_POINT_LIGHTS_SMC\nuniform samplerCube u_pointLightsShadowMap[HILO_POINT_LIGHTS_SMC];\nuniform mat4 u_pointLightSpaceMatrix[HILO_POINT_LIGHTS_SMC];\nuniform vec2 u_pointLightsShadowBias[HILO_POINT_LIGHTS_SMC];\nuniform vec2 u_pointLightCamera[HILO_POINT_LIGHTS_SMC];\n#endif\n#endif\n\n#ifdef HILO_AREA_LIGHTS\nuniform vec3 u_areaLightsPos[HILO_AREA_LIGHTS];\nuniform vec3 u_areaLightsColor[HILO_AREA_LIGHTS];\nuniform vec3 u_areaLightsWidth[HILO_AREA_LIGHTS];\nuniform vec3 u_areaLightsHeight[HILO_AREA_LIGHTS];\nuniform sampler2D u_areaLightsLtcTexture1;\nuniform sampler2D u_areaLightsLtcTexture2;\n\n" + __webpack_require__(/*! ../method/getAreaLight.glsl */ "./src/shader/method/getAreaLight.glsl") + "\n#endif\n\n#ifdef HILO_AMBIENT_LIGHTS\nuniform vec3 u_ambientLightsColor;\n#endif\n\n" + __webpack_require__(/*! ../method/getDiffuse.glsl */ "./src/shader/method/getDiffuse.glsl") + "\n" + __webpack_require__(/*! ../method/getSpecular.glsl */ "./src/shader/method/getSpecular.glsl") + "\n" + __webpack_require__(/*! ../method/getLightAttenuation.glsl */ "./src/shader/method/getLightAttenuation.glsl") + "\n" + __webpack_require__(/*! ../method/unpackFloat.glsl */ "./src/shader/method/unpackFloat.glsl") + "\n" + __webpack_require__(/*! ../method/getShadow.glsl */ "./src/shader/method/getShadow.glsl") + "";

/***/ }),

/***/ "./src/shader/chunk/lightFog.frag":
/*!****************************************!*\
  !*** ./src/shader/chunk/lightFog.frag ***!
  \****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#if defined(HILO_HAS_LIGHT) || defined(HILO_HAS_FRAG_POS)\nvarying vec3 v_fragPos;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/lightFog.vert":
/*!****************************************!*\
  !*** ./src/shader/chunk/lightFog.vert ***!
  \****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#if defined(HILO_HAS_LIGHT) || defined(HILO_HAS_FOG) || defined(HILO_HAS_FRAG_POS)\nuniform mat4 u_modelViewMatrix;\n#ifdef HILO_HAS_FOG\nvarying float v_dist;\n#endif\n\n#if defined(HILO_HAS_LIGHT) || defined(HILO_HAS_FRAG_POS) \nvarying vec3 v_fragPos;\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/lightFog_main.frag":
/*!*********************************************!*\
  !*** ./src/shader/chunk/lightFog_main.frag ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_LIGHT\n#if HILO_SIDE == HILO_FRONT_AND_BACK_SIDE\nnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/lightFog_main.vert":
/*!*********************************************!*\
  !*** ./src/shader/chunk/lightFog_main.vert ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#if defined(HILO_HAS_LIGHT) || defined(HILO_HAS_FOG) || defined(HILO_HAS_FRAG_POS)\nvec3 fragPos = (u_modelViewMatrix * pos).xyz;\n\n#if defined(HILO_HAS_LIGHT) || defined(HILO_HAS_FRAG_POS)\nv_fragPos = fragPos;\n#endif\n\n#ifdef HILO_HAS_FOG\nv_dist = length(fragPos);\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/logDepth.frag":
/*!****************************************!*\
  !*** ./src/shader/chunk/logDepth.frag ***!
  \****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#if defined(HILO_USE_LOG_DEPTH) && defined(HILO_USE_EXT_FRAG_DEPTH)\nuniform float u_logDepth;\nvarying float v_fragDepth;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/logDepth.vert":
/*!****************************************!*\
  !*** ./src/shader/chunk/logDepth.vert ***!
  \****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_USE_LOG_DEPTH\n#ifdef HILO_USE_EXT_FRAG_DEPTH\nvarying float v_fragDepth;\n#else\nuniform float u_logDepth;\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/logDepth_main.frag":
/*!*********************************************!*\
  !*** ./src/shader/chunk/logDepth_main.frag ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#if defined(HILO_USE_LOG_DEPTH) && defined(HILO_USE_EXT_FRAG_DEPTH)\ngl_FragDepthEXT = log2( v_fragDepth ) * u_logDepth * 0.5;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/logDepth_main.vert":
/*!*********************************************!*\
  !*** ./src/shader/chunk/logDepth_main.vert ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_USE_LOG_DEPTH\n#ifdef HILO_USE_EXT_FRAG_DEPTH\nv_fragDepth = 1.0 + gl_Position.w;\n#else\ngl_Position.z = log2( max( 1e-6, gl_Position.w + 1.0 ) ) * u_logDepth - 1.0;\ngl_Position.z *= gl_Position.w;\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/morph.vert":
/*!*************************************!*\
  !*** ./src/shader/chunk/morph.vert ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_MORPH_TARGET_COUNT\nuniform float u_morphWeights[HILO_MORPH_TARGET_COUNT];\n\n#if HILO_MORPH_TARGET_COUNT > 0\n#ifdef HILO_MORPH_HAS_POSITION\nattribute vec3 a_morphPosition0;\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nattribute vec3 a_morphNormal0;\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\nattribute vec3 a_morphTangent0;\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 1\n#ifdef HILO_MORPH_HAS_POSITION\nattribute vec3 a_morphPosition1;\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nattribute vec3 a_morphNormal1;\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\nattribute vec3 a_morphTangent1;\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 2\n#ifdef HILO_MORPH_HAS_POSITION\nattribute vec3 a_morphPosition2;\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nattribute vec3 a_morphNormal2;\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\nattribute vec3 a_morphTangent2;\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 3\n#ifdef HILO_MORPH_HAS_POSITION\nattribute vec3 a_morphPosition3;\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nattribute vec3 a_morphNormal3;\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\nattribute vec3 a_morphTangent3;\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 4\n#ifdef HILO_MORPH_HAS_POSITION\nattribute vec3 a_morphPosition4;\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nattribute vec3 a_morphNormal4;\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\nattribute vec3 a_morphTangent4;\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 5\n#ifdef HILO_MORPH_HAS_POSITION\nattribute vec3 a_morphPosition5;\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nattribute vec3 a_morphNormal5;\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\nattribute vec3 a_morphTangent5;\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 6\n#ifdef HILO_MORPH_HAS_POSITION\nattribute vec3 a_morphPosition6;\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nattribute vec3 a_morphNormal6;\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\nattribute vec3 a_morphTangent6;\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 7\n#ifdef HILO_MORPH_HAS_POSITION\nattribute vec3 a_morphPosition7;\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nattribute vec3 a_morphNormal7;\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\nattribute vec3 a_morphTangent7;\n#endif\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/morph_main.vert":
/*!******************************************!*\
  !*** ./src/shader/chunk/morph_main.vert ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_MORPH_TARGET_COUNT\n#if HILO_MORPH_TARGET_COUNT > 0\n#ifdef HILO_MORPH_HAS_POSITION\npos.xyz += a_morphPosition0 * u_morphWeights[0];\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nnormal += a_morphNormal0 * u_morphWeights[0];\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\ntangent.xyz += a_morphTangent0 * u_morphWeights[0];\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 1\n#ifdef HILO_MORPH_HAS_POSITION\npos.xyz += a_morphPosition1 * u_morphWeights[1];\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nnormal += a_morphNormal1 * u_morphWeights[1];\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\ntangent.xyz += a_morphTangent1 * u_morphWeights[1];\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 2\n#ifdef HILO_MORPH_HAS_POSITION\npos.xyz += a_morphPosition2 * u_morphWeights[2];\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nnormal += a_morphNormal2 * u_morphWeights[2];\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\ntangent.xyz += a_morphTangent2 * u_morphWeights[2];\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 3\n#ifdef HILO_MORPH_HAS_POSITION\npos.xyz += a_morphPosition3 * u_morphWeights[3];\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nnormal += a_morphNormal3 * u_morphWeights[3];\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\ntangent.xyz += a_morphTangent3 * u_morphWeights[3];\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 4\n#ifdef HILO_MORPH_HAS_POSITION\npos.xyz += a_morphPosition4 * u_morphWeights[4];\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nnormal += a_morphNormal4 * u_morphWeights[4];\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\ntangent.xyz += a_morphTangent4 * u_morphWeights[4];\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 5\n#ifdef HILO_MORPH_HAS_POSITION\npos.xyz += a_morphPosition5 * u_morphWeights[5];\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nnormal += a_morphNormal5 * u_morphWeights[5];\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\ntangent.xyz += a_morphTangent5 * u_morphWeights[5];\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 6\n#ifdef HILO_MORPH_HAS_POSITION\npos.xyz += a_morphPosition6 * u_morphWeights[6];\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nnormal += a_morphNormal6 * u_morphWeights[6];\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\ntangent.xyz += a_morphTangent6 * u_morphWeights[6];\n#endif\n#endif\n\n#if HILO_MORPH_TARGET_COUNT > 7\n#ifdef HILO_MORPH_HAS_POSITION\npos.xyz += a_morphPosition7 * u_morphWeights[7];\n#endif\n#if defined(HILO_MORPH_HAS_NORMAL) && defined(HILO_HAS_NORMAL)\nnormal += a_morphNormal7 * u_morphWeights[7];\n#endif\n#if defined(HILO_MORPH_HAS_TANGENT) && defined(HILO_HAS_TANGENT)\ntangent.xyz += a_morphTangent7 * u_morphWeights[7];\n#endif\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/normal.frag":
/*!**************************************!*\
  !*** ./src/shader/chunk/normal.frag ***!
  \**************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_NORMAL\nvarying vec3 v_normal;\n#ifdef HILO_NORMAL_MAP\nuniform HILO_SAMPLER_2D u_normalMap;\nvarying mat3 v_TBN;\n\n#ifdef HILO_NORMAL_MAP_SCALE\nuniform float u_normalMapScale;\n#endif\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/normal.vert":
/*!**************************************!*\
  !*** ./src/shader/chunk/normal.vert ***!
  \**************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_NORMAL\nattribute vec3 a_normal;\nuniform mat3 u_normalMatrix;\nvarying vec3 v_normal;\n\n#ifdef HILO_NORMAL_MAP\nattribute vec4 a_tangent;\nvarying mat3 v_TBN;\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/normal_main.frag":
/*!*******************************************!*\
  !*** ./src/shader/chunk/normal_main.frag ***!
  \*******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_NORMAL_MAP\nvec3 normal = HILO_TEXTURE_2D(u_normalMap).rgb * 2.0 - 1.0;\n#ifdef HILO_NORMAL_MAP_SCALE\nnormal.xy *= u_normalMapScale;\n#endif\nnormal = normalize(v_TBN * normal);\n#elif defined(HILO_HAS_NORMAL)\nvec3 normal = normalize(v_normal);\n#else\nvec3 normal = vec3(0, 0, 1);\n#endif\n\n#if HILO_SIDE == HILO_BACK_SIDE\nnormal = -normal;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/normal_main.vert":
/*!*******************************************!*\
  !*** ./src/shader/chunk/normal_main.vert ***!
  \*******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_NORMAL\n#ifdef HILO_NORMAL_MAP\nvec3 T = normalize(u_normalMatrix * tangent.xyz);\nvec3 N = normalize(u_normalMatrix * normal);\nT = normalize(T - dot(T, N) * N);\nvec3 B = cross(N, T) * tangent.w;\nv_TBN = mat3(T, B, N);\n#endif\nv_normal = normalize(u_normalMatrix * normal);\n#endif";

/***/ }),

/***/ "./src/shader/chunk/pbr.frag":
/*!***********************************!*\
  !*** ./src/shader/chunk/pbr.frag ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n" + __webpack_require__(/*! ../method/textureEnvMap.glsl */ "./src/shader/method/textureEnvMap.glsl") + "\n" + __webpack_require__(/*! ../method/encoding.glsl */ "./src/shader/method/encoding.glsl") + "\n" + __webpack_require__(/*! ./fixMathCrash.glsl */ "./src/shader/chunk/fixMathCrash.glsl") + "\n\nuniform vec4 u_baseColor;\n#ifdef HILO_BASE_COLOR_MAP\nuniform HILO_SAMPLER_2D u_baseColorMap;\n#endif\n\n#ifdef HILO_NEED_WORLD_NORMAL\nuniform mat3 u_viewInverseNormalMatrix;\n#endif\n\n#ifdef HILO_HAS_LIGHT\nuniform float u_metallic;\n#ifdef HILO_METALLIC_MAP\nuniform HILO_SAMPLER_2D u_metallicMap;\n#endif\nuniform float u_roughness;\n#ifdef HILO_ROUGHNESS_MAP\nuniform HILO_SAMPLER_2D u_roughnessMap;\n#endif\n#ifdef HILO_METALLIC_ROUGHNESS_MAP\nuniform HILO_SAMPLER_2D u_metallicRoughnessMap;\n#endif\n#ifdef HILO_OCCLUSION_MAP\nuniform HILO_SAMPLER_2D u_occlusionMap;\n#endif\n\n#ifdef HILO_OCCLUSION_STRENGTH\nuniform float u_occlusionStrength;\n#endif\n\n#ifdef HILO_DIFFUSE_ENV_MAP\n#ifdef HILO_DIFFUSE_ENV_MAP_CUBE\nuniform samplerCube u_diffuseEnvMap;\n#else\nuniform sampler2D u_diffuseEnvMap;\n#endif\nuniform float u_diffuseEnvIntensity;\n#elif defined(HILO_DIFFUSE_ENV_SPHERE_HARMONICS3)\nuniform vec3 u_diffuseEnvSphereHarmonics3[9];\nuniform float u_diffuseEnvIntensity;\n#endif\n#ifdef HILO_SPECULAR_ENV_MAP\nuniform sampler2D u_brdfLUT;\n#ifdef HILO_SPECULAR_ENV_MAP_CUBE\nuniform samplerCube u_specularEnvMap;\n#else\nuniform sampler2D u_specularEnvMap;\n#endif\nuniform float u_specularEnvIntensity;\n\n#ifdef HILO_USE_SHADER_TEXTURE_LOD\nuniform float u_specularEnvMapMipCount;\n#endif\n#endif\n\n#ifdef HILO_EMISSION_MAP\nuniform HILO_SAMPLER_2D u_emission;\n#endif\n\n#ifdef HILO_PBR_SPECULAR_GLOSSINESS\nuniform vec4 u_specular;\nuniform float u_glossiness;\n#ifdef HILO_SPECULAR_GLOSSINESS_MAP\nuniform HILO_SAMPLER_2D u_specularGlossinessMap;\n#endif\n#endif\n\n#ifdef HILO_LIGHT_MAP\nuniform HILO_SAMPLER_2D u_lightMap;\n#endif\n\n\n// PBR Based on https://github.com/KhronosGroup/glTF-WebGL-PBR\n\n// Basic Lambertian diffuse\n// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog\n// See also [1], Equation 1\nvec3 diffuse(vec3 diffuseColor) {\nreturn diffuseColor * HILO_INVERSE_PI;\n}\n\n// The following equation models the Fresnel reflectance term of the spec equation (aka F())\n// Implementation of fresnel from [4], Equation 15\nvec3 specularReflection(vec3 reflectance0, vec3 reflectance90, float VdotH) {\nreturn reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\n// This calculates the specular geometric attenuation (aka G()),\n// where rougher material will reflect less light back to the viewer.\n// This implementation is based on [1] Equation 4, and we adopt their modifications to\n// alphaRoughness as input as originally proposed in [2].\nfloat geometricOcclusion(float NdotL, float NdotV, float alphaRoughness) {\nfloat r = alphaRoughness * alphaRoughness;\n\nfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r + (1.0 - r) * (NdotL * NdotL)));\nfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r + (1.0 - r) * (NdotV * NdotV)));\nreturn attenuationL * attenuationV;\n}\n\n// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())\n// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz\n// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.\nfloat microfacetDistribution(float alphaRoughness, float NdotH) {\nfloat roughnessSq = alphaRoughness * alphaRoughness;\nfloat f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\nreturn roughnessSq * HILO_INVERSE_PI / (f * f);\n}\n\nvec3 computeDiffuseSHLight(vec3 normal, in vec3 sh[9]) {\nreturn sh[0] +\nsh[1] * (normal.y) +\nsh[2] * (normal.z) +\nsh[3] * (normal.x) +\nsh[4] * (normal.y * normal.x) +\nsh[5] * (normal.y * normal.z) +\nsh[6] * ((3.0 * normal.z * normal.z) - 1.0) +\nsh[7] * (normal.z * normal.x) +\nsh[8] * (normal.x * normal.x - (normal.y * normal.y));\n}\n\n// https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Vendor/EXT_lights_image_based/README.md#rgbd\nvec3 decodeRGBD(in vec4 color){\nreturn color.rgb / color.a;\n}\n\nvec3 getIBLContribution(in vec3 N, in vec3 V, vec3 diffuseColor, vec3 specularColor, float ao, float NdotV, float perceptualRoughness) {\nvec3 color = vec3(.0, .0, .0);\n#ifdef HILO_NEED_WORLD_NORMAL\nN = u_viewInverseNormalMatrix * N;\nV = u_viewInverseNormalMatrix * V;\n#endif\n#if defined(HILO_DIFFUSE_ENV_MAP) || defined(HILO_DIFFUSE_ENV_SPHERE_HARMONICS3)\n#ifdef HILO_DIFFUSE_ENV_MAP\n#ifdef HILO_GAMMA_CORRECTION\nvec3 diffuseLight = sRGBToLinear(textureEnvMap(u_diffuseEnvMap, N)).rgb;\n#else\nvec3 diffuseLight = textureEnvMap(u_diffuseEnvMap, N).rgb;\n#endif\n#elif defined(HILO_DIFFUSE_ENV_SPHERE_HARMONICS3)\nvec3 diffuseLight = computeDiffuseSHLight(N, u_diffuseEnvSphereHarmonics3);\n#endif\ncolor.rgb += diffuseLight * diffuseColor * ao * u_diffuseEnvIntensity;\n#endif\n\n#ifdef HILO_SPECULAR_ENV_MAP\nvec3 R = -normalize(reflect(V, N));\nvec3 brdf = texture2D(u_brdfLUT, vec2(NdotV, 1.0 - perceptualRoughness)).rgb;\n#ifdef HILO_USE_SHADER_TEXTURE_LOD\nfloat lod = clamp(perceptualRoughness * u_specularEnvMapMipCount, 0.0, u_specularEnvMapMipCount);\nvec4 specularEnvMap = textureEnvMapLod(u_specularEnvMap, R, lod);\n#else\nvec4 specularEnvMap = textureEnvMap(u_specularEnvMap, R);\n#endif\n\nvec3 specularLight = decodeRGBD(specularEnvMap);\n\n#ifdef HILO_GAMMA_CORRECTION\nspecularLight = sRGBToLinear(specularLight);\n#endif\ncolor.rgb += specularLight * (specularColor * brdf.x + brdf.y) * u_specularEnvIntensity;\n#endif\nreturn color;\n}\n\nvec3 calculateLo(vec3 N, vec3 V, vec3 L, vec3 reflectance0, vec3 reflectance90, float alphaRoughness, vec3 diffuseColor, float NdotV) {\nvec3 H = normalize(L + V);\nfloat NdotL = clamp(dot(N, L), 0.001, 1.0);\nfloat NdotH = clamp(dot(N, H), 0.0, 1.0);\nfloat LdotH = clamp(dot(L, H), 0.0, 1.0);\nfloat VdotH = clamp(dot(V, H), 0.0, 1.0);\n// Calculate the shading terms for the microfacet specular shading model\nvec3 F = specularReflection(reflectance0, reflectance90, VdotH);\nfloat G = geometricOcclusion(NdotL, NdotV, alphaRoughness);\nfloat D = microfacetDistribution(alphaRoughness, NdotH);\n\nvec3 diffuseContrib;\n\n#ifdef HILO_LIGHT_MAP\ndiffuseContrib = vec3(0.0);\n#else\ndiffuseContrib = (1.0 - F) * diffuse(diffuseColor);\n#endif\nvec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);\n// Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\nreturn NdotL * (diffuseContrib + specContrib);\n}\n#endif";

/***/ }),

/***/ "./src/shader/chunk/pbr_main.frag":
/*!****************************************!*\
  !*** ./src/shader/chunk/pbr_main.frag ***!
  \****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\nvec4 baseColor = u_baseColor;\n\n#ifdef HILO_BASE_COLOR_MAP\n#ifdef HILO_GAMMA_CORRECTION\nbaseColor *= sRGBToLinear(HILO_TEXTURE_2D(u_baseColorMap));\n#else\nbaseColor *= HILO_TEXTURE_2D(u_baseColorMap);\n#endif\n#endif\n\n#if defined(HILO_HAS_COLOR)\nbaseColor *= v_color;\n#endif\n\ncolor.a = baseColor.a;\n\n" + __webpack_require__(/*! ./transparency_main.frag */ "./src/shader/chunk/transparency_main.frag") + "\n\n#ifdef HILO_HAS_LIGHT\nvec3 viewPos = vec3(0, 0, 0);\nvec3 N = normal;\nvec3 V = normalize(viewPos - v_fragPos);\n\n#ifdef HILO_OCCLUSION_MAP\nfloat ao  = HILO_TEXTURE_2D(u_occlusionMap).r;\n#else\nfloat ao = 1.0;\n#endif\n\n#ifdef HILO_PBR_SPECULAR_GLOSSINESS\nvec3 specular = u_specular.rgb;\nfloat glossiness = u_glossiness;\n#ifdef HILO_SPECULAR_GLOSSINESS_MAP\nvec4 specularGlossiness = sRGBToLinear(HILO_TEXTURE_2D(u_specularGlossinessMap));\nspecular = specularGlossiness.rgb * specular;\nglossiness = specularGlossiness.a * glossiness;\n#endif\nfloat roughness = 1.0 - glossiness;\nfloat metallic = 0.0;\nvec3 diffuseColor = baseColor.rgb * (1.0 - max(max(specular.r, specular.g), specular.b));\nvec3 specularColor = specular;\n#else\nfloat metallic = u_metallic;\nfloat roughness = u_roughness;\n#ifdef HILO_METALLIC_MAP\nmetallic = HILO_TEXTURE_2D(u_metallicMap).r * u_metallic;\n#endif\n#ifdef HILO_ROUGHNESS_MAP\nroughness  = HILO_TEXTURE_2D(u_roughnessMap).r * u_roughness;\n#endif\n#ifdef HILO_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughnessMap = HILO_TEXTURE_2D(u_metallicRoughnessMap);\n#ifdef HILO_IS_OCCLUSION_MAP_IN_METALLIC_ROUGHNESS_MAP\nao = metallicRoughnessMap.r;\n#endif\nroughness = metallicRoughnessMap.g * u_roughness;\nmetallic = metallicRoughnessMap.b * u_metallic;\n#endif\nroughness = clamp(roughness, 0.04, 1.0);\nmetallic = clamp(metallic, 0.0, 1.0);\nvec3 f0 = vec3(0.04);\nvec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\ndiffuseColor *= 1.0 - metallic;\nvec3 specularColor = mix(f0, baseColor.rgb, metallic);\n#endif\n\n#ifdef HILO_OCCLUSION_STRENGTH\nao = mix(1.0, ao, u_occlusionStrength);\n#endif\n\nfloat reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n// For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n// For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\nfloat reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\nvec3 specularEnvironmentR0 = specularColor.rgb;\nvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\nfloat NdotV = clamp(abs(dot(N, V)), 0.001, 1.0);\nfloat alphaRoughness = roughness * roughness;\n\n#ifdef HILO_DIRECTIONAL_LIGHTS\nfor(int i = 0;i < HILO_DIRECTIONAL_LIGHTS;i++){\nvec3 lightDir = normalize(-u_directionalLightsInfo[i]);\nvec3 radiance = u_directionalLightsColor[i];\nfloat shadow = 1.0;\n#ifdef HILO_DIRECTIONAL_LIGHTS_SMC\nif (i < HILO_DIRECTIONAL_LIGHTS_SMC) {\nfloat bias = HILO_MAX(u_directionalLightsShadowBias[i][1] * (1.0 - dot(N, lightDir)), u_directionalLightsShadowBias[i][0]);\nshadow = getShadow(u_directionalLightsShadowMap[i], u_directionalLightsShadowMapSize[i], bias, v_fragPos, u_directionalLightSpaceMatrix[i]);\n}\n#endif\ncolor.rgb += shadow * radiance * calculateLo(N, V, lightDir, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, NdotV);\n}\n#endif\n\n#ifdef HILO_SPOT_LIGHTS\nfor(int i = 0; i < HILO_SPOT_LIGHTS; i++){\nvec3 lightDir = normalize(-u_spotLightsDir[i]);\nvec3 distanceVec = u_spotLightsPos[i] - v_fragPos;\n\nfloat theta = dot(normalize(distanceVec), lightDir);\nfloat epsilon = u_spotLightsCutoffs[i][0] - u_spotLightsCutoffs[i][1];\nfloat intensity = clamp((theta - u_spotLightsCutoffs[i][1]) / epsilon, 0.0, 1.0);\nfloat attenuation = getLightAttenuation(distanceVec, u_spotLightsInfo[i], u_spotLightsRange[i]);\nvec3 radiance = intensity * attenuation * u_spotLightsColor[i];\n\nfloat shadow = 1.0;\n#ifdef HILO_SPOT_LIGHTS_SMC\nif (i < HILO_SPOT_LIGHTS_SMC) {\nfloat bias = HILO_MAX(u_spotLightsShadowBias[i][1] * (1.0 - dot(N, lightDir)), u_spotLightsShadowBias[i][0]);\nshadow = getShadow(u_spotLightsShadowMap[i], u_spotLightsShadowMapSize[i], bias, v_fragPos, u_spotLightSpaceMatrix[i]);\n}\n#endif\ncolor.rgb += shadow * radiance * calculateLo(N, V, lightDir, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, NdotV);\n}\n#endif\n\n#ifdef HILO_POINT_LIGHTS\nfor(int i = 0; i < HILO_POINT_LIGHTS; i++){\nvec3 distanceVec = u_pointLightsPos[i] - v_fragPos;\nvec3 lightDir = normalize(distanceVec);\n\nfloat shadow = 1.0;\n#ifdef HILO_POINT_LIGHTS_SMC\nif (i < HILO_POINT_LIGHTS_SMC) {\nfloat bias = HILO_MAX(u_pointLightsShadowBias[i][1] * (1.0 - dot(normal, lightDir)), u_pointLightsShadowBias[i][0]);\nshadow = getShadow(u_pointLightsShadowMap[i], bias, u_pointLightsPos[i], v_fragPos, u_pointLightCamera[i], u_pointLightSpaceMatrix[i]);\n}\n#endif\n\nfloat attenuation = getLightAttenuation(distanceVec, u_pointLightsInfo[i], u_pointLightsRange[i]);\nvec3 radiance = attenuation * u_pointLightsColor[i];\n\ncolor.rgb += shadow * radiance * calculateLo(N, V, lightDir, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, NdotV);\n}\n#endif\n\n#ifdef HILO_AREA_LIGHTS\nfor(int i = 0; i < HILO_AREA_LIGHTS; i++){\ncolor.rgb += getAreaLight(diffuseColor, specularColor, roughness, N, V, v_fragPos, u_areaLightsPos[i], u_areaLightsColor[i], u_areaLightsWidth[i], u_areaLightsHeight[i], u_areaLightsLtcTexture1, u_areaLightsLtcTexture2);\n}\n#endif\n\n#ifdef HILO_LIGHT_MAP\nvec4 lightMapColor = HILO_TEXTURE_2D(u_lightMap);\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_lights_image_based#rgbd\ncolor.rgb += baseColor.rgb * decodeRGBD(lightMapColor);\n#endif\n\n// IBL\ncolor.rgb += getIBLContribution(N, V, diffuseColor, specularColor, ao, NdotV, roughness);\n\n#if defined(HILO_AMBIENT_LIGHTS) && (defined(HILO_IS_DIFFUESENV_AND_AMBIENTLIGHT_WORK_TOGETHER) || (!defined(HILO_DIFFUSE_ENV_MAP) && !defined(HILO_DIFFUSE_ENV_SPHERE_HARMONICS3)))\ncolor.rgb += u_ambientLightsColor * baseColor.rgb * ao;\n#endif\n\n#ifdef HILO_EMISSION_MAP\n#ifdef HILO_GAMMA_CORRECTION\ncolor.rgb += sRGBToLinear(HILO_TEXTURE_2D(u_emission)).rgb;\n#else\ncolor.rgb += HILO_TEXTURE_2D(u_emission).rgb;\n#endif\n#endif\n#else\ncolor = baseColor;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/phong.frag":
/*!*************************************!*\
  !*** ./src/shader/chunk/phong.frag ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n" + __webpack_require__(/*! ../method/textureEnvMap.glsl */ "./src/shader/method/textureEnvMap.glsl") + "\n" + __webpack_require__(/*! ./fixMathCrash.glsl */ "./src/shader/chunk/fixMathCrash.glsl") + "\n\n#ifdef HILO_HAS_LIGHT\n#ifdef HILO_HAS_SPECULAR\nuniform float u_shininess;\n#ifdef HILO_SPECULAR_MAP\nuniform HILO_SAMPLER_2D u_specular;\n#else\nuniform vec4 u_specular;\n#endif\n#endif\n#ifdef HILO_EMISSION_MAP\nuniform HILO_SAMPLER_2D u_emission;\n#else\nuniform vec4 u_emission;\n#endif\n#ifdef HILO_AMBIENT_MAP\nuniform HILO_SAMPLER_2D u_ambient;\n#endif\n#ifdef HILO_SPECULAR_ENV_MAP\n#ifdef HILO_SPECULAR_ENV_MAP_CUBE\nuniform samplerCube u_specularEnvMap;\n#else\nuniform sampler2D u_specularEnvMap;\n#endif\nuniform mat4 u_specularEnvMatrix;\nuniform float u_reflectivity;\nuniform float u_refractRatio;\nuniform float u_refractivity;\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/phong_main.frag":
/*!******************************************!*\
  !*** ./src/shader/chunk/phong_main.frag ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_LIGHT\nvec3 lightDiffuse = vec3(0, 0, 0);\nvec3 lightAmbient = vec3(0, 0, 0);\nvec3 viewPos = vec3(0, 0, 0);\n\n#ifdef HILO_AMBIENT_MAP\nlightAmbient = HILO_TEXTURE_2D(u_ambient).rgb;\n#else\nlightAmbient = diffuse.rgb;\n#endif\n\n#ifdef HILO_HAS_SPECULAR\nvec3 lightSpecular = vec3(0, 0, 0);\n#ifdef HILO_SPECULAR_MAP\nvec4 specular = HILO_TEXTURE_2D(u_specular);\n#else\nvec4 specular = u_specular;\n#endif\n#endif\n\n#ifdef HILO_EMISSION_MAP\nvec4 emission = HILO_TEXTURE_2D(u_emission);\n#else\nvec4 emission = u_emission;\n#endif\n\n#ifdef HILO_DIRECTIONAL_LIGHTS\nfor(int i = 0;i < HILO_DIRECTIONAL_LIGHTS;i++){\nvec3 lightDir = -u_directionalLightsInfo[i];\n\nfloat shadow = 1.0;\n#ifdef HILO_DIRECTIONAL_LIGHTS_SMC\nif (i < HILO_DIRECTIONAL_LIGHTS_SMC) {\nfloat bias = HILO_MAX(u_directionalLightsShadowBias[i][1] * (1.0 - dot(normal, lightDir)), u_directionalLightsShadowBias[i][0]);\nshadow = getShadow(u_directionalLightsShadowMap[i], u_directionalLightsShadowMapSize[i], bias, v_fragPos, u_directionalLightSpaceMatrix[i]);\n}\n#endif\n\nfloat diff = getDiffuse(normal, lightDir);\nlightDiffuse += diff * u_directionalLightsColor[i] * shadow;\n\n#ifdef HILO_HAS_SPECULAR\nfloat spec = getSpecular(viewPos, v_fragPos, lightDir, normal, u_shininess);\nlightSpecular += spec * u_directionalLightsColor[i] * shadow;\n#endif\n}\n#endif\n\n#ifdef HILO_SPOT_LIGHTS\nfor(int i = 0; i < HILO_SPOT_LIGHTS; i++){\nvec3 lightDir = -u_spotLightsDir[i];\nvec3 distanceVec = u_spotLightsPos[i] - v_fragPos;\n\nfloat shadow = 1.0;\n#ifdef HILO_SPOT_LIGHTS_SMC\nif (i < HILO_SPOT_LIGHTS_SMC) {\nfloat bias = HILO_MAX(u_spotLightsShadowBias[i][1] * (1.0 - dot(normal, lightDir)), u_spotLightsShadowBias[i][0]);\nshadow = getShadow(u_spotLightsShadowMap[i], u_spotLightsShadowMapSize[i], bias, v_fragPos, u_spotLightSpaceMatrix[i]);\n}\n#endif\n\nfloat diff = getDiffuse(normal, normalize(distanceVec));\nfloat theta = dot(normalize(distanceVec), lightDir);\nfloat epsilon = u_spotLightsCutoffs[i][0] - u_spotLightsCutoffs[i][1];\nfloat intensity = clamp((theta - u_spotLightsCutoffs[i][1]) / epsilon, 0.0, 1.0);\nfloat attenuation = getLightAttenuation(distanceVec, u_spotLightsInfo[i], u_spotLightsRange[i]);\n\nlightDiffuse += intensity * attenuation * shadow * diff * u_spotLightsColor[i];\n\n#ifdef HILO_HAS_SPECULAR\nfloat spec = getSpecular(viewPos, v_fragPos, lightDir, normal, u_shininess);\nlightSpecular += intensity * attenuation * shadow * spec * u_spotLightsColor[i];\n#endif\n}\n#endif\n\n#ifdef HILO_POINT_LIGHTS\nfor(int i = 0;i < HILO_POINT_LIGHTS;i++){\nvec3 distanceVec = u_pointLightsPos[i] - v_fragPos;\nvec3 lightDir = normalize(distanceVec);\n\nfloat shadow = 1.0;\n#ifdef HILO_POINT_LIGHTS_SMC\nif (i < HILO_POINT_LIGHTS_SMC) {\nfloat bias = HILO_MAX(u_pointLightsShadowBias[i][1] * (1.0 - dot(normal, lightDir)), u_pointLightsShadowBias[i][0]);\nshadow = getShadow(u_pointLightsShadowMap[i], bias, u_pointLightsPos[i], v_fragPos, u_pointLightCamera[i], u_pointLightSpaceMatrix[i]);\n}\n#endif\n\nfloat diff = getDiffuse(normal, lightDir);\nfloat attenuation = getLightAttenuation(distanceVec, u_pointLightsInfo[i], u_pointLightsRange[i]);\nlightDiffuse += diff * attenuation * u_pointLightsColor[i] * shadow;\n\n#ifdef HILO_HAS_SPECULAR\nfloat spec = getSpecular(viewPos, v_fragPos, lightDir, normal, u_shininess);\nlightSpecular += spec * attenuation * u_pointLightsColor[i] * shadow;\n#endif\n}\n#endif\n\n#ifdef HILO_AREA_LIGHTS\n#ifndef HILO_HAS_SPECULAR\nvec4 specular = vec4(0.0, 0.0, 0.0, 0.0);\n#endif\nvec3 viewDir = normalize(vec3(0, 0, 0) - v_fragPos);\nfor(int i = 0; i < HILO_AREA_LIGHTS; i++){\ncolor.rgb += getAreaLight(diffuse.rgb, specular.rgb, sqrt(2.0/(u_shininess+2.0)), normal, viewDir, v_fragPos, u_areaLightsPos[i], u_areaLightsColor[i], u_areaLightsWidth[i], u_areaLightsHeight[i], u_areaLightsLtcTexture1, u_areaLightsLtcTexture2);\n}\n#endif\n\n#ifdef HILO_AMBIENT_LIGHTS\ncolor.rgb += u_ambientLightsColor * lightAmbient;\n#endif\n\n#if defined(HILO_SPECULAR_ENV_MAP) && defined(HILO_HAS_SPECULAR)\nvec3 I = normalize(v_fragPos - viewPos);\nif (u_reflectivity > 0.0) {\nvec3 R = reflect(I, normal);\nR = normalize(vec3(u_specularEnvMatrix * vec4(R, 1.0)));\nlightSpecular += textureEnvMap(u_specularEnvMap, R).rgb * u_reflectivity;\n}\nif (u_refractivity > 0.0) {\nvec3 R = refract(I, normal, u_refractRatio);\nR = normalize(vec3(u_specularEnvMatrix * vec4(R, 1.0)));\nlightSpecular += textureEnvMap(u_specularEnvMap, R).rgb * u_refractivity;\n}\n#endif\n\ncolor.rgb += lightDiffuse * diffuse.rgb;\n#ifdef HILO_HAS_SPECULAR\ncolor.rgb += lightSpecular * specular.rgb;\n#endif\n\ncolor.rgb += emission.rgb;\n#else\ncolor = diffuse;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/precision.frag":
/*!*****************************************!*\
  !*** ./src/shader/chunk/precision.frag ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_ES\nprecision HILO_MAX_FRAGMENT_PRECISION float;\n#define GLSLIFY 1\n#endif";

/***/ }),

/***/ "./src/shader/chunk/precision.vert":
/*!*****************************************!*\
  !*** ./src/shader/chunk/precision.vert ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#ifdef GL_ES\nprecision HILO_MAX_VERTEX_PRECISION float;\n#define GLSLIFY 1\n#endif";

/***/ }),

/***/ "./src/shader/chunk/transparency.frag":
/*!********************************************!*\
  !*** ./src/shader/chunk/transparency.frag ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_TRANSPARENCY_MAP\nuniform HILO_SAMPLER_2D u_transparency;\n#else\nuniform float u_transparency;\n#endif\n\n#ifdef HILO_ALPHA_CUTOFF\nuniform float u_alphaCutoff;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/transparency_main.frag":
/*!*************************************************!*\
  !*** ./src/shader/chunk/transparency_main.frag ***!
  \*************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nfloat transparency = 1.0;\n#ifdef HILO_TRANSPARENCY_MAP\ntransparency = HILO_TEXTURE_2D(u_transparency).r;\n#else\ntransparency = u_transparency;\n#endif\ncolor.a *= transparency;\n#ifdef HILO_ALPHA_CUTOFF\nif (color.a < u_alphaCutoff) {\ndiscard;\n} else {\ncolor.a = 1.0;\n}\n#endif";

/***/ }),

/***/ "./src/shader/chunk/unQuantize.vert":
/*!******************************************!*\
  !*** ./src/shader/chunk/unQuantize.vert ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_QUANTIZED\n#ifdef HILO_POSITION_QUANTIZED\nuniform mat4 u_positionDecodeMat;\n#endif\n#ifdef HILO_NORMAL_QUANTIZED\nuniform mat4 u_normalDecodeMat;\n#endif\n#ifdef HILO_UV_QUANTIZED\nuniform mat3 u_uvDecodeMat;\n#endif\n#ifdef HILO_UV1_QUANTIZED\nuniform mat3 u_uv1DecodeMat;\n#endif\n\nvec2 unQuantize(vec2 data, mat3 decodeMat) {\nvec3 result = vec3(data, 1.0);\nresult = decodeMat * result;\nreturn result.xy;\n}\n\nvec3 unQuantize(vec3 data, mat4 decodeMat) {\nvec4 result = vec4(data, 1.0);\nresult = decodeMat * result;\nreturn result.xyz;\n}\n#endif";

/***/ }),

/***/ "./src/shader/chunk/unQuantize_main.vert":
/*!***********************************************!*\
  !*** ./src/shader/chunk/unQuantize_main.vert ***!
  \***********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_QUANTIZED\n#ifdef HILO_POSITION_QUANTIZED\npos.xyz = unQuantize(pos.xyz, u_positionDecodeMat);\n#endif\n#if defined(HILO_HAS_TEXCOORD0) && defined(HILO_UV_QUANTIZED)\nuv = unQuantize(uv, u_uvDecodeMat);\n#endif\n#if defined(HILO_HAS_TEXCOORD1) && defined(HILO_UV1_QUANTIZED)\nuv1 = unQuantize(uv1, u_uv1DecodeMat);\n#endif\n#if defined(HILO_HAS_NORMAL) && defined(HILO_NORMAL_QUANTIZED)\nnormal = unQuantize(normal, u_normalDecodeMat);\n#endif\n#endif";

/***/ }),

/***/ "./src/shader/chunk/uv.frag":
/*!**********************************!*\
  !*** ./src/shader/chunk/uv.frag ***!
  \**********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_TEXCOORD0\nvarying vec2 v_texcoord0;\n#endif\n\n#ifdef HILO_HAS_TEXCOORD1\nvarying vec2 v_texcoord1;\n#endif\n\n#if defined(HILO_HAS_TEXCOORD0) || defined(HILO_HAS_TEXCOORD1)\n#if defined(HILO_HAS_TEXCOORD0) && defined(HILO_HAS_TEXCOORD1)\n#define HILO_SAMPLER_2D hiloSampler2D\n// https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Opaque_types\n#define HILO_TEXTURE_2D(HILO_SAMPLER_2D)  hiloTexture2D(HILO_SAMPLER_2D.texture, HILO_SAMPLER_2D.uv)\nstruct hiloSampler2D{\nsampler2D texture;\nint uv; \n};\n\nvec4 hiloTexture2D(sampler2D texture, int uv){\nif(uv == 0){\nreturn texture2D(texture, v_texcoord0);\n}\nelse{\nreturn texture2D(texture, v_texcoord1);\n}\n}\n#else\n#ifdef HILO_HAS_TEXCOORD1\n#define HILO_V_TEXCOORD v_texcoord1\n#else\n#define HILO_V_TEXCOORD v_texcoord0\n#endif\n#define HILO_SAMPLER_2D sampler2D\n#define HILO_TEXTURE_2D(HILO_SAMPLER_2D)  texture2D(HILO_SAMPLER_2D, HILO_V_TEXCOORD)\n#endif\n#endif\n\n\n#ifdef HILO_DIFFUSE_CUBE_MAP\nvarying vec3 v_position;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/uv.vert":
/*!**********************************!*\
  !*** ./src/shader/chunk/uv.vert ***!
  \**********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_TEXCOORD0\nattribute vec2 a_texcoord0;\nvarying vec2 v_texcoord0;\n#ifdef HILO_UV_MATRIX\nuniform mat3 u_uvMatrix;\n#endif\n#endif\n\n#ifdef HILO_HAS_TEXCOORD1\nattribute vec2 a_texcoord1;\nvarying vec2 v_texcoord1;\n#ifdef HILO_UV_MATRIX1\nuniform mat3 u_uvMatrix1;\n#endif\n#endif\n\n#ifdef HILO_DIFFUSE_CUBE_MAP\nvarying vec3 v_position;\n#endif";

/***/ }),

/***/ "./src/shader/chunk/uv_main.vert":
/*!***************************************!*\
  !*** ./src/shader/chunk/uv_main.vert ***!
  \***************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n#ifdef HILO_HAS_TEXCOORD0\n#ifdef HILO_UV_MATRIX\nv_texcoord0 = (u_uvMatrix * vec3(uv, 1.0)).xy;\n#else\nv_texcoord0 = uv;\n#endif\n#endif\n#ifdef HILO_HAS_TEXCOORD1\n#ifdef HILO_UV_MATRIX1\nv_texcoord1 = (u_uvMatrix1 * vec3(uv1, 1.0)).xy;\n#else\nv_texcoord1 = uv1;\n#endif\n#endif\n#ifdef HILO_DIFFUSE_CUBE_MAP\nv_position = pos.xyz;\n#endif";

/***/ }),

/***/ "./src/shader/geometry.frag":
/*!**********************************!*\
  !*** ./src/shader/geometry.frag ***!
  \**********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n" + __webpack_require__(/*! ./chunk/extensions.frag */ "./src/shader/chunk/extensions.frag") + "\n" + __webpack_require__(/*! ./chunk/baseDefine.glsl */ "./src/shader/chunk/baseDefine.glsl") + "\n" + __webpack_require__(/*! ./chunk/precision.frag */ "./src/shader/chunk/precision.frag") + "\n\n#if defined(HILO_VERTEX_TYPE_POSITION)\nvarying vec3 v_fragPos;\n#elif defined(HILO_VERTEX_TYPE_NORMAL)\nvarying vec3 v_normal;\n#elif defined(HILO_VERTEX_TYPE_DEPTH)\nuniform float u_cameraFar;\nuniform float u_cameraNear;\nuniform float u_cameraType;\n#elif defined(HILO_VERTEX_TYPE_DISTANCE)\n" + __webpack_require__(/*! ./method/packFloat.glsl */ "./src/shader/method/packFloat.glsl") + "\n\nuniform float u_cameraFar;\nuniform float u_cameraNear;\nvarying vec3 v_fragPos;\n#endif\n\nvec4 transformDataToColor(vec3 data){\n#ifdef HILO_WRITE_ORIGIN_DATA\nreturn vec4(data, 1.0);\n#else\nreturn vec4(data * 0.5 + 0.5, 1.0);\n#endif\n}\n\n" + __webpack_require__(/*! ./chunk/logDepth.frag */ "./src/shader/chunk/logDepth.frag") + "\n\nvoid main(void) {\n#if defined(HILO_VERTEX_TYPE_POSITION)\ngl_FragColor = transformDataToColor(v_fragPos);\n#elif defined(HILO_VERTEX_TYPE_NORMAL)\ngl_FragColor = transformDataToColor(v_normal);\n#elif defined(HILO_VERTEX_TYPE_DEPTH)\nfloat z;\n#ifdef HILO_WRITE_ORIGIN_DATA\nz = gl_FragCoord.z;\n#else\n// OrthographicCamera\nif(u_cameraType < 1.0){\nz = gl_FragCoord.z;\n}\n// PerspectiveCamera\nelse{\nz = gl_FragCoord.z * 2.0 - 1.0;\nz = (2.0 * u_cameraNear * u_cameraFar) / (u_cameraFar + u_cameraNear - z * (u_cameraFar - u_cameraNear));\n}\n#endif\ngl_FragColor = vec4(z, z, z, 1.0);\n#elif defined(HILO_VERTEX_TYPE_DISTANCE)\nfloat distance = length(v_fragPos);\n#ifdef HILO_WRITE_ORIGIN_DATA\ngl_FragColor = vec4(distance, distance, distance, 1.0);\n#else\ngl_FragColor = packFloat((distance - u_cameraNear)/(u_cameraFar - u_cameraNear));\n#endif\n#endif\n" + __webpack_require__(/*! ./chunk/logDepth_main.frag */ "./src/shader/chunk/logDepth_main.frag") + "\n}";

/***/ }),

/***/ "./src/shader/method/encoding.glsl":
/*!*****************************************!*\
  !*** ./src/shader/method/encoding.glsl ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nvec4 sRGBToLinear( in vec4 value ) {\nreturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\n\nvec3 sRGBToLinear( in vec3 value ) {\nreturn vec3( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ));\n}\n\n";

/***/ }),

/***/ "./src/shader/method/getAreaLight.glsl":
/*!*********************************************!*\
  !*** ./src/shader/method/getAreaLight.glsl ***!
  \*********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n// modified from https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl#L26\n\n" + __webpack_require__(/*! ../method/transpose.glsl */ "./src/shader/method/transpose.glsl") + "\n\nvec2 LTC_Uv(const in vec3 N, const in vec3 V, const in float roughness) {\nconst float LUT_SIZE = 64.0;\nconst float LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;\nconst float LUT_BIAS = 0.5 / LUT_SIZE;\nfloat dotNV = clamp(dot(N, V), 0.0, 1.0);\nvec2 uv = vec2(roughness, sqrt(1.0 - dotNV));\nuv = (uv * LUT_SCALE) + LUT_BIAS;\nreturn uv;\n}\n\nfloat LTC_ClippedSphereFormFactor(const in vec3 f) {\nfloat l = length(f);\nreturn max(((l * l) + f.z) / (l + 1.0), 0.0);\n}\n\nvec3 LTC_EdgeVectorFormFactor(const in vec3 v1, const in vec3 v2) {\nfloat x = dot(v1, v2);\nfloat y = abs(x);\nfloat a = 0.8543985 + ((0.4965155 + (0.0145206 * y)) * y);\nfloat b = 3.4175940 + ((4.1616724 + y) * y);\nfloat v = a / b;\nfloat theta_sintheta = x > 0.0 ? v : (0.5 * inversesqrt(max(1.0 - (x * x), 1e-7))) - v;\nreturn cross(v1, v2) * theta_sintheta;\n}\n\nvec3 LTC_Evaluate(const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[4]) {\nvec3 v1 = rectCoords[1] - rectCoords[0];\nvec3 v2 = rectCoords[3] - rectCoords[0];\nvec3 lightNormal = cross(v1, v2);\nif (dot(lightNormal, P - rectCoords[0]) < 0.0)\nreturn vec3(0.0);\nvec3 T1, T2;\nT1 = normalize(V - (N * dot(V, N)));\nT2 = -cross(N, T1);\nmat3 mat = mInv * transpose(mat3(T1, T2, N));\nvec3 coords[4];\ncoords[0] = mat * (rectCoords[0] - P);\ncoords[1] = mat * (rectCoords[1] - P);\ncoords[2] = mat * (rectCoords[2] - P);\ncoords[3] = mat * (rectCoords[3] - P);\ncoords[0] = normalize(coords[0]);\ncoords[1] = normalize(coords[1]);\ncoords[2] = normalize(coords[2]);\ncoords[3] = normalize(coords[3]);\nvec3 vectorFormFactor = vec3(0.0);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[0], coords[1]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[1], coords[2]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[2], coords[3]);\nvectorFormFactor += LTC_EdgeVectorFormFactor(coords[3], coords[0]);\nfloat result = LTC_ClippedSphereFormFactor(vectorFormFactor);\nreturn vec3(result);\n}\n\nvec3 getAreaLight(const in vec3 diffuseColor, const in vec3 specularColor, const in float roughness, const in vec3 normal, const in vec3 viewDir, const in vec3 position, const in vec3 lightPos, const in vec3 lightColor, const in vec3 halfWidth, const in vec3 halfHeight, const in sampler2D areaLightsLtcTexture1, const in sampler2D areaLightsLtcTexture2){\nvec3 rectCoords[4];\nrectCoords[0] = (lightPos - halfWidth) - halfHeight;\nrectCoords[1] = (lightPos + halfWidth) - halfHeight;\nrectCoords[2] = (lightPos + halfWidth) + halfHeight;\nrectCoords[3] = (lightPos - halfWidth) + halfHeight;\n\nvec2 uv = LTC_Uv(normal, viewDir, roughness);\nvec4 t1 = texture2D(areaLightsLtcTexture1, uv);\nvec4 t2 = texture2D(areaLightsLtcTexture2, uv);\n\nmat3 mInv = mat3(vec3(t1.x, 0, t1.y), vec3(0, 1, 0), vec3(t1.z, 0, t1.w));\nvec3 fresnel = (specularColor * t2.x) + ((vec3(1.0) - specularColor) * t2.y);\n\nvec3 color = vec3(0.0, 0.0, 0.0);\ncolor += ((lightColor * fresnel) * LTC_Evaluate(normal, viewDir, position, mInv, rectCoords));\ncolor += ((lightColor * diffuseColor) * LTC_Evaluate(normal, viewDir, position, mat3(1.0), rectCoords));\nreturn color;\n}\n\n";

/***/ }),

/***/ "./src/shader/method/getDiffuse.glsl":
/*!*******************************************!*\
  !*** ./src/shader/method/getDiffuse.glsl ***!
  \*******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nfloat getDiffuse(vec3 normal, vec3 lightDir){\nreturn max(dot(normal, lightDir), 0.0);\n}\n\n";

/***/ }),

/***/ "./src/shader/method/getLightAttenuation.glsl":
/*!****************************************************!*\
  !*** ./src/shader/method/getLightAttenuation.glsl ***!
  \****************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nfloat getLightAttenuation(vec3 distanceVec, vec3 info, float range){\nfloat distance = length(distanceVec);\nfloat attenuation = 1.0;\n#ifdef HILO_USE_PHYSICS_LIGHT\nattenuation = max(1.0 / (distance * distance), 0.001);\nif (range > 0.0) {\nattenuation *= max(min(1.0 - pow( distance / range, 4.0 ), 1.0), 0.0);\n}\n#else\nattenuation = 1.0/(info.x + info.y * distance + info.z * distance * distance);\n#endif\n\nreturn attenuation;\n}\n\n";

/***/ }),

/***/ "./src/shader/method/getShadow.glsl":
/*!******************************************!*\
  !*** ./src/shader/method/getShadow.glsl ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nbool isOutOfRange(vec2 pos) {\nif (pos.x < 0.0 || pos.x > 1.0 || pos.y < 0.0 || pos.y > 1.0) {\nreturn true;\n}\nreturn false;\n}\n\nfloat getShadow(sampler2D shadowMap, vec2 shadowMapSize, float bias, vec3 fragPos, mat4 lightSpaceMatrix) {\nvec4 fragPosLightSpace = lightSpaceMatrix * vec4(fragPos, 1.0);\nvec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;\nprojCoords = projCoords * 0.5 + 0.5;\nif (isOutOfRange(projCoords.xy)) {\nreturn 1.0;\n}\nfloat currentDepth = projCoords.z;\nfloat shadow = 0.0;\nvec2 texelSize = 1.0 / shadowMapSize;\nfor (int x = -1; x <= 1; ++x) {\nfor (int y = -1; y <= 1; ++y) {\nvec2 pos = projCoords.xy + vec2(x, y) * texelSize;\nif (isOutOfRange(pos)) {\nshadow += 1.0;\n} else {\nfloat pcfDepth = texture2D(shadowMap, pos).r;\nshadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;\n}\n}\n}\nreturn 1.0 - shadow / 9.0;\n}\n\nfloat getShadow(samplerCube shadowMap, float bias, vec3 lightPos, vec3 position, vec2 camera, mat4 lightSpaceMatrix) {\nvec4 distanceVec = lightSpaceMatrix * vec4(position, 1.0) - lightSpaceMatrix * vec4(lightPos, 1.0);\nfloat currentDistance = length(distanceVec);\nvec3 direction = normalize(distanceVec).xyz;\n\nfloat shadow = 0.0;\nconst float samples = 2.0;\nconst float offset = 0.01;\nconst float step = offset / (samples * 0.5);\nfor(float x = -offset; x < offset; x +=step)\n{\nfor(float y = -offset; y < offset; y +=step)\n{\nfor(float z = -offset; z < offset; z +=step)\n{\nfloat closestDistance = camera[0] + (camera[1] - camera[0]) * unpackFloat(textureCube(shadowMap, direction + vec3(x, y, z)));\nif (closestDistance == camera[0]) {\ncontinue;\n}\nelse if(currentDistance - bias > closestDistance)\nshadow += 1.0;\n}\n}\n}\nshadow /= (samples * samples * samples);\n\nreturn 1.0 - shadow;\n}\n\n";

/***/ }),

/***/ "./src/shader/method/getSpecular.glsl":
/*!********************************************!*\
  !*** ./src/shader/method/getSpecular.glsl ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nfloat getSpecular(vec3 cameraPos, vec3 fragPos, vec3 lightDir, vec3 normal, float shininess){\nvec3 viewDir = normalize(cameraPos - fragPos);\n#ifdef LIGHT_TYPE_PHONG\nreturn pow(max(dot(viewDir, reflect(-lightDir, normal), 0.0), shininess);\n#else\nreturn pow(max(dot(normal, normalize(lightDir + viewDir)), 0.0), shininess);\n#endif\n}\n\n";

/***/ }),

/***/ "./src/shader/method/packFloat.glsl":
/*!******************************************!*\
  !*** ./src/shader/method/packFloat.glsl ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\n// https://github.com/playcanvas/engine/blob/master/src/graphics/program-lib/chunks/packDepth.frag\n// Packing a float in GLSL with multiplication and mod\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\nvec4 packFloat(float depth) {\nconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\nconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\n// combination of mod and multiplication and division works better\nvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\nres -= res.xxyz * bit_mask;\nreturn res;\n}\n\n\n\n";

/***/ }),

/***/ "./src/shader/method/textureEnvMap.glsl":
/*!**********************************************!*\
  !*** ./src/shader/method/textureEnvMap.glsl ***!
  \**********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nvec4 textureEnvMap(sampler2D texture, vec3 position){\nreturn texture2D(texture, vec2(atan(position.x, position.z) * HILO_INVERSE_PI * 0.5+0.5,  acos(position.y) * HILO_INVERSE_PI));\n}\n\nvec4 textureEnvMap(samplerCube texture, vec3 position){\nreturn textureCube(texture, position);\n}\n\n#ifdef HILO_USE_SHADER_TEXTURE_LOD\nvec4 textureEnvMapLod(sampler2D texture, vec3 position, float lod){\nreturn texture2DLodEXT(texture, vec2(atan(position.x, position.z) * HILO_INVERSE_PI * 0.5+0.5,  acos(position.y) * HILO_INVERSE_PI), lod);\n}\n\nvec4 textureEnvMapLod(samplerCube texture, vec3 position, float lod){\nreturn textureCubeLodEXT(texture, position, lod);\n}\n#endif\n\n";

/***/ }),

/***/ "./src/shader/method/transpose.glsl":
/*!******************************************!*\
  !*** ./src/shader/method/transpose.glsl ***!
  \******************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nfloat transpose(float m) {\nreturn m;\n}\n\nmat2 transpose(mat2 m) {\nreturn mat2(m[0][0], m[1][0],\nm[0][1], m[1][1]);\n}\n\nmat3 transpose(mat3 m) {\nreturn mat3(m[0][0], m[1][0], m[2][0],\nm[0][1], m[1][1], m[2][1],\nm[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose(mat4 m) {\nreturn mat4(m[0][0], m[1][0], m[2][0], m[3][0],\nm[0][1], m[1][1], m[2][1], m[3][1],\nm[0][2], m[1][2], m[2][2], m[3][2],\nm[0][3], m[1][3], m[2][3], m[3][3]);\n}";

/***/ }),

/***/ "./src/shader/method/unpackFloat.glsl":
/*!********************************************!*\
  !*** ./src/shader/method/unpackFloat.glsl ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = "#define GLSLIFY 1\nfloat unpackFloat(vec4 rgbaDepth) {\nconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\nfloat depth = dot(rgbaDepth, bitShift);\nreturn depth;\n}\n\n";

/***/ }),

/***/ "./src/shader/pbr.frag":
/*!*****************************!*\
  !*** ./src/shader/pbr.frag ***!
  \*****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n" + __webpack_require__(/*! ./chunk/extensions.frag */ "./src/shader/chunk/extensions.frag") + "\n" + __webpack_require__(/*! ./chunk/baseDefine.glsl */ "./src/shader/chunk/baseDefine.glsl") + "\n" + __webpack_require__(/*! ./chunk/precision.frag */ "./src/shader/chunk/precision.frag") + "\n\n" + __webpack_require__(/*! ./chunk/color.frag */ "./src/shader/chunk/color.frag") + "\n" + __webpack_require__(/*! ./chunk/uv.frag */ "./src/shader/chunk/uv.frag") + "\n" + __webpack_require__(/*! ./chunk/normal.frag */ "./src/shader/chunk/normal.frag") + "\n" + __webpack_require__(/*! ./chunk/lightFog.frag */ "./src/shader/chunk/lightFog.frag") + "\n" + __webpack_require__(/*! ./chunk/pbr.frag */ "./src/shader/chunk/pbr.frag") + "\n" + __webpack_require__(/*! ./chunk/light.frag */ "./src/shader/chunk/light.frag") + "\n" + __webpack_require__(/*! ./chunk/transparency.frag */ "./src/shader/chunk/transparency.frag") + "\n" + __webpack_require__(/*! ./chunk/fog.frag */ "./src/shader/chunk/fog.frag") + "\n" + __webpack_require__(/*! ./chunk/logDepth.frag */ "./src/shader/chunk/logDepth.frag") + "\n\nvoid main(void) {\nvec4 color = vec4(0., 0., 0., 1.);\n\n" + __webpack_require__(/*! ./chunk/normal_main.frag */ "./src/shader/chunk/normal_main.frag") + "\n" + __webpack_require__(/*! ./chunk/lightFog_main.frag */ "./src/shader/chunk/lightFog_main.frag") + "\n" + __webpack_require__(/*! ./chunk/pbr_main.frag */ "./src/shader/chunk/pbr_main.frag") + "\n" + __webpack_require__(/*! ./chunk/frag_color.frag */ "./src/shader/chunk/frag_color.frag") + "\n" + __webpack_require__(/*! ./chunk/logDepth_main.frag */ "./src/shader/chunk/logDepth_main.frag") + "\n}";

/***/ }),

/***/ "./src/shader/screen.frag":
/*!********************************!*\
  !*** ./src/shader/screen.frag ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n" + __webpack_require__(/*! ./chunk/extensions.frag */ "./src/shader/chunk/extensions.frag") + "\n" + __webpack_require__(/*! ./chunk/baseDefine.glsl */ "./src/shader/chunk/baseDefine.glsl") + "\n" + __webpack_require__(/*! ./chunk/precision.frag */ "./src/shader/chunk/precision.frag") + "\n\nvarying vec2 v_texcoord0;\nuniform sampler2D u_diffuse;\n\nvoid main(void) {  \ngl_FragColor = texture2D(u_diffuse, v_texcoord0);\n}";

/***/ }),

/***/ "./src/shader/screen.vert":
/*!********************************!*\
  !*** ./src/shader/screen.vert ***!
  \********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = "#define GLSLIFY 1\n" + __webpack_require__(/*! ./chunk/extensions.vert */ "./src/shader/chunk/extensions.vert") + "\n" + __webpack_require__(/*! ./chunk/baseDefine.glsl */ "./src/shader/chunk/baseDefine.glsl") + "\n" + __webpack_require__(/*! ./chunk/precision.vert */ "./src/shader/chunk/precision.vert") + "\n\nattribute vec2 a_position;\nattribute vec2 a_texcoord0;\nvarying vec2 v_texcoord0;\n\n\nvoid main(void) {\nvec4 pos = vec4(a_position, 0.0, 1.0);\ngl_Position = pos;\nv_texcoord0 = a_texcoord0;\n}";

/***/ }),

/***/ 0:
/*!***********************************************!*\
  !*** multi ./src/polyfill.js ./src/Hilo3d.js ***!
  \***********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./src/polyfill.js */"./src/polyfill.js");
module.exports = __webpack_require__(/*! ./src/Hilo3d.js */"./src/Hilo3d.js");


/***/ })

/******/ });
if(typeof window !== 'undefined' && window.Hilo3d){
    {
        module.exports = window.Hilo3d;
    }
}
});

var Hilo3d$1 = unwrapExports(Hilo3d);
var Hilo3d_1 = Hilo3d.util;
var Hilo3d_2 = Hilo3d.GLTFExtensions;
var Hilo3d_3 = Hilo3d.Class;
var Hilo3d_4 = Hilo3d.EventMixin;
var Hilo3d_5 = Hilo3d.Fog;
var Hilo3d_6 = Hilo3d.Mesh;
var Hilo3d_7 = Hilo3d.Node;
var Hilo3d_8 = Hilo3d.SkinedMesh;
var Hilo3d_9 = Hilo3d.Stage;
var Hilo3d_10 = Hilo3d.Tween;
var Hilo3d_11 = Hilo3d.version;
var Hilo3d_12 = Hilo3d.BoxGeometry;
var Hilo3d_13 = Hilo3d.Geometry;
var Hilo3d_14 = Hilo3d.GeometryData;
var Hilo3d_15 = Hilo3d.MorphGeometry;
var Hilo3d_16 = Hilo3d.PlaneGeometry;
var Hilo3d_17 = Hilo3d.SphereGeometry;
var Hilo3d_18 = Hilo3d.Camera;
var Hilo3d_19 = Hilo3d.PerspectiveCamera;
var Hilo3d_20 = Hilo3d.OrthographicCamera;
var Hilo3d_21 = Hilo3d.Buffer;
var Hilo3d_22 = Hilo3d.capabilities;
var Hilo3d_23 = Hilo3d.extensions;
var Hilo3d_24 = Hilo3d.Framebuffer;
var Hilo3d_25 = Hilo3d.glType;
var Hilo3d_26 = Hilo3d.Program;
var Hilo3d_27 = Hilo3d.RenderInfo;
var Hilo3d_28 = Hilo3d.RenderList;
var Hilo3d_29 = Hilo3d.VertexArrayObject;
var Hilo3d_30 = Hilo3d.WebGLRenderer;
var Hilo3d_31 = Hilo3d.WebGLResourceManager;
var Hilo3d_32 = Hilo3d.WebGLState;
var Hilo3d_33 = Hilo3d.BasicLoader;
var Hilo3d_34 = Hilo3d.CubeTextureLoader;
var Hilo3d_35 = Hilo3d.GLTFLoader;
var Hilo3d_36 = Hilo3d.GLTFParser;
var Hilo3d_37 = Hilo3d.AliAMCExtension;
var Hilo3d_38 = Hilo3d.HDRLoader;
var Hilo3d_39 = Hilo3d.KTXLoader;
var Hilo3d_40 = Hilo3d.LoadCache;
var Hilo3d_41 = Hilo3d.LoadQueue;
var Hilo3d_42 = Hilo3d.ShaderMaterialLoader;
var Hilo3d_43 = Hilo3d.TextureLoader;
var Hilo3d_44 = Hilo3d.Loader;
var Hilo3d_45 = Hilo3d.Texture;
var Hilo3d_46 = Hilo3d.LazyTexture;
var Hilo3d_47 = Hilo3d.CubeTexture;
var Hilo3d_48 = Hilo3d.DataTexture;
var Hilo3d_49 = Hilo3d.Shader;
var Hilo3d_50 = Hilo3d.BasicMaterial;
var Hilo3d_51 = Hilo3d.GeometryMaterial;
var Hilo3d_52 = Hilo3d.Material;
var Hilo3d_53 = Hilo3d.PBRMaterial;
var Hilo3d_54 = Hilo3d.semantic;
var Hilo3d_55 = Hilo3d.ShaderMaterial;
var Hilo3d_56 = Hilo3d.AxisHelper;
var Hilo3d_57 = Hilo3d.AxisNetHelper;
var Hilo3d_58 = Hilo3d.CameraHelper;
var Hilo3d_59 = Hilo3d.AmbientLight;
var Hilo3d_60 = Hilo3d.AreaLight;
var Hilo3d_61 = Hilo3d.DirectionalLight;
var Hilo3d_62 = Hilo3d.CubeLightShadow;
var Hilo3d_63 = Hilo3d.Light;
var Hilo3d_64 = Hilo3d.LightManager;
var Hilo3d_65 = Hilo3d.LightShadow;
var Hilo3d_66 = Hilo3d.PointLight;
var Hilo3d_67 = Hilo3d.SpotLight;
var Hilo3d_68 = Hilo3d.Animation;
var Hilo3d_69 = Hilo3d.AnimationStates;
var Hilo3d_70 = Hilo3d.MeshPicker;
var Hilo3d_71 = Hilo3d.Ticker;
var Hilo3d_72 = Hilo3d.log;
var Hilo3d_73 = Hilo3d.Cache;
var Hilo3d_74 = Hilo3d.browser;
var Hilo3d_75 = Hilo3d.WebGLSupport;
var Hilo3d_76 = Hilo3d.constants;
var Hilo3d_77 = Hilo3d.Color;
var Hilo3d_78 = Hilo3d.Euler;
var Hilo3d_79 = Hilo3d.EulerNotifier;
var Hilo3d_80 = Hilo3d.Frustum;
var Hilo3d_81 = Hilo3d.math;
var Hilo3d_82 = Hilo3d.Matrix3;
var Hilo3d_83 = Hilo3d.Matrix4;
var Hilo3d_84 = Hilo3d.Matrix4Notifier;
var Hilo3d_85 = Hilo3d.Plane;
var Hilo3d_86 = Hilo3d.Quaternion;
var Hilo3d_87 = Hilo3d.Ray;
var Hilo3d_88 = Hilo3d.Sphere;
var Hilo3d_89 = Hilo3d.Vector2;
var Hilo3d_90 = Hilo3d.Vector3;
var Hilo3d_91 = Hilo3d.Vector3Notifier;
var Hilo3d_92 = Hilo3d.Vector4;
var Hilo3d_93 = Hilo3d.SphericalHarmonics3;
var Hilo3d_94 = Hilo3d.Skeleton;

var Hilo3d$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': Hilo3d$1,
  __moduleExports: Hilo3d,
  util: Hilo3d_1,
  GLTFExtensions: Hilo3d_2,
  Class: Hilo3d_3,
  EventMixin: Hilo3d_4,
  Fog: Hilo3d_5,
  Mesh: Hilo3d_6,
  Node: Hilo3d_7,
  SkinedMesh: Hilo3d_8,
  Stage: Hilo3d_9,
  Tween: Hilo3d_10,
  version: Hilo3d_11,
  BoxGeometry: Hilo3d_12,
  Geometry: Hilo3d_13,
  GeometryData: Hilo3d_14,
  MorphGeometry: Hilo3d_15,
  PlaneGeometry: Hilo3d_16,
  SphereGeometry: Hilo3d_17,
  Camera: Hilo3d_18,
  PerspectiveCamera: Hilo3d_19,
  OrthographicCamera: Hilo3d_20,
  Buffer: Hilo3d_21,
  capabilities: Hilo3d_22,
  extensions: Hilo3d_23,
  Framebuffer: Hilo3d_24,
  glType: Hilo3d_25,
  Program: Hilo3d_26,
  RenderInfo: Hilo3d_27,
  RenderList: Hilo3d_28,
  VertexArrayObject: Hilo3d_29,
  WebGLRenderer: Hilo3d_30,
  WebGLResourceManager: Hilo3d_31,
  WebGLState: Hilo3d_32,
  BasicLoader: Hilo3d_33,
  CubeTextureLoader: Hilo3d_34,
  GLTFLoader: Hilo3d_35,
  GLTFParser: Hilo3d_36,
  AliAMCExtension: Hilo3d_37,
  HDRLoader: Hilo3d_38,
  KTXLoader: Hilo3d_39,
  LoadCache: Hilo3d_40,
  LoadQueue: Hilo3d_41,
  ShaderMaterialLoader: Hilo3d_42,
  TextureLoader: Hilo3d_43,
  Loader: Hilo3d_44,
  Texture: Hilo3d_45,
  LazyTexture: Hilo3d_46,
  CubeTexture: Hilo3d_47,
  DataTexture: Hilo3d_48,
  Shader: Hilo3d_49,
  BasicMaterial: Hilo3d_50,
  GeometryMaterial: Hilo3d_51,
  Material: Hilo3d_52,
  PBRMaterial: Hilo3d_53,
  semantic: Hilo3d_54,
  ShaderMaterial: Hilo3d_55,
  AxisHelper: Hilo3d_56,
  AxisNetHelper: Hilo3d_57,
  CameraHelper: Hilo3d_58,
  AmbientLight: Hilo3d_59,
  AreaLight: Hilo3d_60,
  DirectionalLight: Hilo3d_61,
  CubeLightShadow: Hilo3d_62,
  Light: Hilo3d_63,
  LightManager: Hilo3d_64,
  LightShadow: Hilo3d_65,
  PointLight: Hilo3d_66,
  SpotLight: Hilo3d_67,
  Animation: Hilo3d_68,
  AnimationStates: Hilo3d_69,
  MeshPicker: Hilo3d_70,
  Ticker: Hilo3d_71,
  log: Hilo3d_72,
  Cache: Hilo3d_73,
  browser: Hilo3d_74,
  WebGLSupport: Hilo3d_75,
  constants: Hilo3d_76,
  Color: Hilo3d_77,
  Euler: Hilo3d_78,
  EulerNotifier: Hilo3d_79,
  Frustum: Hilo3d_80,
  math: Hilo3d_81,
  Matrix3: Hilo3d_82,
  Matrix4: Hilo3d_83,
  Matrix4Notifier: Hilo3d_84,
  Plane: Hilo3d_85,
  Quaternion: Hilo3d_86,
  Ray: Hilo3d_87,
  Sphere: Hilo3d_88,
  Vector2: Hilo3d_89,
  Vector3: Hilo3d_90,
  Vector3Notifier: Hilo3d_91,
  Vector4: Hilo3d_92,
  SphericalHarmonics3: Hilo3d_93,
  Skeleton: Hilo3d_94
});

/**
 * @File   : Hilo3d.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 2018/9/29 下午1:26:08
 * @Description:
 */

/**
 * @hidden
 */
var math = Hilo3d$2.math;
var clamp = math.clamp;
var DEG2RAD = math.DEG2RAD;
var degToRad = math.degToRad;
var isPowerOfTwo = math.isPowerOfTwo;
var nearestPowerOfTwo = math.nearestPowerOfTwo;
var nextPowerOfTwo = math.nextPowerOfTwo;
var RAD2DEG = math.RAD2DEG;
var radToDeg = math.radToDeg;
/**
 * 判断一个实例是否为`Vector2`。
 */
function isVector2(value) {
    return value.isVector2;
}
/**
 * 判断一个实例是否为`Vector3`。
 */
function isVector3(value) {
    return value.isVector3;
}
/**
 * 判断一个实例是否为`Vector4`。
 */
function isVector4(value) {
    return value.isVector4;
}
/**
 * 判断一个实例是否为`Matrix3`。
 */
function isMatrix3(value) {
    return value.isMatrix3;
}
/**
 * 判断一个实例是否为`Matrix4`。
 */
function isMatrix4(value) {
    return value.isMatrix4;
}
/**
 * 判断一个实例是否为`Quaternion`。
 */
function isQuaternion(value) {
    return value.isQuaternion;
}
/**
 * 判断一个实例是否为`Color`。
 */
function isColor(value) {
    return value.isColor;
}
/**
 * 判断一个实例是否为`Euler`。
 */
function isEuler(value) {
    return value.isEuler;
}
/**
 * 判断一个实例是否为`SphericalHarmonics3`。
 */
function isSphericalHarmonics3(value) {
    return value.isSphericalHarmonics3;
}
var Vector2 = /** @class */ (function (_super) {
    __extends(Vector2, _super);
    function Vector2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Vector2;
}(Hilo3d$2.Vector2));
var Vector3 = /** @class */ (function (_super) {
    __extends(Vector3, _super);
    function Vector3() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Vector3;
}(Hilo3d$2.Vector3));
var Vector4 = /** @class */ (function (_super) {
    __extends(Vector4, _super);
    function Vector4() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Vector4;
}(Hilo3d$2.Vector4));
var Matrix3 = /** @class */ (function (_super) {
    __extends(Matrix3, _super);
    function Matrix3() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Matrix3;
}(Hilo3d$2.Matrix3));
var Matrix4 = /** @class */ (function (_super) {
    __extends(Matrix4, _super);
    function Matrix4() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Matrix4;
}(Hilo3d$2.Matrix4));
var Quaternion = /** @class */ (function (_super) {
    __extends(Quaternion, _super);
    function Quaternion() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Quaternion;
}(Hilo3d$2.Quaternion));
var Color = /** @class */ (function (_super) {
    __extends(Color, _super);
    function Color() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Color;
}(Hilo3d$2.Color));
var Euler = /** @class */ (function (_super) {
    __extends(Euler, _super);
    function Euler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Euler;
}(Hilo3d$2.Euler));
var SphericalHarmonics3 = /** @class */ (function (_super) {
    __extends(SphericalHarmonics3, _super);
    function SphericalHarmonics3() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SphericalHarmonics3;
}(Hilo3d$2.SphericalHarmonics3));
/**
 * 判断一个实例是否为`Spherical`。
 */
function isSpherical(value) {
    return value.isSpherical;
}
/**
 * 球面坐标系。
 */
var Spherical = /** @class */ (function () {
    function Spherical(radius, phi, theta) {
        this.isSpherical = true;
        /**
         * 球面球心。
         */
        this.center = new Vector3();
        this.radius = radius || 0;
        this.phi = phi || 0;
        this.theta = theta || 0;
    }
    Spherical.prototype.set = function (radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    };
    Spherical.prototype.clone = function () {
        return new Spherical().copy(this);
    };
    Spherical.prototype.copy = function (other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    };
    /**
     * restrict phi to be between EPS and PI-EPS。
     */
    Spherical.prototype.makeSafe = function () {
        var EPS = Spherical.EPS;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
    };
    /**
     * 从笛卡尔坐标系的Vector3转换。
     */
    Spherical.prototype.setFromVector3 = function (vector) {
        return this.setFromCartesianCoords(vector.x, vector.y, vector.z);
    };
    /**
     * 从笛卡尔坐标系的x、y、z转换。
     */
    Spherical.prototype.setFromCartesianCoords = function (x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        }
        else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos(clamp(y / this.radius, -1, 1));
        }
        return this;
    };
    /**
     * 转换到笛卡尔坐标系的Vector3。
     */
    Spherical.prototype.toVector3 = function (vector) {
        vector = vector || new Vector3();
        var _a = this, radius = _a.radius, phi = _a.phi, theta = _a.theta, center = _a.center;
        vector.x = radius * Math.sin(phi) * Math.sin(theta) + center.x;
        vector.y = radius * Math.cos(phi) + center.y;
        vector.z = radius * Math.sin(phi) * Math.cos(theta) + center.z;
        return vector;
    };
    Spherical.EPS = 0.000001;
    return Spherical;
}());

var Tween = /** @class */ (function (_super) {
    __extends(Tween, _super);
    function Tween() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Tween;
}(Hilo3d$2.Tween));

/**
 * 判断一个实例是否为`Level`。
 */
function isLevel(value) {
    return value.isLevel;
}
/**
 * 关卡类，单个关卡的逻辑容器，挂载在`World`下，也是存储`SceneActor`的实际容器，通常使用`getLevel`获取。
 * 一般来讲，我们不建议直接使用`Level`中的一些方法，而是使用`World`进行代理，更符合直觉。
 * 它的实际游戏逻辑由[LevelScriptActor](../levelscriptactor)描述。
 *
 * @template IState Level的状态Actor类型，用于存储当前关卡的状态数据。
 * @noInheritDoc
 */
var Level = /** @class */ (function (_super) {
    __extends(Level, _super);
    /**
     * 创建Level，不要自己创建！
     *
     * @hidden
     */
    function Level(name, LevelScript, world) {
        var _this = _super.call(this, name) || this;
        _this.isLevel = true;
        /**
         * 开放世界游戏，end用于无缝自动切换关卡，先占位，待完成
         */
        _this.bound = {
            start: new Vector3(0, 0, 0),
            end: null
        };
        _this._world = null;
        _this._actors = new SArray();
        _this._actorsForUpdate = new SArray();
        _this._actorsNeedUpdate = false;
        _this._script = null;
        _this._updatable = false;
        _this.handleLoading = function (params) {
            try {
                _this._script.onLoading(params);
            }
            catch (error) {
                throwException(error, _this._script);
            }
            _this.game.event.trigger('LevelIsPreloading', { level: _this, state: params });
        };
        _this.handleLoadError = function (_a) {
            var error = _a.error, state = _a.state;
            throwException(error, _this._script, state);
        };
        _this.handleLoadDone = function () {
            _this.game.resource.onLoading.remove(_this.handleLoading);
            _this.game.resource.onError.remove(_this.handleLoadError);
            _this.game.event.trigger('LevelDidPreload', { level: _this });
            try {
                _this._script.onCreate();
            }
            catch (error) {
                throwException(error, _this._script);
            }
            _this._state.updateOnEverTick = true;
            _this._script.updateOnEverTick = true;
            _this.game.event.trigger('LevelDidCreateActors', { level: _this });
        };
        _this._world = world;
        _this._ScriptClass = LevelScript;
        return _this;
    }
    Object.defineProperty(Level.prototype, "state", {
        /**
         * Level状态Actor实例引用。
         */
        get: function () {
            return this._state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Level.prototype, "game", {
        /**
         * 当前`Game`实例引用。一般不直接使用，而是用`actor.getGame()`或`component.getGame`，提供更好的泛型类型推断。
         */
        get: function () {
            return this._world.game;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Level.prototype, "world", {
        /**
         * 当前`World`实例引用。一般不直接使用，而是用`actor.getWorld()`或`component.getWorld`，提供更好的泛型类型推断。
         */
        get: function () {
            return this._world;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Level.prototype, "parent", {
        /**
         * Level的父级World实例引用。
         */
        get: function () {
            return this._world;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Level.prototype, "actors", {
        /**
         * 当前所有的actors，建议使用`world.actors`获取。
         */
        get: function () {
            return this._actors;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 生命周期，用于错误边界处理。将在Game中大部分可预知错误发生时被调用（通常是生命周期中的非异步错误）。
     * 错误将会根据一定的路径向上传递，一直到`Engine`的层次，你可以在确保完美处理了问题后返回`true`来通知引擎不再向上传递。
     * 当然你也可以将自定义的一些错误加入错误边界机制中，详见[Exception](../../guide/exception)。
     */
    Level.prototype.onError = function (error, details) {
        return this._script.onError(error, details);
    };
    /**
     * 用于继承上个挂卡的actors，**不要自己调用！！**
     *
     * @hidden
     */
    Level.prototype.inherit = function (inheritActors) {
        var _this = this;
        this._actors.merge(inheritActors);
        inheritActors.forEach(function (actor) {
            if (isLevel(actor.parent)) {
                actor._parent = _this;
            }
        });
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Level.prototype.init = function (initState) {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._script = this.game.addActor(this.name + "-level-script", this._ScriptClass);
                        this._script.updateOnEverTick = false;
                        this._state = this.game.addActor('level-state', this._ScriptClass.LevelStateClass);
                        this._state.copy(initState);
                        this._state.updateOnEverTick = false;
                        this._script._parent = this;
                        this._state.copy(initState);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._script.onLogin()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        throwException(error_1, this._script);
                        return [3 /*break*/, 4];
                    case 4:
                        this._updatable = true;
                        this.game.event.trigger('LevelDidInit', { level: this });
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Level.prototype.startLoading = function () {
        this.game.event.trigger('LevelWillPreload', { level: this });
        try {
            this._script.onPreload();
        }
        catch (error) {
            throwException(error, this._script);
        }
        if (this.game.resource.loadDone) {
            this.handleLoadDone();
            return;
        }
        this.game.resource.onLoading.add(this.handleLoading);
        this.game.resource.onError.add(this.handleLoadError);
        this.game.resource.onLoaded.addOnce(this.handleLoadDone);
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Level.prototype.update = function (delta) {
        if (!this._updatable) {
            return;
        }
        if (this._actorsNeedUpdate) {
            this._actorsForUpdate.copy(this._actors);
            this._actorsNeedUpdate = false;
        }
        this._actorsForUpdate.forEach(function (actor) { return actor.update(delta); });
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Level.prototype.destroy = function (forceClear) {
        if (forceClear === void 0) { forceClear = false; }
        _super.prototype.destroy.call(this);
        this.game.event.trigger('LevelWillDestroy', { level: this });
        /**
         * 销毁时同时取消所有资源加载逻辑。
         */
        this.game.resource.onLoading.remove(this.handleLoading);
        this.game.resource.onError.remove(this.handleLoadError);
        this.game.resource.onLoaded.remove(this.handleLoadDone);
        /**
         * 取消所有Tween动画。
         */
        Tween.removeAll();
        var inheritActors = new SArray();
        if (!forceClear) {
            this._actorsForUpdate.forEach(function (actor) {
                if (actor.persistent) {
                    inheritActors.add(actor);
                }
                else {
                    actor.destroy();
                }
            });
        }
        else {
            this._actorsForUpdate.forEach(function (actor) {
                actor.destroy();
            });
        }
        // parent is not right, do not use removeFromParent
        this.game.removeActor(this._script);
        this.game.removeActor(this._state);
        return inheritActors;
    };
    /**
     * 通过指定的Actor类`ActorClass`和初始化参数`initOptions`，向Level中添加一个`SceneActor`。
     * 一般使用`world.addActor`进行代理。
     */
    Level.prototype.addActor = function (name, ActorClass, initOptions, parent, parentComponent) {
        var actor = new ActorClass(name, this.game, initOptions);
        if (this.game.devMode) {
            try {
                actor.verifyAdding(initOptions);
            }
            catch (error) {
                throwException(error, actor);
                return;
            }
        }
        actor.initialized();
        this._actors.add(actor);
        if (!parent) {
            actor._parent = this;
        }
        else {
            parent.addChild(actor, parentComponent);
        }
        actor.added();
        this._actorsNeedUpdate = true;
        return actor;
    };
    /**
     * 从Level中移除一个SceneActor。
     * 一般使用`world.removeActor`进行代理。
     */
    Level.prototype.removeActor = function (actor) {
        // debugger;
        actor.destroy();
        actor._parent = null;
        this._actors.remove(actor);
        this._actorsNeedUpdate = true;
        return this;
    };
    Level = __decorate([
        SClass({ className: 'Level', classType: 'Level' })
    ], Level);
    return Level;
}(SObject));

function isSceneActor(value) {
    return value.isSceneActor;
}

/**
 * @File   : Layers.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 1/28/2019, 7:58:47 PM
 * @Description:
 */
/**
 * 判断一个实例是否为`Layers`。
 */
function isLayers(value) {
    return value.isLayers;
}
/**
 * 图层类。用于在开启`World`的图层功能时，快速切换可视对象。
 * 图层是根据一个32通道的mask设定的，你可以通过这个类的一些方法开启或关闭某个或某些通道。
 * 图层可以给每个`Actor`设定，其中包含当前主相机的`Actor`负责测试所有实例是否可见。
 *
 * 实例请见[Layers](../../example/render/layers)。
 */
var Layers = /** @class */ (function () {
    function Layers() {
        this.isLayers = true;
        this._mask = 0xffffffff;
    }
    /**
     * 强制设置为某些通道。
     */
    Layers.prototype.set = function (channel) {
        this._mask = 1 << channel | 0;
    };
    /**
     * 切换某些通道。
     */
    Layers.prototype.toggle = function (channel) {
        this._mask ^= (1 << channel | 0);
    };
    /**
     * 开启某些通道。
     */
    Layers.prototype.enable = function (channel) {
        this._mask |= (1 << channel | 0);
    };
    /**
     * 关闭某些通道。
     */
    Layers.prototype.disable = function (channel) {
        this._mask &= ~(1 << channel | 0);
    };
    /**
     * 通道复位。
     */
    Layers.prototype.reset = function () {
        this._mask = 0xffffffff;
    };
    /**
     * 和另一个图层进行测试。
     */
    Layers.prototype.test = function (layers) {
        return (this._mask & layers._mask) !== 0;
    };
    return Layers;
}());

/**
 * @hidden
 */
var tmpVec3 = new Vector3();
/**
 * 判断一个实例是否为`SceneComponent`。
 */
function isSceneComponent(value) {
    return value.isSceneComponent;
}
/**
 * 场景Component类，作为`SceneActor`的根组件，即为实际拥有3D变换功能的一类特殊Component。
 * 你可以直接使用它，也可以使用继承自它的那些类（比如`PrimitiveComponent`，图元组件，用于承载模型数据）。
 * SceneComponent实例可以以树状结构嵌套，但处于性能考虑，原则上一旦生成就不建议再去动态插拔子级实例。
 *
 * @template IStateTypes 初始化参数类型，必须继承自[ISceneComponentState](../interfaces/iscenecomponentstate)。
 * @noInheritDoc
 */
var SceneComponent = /** @class */ (function (_super) {
    __extends(SceneComponent, _super);
    function SceneComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isSceneComponent = true;
        /**
         * 是否需要在销毁时释放Gl资源，如果确定以后还会使用相同的材质、几何体等，可以设为`false`，性能优化。
         * 对于GlTF模型实例化的资源默认会设为`false`，而在资源释放时统一释放Gl资源。
         *
         * @default true
         */
        _this.needReleaseGlRes = true;
        /**
         * 图层属性，详见[Layers](../layers)。
         */
        _this.layers = new Layers();
        _this._children = new SArray();
        _this._tmpQuat = new Quaternion();
        return _this;
    }
    Object.defineProperty(SceneComponent.prototype, "parent", {
        /**
         * 获取自身的父级实例，根据情况不同可能有不同的类型，一般不需要自己使用。
         */
        get: function () {
            return this._parent || this._owner;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "children", {
        /**
         * 获取自身的所有子级SceneComponent，一般不需要自己使用。
         */
        get: function () {
            return this._children;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "hiloNode", {
        /**
         * 底层hilo3d的节点，内部随时可能变更实现，**不要自己使用**。
         *
         * @hidden
         */
        get: function () {
            return this._node;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "visible", {
        /**
         * 获取该组件在世界中是否可见。
         */
        get: function () {
            return this._node.visible;
        },
        /**
         * 设置该组件在世界中是否可见。
         */
        set: function (value) {
            this._node.visible = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "isStatic", {
        /**
         * 获取是否为静态对象，若是，则从此层开始的所有子级实例都不会在每一帧更新`WorldMatrix`。
         * 用于性能优化。
         */
        get: function () {
            return !this._node.autoUpdateWorldMatrix;
        },
        /**
         * 设置是否为静态对象，若是，则从此层开始的所有子级实例都不会在每一帧更新`WorldMatrix`。
         * 用于性能优化。
         */
        set: function (value) {
            this._node.autoUpdateWorldMatrix = !value;
            this._node.autoUpdateChildWorldMatrix = !value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "position", {
        /**
         * 获取本地空间位置数据。
         */
        get: function () {
            return this._node.position;
        },
        /**
         * 设置本地空间位置数据。
         */
        set: function (position) {
            this._node.position.copy(position);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "rotation", {
        /**
         * 获取本地空间旋转数据。
         */
        get: function () {
            return this._node.rotation;
        },
        /**
         * 设置本地空间旋转数据。
         */
        set: function (rotation) {
            this._node.rotation.copy(rotation);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "scale", {
        /**
         * 获取本地空间缩放数据。
         */
        get: function () {
            return this._node.scale;
        },
        /**
         * 设置本地空间缩放数据。
         */
        set: function (scale) {
            this._node.scale.copy(scale);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "pivot", {
        /**
         * 获取本地空间锚点数据。
         */
        get: function () {
            return this._node.pivot;
        },
        /**
         * 设置本地空间锚点数据。
         */
        set: function (pivot) {
            this._node.pivot.copy(pivot);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "quaternion", {
        /**
         * 获取本地空间四元数数据。
         */
        get: function () {
            return this._node.quaternion;
        },
        /**
         * 设置本地空间四元数数据。
         */
        set: function (quaternion) {
            this._node.quaternion.copy(quaternion);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "matrix", {
        /**
         * 获取本地矩阵数据。
         */
        get: function () {
            return this._node.matrix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "x", {
        get: function () {
            return this.position.x;
        },
        set: function (value) {
            this.position.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "y", {
        get: function () {
            return this.position.y;
        },
        set: function (value) {
            this.position.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "z", {
        get: function () {
            return this.position.z;
        },
        set: function (value) {
            this.position.z = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "rotationX", {
        get: function () {
            return this.rotation.x;
        },
        set: function (value) {
            this.rotation.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "rotationY", {
        get: function () {
            return this.rotation.y;
        },
        set: function (value) {
            this.rotation.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "rotationZ", {
        get: function () {
            return this.rotation.z;
        },
        set: function (value) {
            this.rotation.z = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "scaleX", {
        get: function () {
            return this.scale.x;
        },
        set: function (value) {
            this.scale.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "scaleY", {
        get: function () {
            return this.scale.y;
        },
        set: function (value) {
            this.scale.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "scaleZ", {
        get: function () {
            return this.scale.z;
        },
        set: function (value) {
            this.scale.z = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "pivotX", {
        get: function () {
            return this.pivot.x;
        },
        set: function (value) {
            this.pivot.x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "pivotY", {
        get: function () {
            return this.pivot.y;
        },
        set: function (value) {
            this.pivot.y = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "pivotZ", {
        get: function () {
            return this.pivot.z;
        },
        set: function (value) {
            this.pivot.z = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "worldMatrix", {
        /**
         * 直接获取世界矩阵的数据。
         */
        get: function () {
            return this._node.worldMatrix;
        },
        /**
         * 直接设置世界矩阵的数据。
         */
        set: function (matrix) {
            this._node.worldMatrix.copy(matrix);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "absolutePosition", {
        /**
         * 直接获取组件在世界空间的位置数据。
         */
        get: function () {
            return this._node.worldMatrix.getTranslation();
        },
        /**
         * 直接设置组件在世界空间的位置数据。
         *
         * **注意此设置会涉及矩阵的clone和乘法，有一些性能开销，**
         */
        set: function (value) {
            var parent = this._node.parent;
            if (parent) {
                var invertParentWorldMatrix = parent.worldMatrix.clone();
                invertParentWorldMatrix.invert();
                this.position = value.transformMat4(invertParentWorldMatrix);
            }
            else {
                this.position = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "absoluteRotation", {
        /**
         * 直接获取组件在世界空间的旋转数据。
         *
         * **注意此值从世界矩阵实时计算而来，有一些性能消耗。**
         */
        get: function () {
            var quat = new Quaternion();
            return this._node.worldMatrix.getRotation(quat);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "absoluteScale", {
        /**
         * 直接获取组件在世界空间的缩放数据。
         *
         * **注意此值从世界矩阵实时计算而来，有一些性能消耗。**
         */
        get: function () {
            return this._node.worldMatrix.getScaling();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "ndcPosition", {
        /**
         * 直接获取组件在**当前摄像机**下标准设备空间的位置数据。
         *
         * **注意此值从世界矩阵和视图矩阵实时计算而来，有一些性能消耗。**
         */
        get: function () {
            var mainCamera = this.getWorld().mainCamera;
            if (!mainCamera) {
                return null;
            }
            return this.absolutePosition.transformMat4(mainCamera.viewProjectionMatrix);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "forwardVector", {
        /**
         * 直接获取组件在本地空间的forward向量。
         */
        get: function () {
            return new Vector3(0, 0, 1).transformQuat(this.quaternion);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "upVector", {
        /**
         * 直接获取组件在本地空间的up向量。
         */
        get: function () {
            return new Vector3(0, 1, 0).transformQuat(this.quaternion);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "rightVector", {
        /**
         * 直接获取组件在本地空间的right向量。
         */
        get: function () {
            return new Vector3(1, 0, 0).transformQuat(this.quaternion);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "worldForwardVector", {
        /**
         * 直接获取组件在世界空间的forward向量。
         *
         * **注意会先获取`absoluteRotation`，有一定开销！**
         */
        get: function () {
            return new Vector3(0, 0, 1).transformQuat(this.absoluteRotation);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "worldUpVector", {
        /**
         * 直接获取组件在世界空间的up向量。
         *
         * **注意会先获取`absoluteRotation`，有一定开销！**
         */
        get: function () {
            return new Vector3(0, 1, 0).transformQuat(this.absoluteRotation);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "worldRightVector", {
        /**
         * 直接获取组件在世界空间的right向量。
         *
         * **注意会先获取`absoluteRotation`，有一定开销！**
         */
        get: function () {
            return new Vector3(1, 0, 0).transformQuat(this.absoluteRotation);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneComponent.prototype, "up", {
        /**
         * 直接获取组件的UP向量。
         *
         * **注意这是一个可修改的值，如果没有特殊需求以防万一请用`upVector`！**
         */
        get: function () {
            return this._node.up;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 直接获取组件在**指定摄像机**下标准设备空间的位置数据。
     *
     * **注意此值从世界矩阵和视图矩阵实时计算而来，有一些性能消耗。**
     */
    SceneComponent.prototype.getNdcPosition = function (camera) {
        return this.absolutePosition.transformMat4(camera.viewProjectionMatrix);
    };
    /**
     * 初始化，继承请先`super.onInit()`。
     */
    SceneComponent.prototype.onInit = function (initState) {
        this._node = new Hilo3d$2.Node();
        if (!initState) {
            return;
        }
        var initTransform = initState;
        if (initTransform.position) {
            this._node.position.copy(initTransform.position);
            delete initTransform['position'];
        }
        if (initTransform.rotation) {
            this._node.rotation.copy(initTransform.rotation);
            delete initTransform['rotation'];
        }
        if (initTransform.pivot) {
            this._node.pivot.copy(initTransform.pivot);
            delete initTransform['pivot'];
        }
        if (initTransform.quaternion) {
            this._node.quaternion.copy(initTransform.quaternion);
            delete initTransform['quaternion'];
        }
        if (initTransform.matrix) {
            this._node.matrix.copy(initTransform.matrix);
            delete initTransform['matrix'];
        }
        if (initTransform.visible !== undefined) {
            this._node.visible = initTransform.visible;
        }
    };
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    SceneComponent.prototype.onDestroy = function () {
        if (this.needReleaseGlRes) {
            this._node.destroy(this.getGame().renderer, true);
        }
        else {
            this._node.removeFromParent();
        }
    };
    /**
     * 获取组件的的包围盒(AABB)信息。
     * @param bounds 当前计算的包围盒信息，可用于节省开销
     * @param currentMatrix 当前计算的矩阵，可用于节省开销
     */
    SceneComponent.prototype.getBounds = function (bounds, currentMatrix) {
        return this._node.getBounds(null, currentMatrix, bounds);
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    SceneComponent.prototype.addChild = function (component) {
        this._children.add(component);
        component._parent = this;
        component._node.addTo(this._node);
        return this;
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    SceneComponent.prototype.removeChild = function (component) {
        var index = this._children.indexOf(component);
        if (index < 0) {
            return;
        }
        component._parent = null;
        this._children.remove(index);
        return this;
    };
    /**
     * 设置本地空间位置数据。
     */
    SceneComponent.prototype.setPosition = function (x, y, z) {
        this._node.setPosition(x, y, z);
        return this;
    };
    /**
     * 设置本地空间旋转数据。
     */
    SceneComponent.prototype.setRotation = function (x, y, z) {
        this._node.setRotation(x, y, z);
        return this;
    };
    /**
     * 设置本地空间位移数据。
     */
    SceneComponent.prototype.setScale = function (x, y, z) {
        this._node.setScale(x, y, z);
        return this;
    };
    /**
     * 设置本地空间锚点数据。
     */
    SceneComponent.prototype.setPivot = function (x, y, z) {
        this._node.setPivot(x, y, z);
        return this;
    };
    /**
     * 设置本地空间四元数数据。
     */
    SceneComponent.prototype.setQuaternion = function (x, y, z, w) {
        this._node.quaternion.x = x;
        this._node.quaternion.y = y;
        this._node.quaternion.z = z;
        this._node.quaternion.w = w;
        return this;
    };
    /**
     * 设置世界空间位置数据。
     */
    SceneComponent.prototype.setAbsolutePosition = function (x, y, z) {
        this.absolutePosition = new Vector3(x, y, z);
        return this;
    };
    /**
     * 沿着某个轴`axis`平移`distance`距离。
     */
    SceneComponent.prototype.translate = function (axis, distance) {
        tmpVec3.copy(axis).scale(distance);
        this.position.add(tmpVec3);
        // this.absolutePosition = this.absolutePosition.add(tmpVec3);
        return this;
    };
    /**
     * 绕着某个轴`axis`旋转`rad`弧度。
     */
    SceneComponent.prototype.rotate = function (axis, rad) {
        this._tmpQuat.setAxisAngle(axis, rad);
        this.quaternion.multiply(this._tmpQuat);
        return this;
    };
    /**
     * 更新当前实例以及子级组件的世界矩阵。
     */
    SceneComponent.prototype.updateMatrixWorld = function (force) {
        var node = this._node;
        while (node) {
            if (node.parent && node.parent.isStage) {
                node.updateMatrixWorld(force);
                break;
            }
            node = node.parent;
        }
        return this;
    };
    /**
     * 将自己从父级移除，基本等同于`destroy`方法，从Owner中销毁自身，同时递归移除所有子级组件。
     * 若父级也为`SceneComponent`，则会将自身从父级`children`中移除。
     */
    SceneComponent.prototype.removeFromParent = function () {
        if (!isSceneActor(this._parent)) {
            this._parent.removeChild(this);
        }
        this._owner.removeComponent(this);
        return this;
    };
    /**
     * 修改自身的朝向。
     */
    SceneComponent.prototype.lookAt = function (target) {
        if (isVector3(target)) {
            this._node.lookAt(target);
            return this;
        }
        if (isSceneActor(target)) {
            this._node.lookAt(target.transform.absolutePosition);
            return this;
        }
        this._node.lookAt(target.absolutePosition);
        return this;
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    SceneComponent.prototype.cloneFromHiloNode = function (node) {
        this._node.gltfExtensions = node.gltfExtensions;
        this._node.jointName = node.jointName;
        this._node.animationId = node.animationId;
        this._node.name = node.name;
    };
    /**
     * 可以自行重写用于添加预渲染策略！
     * 进行一次预渲染，期间会处理材质预编译、资源预提交等。
     */
    SceneComponent.prototype.preRender = function () {
    };
    SceneComponent = __decorate([
        SClass({ className: 'SceneComponent' })
    ], SceneComponent);
    return SceneComponent;
}(Component));

/**
 * @File   : Constants.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 10/9/2018, 11:43:07 PM
 * @Description:
 */
/**
 * WebGL相关的静态约束。
 */
var Constants = Hilo3d$2.constants;

/**
 * 判断一个实例是否为`Texture`。
 */
function isTexture(value) {
    return value.isTexture;
}
var Texture = /** @class */ (function (_super) {
    __extends(Texture, _super);
    function Texture() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Texture;
}(Hilo3d$2.Texture));

/**
 * @hidden
 */
function isIMaterialUniform(value) {
    return value && !value.substr && 'value' in value;
}
/**
 * @hidden
 */
function isIMaterialAttribute(value) {
    return value.name !== undefined;
}
/**
 * @hidden
 */
function isNumber(value) {
    return !!value.toPrecision;
}
/**
 * @hidden
 */
function isNumberArray(value) {
    return !!value.push;
}
/**
 * @hidden
 */
function isString(value) {
    return !!value.toLowerCase;
}
/**
 * 判断一个实例是否为`RawShaderMaterial`。
 */
function isRawShaderMaterial(value) {
    return value.isRawShaderMaterial;
}
/**
 * 纯净的自定义材质类，允许你创建属于自己的Shader材质。
 *
 * @noInheritDoc
 */
var RawShaderMaterial = /** @class */ (function (_super) {
    __extends(RawShaderMaterial, _super);
    function RawShaderMaterial(options) {
        var _this = _super.call(this, { useHeaderCache: true }) || this;
        _this.isRawShaderMaterial = true;
        /**
         * 类名。
         */
        _this.className = 'RawShaderMaterial';
        /**
         * 当材质作为模型中的自定义材质时，每次创建一个新模型实例时是否要对材质进行`clone`。
         * 这通常用于可能有多个实例的、具有材质动画的模型。
         */
        _this.cloneForInst = false;
        _this._chuckDefines = [];
        _this._chuckVs = [];
        _this._chuckFs = [];
        _this._uniforms = {};
        /**
         * 获取定制的渲染参数，一般用于宏开关。
         */
        _this.getCustomRenderOption = function (options) {
        };
        _this._initOptions = options;
        if (!options) {
            return _this;
        }
        _this.className = _this.constructor.CLASS_NAME.value;
        options.shaderCacheId = options.id;
        if (!options.id && _this.className !== 'RawShaderMaterial' && _this.className !== 'ShaderMaterial') {
            options.shaderCacheId = _this.className;
        }
        delete options.id;
        _this.init(options);
        return _this;
    }
    RawShaderMaterial_1 = RawShaderMaterial;
    /**
     * 获取特定的Uniform实例引用，可以获取后直接用`value`来设置它。
     */
    RawShaderMaterial.prototype.getUniform = function (key) {
        return this._uniforms[key];
    };
    /**
     * 直接设置某个特定uniform的`value`。
     */
    RawShaderMaterial.prototype.setUniform = function (key, value) {
        var uniform = this._uniforms[key];
        if (!uniform || uniform.value === null || uniform.value === undefined) {
            this.initUniform(key, { value: value });
            return this;
        }
        uniform.value = value;
        return this;
    };
    /**
     * 通过一个回调函数以及其传入的uniform当前值，设置某个特定uniform的`value`。
     */
    RawShaderMaterial.prototype.changeUniform = function (key, handler) {
        var value = handler(this._uniforms[key].value);
        return this.setUniform(key, value);
    };
    RawShaderMaterial.prototype.init = function (options) {
        if (!options.id) {
            delete options.id;
        }
        // default blend mode
        this.blendSrc = Constants.SRC_ALPHA;
        this.blendDst = Constants.ONE_MINUS_SRC_ALPHA;
        this.blendEquationAlpha = Constants.FUNC_ADD;
        Object.assign(this, options);
        this.uniforms = {};
        this.attributes = {};
        this.vs = '';
        this.fs = '';
        this.initChunks(options);
        this.initAttributes(options);
        this.initUniforms(options);
        this.initShaders(options);
    };
    RawShaderMaterial.prototype.initChunks = function (options) {
        options.attributes = options.attributes || {};
        options.uniforms = options.uniforms || {};
        if (options.chunks) {
            var length_1 = options.chunks.length;
            for (var index = 0; index < length_1; index += 1) {
                var chuck = options.chunks[index];
                if (Debug.devMode) {
                    this.checkChuck(chuck, options);
                }
                Object.assign(options.attributes, chuck.attributes);
                Object.assign(options.uniforms, chuck.uniforms);
                if (chuck.vs) {
                    this._chuckVs.push(chuck.vs);
                    if (chuck.isMain && chuck.hasVsOut) {
                        this._mainVsChunkName = chuck.vsEntryName;
                    }
                }
                if (chuck.fs) {
                    this._chuckFs.push(chuck.fs);
                    if (chuck.isMain && chuck.hasFsOut) {
                        this._mainFsChunkName = chuck.fsEntryName;
                    }
                }
                if (chuck.defines) {
                    this._chuckDefines.push(chuck.defines);
                }
            }
        }
        if (options.vs) {
            if (isString(options.vs)) {
                this._chuckVs.push({ main: options.vs, header: '' });
            }
            else {
                this._chuckVs.push(options.vs);
            }
            this._mainVsChunkName = '';
        }
        if (options.fs) {
            if (isString(options.fs)) {
                this._chuckFs.push({ main: options.fs, header: '' });
            }
            else if (options.fs) {
                this._chuckFs.push(options.fs);
            }
            this._mainFsChunkName = '';
        }
        if (options.defines) {
            this._chuckDefines.push(options.defines);
        }
    };
    RawShaderMaterial.prototype.checkChuck = function (chuck, options) {
        var requiredUniforms = chuck.requiredUniforms, requiredAttributes = chuck.requiredAttributes, uniforms = chuck.uniforms, attributes = chuck.attributes;
        // check requiredAttributes
        for (var _i = 0, requiredAttributes_1 = requiredAttributes; _i < requiredAttributes_1.length; _i++) {
            var key = requiredAttributes_1[_i];
            if (!options.attributes[key]) {
                throw new Error("Shader chuck \"" + chuck.name + "\" requires attribute \"" + key + "\" !");
            }
        }
        // check requiredUniforms
        for (var _a = 0, requiredUniforms_1 = requiredUniforms; _a < requiredUniforms_1.length; _a++) {
            var key = requiredUniforms_1[_a];
            if (!options.uniforms[key]) {
                throw new Error("Shader chuck \"" + chuck.name + "\" requires uniform \"" + key + "\" !");
            }
        }
        // check conflict
        for (var key in attributes) {
            if (options.attributes[key]) {
                throw new Error("Attribute \"" + key + "\" is already existed, re-defined in shader chuck \"" + chuck.name + "\" !");
            }
        }
        for (var key in uniforms) {
            if (options.uniforms[key]) {
                throw new Error("Uniform \"" + key + "\" is already existed, re-defined in shader chuck \"" + chuck.name + "\" !");
            }
        }
    };
    RawShaderMaterial.prototype.initAttributes = function (options) {
        var attributes = options.attributes;
        this.attributes = {};
        var _loop_1 = function (key) {
            var attribute = attributes[key];
            if (!isIMaterialAttribute(attribute)) {
                this_1.attributes[key] = attribute;
            }
            else {
                this_1.attributes[key] = {
                    get: function (mesh) { return mesh.geometry[attribute.name]; }
                };
            }
        };
        var this_1 = this;
        for (var key in attributes) {
            _loop_1(key);
        }
    };
    RawShaderMaterial.prototype.initUniforms = function (options) {
        var uniforms = options.uniforms;
        if (!uniforms['u_gammaFactor']) {
            uniforms['u_gammaFactor'] = 'GAMMAFACTOR';
        }
        if (!uniforms['u_exposure']) {
            uniforms['u_exposure'] = 'EXPOSURE';
        }
        for (var key in uniforms) {
            var uniform = uniforms[key];
            if (!isIMaterialUniform(uniform)) {
                this.uniforms[key] = uniform;
                continue;
            }
            this.initUniform(key, uniform);
        }
    };
    RawShaderMaterial.prototype.initUniform = function (key, uniform) {
        var _uniforms = this._uniforms;
        if (uniform.isGlobal) {
            _uniforms[key] = uniform;
        }
        else {
            _uniforms[key] = { value: uniform.value };
        }
        var value = _uniforms[key].value;
        this.isDirty = true;
        if (value === null || value === undefined) {
            this.uniforms[key] = {
                get: function () {
                    return null;
                }
            };
            return;
        }
        if (isTexture(value)) {
            this.uniforms[key] = {
                get: function (_, __, programInfo) {
                    return Hilo3d$2.semantic.handlerTexture(_uniforms[key].value, programInfo.textureIndex);
                }
            };
            return;
        }
        if (isNumber(value) || isNumberArray(value)) {
            this.uniforms[key] = {
                get: function () {
                    return _uniforms[key].value;
                }
            };
            return;
        }
        this.uniforms[key] = {
            get: function () {
                return _uniforms[key].value.elements;
            }
        };
    };
    RawShaderMaterial.prototype.initShaders = function (options) {
        var definesChuck = this._chuckDefines.join('\n') + '\n';
        this.vs += definesChuck;
        this.fs += definesChuck;
        this.vs += this.generateShader(this._chuckVs);
        this.fs += this.generateShader(this._chuckFs);
        if (this._mainVsChunkName) {
            this.vs += "\nvoid main() {\ngl_Position = " + this._mainVsChunkName + "();\n}\n";
        }
        if (this._mainFsChunkName) {
            this.fs += "\nvoid main() {\ngl_FragColor = " + this._mainFsChunkName + "();\n}\n";
        }
        this.initCommonOptions(options);
    };
    /**
     * 不需要自己使用！
     *
     * @hidden
     */
    RawShaderMaterial.prototype.initCommonOptions = function (options, fromLoader) {
        if (fromLoader === void 0) { fromLoader = false; }
        if (options.alphaMode && (!fromLoader || !this._initOptions.alphaMode)) {
            switch (options.alphaMode) {
                case 'BLEND':
                    this.transparent = true;
                    this.blend = true;
                    if (!fromLoader) {
                        this.blendSrc = options.blendSrc || Constants.SRC_ALPHA;
                        this.blendDst = options.blendDst || Constants.ONE_MINUS_SRC_ALPHA;
                        this.blendEquationAlpha = options.blendEquationAlpha || Constants.FUNC_ADD;
                    }
                    break;
                case 'MASK':
                    if ('alphaCutoff' in options) {
                        this.alphaCutoff = options.alphaCutoff;
                    }
                    else {
                        this.alphaCutoff = 0.5;
                    }
                    break;
                case 'OPAQUE':
                default:
                    this.ignoreTranparent = true;
                    break;
            }
            this._initOptions.alphaMode = options.alphaMode;
        }
        if ((options.doubleSided && !fromLoader) || (options.doubleSided && !this._initOptions.doubleSided)) {
            this.side = Constants.FRONT_AND_BACK;
            this._initOptions.doubleSided = true;
        }
        this.lightType = options.unlit ? 'NONE' : 'ENABLE';
    };
    RawShaderMaterial.prototype.generateShader = function (chucks) {
        var headerCode = '';
        var mainCode = '';
        var length = chucks.length;
        for (var index = 0; index < length; index += 1) {
            var _a = chucks[index], header = _a.header, main = _a.main;
            headerCode += header + '\n';
            mainCode += main + '\n';
        }
        return headerCode + '\n' + mainCode + '\n';
    };
    /**
     * clone一个材质，一般不会重新编译program，但会生成一份新的`uniforms`。
     */
    RawShaderMaterial.prototype.clone = function () {
        var material = new this.constructor(this._initOptions);
        material.initCommonOptions(this._initOptions);
        return material;
    };
    RawShaderMaterial.prototype.destroyTextures = function () {
        _super.prototype.destroyTextures.call(this);
        for (var propName in this._uniforms) {
            var texture = this._uniforms[propName].value;
            if (texture && isTexture(texture)) {
                texture.destroy();
            }
        }
        return this;
    };
    var RawShaderMaterial_1;
    /**
     * 类名。
     */
    RawShaderMaterial.CLASS_NAME = new SName('RawShaderMaterial');
    RawShaderMaterial = RawShaderMaterial_1 = __decorate([
        SMaterial({ className: 'RawShaderMaterial' })
    ], RawShaderMaterial);
    return RawShaderMaterial;
}(Hilo3d$2.ShaderMaterial));

var Shader = /** @class */ (function (_super) {
    __extends(Shader, _super);
    function Shader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Shader;
}(Hilo3d$2.Shader));

/**
 * 判断一个对象是否为`SkyboxMaterial`。
 */
function isSkyboxMaterial(value) {
    return value.isSkyboxMaterial;
}
/**
 * 默认的天空盒纹理，支持纯色、立方体纹理、全景纹理模式。
 */
var SkyboxMaterial = /** @class */ (function (_super) {
    __extends(SkyboxMaterial, _super);
    function SkyboxMaterial(options) {
        var _this = _super.call(this, {
            depthMask: true,
            // 渲染非透明物体的队列中，最后渲染天空盒来保证良好的性能
            renderOrder: 9999,
            side: Constants.BACK,
            attributes: {
                a_position: 'POSITION',
                a_uv: 'TEXCOORD_0'
            },
            uniforms: {
                u_viewProjectionMatrix: { value: new Matrix4() },
                u_texture: options.uniforms.u_texture,
                u_color: options.uniforms.u_color,
                u_rotation: options.uniforms.u_rotation,
                u_factor: options.uniforms.u_factor || { value: 1 },
                u_exposure: options.uniforms.u_exposure,
                u_degrees: options.uniforms.u_degrees
            },
            vs: "\nprecision highp float;\n\nattribute vec3 a_position;\nattribute vec2 a_uv;\n\nuniform mat4 u_viewProjectionMatrix;\n\nvarying vec2 v_uv;\n\n#ifdef SKYBOX_CUBE\nvarying vec3 v_position;\n#endif\n\nvoid main()\n{\n#ifdef SKYBOX_CUBE\nv_position = a_position.xyz;\n#endif\nvec4 pos = u_viewProjectionMatrix * vec4(a_position, 1.0);\ngl_Position = pos.xyww;\nv_uv = a_uv;\n}\n",
            fs: "\nprecision mediump float;\n\nuniform float u_factor;\nuniform vec4 u_color;\n\n" + Shader.shaders['chunk/color.frag'] + "\n" + Shader.shaders['method/encoding.glsl'] + "\n\n#ifdef SKYBOX_CUBE\nuniform samplerCube u_texture;\nuniform float u_exposure;\nvarying vec3 v_position;\n#endif\n\n#ifdef SKYBOX_PANORAMIC\nuniform sampler2D u_texture;\nuniform float u_exposure;\n#endif\n\nvarying vec2 v_uv;\n\nvec3 decodeRGBD(vec4 color) {\nreturn color.rgb / color.a;\n}\n\nvoid main()\n{\nvec4 color = vec4(1., 1., 1., 1.);\n\n#ifdef SKYBOX_CUBE\nvec3 tex = decodeRGBD(textureCube(u_texture, v_position));\n#endif\n\n#ifdef SKYBOX_PANORAMIC\nvec3 tex = decodeRGBD(texture2D(u_texture, v_uv));\n#endif\n\n#ifdef HILO_GAMMA_CORRECTION\ntex = sRGBToLinear(tex);\n#endif\ncolor.rgb = tex * u_color.rgb * u_exposure * u_factor;\n\n" + Shader.shaders['chunk/frag_color.frag'] + "\n}     \n"
        }) || this;
        _this.isSkyboxMaterial = true;
        _this.type = 'Color';
        _this.getCustomRenderOption = function (options) {
            if (_this.type === 'Cube') {
                options.SKYBOX_CUBE = 1;
            }
            else if (_this.type === 'Panoramic') {
                options.SKYBOX_PANORAMIC = 1;
            }
            else {
                options.SKYBOX_COLOR = 1;
            }
            return options;
        };
        _this.type = options.type;
        return _this;
    }
    SkyboxMaterial = __decorate([
        SMaterial({ className: 'SkyboxMaterial' })
    ], SkyboxMaterial);
    return SkyboxMaterial;
}(RawShaderMaterial));

/**
 * 判断一个实例是否为`Mesh`。
 */
function isMesh(value) {
    return value.isMesh;
}
/**
 * 曲面类。封装几何体`Geometry`和材质`Material`。
 */
var Mesh = /** @class */ (function (_super) {
    __extends(Mesh, _super);
    function Mesh() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * 获取指定类型的材质。
     */
    Mesh.prototype.getMaterial = function () {
        return this.material;
    };
    /**
     * 克隆。
     */
    Mesh.prototype.clone = function (isChild) {
        return _super.prototype.clone.call(this, isChild);
    };
    return Mesh;
}(Hilo3d$2.Mesh));

/**
 * 判断一个实例是否为`BoxGeometry`。
 */
function isBoxGeometry(value) {
    return value.isBoxGeometry;
}
var BoxGeometry = /** @class */ (function (_super) {
    __extends(BoxGeometry, _super);
    function BoxGeometry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return BoxGeometry;
}(Hilo3d$2.BoxGeometry));

/**
 * 判断一个实例是否为`SphereGeometry`。
 */
function isSphereGeometry(value) {
    return value.isSphereGeometry;
}
var SphereGeometry = /** @class */ (function (_super) {
    __extends(SphereGeometry, _super);
    function SphereGeometry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SphereGeometry;
}(Hilo3d$2.SphereGeometry));

/**
 * 判断一个实例是否为`BreakGuardException`。
 */
function isBreakGuardException(value) {
    return value.isBreakGuardException;
}
/**
 * 破坏守护机制的异常。
 *
 * @noInheritDoc
 */
var BreakGuardException = /** @class */ (function (_super) {
    __extends(BreakGuardException, _super);
    /**
     * 构建异常。
     *
     * @param object 触发异常的实例。
     * @param message 追加信息。
     */
    function BreakGuardException(object, message) {
        if (message === void 0) { message = ''; }
        var _this = _super.call(this, 'BreakGuard', object, message) || this;
        _this.isBreakGuardException = true;
        return _this;
    }
    return BreakGuardException;
}(BaseException));

/**
 * 判断一个实例是否为`CameraComponent`。
 */
function isCameraComponent(value) {
    return value.isCameraComponent;
}
/**
 * 判断一个实例是否为`CameraActor`。
 */
function isCameraActor(value) {
    return isSceneActor(value) && isCameraComponent(value.root);
}
/**
 * 摄像机Component基类，承担着场景摄像机的实际功能。
 * 一般不直接使用，而是使用各个派生类。
 *
 * @noInheritDoc
 */
var CameraComponent = /** @class */ (function (_super) {
    __extends(CameraComponent, _super);
    function CameraComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isCameraComponent = true;
        _this._isMainCamera = false;
        _this._rendererAlive = false;
        return _this;
    }
    Object.defineProperty(CameraComponent.prototype, "isMainCamera", {
        /**
         * 是否为当前World的主摄像机。
         */
        get: function () {
            return this._isMainCamera;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CameraComponent.prototype, "viewMatrix", {
        /**
         * 视图矩阵。
         */
        get: function () {
            return this._camera.viewMatrix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CameraComponent.prototype, "projectionMatrix", {
        /**
         * 投影矩阵。
         */
        get: function () {
            return this._camera.projectionMatrix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CameraComponent.prototype, "viewProjectionMatrix", {
        /**
         * 视图投影矩阵。
         */
        get: function () {
            return this._camera.viewProjectionMatrix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CameraComponent.prototype, "rendererAlive", {
        /**
         * 渲染器是否在正常活动。
         */
        get: function () {
            return this._rendererAlive;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 修改天空盒材质。
     */
    CameraComponent.prototype.changeBackgroundMat = function (action) {
        var preType = this._backgroundMat.type;
        action(this._backgroundMat);
        if (preType !== this._backgroundMat.type) {
            this.generateSkybox(this._backgroundMat);
            if (this._isMainCamera) {
                this.disableSkybox();
                this.enableSkybox();
            }
        }
    };
    /**
     * 初始化，继承请先`super.onInit()`。
     */
    CameraComponent.prototype.onInit = function (initState) {
        _super.prototype.onInit.call(this, initState);
        this._camera = this.onCreateCamera(initState);
        this._camera.__forceUseParentWorldMatrix = true;
        this._node.addChild(this._camera);
        this._node._rotation.order = 'XYZ';
        this._node.isCamera = true;
        this.generateSkybox(initState.backgroundMat);
    };
    CameraComponent.prototype.generateSkybox = function (mat) {
        if (!mat) {
            mat = new SkyboxMaterial({ type: 'Color', uniforms: {
                    u_color: { value: this.getGame().renderer.clearColor }
                } });
        }
        if (mat.type === 'Color') {
            this.getGame().renderer.clearColor.copy(mat.getUniform('u_color').value);
            return;
        }
        this._backgroundMat = mat;
        if (mat.type === 'Panoramic') {
            this._background = new Mesh({
                geometry: new SphereGeometry({ radius: 1 }),
                material: this._backgroundMat
            });
        }
        else {
            this._background = new Mesh({
                geometry: new BoxGeometry({ width: 2, height: 2, depth: 2 }),
                material: this._backgroundMat
            });
        }
    };
    CameraComponent.prototype.onCreateCamera = function (initState) {
        return null;
    };
    /**
     * 特殊生命周期，当摄像机被作为World的主摄像机时被触发。
     */
    CameraComponent.prototype.onAsMainCamera = function (isMain) {
        var game = this.getGame();
        if (isMain) {
            this.enableSkybox();
            game.hiloStage.camera = this._camera;
            this._isMainCamera = true;
        }
        else if (this._isMainCamera) {
            this.disableSkybox();
            game.hiloStage.camera = null;
            this._isMainCamera = false;
        }
    };
    CameraComponent.prototype.enableSkybox = function () {
        if (this._background) {
            this.getGame().hiloStage.addChild(this._background);
        }
    };
    CameraComponent.prototype.disableSkybox = function () {
        if (this._background) {
            this.getGame().hiloStage.removeChild(this._background);
        }
    };
    /**
     * 加入World，继承请先`super.onAdd()`。
     */
    CameraComponent.prototype.onAdd = function () {
        if (!this.getWorld().mainCamera) {
            this.getWorld().setMainCamera(this);
        }
    };
    /**
     * 每一帧更新，继承请先`super.onUpdate()`。
     */
    CameraComponent.prototype.onUpdate = function () {
        var _this = this;
        this._rendererAlive = false;
        if (this._isMainCamera && this._background) {
            this._backgroundMat.changeUniform('u_viewProjectionMatrix', function (mat) {
                mat.copy(_this.viewMatrix);
                var rotation = _this._backgroundMat.getUniform('u_rotation');
                if (rotation && rotation.value !== 0) {
                    mat.rotateY(-rotation.value);
                }
                mat.elements[12] = 0;
                mat.elements[13] = 0;
                mat.elements[14] = 0;
                mat.premultiply(_this.projectionMatrix);
                return mat;
            });
        }
    };
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    CameraComponent.prototype.onDestroy = function () {
        this.onAsMainCamera(false);
        if (this.getWorld().mainCamera === this) {
            this.getWorld().removeMainCamera();
        }
        _super.prototype.onDestroy.call(this);
    };
    /**
     * 计算向量`vector`从世界空间被该相机投影到二维画布上的位置。
     * 若不传容器的`width`和`height`，则返回`0 ~ 1`的值。
     */
    CameraComponent.prototype.projectVector = function (vector, width, height) {
        return this._camera.projectVector(vector, width, height);
    };
    /**
     * 计算向量`vector`从屏幕空间反变换到世界空间后的位置。
     * 若不传容器的`width`和`height`，则认为`vector`是NDC的坐标。
     */
    CameraComponent.prototype.unprojectVector = function (vector, width, height) {
        return this._camera.unprojectVector(vector, width, height);
    };
    /**
     * 更新视图投影矩阵
     */
    CameraComponent.prototype.updateViewProjectionMatrix = function () {
        this._camera.updateProjectionMatrix();
    };
    /**
     * 根据容器上的一个点`(x, y)`以及容器的宽度`width`和高度`height`，还有射线长度`rayLength`生成世界空间的一条射线。
     * 射线起点和终点将会被存储到传入的`outFrom`和`outTo`中。
     */
    CameraComponent.prototype.generateRay = function (x, y, width, height, outFrom, outTo, rayLength) {
        throw new Error('Not implements');
    };
    /**
     * 截取当前画布并返回Blob或Base64。
     * 但注意其开销！其会**立即再渲染一遍当前场景**！
     *
     * @param mimetype 编码类型，例如image/jpeg
     * @param encoderOptions 编码参数，0 ~ 1。
     */
    CameraComponent.prototype.captureScreen = function (mode, mimetype, encoderOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var canvas;
            var _this = this;
            return __generator(this, function (_a) {
                if (!this._isMainCamera) {
                    throw new BreakGuardException(this, '`captureScreen` can not be called by `mainCamera` now !');
                }
                canvas = this.getGame().canvas;
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this.render();
                        try {
                            if (mode === 'blob') {
                                canvas.toBlob(function (blob) { return resolve(blob); }, mimetype, encoderOptions);
                            }
                            else {
                                resolve(canvas.toDataURL(mimetype, encoderOptions));
                            }
                        }
                        catch (error) {
                            reject(error);
                        }
                    })];
            });
        });
    };
    /**
     * 渲染当前摄像机对应的画面。如果没有特殊需求（比如后处理、镜面等）不需要自己调用。
     *
     * @param frameBuffer 如果指定，则将会渲染到这个FrameBuffer，不会输出到屏幕上。
     * @param fireEvent 开发者无需关心，**不要自己使用！**。
     */
    CameraComponent.prototype.render = function (frameBuffer, fireEvent) {
        var _this = this;
        if (fireEvent === void 0) { fireEvent = false; }
        var game = this.getGame();
        var world = this.getWorld();
        var renderer = game.renderer;
        if (this._isMainCamera && fireEvent) {
            game.event.trigger('MainRendererWillStart');
        }
        if (!this._isMainCamera) {
            game.hiloStage.camera = this._camera;
        }
        if (world.enableLayers) {
            world.actors.forEach(function (actor) {
                actor.visible = _this.layers.test(actor.layers);
            });
        }
        try {
            if (frameBuffer) {
                frameBuffer.bind();
                renderer.render(game.hiloStage, this._camera, false);
                frameBuffer.unbind();
            }
            else {
                renderer.render(game.hiloStage, this._camera, fireEvent);
            }
            this._rendererAlive = true;
        }
        catch (error) {
            throwException(error, this);
            this._rendererAlive = false;
        }
        if (!this._isMainCamera) {
            game.hiloStage.camera = world.mainCamera._camera;
        }
        if (this._isMainCamera && fireEvent) {
            game.event.trigger('MainRendererIsFinished');
        }
    };
    CameraComponent = __decorate([
        SClass({ className: 'CameraComponent' })
    ], CameraComponent);
    return CameraComponent;
}(SceneComponent));

/**
 * 判断一个实例是否为`UnmetRequireException`。
 */
function isUnmetRequireException(value) {
    return value.isUnmetRequireException;
}
/**
 * 前置功能缺失异常。
 *
 * @noInheritDoc
 */
var UnmetRequireException = /** @class */ (function (_super) {
    __extends(UnmetRequireException, _super);
    /**
     * 构建异常。
     *
     * @param object 触发异常的实例。
     * @param message 追加信息。
     */
    function UnmetRequireException(object, message) {
        if (message === void 0) { message = ''; }
        var _this = _super.call(this, 'UnmetRequire', object, message) || this;
        _this.isUnmetRequireException = true;
        return _this;
    }
    return UnmetRequireException;
}(BaseException));

/**
 * 判断一个实例是否为`PerspectiveCameraComponent`。
 */
function isPerspectiveCameraComponent(value) {
    return value.isPerspectiveCameraComponent;
}
/**
 * 判断一个实例是否为`PerspectiveCameraActor`。
 */
function isPerspectiveCameraActor(value) {
    return isSceneActor(value) && isPerspectiveCameraComponent(value.root);
}
/**
 * 透视摄像机组件。
 *
 * @noInheritDoc
 */
var PerspectiveCameraComponent = /** @class */ (function (_super) {
    __extends(PerspectiveCameraComponent, _super);
    function PerspectiveCameraComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isPerspectiveCameraComponent = true;
        return _this;
    }
    PerspectiveCameraComponent.prototype.onCreateCamera = function (initState) {
        return new Hilo3d$2.PerspectiveCamera(initState);
    };
    Object.defineProperty(PerspectiveCameraComponent.prototype, "near", {
        /**
         * 摄像机近裁剪面。
         */
        get: function () {
            return this._camera.near;
        },
        /**
         * 摄像机近裁剪面。
         */
        set: function (near) {
            this._camera.near = near;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PerspectiveCameraComponent.prototype, "far", {
        /**
         * 摄像机远裁剪面。
         */
        get: function () {
            return this._camera.far;
        },
        /**
         * 摄像机远裁剪面。
         */
        set: function (far) {
            this._camera.far = far;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PerspectiveCameraComponent.prototype, "fov", {
        /**
         * 摄像机俯仰角。
         */
        get: function () {
            return this._camera.fov;
        },
        /**
         * 摄像机俯仰角。
         */
        set: function (fov) {
            this._camera.fov = fov;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PerspectiveCameraComponent.prototype, "aspect", {
        /**
         * 摄像机视场纵横比。
         */
        get: function () {
            return this._camera.aspect;
        },
        /**
         * 摄像机视场纵横比。
         */
        set: function (aspect) {
            this._camera.aspect = aspect;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 根据容器上的一个点`(x, y)`以及容器的宽度`width`和高度`height`，还有射线长度`rayLength`生成世界空间的一条射线。
     * 射线起点和终点将会被存储到传入的`outFrom`和`outTo`中。
     */
    PerspectiveCameraComponent.prototype.generateRay = function (x, y, width, height, outFrom, outTo, rayLength) {
        if (rayLength === void 0) { rayLength = 100; }
        this._node.worldMatrix.getTranslation(outFrom);
        outTo.set(x, y, 1);
        outTo.copy(this._camera.unprojectVector(outTo, width, height).subtract(outFrom)).normalize().scale(rayLength).add(outFrom);
        return this;
    };
    PerspectiveCameraComponent = __decorate([
        SClass({ className: 'PerspectiveCameraComponent' })
    ], PerspectiveCameraComponent);
    return PerspectiveCameraComponent;
}(CameraComponent));

/**
 * 判断一个实例是否为`OrthographicCameraComponent`。
 */
function isOrthographicCameraComponent(value) {
    return value.isOrthographicCameraComponent;
}
/**
 * 判断一个实例是否为`OrthographicCameraActor`。
 */
function isOrthographicCameraActor(value) {
    return isSceneActor(value) && isOrthographicCameraComponent(value.root);
}
/**
 * 正交摄像机组件。
 *
 * @noInheritDoc
 */
var OrthographicCameraComponent = /** @class */ (function (_super) {
    __extends(OrthographicCameraComponent, _super);
    function OrthographicCameraComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isOrthographicCameraComponent = true;
        return _this;
    }
    OrthographicCameraComponent.prototype.onCreateCamera = function (initState) {
        return new Hilo3d$2.OrthographicCamera(initState);
    };
    Object.defineProperty(OrthographicCameraComponent.prototype, "near", {
        /**
         * 摄像机近裁剪面。
         */
        get: function () {
            return this._camera.near;
        },
        /**
         * 摄像机近裁剪面。
         */
        set: function (near) {
            this._camera.near = near;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrthographicCameraComponent.prototype, "far", {
        /**
         * 摄像机远裁剪面。
         */
        get: function () {
            return this._camera.far;
        },
        /**
         * 摄像机远裁剪面。
         */
        set: function (far) {
            this._camera.far = far;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrthographicCameraComponent.prototype, "left", {
        /**
         * 摄像机左裁剪面。
         */
        get: function () {
            return this._camera.left;
        },
        /**
         * 摄像机左裁剪面。
         */
        set: function (left) {
            this._camera.left = left;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrthographicCameraComponent.prototype, "right", {
        /**
         * 摄像机右裁剪面。
         */
        get: function () {
            return this._camera.right;
        },
        /**
         * 摄像机右裁剪面。
         */
        set: function (right) {
            this._camera.right = right;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrthographicCameraComponent.prototype, "top", {
        /**
         * 摄像机上裁剪面。
         */
        get: function () {
            return this._camera.top;
        },
        /**
         * 摄像机上裁剪面。
         */
        set: function (top) {
            this._camera.top = top;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrthographicCameraComponent.prototype, "bottom", {
        /**
         * 摄像机下裁剪面。
         */
        get: function () {
            return this._camera.bottom;
        },
        /**
         * 摄像机下裁剪面。
         */
        set: function (bottom) {
            this._camera.bottom = bottom;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 根据容器上的一个点`(x, y)`以及容器的宽度`width`和高度`height`，还有射线长度`rayLength`生成世界空间的一条射线。
     * 射线起点和终点将会被存储到传入的`outFrom`和`outTo`中。
     */
    OrthographicCameraComponent.prototype.generateRay = function (x, y, width, height, outFrom, outTo, rayLength) {
        if (rayLength === void 0) { rayLength = 100; }
        var camera = this._camera;
        outFrom.set(x, y, (camera.near + camera.far) / (camera.near - camera.far));
        outFrom.copy(this._camera.unprojectVector(outFrom, width, height));
        var forwardVector = this.forwardVector;
        outTo.copy(outFrom).add(forwardVector.scale(-rayLength));
        return this;
    };
    OrthographicCameraComponent = __decorate([
        SClass({ className: 'OrthographicCameraComponent' })
    ], OrthographicCameraComponent);
    return OrthographicCameraComponent;
}(CameraComponent));

/**
 * 判断一个实例是否为`World`。
 */
function isWorld(value) {
    return value.isWorld;
}
/**
 * 世界类，单个世界的逻辑容器，挂载在`Game`下，通常使用`getWorld`获取。
 * 一般来讲，我们不建议直接使用`Level`中的一些方法，而是使用`World`进行代理，更符合直觉。
 * 它的实际游戏逻辑由[GameModeActor](../gamemodeactor)描述。
 *
 * @template IState World的状态Actor类型，用于存储当前世界的状态数据。
 * @noInheritDoc
 */
var World = /** @class */ (function (_super) {
    __extends(World, _super);
    /**
     * 创建World，不要自己创建！
     *
     * @hidden
     */
    function World(name, GameMode, levels, game) {
        var _this = _super.call(this, name) || this;
        _this.isWorld = true;
        /**
         * 开启图层功能，若开启，可以通过给每个`Actor`指定`layers`，之后通过摄像机的`layers`来控制显示内容。
         * 详见示例**[Layers](../../example/renderer/layers)**。
         */
        _this.enableLayers = false;
        _this._game = null;
        _this._script = null;
        _this._level = null;
        _this._levels = {};
        _this._mainCamera = null;
        // use for splitting screen mode, waiting.....
        _this._mainCameras = [];
        _this._physicWorld = null;
        _this._updatable = false;
        _this._game = game;
        _this._levels = levels;
        _this._GameModeClass = GameMode;
        return _this;
    }
    Object.defineProperty(World, "UP", {
        /**
         * 世界的up单位向量。
         */
        get: function () {
            return new Vector3(0, 1, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World, "DOWN", {
        /**
         * 世界的down单位向量。
         */
        get: function () {
            return new Vector3(0, -1, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World, "RIGHT", {
        /**
         * 世界的right单位向量。
         */
        get: function () {
            return new Vector3(1, 0, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World, "LEFT", {
        /**
         * 世界的left单位向量。
         */
        get: function () {
            return new Vector3(-1, 0, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World, "FORWARD", {
        /**
         * 世界的forward单位向量。
         */
        get: function () {
            return new Vector3(0, 0, -1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World, "BACK", {
        /**
         * 世界的back单位向量。
         */
        get: function () {
            return new Vector3(0, 0, 1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "state", {
        /**
         * World状态Actor实例引用。
         */
        get: function () {
            return this._state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "game", {
        /**
         * 当前`Game`实例引用。一般不直接使用，而是用`actor.getGame()`或`component.getGame`，提供更好的泛型类型推断。
         */
        get: function () {
            return this._game;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "level", {
        /**
         * 当前`Level`实例引用。一般不直接使用，而是用`actor.getLevel()`或`component.getLevel`，提供更好的泛型类型推断。
         */
        get: function () {
            return this._level;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "parent", {
        /**
         * Wolrd的父级Game实例引用。
         */
        get: function () {
            return this._game;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "actors", {
        /**
         * 当前Level所有的actors，建议从这里获取。
         */
        get: function () {
            return this._level.actors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "mainCamera", {
        /**
         * 当前的摄像机组件实例引用。
         */
        get: function () {
            return this._mainCamera;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "physicWorld", {
        /**
         * 当前的物理世界实例引用，需要使用[enablePhysic](#enablephysic)开启后获取。
         */
        get: function () {
            return this._physicWorld;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "upVector", {
        /**
         * 当前世界的up单位向量。
         *
         * @deprecated
         */
        get: function () {
            return new Vector3(0, 1, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "downVector", {
        /**
         * 当前世界的down单位向量。
         *
         * @deprecated
         */
        get: function () {
            return new Vector3(0, -1, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "rightVector", {
        /**
         * 当前世界的right单位向量。
         *
         * @deprecated
         */
        get: function () {
            return new Vector3(1, 0, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "leftVector", {
        /**
         * 当前世界的left单位向量。
         *
         * @deprecated
         */
        get: function () {
            return new Vector3(-1, 0, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "forwardVector", {
        /**
         * 当前世界的forward单位向量。
         *
         * @deprecated
         */
        get: function () {
            return new Vector3(0, 0, -1);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "backVector", {
        /**
         * 当前世界的back单位向量。
         *
         * @deprecated
         */
        get: function () {
            return new Vector3(0, 0, 1);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 生命周期，用于错误边界处理。将在Game中大部分可预知错误发生时被调用（通常是生命周期中的非异步错误）。
     * 错误将会根据一定的路径向上传递，一直到`Engine`的层次，你可以在确保完美处理了问题后返回`true`来通知引擎不再向上传递。
     * 当然你也可以将自定义的一些错误加入错误边界机制中，详见[Exception](../../guide/exception)。
     */
    World.prototype.onError = function (error, details) {
        return this._script.onError(error, details);
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    World.prototype.init = function (initState) {
        return __awaiter(this, void 0, void 0, function () {
            var error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._script = this._game.addActor(this.name + "-game-mode", this._GameModeClass);
                        this._script.updateOnEverTick = false;
                        this._state = this._game.addActor('world-state', this._GameModeClass.WorldStateClass);
                        this._state.copy(initState);
                        this._state.updateOnEverTick = false;
                        this._script._parent = this;
                        this._state.copy(initState);
                        this._game.event.trigger('WorldDidInit', { world: this });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._script.onLogin()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        throwException(error_1, this._script);
                        return [3 /*break*/, 4];
                    case 4:
                        try {
                            this._script.onCreatePlayers();
                        }
                        catch (error) {
                            throwException(error, this._script);
                        }
                        this._game.event.trigger('WorldDidCreatePlayers', { world: this });
                        if (this._game.players.length < 1) {
                            throw new UnmetRequireException(this, 'You must give at least one player !');
                        }
                        this._script.updateOnEverTick = true;
                        this._state.updateOnEverTick = true;
                        this._updatable = true;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    World.prototype.update = function (delta) {
        if (!this._updatable) {
            return;
        }
        if (this._level) {
            this._level.update(delta);
        }
        if (!this.mainCamera) {
            return;
        }
        this.mainCamera.render(null, true);
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    World.prototype.destroy = function (forceClear) {
        if (forceClear === void 0) { forceClear = true; }
        _super.prototype.destroy.call(this);
        this._game.event.trigger('WorldWillDestroy', { world: this });
        try {
            this._script.onDestroyPlayers();
        }
        catch (error) {
            throwException(error, this._script);
        }
        var inheritActors = this._level.destroy(forceClear);
        // parent is not right, do not use removeFromParent
        this.game.removeActor(this._script);
        this.game.removeActor(this._state);
        if (this._physicWorld) {
            this._physicWorld.destroy();
        }
        this._game.players.forEach(function (player) {
            player.releaseController();
        });
        return inheritActors;
    };
    /**
     * 实际上的关卡切换逻辑，一般使用`game.switchLevel`进行代理。
     */
    World.prototype.switchLevel = function (name, initState, 
    // from world, for persistent level
    initActors) {
        if (initState === void 0) { initState = null; }
        return __awaiter(this, void 0, void 0, function () {
            var inheritActors, level, Script;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._levels[name]) {
                            throwException(new MissingMemberException(this, 'Level', name, this), this);
                        }
                        level = this._level;
                        Script = this._levels[name].Script;
                        this._level = new Level(name, Script, this);
                        this.addActor = this._level.addActor.bind(this._level);
                        this.removeActor = this._level.removeActor.bind(this._level);
                        // 先销毁当前关卡
                        if (level) {
                            inheritActors = level.destroy();
                        }
                        // 再继承Actor
                        this._level.inherit(inheritActors || initActors || new SArray());
                        // 然后当前关卡的onInit/onAdd/onLogin
                        return [4 /*yield*/, this._level.init(initState)];
                    case 1:
                        // 然后当前关卡的onInit/onAdd/onLogin
                        _a.sent();
                        // 最后加载资源
                        this._level.startLoading();
                        return [2 /*return*/, this];
                }
            });
        });
    };
    /**
     * 开启物理世界，具体使用见示例[Physic](../../example/physic/base)。
     *
     * @enableContactEvents 是否要启用高级碰撞事件，这可以让你拥有对碰撞更细致的控制，但会有一些性能损耗，默认不开启。
     */
    World.prototype.enablePhysic = function (physicWorld, enableContactEvents) {
        if (enableContactEvents === void 0) { enableContactEvents = false; }
        this._physicWorld = physicWorld;
        if (enableContactEvents) {
            this._physicWorld.initContactEvents();
        }
        return this;
    };
    World.prototype.setMainCamera = function (obj) {
        if (this._mainCamera) {
            this._mainCamera.onAsMainCamera(false);
        }
        if (isSObject(obj) && isCameraComponent(obj)) {
            this._mainCamera = obj;
        }
        else {
            this._mainCamera = obj.camera;
        }
        this._mainCamera.onAsMainCamera(true);
        return this.resizeMainCamera();
    };
    /**
     * 重置当前摄像机相关的尺寸参数，一般不需要自己调用。
     */
    World.prototype.resizeMainCamera = function () {
        if (!this._mainCamera) {
            return this;
        }
        var _a = this._game.bound, width = _a.width, height = _a.height;
        var aspect = width / height;
        if (isPerspectiveCameraComponent(this._mainCamera)) {
            this._mainCamera.aspect = aspect;
            return this;
        }
        if (isOrthographicCameraComponent(this._mainCamera)) {
            this._mainCamera.top = this._mainCamera.right / aspect;
            this._mainCamera.bottom = -this._mainCamera.top;
        }
        return this;
    };
    /**
     * 移除当前世界的主摄像机引用，一般在主摄像机销毁时调用，比如关卡切换时。
     */
    World.prototype.removeMainCamera = function () {
        this._mainCamera = null;
        this._mainCameras = [];
    };
    World = __decorate([
        SClass({ className: 'World', classType: 'World' })
    ], World);
    return World;
}(SObject));

function isSceneComponent$1(value) {
    return value.isSceneComponent;
}

/**
 * 判断一个实例是否为`ChildActorComponent`。
 */
function isChildActorComponent(value) {
    return value.isChildActorComponent;
}
/**
 * 用于给一个Actor挂载一个子级Actor的组件。
 * 注意此组件仅仅是建立了渲染层以及逻辑上的父子关系，但子级Actor仍然存在于`Game`或者`World`中，并不按照bfs顺序更新。
 *
 * @template TActor 要挂载的子级Actor的类型。
 * @noInheritDoc
 */
var ChildActorComponent = /** @class */ (function (_super) {
    __extends(ChildActorComponent, _super);
    function ChildActorComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isChildActorComponent = true;
        /**
         * 声明通过该Component挂载的Actor是否随着父级的销毁而自动销毁。
         * 没有十足把握请不要修改！
         * 若想变更Actor的父级，请使用`SceneActor`下的`changeParent`方法。
         */
        _this.autoDestroyActor = true;
        return _this;
    }
    Object.defineProperty(ChildActorComponent.prototype, "actor", {
        /**
         * 挂载的Actor的引用。
         */
        get: function () {
            return this._actor;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    ChildActorComponent.prototype.onInit = function (initState) {
        this._actor = initState.actor;
        this._parent = initState.parent || this.getRoot();
        if (!isSceneActor(this._actor) || !isSceneComponent$1(this._parent)) {
            return;
        }
        this._actor.root.hiloNode.removeFromParent();
        this._actor._parent = this;
        this._parent.hiloNode.addChild(this._actor.root.hiloNode);
    };
    /**
     * @hidden
     */
    ChildActorComponent.prototype.onDestroy = function () {
        if (!this._actor) {
            return;
        }
        this._actor._parent = null;
        if (isSceneActor(this._actor)) {
            this._actor.root.hiloNode.removeFromParent();
            if (this.autoDestroyActor) {
                this.getWorld().removeActor(this._actor);
            }
        }
        else {
            if (this.autoDestroyActor) {
                this.getGame().removeActor(this._actor);
            }
        }
    };
    /**
     * @hidden
     */
    ChildActorComponent.prototype.removeActor = function (actor) {
        this.removeFromParent();
    };
    ChildActorComponent = __decorate([
        SClass({ className: 'ChildActorComponent' })
    ], ChildActorComponent);
    return ChildActorComponent;
}(Component));

/**
 * 判断一个实例是否为`MemberConflictException`。
 */
function isMemberConflictException(value) {
    return value.isMemberConflictException;
}
/**
 * 成员冲突异常。
 *
 * @noInheritDoc
 */
var MemberConflictException = /** @class */ (function (_super) {
    __extends(MemberConflictException, _super);
    /**
     * 构建异常。
     *
     * @param parent 成员父级实例。
     * @param memberType 成员类型。
     * @param memberName 成员名称。
     * @param object 触发异常的实例。
     * @param message 追加信息。
     */
    function MemberConflictException(parent, memberType, memberName, object, message) {
        if (message === void 0) { message = ''; }
        var _this = _super.call(this, 'MemberConflict', object, memberType + " \"" + memberName + "\" is already in " + parent.className + " \"" + parent.name + "\". " + message) || this;
        _this.isMemberConflictException = true;
        return _this;
    }
    return MemberConflictException;
}(BaseException));

/**
 * Sein.js封装的用于存储`SObject`实例的特殊Map容器。
 *
 * @template T 存储的实例的类型。
 */
var SMap = /** @class */ (function (_super) {
    __extends(SMap, _super);
    function SMap() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._table = {};
        _this._tableReflect = {};
        return _this;
    }
    Object.defineProperty(SMap.prototype, "array", {
        /**
         * 原始基础数组。
         */
        get: function () {
            return this._array;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置对应键的实例引用。
     */
    SMap.prototype.set = function (key, item) {
        var oldItem = this._table[key];
        if (oldItem) {
            this.removeItem(oldItem);
            delete this._tableReflect[oldItem.uuid];
        }
        this.addItem(item);
        this._table[key] = item;
        this._tableReflect[item.uuid] = key;
        return this;
    };
    /**
     * 判断键是否在容器内。
     */
    SMap.prototype.has = function (key) {
        return !!this._table[key];
    };
    /**
     * 通过键从容器中移除一个实例。
     */
    SMap.prototype.remove = function (key) {
        var oldItem = this._table[key];
        if (!oldItem) {
            return;
        }
        this.removeItem(oldItem);
        delete this._table[key];
        delete this._tableReflect[oldItem.uuid];
        return oldItem;
    };
    /**
     * 通过键获取一个实例。
     */
    SMap.prototype.get = function (key) {
        return this.findByName(key);
    };
    /**
     * 通过索引从容器中获取一个实例。
     */
    SMap.prototype.getAtIndex = function (index) {
        return this._array[index];
    };
    /**
     * 清空所有存储的实例。
     */
    SMap.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this._table = {};
        this._tableReflect = {};
        return this;
    };
    /**
     * 遍历所有键值对。
     * 通过回调的返回值设`true`，你可以终止迭代，这用于性能优化。
     */
    SMap.prototype.forEachEntities = function (func) {
        var length = this.length;
        for (var index = 0; index < length; index += 1) {
            var item = this._array[index];
            if (func(this._tableReflect[item.uuid], item)) {
                return this;
            }
        }
        return this;
    };
    /**
     * 从一个基本的数组实例初始化SIterable。
     */
    SMap.prototype.fromArray = function (array) {
        this.clear();
        var length = array.length;
        for (var index = 0; index < length; index += 1) {
            this.set(array[index].name.value, array[index]);
        }
        return this;
    };
    /**
     * 通过名字查找第一个实例。
     */
    SMap.prototype.findByName = function (name) {
        return this._table[name];
    };
    /**
     * 通过名字查找所有实例。
     */
    SMap.prototype.findAllByName = function (name) {
        return [this._table[name]];
    };
    return SMap;
}(SIterable));

/**
 * 判断一个实例是否为`Actor`。
 */
function isActor(value) {
    return value.isActor;
}
/**
 * 游戏世界的基石，作为Components的封装容器。
 * 自身可以包含一定程度的业务逻辑，但不推荐，推荐在专用Actor中编写业务逻辑，比如`GameModeActor`和`LevelScriptActor`。
 *
 * @template IOptionTypes 初始化参数类型，一般交由由继承的类定义实现多态。
 * @template TRootComponent 根级组件类型，一般交由由继承的类定义实现多态。
 *
 * @noInheritDoc
 */
var Actor = /** @class */ (function (_super) {
    __extends(Actor, _super);
    /**
     * 构造Actor，**不可自行构造！！！**请参见`game.addActor`或`world.addActor`方法。
     */
    function Actor(name, game, initOptions) {
        var _this = _super.call(this, name) || this;
        _this.isActor = true;
        /**
         * Actor是否需要在每一帧进行进行`update`调用，如果为`false`，则将不会触发`onUpdate`生命周期（包括挂载在其下的所有Component）。
         * 用于性能优化。
         */
        _this.updateOnEverTick = true;
        /**
         * 在Actor自身销毁时，是否同时需要触发其下挂载的所有Component的销毁，也就是`onDestroy`生命周期的调用。
         * 用于性能优化。
         */
        _this.emitComponentsDestroy = true;
        /**
         * 用于给Actor归类的标签，可以用于后续的快速索引。
         */
        _this.tag = new SName('UnTagged');
        _this._game = null;
        _this._root = null;
        _this._components = new SMap();
        _this._componentsForUpdate = new SArray();
        _this._componentsNeedUpdate = false;
        _this._parent = null;
        _this._inWorld = false;
        _this._linked = false;
        _this._game = game;
        _this._initOptions = initOptions;
        return _this;
    }
    Object.defineProperty(Actor.prototype, "parent", {
        /**
         * 获取自身的父级实例，根据情况不同可能有不同的类型，一般不需要自己使用。
         */
        get: function () {
            return this._parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Actor.prototype, "linked", {
        /**
         * Actor是否被连接到了舞台上。
         */
        get: function () {
            return this._linked;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Actor.prototype, "event", {
        /**
         * Actor自身范围内的事件系统管理器，将会直接代理到其的根组件`root`。
         */
        get: function () {
            return this._root.event;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Actor.prototype, "root", {
        /**
         * Actor自身的根组件。一般来讲创建后就不会变更。
         */
        get: function () {
            return this._root;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 用于验证改Actor在当前状态是否可被添加，一般用于防止重复添加不可重复的系统Actor等。
     * 你可以重写此方法来达成验证，如果验证不通过请抛出异常。
     * 注意，此验证仅会在`development`环境下被执行！
     */
    Actor.prototype.verifyAdding = function (initOptions) { };
    /**
     * 用于验证该Actor在当前状态是否可被移除。
     * 你可以重写此方法来达成验证，如果验证不通过请抛出异常。
     * 注意，此验证仅会在`development`环境下被执行！
     */
    Actor.prototype.verifyRemoving = function () { };
    /**
     * 生命周期，将在Actor被创建时最先调用，用于创建从属于该Actor的根组件。
     * 在原生Actor中均有默认值，你可以用此周期来定义你自己的Actor。
     */
    Actor.prototype.onCreateRoot = function (initOptions) {
        return this.addComponent('root', Component);
    };
    /**
     * 生命周期，将在Actor创建了根组件后、在正式被添加到游戏中之前被调用。
     */
    Actor.prototype.onInit = function (initOptions) {
    };
    /**
     * 生命周期，将在Actor被正式加入到游戏中之后被调用。
     */
    Actor.prototype.onAdd = function (initOptions) {
    };
    /**
     * 生命周期，将在Actor被正式加入到游戏中之后，并且`updateOnEverTick`为`true`时在每一帧被调用。
     */
    Actor.prototype.onUpdate = function (delta) {
    };
    /**
     * 生命周期，用于错误边界处理。将在游戏中大部分可预知错误发生时被调用（通常是生命周期中的非异步错误）。
     * 错误将会根据一定的路径向上传递，一直到`Engine`的层次，你可以在确保完美处理了问题后返回`true`来通知引擎不再向上传递。
     * 当然你也可以将自定义的一些错误加入错误边界机制中，详见[Exception](../../guide/exception)。
     */
    Actor.prototype.onError = function (error, details) {
    };
    /**
     * 生命周期，将在调用`actor.unLink`方法后触发。
     */
    Actor.prototype.onUnLink = function () {
    };
    /**
     * 生命周期，将在调用`actor.reLink`方法后触发。
     *
     * @param parent 要恢复连接到的父级。
     */
    Actor.prototype.onReLink = function (parent) {
    };
    /**
     * 生命周期，将在Actor被销毁时触发。
     */
    Actor.prototype.onDestroy = function () {
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Actor.prototype.initialized = function () {
        try {
            this._root = this.onCreateRoot(this._initOptions);
            this._componentsForUpdate.add(this._root);
        }
        catch (error) {
            throwException(error, this);
        }
        this._root.isRoot = true;
        try {
            this.onInit(this._initOptions);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Actor.prototype.added = function () {
        if (this._inWorld) {
            return;
        }
        this._inWorld = true;
        this._linked = true;
        this._components.forEach(function (component) {
            component.added();
        });
        try {
            this.onAdd(this._initOptions);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Actor.prototype.update = function (delta) {
        this.syncComponentsNeedUpdate();
        if (!this.updateOnEverTick || !this._inWorld || !this._parent) {
            return;
        }
        try {
            this.onUpdate(delta);
        }
        catch (error) {
            throwException(error, this);
        }
        this._componentsForUpdate.forEach(function (component) {
            component.update(delta);
        });
    };
    /**
     * 将一个已经创建的`actor`从游戏世界中移除，但仍然保留其状态。之后可以用`reLink`方法让其重新和游戏世界建立连接。
     * 注意如果有子级`actor`，并不会自动`unLink`！
     * 这一般用于性能优化，比如对象池的创建。
     */
    Actor.prototype.unLink = function () {
        if (!this._linked) {
            return this;
        }
        try {
            this.onUnLink();
        }
        catch (error) {
            throwException(error, this);
        }
        this.syncComponentsNeedUpdate();
        this._componentsForUpdate.forEach(function (component) { return component.unLink(); });
        var parent = this._parent;
        var realParent;
        if (isChildActorComponent(parent)) {
            parent.autoDestroyActor = false;
            parent.removeFromParent();
            this._parent = parent.getOwner();
            realParent = !isSceneActor(parent.getOwner()) ? parent.getGame() : parent.getWorld();
        }
        else {
            realParent = parent;
        }
        /**
         * @todo: fix types
         */
        realParent.actors.remove(this);
        realParent._actorsNeedUpdate = true;
        this._linked = false;
        return this;
    };
    /**
     * 将一个已经使用`unLink`方法和游戏世界断开连接的`actor`恢复连接，将其重新加入世界中。
     * 这一般用于性能优化，比如对象池的创建。
     *
     * @param parent 指定要恢复连接到的父级，不指定则使用上一次的父级。
     */
    Actor.prototype.reLink = function (parent) {
        if (this._linked) {
            return this;
        }
        parent = parent || this._parent;
        var realParent;
        if (isActor(parent)) {
            realParent = !isSceneActor(parent) ? parent.getGame() : parent.getWorld();
        }
        else {
            realParent = parent;
        }
        if (isWorld(realParent) && this.getGame().world !== realParent) {
            throw new Error("ReLink error! Current world is different from pre world !");
        }
        /**
         * @todo: fix types
         */
        realParent.actors.add(this);
        realParent._actorsNeedUpdate = true;
        if (isActor(parent)) {
            parent.addChild(this);
        }
        try {
            this.onReLink(parent);
        }
        catch (error) {
            throwException(error, this);
        }
        this.syncComponentsNeedUpdate();
        this._componentsForUpdate.forEach(function (component) { return component.reLink(); });
        this._linked = true;
        return this;
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Actor.prototype.destroy = function () {
        if (this.emitComponentsDestroy) {
            this.syncComponentsNeedUpdate();
            this._componentsForUpdate.forEach(function (component) { return component.destroy(); });
        }
        else {
            this._root.destroy();
        }
        _super.prototype.destroy.call(this);
        this._parent = null;
    };
    Actor.prototype.syncComponentsNeedUpdate = function () {
        var _this = this;
        if (this._componentsNeedUpdate) {
            this._componentsForUpdate.clear();
            this._components.forEach(function (item) {
                if (item.isRoot || item.needUpdateAndDestroy) {
                    _this._componentsForUpdate.add(item);
                }
            });
            this._componentsNeedUpdate = false;
        }
    };
    /**
     * 获取当前`Game`实例。
     *
     * @template IGameState 当前游戏状态管理器的类型。
     */
    Actor.prototype.getGame = function () {
        return this._game;
    };
    /**
     * 获取当前`World`实例。
     *
     * @template IWorldState 当前世界状态管理器的类型。
     */
    Actor.prototype.getWorld = function () {
        return this._game.world;
    };
    /**
     * 获取当前`Level`实例。
     *
     * @template ILevelState 当前关卡状态管理器的类型。
     */
    Actor.prototype.getLevel = function () {
        return this._game.level;
    };
    /**
     * 仅在初始化了物理引擎之后，用于获取当前物理世界`PhysicWorld`实例。
     * 如何使用物理引擎请见**Guide**和**Demo**。
     */
    Actor.prototype.getPhysicWorld = function () {
        return this._game.world.physicWorld;
    };
    /**
     * 将自己从父级移除，基本等同于`destroy`方法，从游戏中销毁自身。
     */
    Actor.prototype.removeFromParent = function () {
        if (!this._parent) {
            throwException(new Error("Actor " + this.name + " has no parent, is it an invalid reference to an actor is already removed from world ?"), this);
        }
        this._parent.removeActor(this);
    };
    /**
     * 根据指定的`ComponentClass`和其初始化参数`initState`来添加一个Component。**注意这里要求每个Component的名字`name`是唯一的**。
     * 如果是在`world`中添加一个`SceneComponent`，你可以指定一个`parent`作为要添加的Component的父级，让它们在渲染层连接起来。
     */
    Actor.prototype.addComponent = function (name, ComponentClass, initState, parent) {
        if (this._components.has(name)) {
            throw new MemberConflictException(this, 'Component', name, this);
        }
        if (parent && parent.getOwner() !== this) {
            throw new BreakGuardException(this, "Owner of parent component " + parent.name + " must be same to owner of child " + this.name);
        }
        var component = new ComponentClass(name, this, initState);
        if (parent && (!isSceneComponent$1(parent) || !isSceneComponent$1(component))) {
            throw new BreakGuardException(this, "Only SceneComponent could have child SceneComponent ! \nCurrent parent: " + parent.name + "(" + parent.className + "), child: " + component.name + "(" + component.className + ")");
        }
        if (Debug.devMode) {
            try {
                component.verifyAdding(initState);
            }
            catch (error) {
                throwException(error, component);
                return;
            }
        }
        this._components.set(name, component);
        component.initialized();
        if (isSceneComponent$1(component)) {
            if (parent) {
                parent.addChild(component);
            }
            else if (this._root && isSceneComponent$1(this._root)) {
                this._root.addChild(component);
            }
            else {
                component._parent = this;
            }
        }
        else {
            component._parent = this;
        }
        if (this._inWorld) {
            component.added();
        }
        if (component.needUpdateAndDestroy) {
            this._componentsNeedUpdate = true;
        }
        return component;
    };
    Actor.prototype.removeComponent = function (value) {
        var component;
        if (isSObject(value) && isComponent(value)) {
            component = value;
        }
        else {
            component = this._components.get(value);
        }
        if (!component) {
            return this;
        }
        if (!component.canBeRemoved || component.isRoot) {
            throw new BreakGuardException(this, "In actor " + this.name + ", component " + component.name + " can not be removed.\nIt's one of '!canBeRemoved', 'root'");
        }
        if (Debug.devMode) {
            try {
                component.verifyRemoving();
            }
            catch (error) {
                throwException(error, component);
                return;
            }
        }
        if (component.parent && isSceneComponent$1(component.parent)) {
            component.parent.removeChild(component);
            this.clearSceneComponent(component);
        }
        component.destroy();
        this._components.remove(component.name.value);
        if (component.needUpdateAndDestroy) {
            this._componentsNeedUpdate = true;
        }
        return this;
    };
    /**
     * 将一个Actor作为自身的子级，注意子级Actor将仍然存在于`game`或者`world`中，并拥有自身独立的生命周期，这里只是建立了一个连接关系。
     * 如果父子为`SceneActor`，那么这层链接关系还会反映到渲染层，同时可以指定一个`SceneComponent`作为其父级节点。
     */
    Actor.prototype.addChild = function (actor, parentComponent) {
        if (actor.parent && isChildActorComponent(actor.parent)) {
            actor.parent.getOwner().removeComponent(actor.parent);
        }
        this.addComponent(actor.name.value, ChildActorComponent, { actor: actor, parent: parentComponent });
    };
    /**
     * 解除自身和一个子级Actor的链接。注意此方法也会直接将子级Actor从游戏中销毁！
     * 如果只是想要改变一个SceneActor的归属，请使用`SceneActor`下的`changeParent`方法。
     */
    Actor.prototype.removeChild = function (actor) {
        if (!actor.parent || !isChildActorComponent(actor.parent)) {
            return;
        }
        this.removeComponent(actor.parent);
    };
    // todo: 级联将导致所有子组件递归销毁
    // 性能会不会有问题？
    // 这个情况还要考虑更完美的处理方式？
    Actor.prototype.clearSceneComponent = function (component) {
        var _this = this;
        component.children.forEach(function (child) {
            component.destroy();
            _this._components.remove(child.name.value);
            _this.clearSceneComponent(child);
        });
    };
    /**
     * 根据名字查找一个Component。
     */
    Actor.prototype.findComponentByName = function (name) {
        return this._components.get(name);
    };
    /**
     * 根据某个类查找一个Component。
     */
    Actor.prototype.findComponentByClass = function (ComponentClass) {
        return this._components.findByClass(ComponentClass);
    };
    /**
     * 查找某个类的所有实例Component。
     */
    Actor.prototype.findComponentsByClass = function (ComponentClass) {
        return this._components.findAllByClass(ComponentClass);
    };
    /**
     * 通过一个Filter来查找组件。
     */
    Actor.prototype.findComponentByFilter = function (filter) {
        return this._components.findByFilter(filter);
    };
    /**
     * 通过一个Filter来查找所有。
     */
    Actor.prototype.findComponentsByFilter = function (filter) {
        return this._components.findAllByFilter(filter);
    };
    Actor = __decorate([
        SClass({ className: 'Actor', classType: 'Actor' })
    ], Actor);
    return Actor;
}(SObject));

/**
 * 判断一个实例是否为`Ticker`。
 */
function isTicker(value) {
    return value.isTicker;
}
/**
 * 维护一个监听器队列，在每一帧调用队列里的回调。
 *
 * @noInheritDoc
 */
var Ticker = /** @class */ (function (_super) {
    __extends(Ticker, _super);
    /**
     * 指定锁定帧率，创建一个Ticker。
     * 若不指定则不锁帧。
     */
    function Ticker(fps) {
        var _this = _super.call(this, 'SeinTimer') || this;
        _this.isTicker = true;
        _this._rafId = 0;
        _this._lockFrame = false;
        _this._fps = 0;
        _this._spf = 0;
        _this._pre = 0;
        _this._delta = 0;
        _this._actualPre = 0;
        _this._tickers = [];
        _this._tickersQueue = [];
        _this._needUpdate = false;
        _this._paused = true;
        _this.update = function (ts, rafId) {
            if (_this._paused || _this._rafId !== rafId) {
                return;
            }
            _this.raf(_this.update);
            if (_this._pre === 0) {
                _this._pre = ts;
                _this._actualPre = Date.now();
                return;
            }
            if (_this._needUpdate) {
                _this._tickersQueue = _this._tickers.slice();
                _this._needUpdate = false;
            }
            var delta = ts - _this._pre;
            _this._pre = ts;
            if (!_this._lockFrame) {
                var length_1 = _this._tickersQueue.length;
                for (var i = 0; i < length_1; i += 1) {
                    _this._tickersQueue[i](delta);
                }
                return;
            }
            if (_this._delta >= _this._spf) {
                var now = Date.now();
                var actualDelta = now - _this._actualPre;
                _this._actualPre = now;
                _this._delta -= _this._spf * ~~(_this._delta / _this._spf);
                var length_2 = _this._tickersQueue.length;
                for (var i = 0; i < length_2; i += 1) {
                    _this._tickersQueue[i](actualDelta);
                }
            }
            _this._delta += delta;
        };
        if (fps !== undefined && fps !== null) {
            _this.fps = fps;
        }
        return _this;
    }
    Object.defineProperty(Ticker.prototype, "fps", {
        /**
         * 获取锁定帧率。
         */
        get: function () {
            return this._fps;
        },
        /**
         * 修改锁定帧率。
         */
        set: function (fps) {
            if (60 % fps !== 0) {
                Debug.warn(fps + "fps is not safe, you can only choice 60, 30, 20(not in low-power mode in safari), 15, 10 or 5 !");
            }
            this._fps = fps;
            this._spf = 1000 / fps;
            this._lockFrame = true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ticker.prototype, "paused", {
        /**
         * Ticker是否暂停。
         */
        get: function () {
            return this._paused;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Ticker.prototype, "lockFrame", {
        /**
         * 获取是否开启锁帧。
         */
        get: function () {
            return this._lockFrame;
        },
        /**
         * 设置是否开启锁帧。
         */
        set: function (value) {
            this._lockFrame = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 添加一个ticker监听器到队列中。
     */
    Ticker.prototype.add = function (listener) {
        this._tickers.push(listener);
        this._needUpdate = true;
        return this;
    };
    /**
     * 从队列中移除一个监听器。
     */
    Ticker.prototype.remove = function (listener) {
        this._tickers.splice(this._tickers.indexOf(listener), 1);
        this._needUpdate = true;
        return this;
    };
    /**
     * 启动Ticker。
     */
    Ticker.prototype.start = function () {
        this._paused = false;
        this._pre = 0;
        this._delta = 0;
        this._actualPre = 0;
        this.raf(this.update);
        return this;
    };
    /**
     * 暂停Ticker。
     */
    Ticker.prototype.pause = function () {
        this._paused = true;
        this._rafId += 1;
        return this;
    };
    Ticker.prototype.raf = function (callback) {
        if (this._rafId >= 65535) {
            this._rafId = 0;
        }
        else {
            this._rafId += 1;
        }
        var rafId = this._rafId;
        requestAnimationFrame(function (ts) { return callback(ts, rafId); });
    };
    Ticker = __decorate([
        SClass({ className: 'Ticker', classType: 'Ticker' })
    ], Ticker);
    return Ticker;
}(SObject));

/**
 * 判断一个实例是否为`Engine`。
 */
function isEngine(value) {
    return value.isEngine;
}
/**
 * 顶层引擎类，一般除了初始化游戏不需要直接控制。
 *
 * @noInheritDoc
 */
var Engine = /** @class */ (function (_super) {
    __extends(Engine, _super);
    function Engine(options) {
        var _this = _super.call(this, 'SeinEngine') || this;
        _this.isEngine = true;
        _this._options = null;
        _this._ticker = null;
        _this._games = [];
        _this._runningGames = [];
        _this.update = function (delta) {
            var length = _this._runningGames.length;
            Tween.tick();
            for (var i = 0; i < length; i += 1) {
                _this._runningGames[i].update(delta);
            }
        };
        Engine_1.RUNNING_ENGINES.push(_this);
        _this._options = options || {};
        _this._ticker = new Ticker(_this._options.fps);
        _this._ticker.add(_this.update);
        return _this;
    }
    Engine_1 = Engine;
    /**
     * 获取当前运行的Engine实例。
     *
     * @param index 索引，不传则取回第一个，一般也就是唯一的一个。
     */
    Engine.GET_RUNNING_ENGINE = function (index) {
        if (index === void 0) { index = 0; }
        return Engine_1.RUNNING_ENGINES[index];
    };
    Object.defineProperty(Engine.prototype, "options", {
        /**
         * 当前参数。
         */
        get: function () {
            return this._options;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Engine.prototype, "ticker", {
        /**
         * 全局Ticker。
         */
        get: function () {
            return this._ticker;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Engine.prototype, "env", {
        /**
         * 当前运行环境，一般为`development`或`production`。
         */
        get: function () {
            return Debug.env;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Engine.prototype, "devMode", {
        /**
         * `env`不为`production`时，判定为开发环境。
         */
        get: function () {
            return Debug.devMode;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 生命周期，用于错误边界处理。将在游戏中大部分可预知错误发生时被调用（通常是生命周期中的非异步错误）。
     * 错误将会根据一定的路径向上传递，一直到`Engine`的层次，你可以在确保完美处理了问题后返回`true`来通知引擎不再向上传递。
     * 当然你也可以将自定义的一些错误加入错误边界机制中，详见[Exception](../../guide/exception)。
     */
    Engine.prototype.onError = function (error, details) {
        Debug.warn("Error '" + error.message + "' reaches engine, try to catch it in exception chain !");
    };
    /**
     * 添加一个游戏实例到引擎中。
     */
    Engine.prototype.addGame = function (game) {
        game._engine = this;
        this._games.push(game);
        try {
            game.onAdd();
        }
        catch (error) {
            throwException(error, game);
        }
        return this;
    };
    /**
     * 将一个游戏实例从引擎中移除。
     */
    Engine.prototype.removeGame = function (game) {
        var index = this._runningGames.indexOf(game);
        if (index >= 0) {
            this.destroyGame(game);
        }
        index = this._games.indexOf(game);
        if (index >= 0) {
            this._games.splice(index, 1);
        }
        game._engine = null;
        return this;
    };
    /**
     * 获取当前运行的某个Game实例。
     *
     * @param index 索引，不传则取回第一个，一般也就是唯一的一个。
     */
    Engine.prototype.getRunningGame = function (index) {
        if (index === void 0) { index = 0; }
        return this._runningGames[index];
    };
    /**
     * 不要自己调用！
     *
     * @hidden
     */
    Engine.prototype.startGame = function (game) {
        if (this._runningGames.indexOf(game) < 0) {
            this._runningGames.push(game);
            try {
                game.onStart();
            }
            catch (error) {
                throwException(error, game);
            }
        }
        if (this._ticker.paused) {
            this._ticker.start();
        }
        return this;
    };
    /**
     * 不要自己调用！
     *
     * @hidden
     */
    Engine.prototype.pauseGame = function (game) {
        try {
            game.onPause();
        }
        catch (error) {
            throwException(error, game);
        }
        this._runningGames.splice(this._runningGames.indexOf(game), 1);
        if (this._runningGames.length === 0) {
            this._ticker.pause();
        }
        return this;
    };
    /**
     * 不要自己调用！
     *
     * @hidden
     */
    Engine.prototype.resumeGame = function (game) {
        this._runningGames.push(game);
        try {
            game.onResume();
        }
        catch (error) {
            throwException(error, game);
        }
        if (this._ticker.paused) {
            this._ticker.start();
        }
        return this;
    };
    /**
     * 不要自己调用！
     *
     * @hidden
     */
    Engine.prototype.restartGame = function (game) {
        this.destroyGame(game);
        this.startGame(game);
        return this;
    };
    /**
     * @hidden
     */
    Engine.prototype.destroyGame = function (game) {
        var index = this._runningGames.indexOf(game);
        if (index >= 0) {
            this._runningGames.splice(index, 1);
            try {
                game.onDestroy();
            }
            catch (error) {
                throwException(error, game);
            }
        }
        if (this._runningGames.length === 0) {
            this._ticker.pause();
        }
        this.removeGame(game);
        return this;
    };
    /**
     * 启动所有游戏，一般使用`game.start()`作为替代，启动特定游戏。
     */
    Engine.prototype.start = function () {
        this._games.forEach(function (game) { return game.start(); });
        return this;
    };
    /**
     * 暂停所有游戏，一般使用`game.pause()`作为替代，暂停特定游戏。
     */
    Engine.prototype.pause = function () {
        this._runningGames.forEach(function (game) { return game.pause(); });
        return this;
    };
    /**
     * 唤醒所有游戏，一般使用`game.resume()`作为替代，唤醒特定游戏。
     */
    Engine.prototype.resume = function () {
        this._games.forEach(function (game) { return game.resume(); });
        return this;
    };
    /**
     * 销毁所有游戏，一般使用`game.destroy()`作为替代，销毁特定游戏。
     */
    Engine.prototype.destroy = function () {
        this._runningGames.forEach(function (game) { return game.destroy(); });
        this._games = [];
        Engine_1.RUNNING_ENGINES.splice(Engine_1.RUNNING_ENGINES.indexOf(this), 1);
    };
    var Engine_1;
    /**
     * 当前所有正在运行的Engine，一般情况下只有一个。
     */
    Engine.RUNNING_ENGINES = [];
    Engine = Engine_1 = __decorate([
        SClass({ className: 'Engine', classType: 'Engine' })
    ], Engine);
    return Engine;
}(SObject));

/**
 * 判断一个实例是否为`ResourceLoadException`。
 */
function isResourceLoadException(value) {
    return value.isResourceLoadException;
}
/**
 * 资源加载异常。
 *
 * @noInheritDoc
 */
var ResourceLoadException = /** @class */ (function (_super) {
    __extends(ResourceLoadException, _super);
    /**
     * 构建异常。
     *
     * @param parent 成员父级实例。
     * @param memberType 成员类型。
     * @param memberName 成员名称。
     * @param object 触发异常的实例。
     * @param message 追加信息。
     */
    function ResourceLoadException(resourceName, resourceManager, message) {
        if (message === void 0) { message = ''; }
        var _this = _super.call(this, 'ResourceLoad', resourceManager, "Error occured when load resource \"" + resourceName + "\". " + message) || this;
        _this.isResourceLoadException = true;
        _this.resourceName = resourceName;
        return _this;
    }
    return ResourceLoadException;
}(BaseException));

/**
 * 判断一个实例是否为`ResourceLoader`。
 */
function isResourceLoader(value) {
    return value.isResourceLoader;
}
/**
 * 资源加载器。加载器用于在资源管理器[ResourceManager](../eesourcemanager)注册加载器时。
 * 你可以继承此基类来派生自己的加载器。
 *
 * @template IResource 此加载器对应的实体参数类型。
 * @noInheritDoc
 */
var ResourceLoader = /** @class */ (function (_super) {
    __extends(ResourceLoader, _super);
    function ResourceLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isResourceLoader = true;
        return _this;
    }
    /**
     * 加载一个资源，并根据情况执行`callbacks`中的回调。
     */
    ResourceLoader.prototype.load = function (entity, callbacks) {
        setTimeout(function () { return callbacks.onLoaded(entity); }, 0);
    };
    /**
     * 取消加载特定实体。一般不需要自己编写逻辑，而是使用`entity.canceled`在加载终点丢弃。
     * 注意`entity.canceled`是在这里赋值的，所以一般继承请务必先执行`super.cancel()`！
     */
    ResourceLoader.prototype.cancel = function (entity) {
        entity.canceled = true;
    };
    /**
     * 通过指定资源实体实例化出一个具体的对象。
     */
    ResourceLoader.prototype.instantiate = function (entity, options) {
        throw new Error('Not implemented !');
    };
    /**
     * 释放资源时将会调用，用于自定义释放逻辑。
     */
    ResourceLoader.prototype.release = function (entity) {
    };
    /**
     * 此加载器所关联的后缀，例如`.png`。
     *
     * 注意后面的会覆盖前面的！
     */
    ResourceLoader.EXTENSIONS = [];
    ResourceLoader = __decorate([
        SClass({ className: 'ResourceLoader' })
    ], ResourceLoader);
    return ResourceLoader;
}(SObject));

/**
 * 判断一个实例是否为`RigidBodyComponent`。
 */
function isRigidBodyComponent(value) {
    return value.isRigidBodyComponent;
}
/**
 * @hidden
 */
var vec3Unit = new Vector3(1, 1, 1);
/**
 * @hidden
 */
var vec3Zero = new Vector3(0, 0, 0);
/**
 * 刚体组件类，为Actor添加物理引擎和碰撞检测、拾取的基本功能。
 * **当挂载到Actor后，你可以直接通过`actor.rigidBody`来访问它。**
 *
 * @noInheritDoc
 */
var RigidBodyComponent = /** @class */ (function (_super) {
    __extends(RigidBodyComponent, _super);
    function RigidBodyComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isRigidBodyComponent = true;
        /**
         * 不要自己使用。
         *
         * @hidden
         */
        _this.needUpdateCollider = false;
        _this._disabled = false;
        _this._sleeping = false;
        _this._valid = false;
        _this._tmpQuat = new Quaternion();
        _this._tmpQuat2 = new Quaternion();
        _this._tmpScale = new Vector3(1, 1, 1);
        _this._tmpScale2 = new Vector3(1, 1, 1);
        _this._tmpScale3 = new Vector3(1, 1, 1);
        /**
         * **不要自己调用！！**
         *
         * @hidden
         */
        _this.handleCollision = function (_a) {
            var body = _a.body, contact = _a.contact;
            var other;
            var self;
            if (body.id === contact.bi.id) {
                self = contact.bj;
                other = contact.bi;
            }
            else {
                self = contact.bi;
                other = contact.bj;
            }
            if (!_this._valid || !other.component.valid) {
                return;
            }
            _this.event.trigger('Collision', {
                selfBody: self.component,
                otherBody: other.component,
                selfActor: self.component.getOwner(),
                otherActor: other.component.getOwner()
            });
        };
        /**
         * **不要自己调用！！**
         *
         * @hidden
         */
        _this.handleBodyEnter = function (selfBody, otherBody) {
            if (!_this._valid || !otherBody.valid) {
                return;
            }
            _this.event.trigger('BodyEnter', { selfBody: selfBody, otherBody: otherBody, selfActor: selfBody.getOwner(), otherActor: otherBody.getOwner() });
        };
        /**
         * **不要自己调用！！**
         *
         * @hidden
         */
        _this.handleBodyLeave = function (selfBody, otherBody) {
            if (!_this._valid || !otherBody.valid) {
                return;
            }
            _this.event.trigger('BodyLeave', { selfBody: selfBody, otherBody: otherBody, selfActor: selfBody.getOwner(), otherActor: otherBody.getOwner() });
        };
        /**
         * **不要自己调用！！**
         *
         * @hidden
         */
        _this.handleColliderEnter = function (selfBody, otherBody, selfCollider, otherCollider) {
            if (!_this._valid || !otherBody.valid) {
                return;
            }
            _this.event.trigger('ColliderEnter', {
                selfBody: selfBody, otherBody: otherBody, selfCollider: selfCollider, otherCollider: otherCollider,
                selfActor: selfBody.getOwner(), otherActor: otherBody.getOwner()
            });
        };
        /**
         * **不要自己调用！！**
         *
         * @hidden
         */
        _this.handleColliderLeave = function (selfBody, otherBody, selfCollider, otherCollider) {
            if (!_this._valid || !otherBody.valid) {
                return;
            }
            _this.event.trigger('ColliderLeave', {
                selfBody: selfBody, otherBody: otherBody, selfCollider: selfCollider, otherCollider: otherCollider,
                selfActor: selfBody.getOwner(), otherActor: otherBody.getOwner()
            });
        };
        /**
         * **不要自己调用！！**
         *
         * @hidden
         */
        _this.handleBeforeStep = function (_, forceSync) {
            if (forceSync === void 0) { forceSync = false; }
            if (!_this._valid) {
                return;
            }
            if (_this._physicStatic && !_this._sleeping && _this.mass !== 0) {
                _this.setAngularVelocity(vec3Zero);
                _this.setLinearVelocity(vec3Zero);
            }
            _this.syncTransformToRigidBody(forceSync);
            _this.event.trigger('BeforeStep', _this);
        };
        /**
         * **不要自己调用！！**
         *
         * @hidden
         */
        _this.handleAfterStep = function () {
            if (!_this.valid) {
                return;
            }
            if (_this._physicStatic || _this._sleeping) {
                return;
            }
            var transform = _this._owner.transform;
            _this.event.trigger('AfterStep', _this);
            _this.getPhysicWorld().setRootTransform(_this);
            // object has now its world rotation. needs to be converted to local.
            if (_this._owner.parent) {
                _this.getParentsRotationAndScale();
                _this._tmpQuat.conjugate();
                transform.quaternion = _this._tmpQuat.multiply(transform.quaternion);
            }
            // take the position set and make it the absolute position of this object.
            transform.absolutePosition = transform.position;
        };
        /**
         * **不要自己调用！！**
         *
         * @hidden
         */
        _this.handlePick = function (result) {
            _this.event.trigger('Pick', result);
        };
        return _this;
    }
    RigidBodyComponent_1 = RigidBodyComponent;
    Object.defineProperty(RigidBodyComponent.prototype, "rigidBody", {
        /**
         * 获取物理世界的刚体，不需要自己使用。
         *
         * @hidden
         */
        get: function () {
            return this._rigidBody;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "valid", {
        /**
         * 刚体当前是否有效，不需要自己使用。
         *
         * @hidden
         */
        get: function () {
            return this._valid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "event", {
        /**
         * RigidBodyComponent的事件管理器。
         */
        get: function () {
            return this._event;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "mass", {
        /**
         * 获取重力。
         */
        get: function () {
            return this.getPhysicWorld().getBodyMass(this);
        },
        /**
         * 设置重力。
         */
        set: function (value) {
            this.getPhysicWorld().setBodyMass(this, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "filterGroup", {
        /**
         * 获取filterGroup。
         */
        get: function () {
            return this.getPhysicWorld().getFilterGroup(this);
        },
        /**
         * 设置filterGroup，一个32bits的整数，用于给刚体分组。
         */
        set: function (value) {
            this.getPhysicWorld().setFilterGroup(this, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "filterMask", {
        /**
         * 获取filterMask。
         */
        get: function () {
            return this.getPhysicWorld().getFilterMask(this);
        },
        /**
         * 设置filterMask，一个32bits的整数，用于给分组后的刚体设置碰撞对象范围。
         */
        set: function (value) {
            this.getPhysicWorld().setFilterMask(this, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "friction", {
        /**
         * 获取刚体摩擦力。
         */
        get: function () {
            return this.getPhysicWorld().getBodyFriction(this);
        },
        /**
         * 设置刚体摩擦力。
         */
        set: function (value) {
            this.getPhysicWorld().setBodyFriction(this, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "restitution", {
        /**
         * 获取刚体弹性系数。
         */
        get: function () {
            return this.getPhysicWorld().getBodyRestitution(this);
        },
        /**
         * 设置刚体弹性系数。
         */
        set: function (value) {
            this.getPhysicWorld().setBodyRestitution(this, value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "unControl", {
        /**
         * 获取刚体是否处于不可控状态，详见[IRigidBodyComponentState](../interfaces/irigidbodycomponentstate)。
         */
        get: function () {
            return this._unControl;
        },
        /**
         * 设置刚体是否处于不可控状态，详见[IRigidBodyComponentState](../interfaces/irigidbodycomponentstate)。
         */
        set: function (value) {
            this._unControl = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "physicStatic", {
        /**
         * 获取刚体是否处于物理静止状态，详见[IRigidBodyComponentState](../interfaces/irigidbodycomponentstate)。
         */
        get: function () {
            return this._physicStatic;
        },
        /**
         * 设置刚体是否处于物理静止状态，详见[IRigidBodyComponentState](../interfaces/irigidbodycomponentstate)。
         */
        set: function (value) {
            this._physicStatic = value;
            this.getPhysicWorld().setBodyType(this, value ? exports.ERigidBodyType.Static : exports.ERigidBodyType.Dynamic);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RigidBodyComponent.prototype, "disabled", {
        /**
         * 刚体组件目前是否停止运作。
         */
        get: function () {
            return this._disabled;
        },
        enumerable: false,
        configurable: true
    });
    RigidBodyComponent.prototype.verifyAdding = function () {
        if (!this.getPhysicWorld()) {
            throw new UnmetRequireException(this, 'Physic world is required for adding RigidBodyComponent !');
        }
        if (this._owner.findComponentByClass(RigidBodyComponent_1)) {
            throw new MemberConflictException(this._owner, 'RigidBodyComponent', this.name, this);
        }
    };
    RigidBodyComponent.prototype.onInit = function (initState) {
        this._unControl = initState.unControl || false;
        this._physicStatic = initState.physicStatic || false;
        if (typeof initState.filterMask !== 'undefined') {
            this.filterMask = initState.filterMask;
        }
        if (typeof initState.filterGroup !== 'undefined') {
            this.filterGroup = initState.filterGroup;
        }
        this._event.register('Pick');
        this._event.register('Collision');
        this._event.register('BodyEnter');
        this._event.register('BodyLeave');
        this._event.register('ColliderEnter');
        this._event.register('ColliderLeave');
        this._event.register('BeforeStep');
        this._event.register('AfterStep');
        // fixme: hack for performance
        this._owner._rigidBody = this;
    };
    /**
     * 添加到世界，继承请先`super.onAdd()`。
     */
    RigidBodyComponent.prototype.onAdd = function (initState) {
        this._rigidBody = this.getPhysicWorld().createRigidBody(this, initState);
        this.getPhysicWorld().initEvents(this);
        this._valid = true;
        if (initState.sleeping === true) {
            this.sleep();
        }
    };
    /**
     * 从世界中暂时移除，继承请先`super.onUnLink()`。
     */
    RigidBodyComponent.prototype.onUnLink = function () {
        this.disable();
    };
    /**
     * 重连世界，继承请先`super.onReLink()`。
     */
    RigidBodyComponent.prototype.onReLink = function () {
        this.enable();
    };
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    RigidBodyComponent.prototype.onDestroy = function () {
        var _this = this;
        this._valid = false;
        var physicWorld = this.getPhysicWorld();
        setTimeout(function () { return physicWorld.removeRigidBody(_this); }, 0);
        if (this._owner.rigidBody === this) {
            this._owner._rigidBody = null;
        }
    };
    /**
     * 暂时使得刚体失去效应，可以用`enable`恢复。
     */
    RigidBodyComponent.prototype.disable = function () {
        this.getPhysicWorld().disableRigidBody(this);
        this._disabled = true;
    };
    /**
     * 使得一个暂时失去效应的刚体恢复。
     */
    RigidBodyComponent.prototype.enable = function () {
        this.getPhysicWorld().enableRigidBody(this);
        this._disabled = false;
    };
    /**
     * 获取质心。
     */
    RigidBodyComponent.prototype.getMassCenter = function () {
        return this._owner.transform.position;
    };
    /**
     * 设置刚体的父级Actor的`transform`。
     */
    RigidBodyComponent.prototype.setRootTransform = function () {
        this.getPhysicWorld().setRootTransform(this);
        return this;
    };
    /**
     * 设置刚体的`transform`。
     */
    RigidBodyComponent.prototype.setRigidBodyTransform = function (newPosition, newRotation) {
        this.getPhysicWorld().setRigidBodyTransform(this, newPosition, newRotation);
        return this;
    };
    /**
     * 设置线速度。
     */
    RigidBodyComponent.prototype.setLinearVelocity = function (velocity) {
        this.getPhysicWorld().setLinearVelocity(this, velocity);
        return this;
    };
    /**
     * 设置角速度。
     */
    RigidBodyComponent.prototype.setAngularVelocity = function (velocity) {
        this.getPhysicWorld().setAngularVelocity(this, velocity);
        return this;
    };
    /**
     * 获取线速度。
     */
    RigidBodyComponent.prototype.getLinearVelocity = function () {
        return this.getPhysicWorld().getLinearVelocity(this);
    };
    /**
     * 获取角速度。
     */
    RigidBodyComponent.prototype.getAngularVelocity = function () {
        return this.getPhysicWorld().getAngularVelocity(this);
    };
    /**
     * 使刚体进入睡眠状态，不会触发任何碰撞事件，但可以正确响应拾取操作。
     */
    RigidBodyComponent.prototype.sleep = function () {
        this.getPhysicWorld().sleepBody(this);
        this._sleeping = true;
        return this;
    };
    /**
     * 唤醒刚体。
     */
    RigidBodyComponent.prototype.wakeUp = function () {
        this.getPhysicWorld().wakeUpBody(this);
        this._sleeping = false;
        return this;
    };
    /**
     * 强制同步物理刚体的transform到组件父级Actor。
     */
    RigidBodyComponent.prototype.forceSync = function () {
        this.handleBeforeStep(null, true);
        return this;
    };
    RigidBodyComponent.prototype.getParentsRotationAndScale = function () {
        var parent = this._owner.parent;
        this._tmpQuat.set(0, 0, 0, 1);
        this._tmpScale.set(1, 1, 1);
        while (parent && !isLevel(parent)) {
            var actor = parent.getOwner();
            this._tmpQuat2.copy(actor.transform.quaternion);
            this._tmpQuat.multiply(this._tmpQuat2);
            this._tmpScale2.copy(actor.transform.scale);
            this._tmpScale.multiply(this._tmpScale2);
            parent = actor.parent;
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    RigidBodyComponent.prototype.getCurrentTransform = function () {
        var transform = this._owner.transform;
        transform.updateMatrixWorld(true);
        if (this._owner.parent && !isLevel(this._owner.parent)) {
            this.getParentsRotationAndScale();
            this._tmpQuat.multiply(transform.quaternion);
            this._tmpScale.multiply(transform.scale);
        }
        else {
            this._tmpQuat.copy(transform.quaternion);
            this._tmpScale.copy(transform.scale);
        }
        return [transform.absolutePosition, this._tmpQuat, this._tmpScale];
    };
    RigidBodyComponent.prototype.syncTransformToRigidBody = function (forceSync) {
        // todo: bug: change this.box.transform.position & change this.box.transform.scale.x = .3;
        var transform = this._owner.transform;
        if (this.needUpdateCollider) {
            this.getPhysicWorld().updateBounding(this);
            this.needUpdateCollider = false;
        }
        if (!forceSync && this._unControl) {
            return;
        }
        if (forceSync) {
            transform.updateMatrixWorld(true);
        }
        this._tmpScale3.copy(this._tmpScale);
        if (this._owner.parent && !isLevel(this._owner.parent)) {
            this.getParentsRotationAndScale();
            this._tmpQuat.multiply(transform.quaternion);
            this._tmpScale.multiply(transform.scale);
        }
        else {
            this._tmpQuat.copy(transform.quaternion);
            this._tmpScale.copy(transform.scale);
        }
        var updateScale = (forceSync && !this._tmpScale.equals(vec3Unit)) || !this._tmpScale.equals(this._tmpScale3);
        this.getPhysicWorld().setRigidBodyTransform(this, transform.absolutePosition, this._tmpQuat, updateScale ? this._tmpScale : null);
        if (forceSync) {
            this.getPhysicWorld().updateBounding(this);
        }
    };
    var RigidBodyComponent_1;
    RigidBodyComponent = RigidBodyComponent_1 = __decorate([
        SClass({ className: 'RigidBodyComponent', classType: 'RigidBody' })
    ], RigidBodyComponent);
    return RigidBodyComponent;
}(Component));

/**
 * 判断一个实例是否为`ColliderComponent`。
 */
function isColliderComponent(value) {
    return value.isColliderComponent;
}
/**
 * 碰撞体组件基类。一般不自己使用，而是交由继承的类实现多态。
 *
 * @template IStateTypes 初始化参数类型，一般交由由继承的类定义实现多态。
 * @noInheritDoc
 */
var ColliderComponent = /** @class */ (function (_super) {
    __extends(ColliderComponent, _super);
    function ColliderComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isColliderComponent = true;
        _this._type = exports.EColliderType.Null;
        return _this;
    }
    Object.defineProperty(ColliderComponent.prototype, "collider", {
        /**
         * 获取物理世界的碰撞体，不要自己操作。
         *
         * @hidden
         */
        get: function () {
            return this._collider;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColliderComponent.prototype, "type", {
        /**
         * 获取碰撞体类型。
         */
        get: function () {
            return this._type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColliderComponent.prototype, "initState", {
        /**
         * 获取初始化参数实例引用。
         */
        get: function () {
            return this._initState;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ColliderComponent.prototype, "isTrigger", {
        /**
         * 获取是否是触发器。
         */
        get: function () {
            return this.getPhysicWorld().getColliderIsTrigger(this);
        },
        // set friction(value: number) {
        //   this.getPhysicWorld().setColliderFriction(this, value);
        // }
        // get friction() {
        //   return this.getPhysicWorld().getColliderFriction(this);
        // }
        // set restitution(value: number) {
        //   this.getPhysicWorld().setColliderRestitution(this, value);
        // }
        // get restitution() {
        //   return this.getPhysicWorld().getColliderRestitution(this);
        // }
        /**
         * 设置是否是触发器。
         */
        set: function (value) {
            this.getPhysicWorld().setColliderIsTrigger(this, value);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 开发环境下，验证可添加性。
     */
    ColliderComponent.prototype.verifyAdding = function () {
        var rigidBody = this._owner.rigidBody;
        if (!rigidBody) {
            throw new BreakGuardException(this, 'RigidBodyComponent must be added before adding ColliderComponent !');
        }
    };
    /**
     * 添加到世界，继承请先`super.onAdd()`。
     */
    ColliderComponent.prototype.onAdd = function (initState) {
        var rigidBody = this._owner.rigidBody;
        var options = this._initState = initState || this.getDefaultOptions();
        options.offset = options.offset || [0, 0, 0];
        options.quaternion = options.quaternion || [0, 0, 0, 1];
        this._collider = this.getPhysicWorld().createCollider(rigidBody, this, { type: this._type, options: options });
    };
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    ColliderComponent.prototype.onDestroy = function () {
        var _this = this;
        var physicWorld = this.getPhysicWorld();
        setTimeout(function () {
            if (_this._owner && _this._owner.rigidBody) {
                physicWorld.removeCollider(_this._owner.rigidBody, _this);
            }
        }, 0);
    };
    ColliderComponent.prototype.getDefaultOptions = function () {
        return null;
    };
    ColliderComponent = __decorate([
        SClass({ className: 'ColliderComponent' })
    ], ColliderComponent);
    return ColliderComponent;
}(Component));

/**
 * 判断一个实例是否为`BoxColliderComponent`。
 */
function isBoxColliderComponent(value) {
    return value.isBoxColliderComponent;
}
/**
 * 盒碰撞体，最常见的碰撞体之一。
 *
 * @noInheritDoc
 */
var BoxColliderComponent = /** @class */ (function (_super) {
    __extends(BoxColliderComponent, _super);
    function BoxColliderComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isBoxColliderComponent = true;
        _this._type = exports.EColliderType.Box;
        return _this;
    }
    BoxColliderComponent.prototype.getDefaultOptions = function () {
        return null;
    };
    BoxColliderComponent = __decorate([
        SClass({ className: 'BoxColliderComponent', classType: 'Collider' })
    ], BoxColliderComponent);
    return BoxColliderComponent;
}(ColliderComponent));

/**
 * 判断一个实例是否为`SphereColliderComponent`。
 */
function isSphereColliderComponent(value) {
    return value.isSphereColliderComponent;
}
/**
 * 球碰撞体，最常见的碰撞体之一。
 *
 * @noInheritDoc
 */
var SphereColliderComponent = /** @class */ (function (_super) {
    __extends(SphereColliderComponent, _super);
    function SphereColliderComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isSphereColliderComponent = true;
        _this._type = exports.EColliderType.Sphere;
        return _this;
    }
    SphereColliderComponent.prototype.getDefaultOptions = function () {
        return null;
    };
    SphereColliderComponent = __decorate([
        SClass({ className: 'SphereColliderComponent', classType: 'Collider' })
    ], SphereColliderComponent);
    return SphereColliderComponent;
}(ColliderComponent));

/**
 * 判断一个实例是否为`SceneActor`。
 */
function isSceneActor$1(value) {
    return value.isSceneActor;
}
/**
 * 场景Actor类，如果你想将一个`Actor`放入World(Level)，那么它必须为`SceneActor`。
 * 简而言之，这就是一个可以被赋予`transform`的Actor，它的根组件也必须为`SceneComponent`。
 *
 * @template IOptionTypes 初始化参数类型，必须继承自[ISceneComponentState](../interfaces/iscenecomponentstate)。
 * @template TRootComponent 根级组件类型，必须继承自[ISceneComponent](../interfaces/iscenecomponent)。
 * @noInheritDoc
 */
var SceneActor = /** @class */ (function (_super) {
    __extends(SceneActor, _super);
    function SceneActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isSceneActor = true;
        /**
         * 指定此实例是否为**持久的**，如果是，则此实例可以在关卡切换时被继承，或者在特殊状况时再世界切换时被继承。
         */
        _this.persistent = false;
        _this._rigidBody = null;
        _this._animator = null;
        _this._controller = null;
        return _this;
    }
    Object.defineProperty(SceneActor.prototype, "parent", {
        /**
         * 获取自身的父级实例，根据情况不同可能有不同的类型，一般不需要自己使用。
         */
        get: function () {
            return this._parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneActor.prototype, "transform", {
        /**
         * 获取自身的`transform`实例引用，本质上是根组件的一个代理。
         */
        get: function () {
            return this._root;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneActor.prototype, "rigidBody", {
        /**
         * 获取自身的刚体组件实例引用，需要开启物理引擎并初始化刚体，详见[RigidBodyComponent](../rigidbodycomponent)。
         */
        get: function () {
            return this._rigidBody;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneActor.prototype, "animator", {
        /**
         * 获取自身的动画组件实例引用，需要有模型动画或自己创建，详见[AnimatorComponent](../animatorcomponent)。
         */
        get: function () {
            return this._animator;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneActor.prototype, "layers", {
        /**
         * 图层属性，详见[Layers](../layers)。
         */
        get: function () {
            return this._root.layers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneActor.prototype, "visible", {
        /**
         * 获取是否可见，代理到根组件的同属性。详见`SceneComponent`的同属性。
         */
        get: function () {
            return this.root.visible;
        },
        /**
         * 设置是否可见，代理到根组件的同属性。详见`SceneComponent`的同属性。
         */
        set: function (value) {
            this.root.visible = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneActor.prototype, "isStatic", {
        /**
         * 获取是否为静态对象，代理到根组件的同属性。详见`SceneComponent`的同属性。
         */
        get: function () {
            return this._root.isStatic;
        },
        /**
         * 设置是否为静态对象，代理到根组件的同属性。详见`SceneComponent`的同属性。
         */
        set: function (value) {
            this._root.isStatic = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SceneActor.prototype, "needReleaseGlRes", {
        /**
         * 代理到根节点的同名属性，决定其下所有SceneComponent销毁时是否要同时释放Gl资源。
         */
        get: function () {
            return this._root.needReleaseGlRes;
        },
        /**
         * 代理到根节点的同名属性，决定其下所有SceneComponent销毁时是否要同时释放Gl资源。
         */
        set: function (value) {
            this._root.needReleaseGlRes = value;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 生命周期，创建默认的`SceneComponent`根组件，可以覆盖。
     */
    SceneActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', SceneComponent, options);
    };
    /**
     * 专属于`SceneActor`的生命周期，一般用于从GlTF模型中实例化对象(使用`resource.instantiate`方法)的情景。
     * 如果不是从资源中实例化的，将按顺序正常触发。
     * 此回调将在真正完成实例化后被触发，时机在`onAdd`之后，确保实例已经完全就绪（包括世界矩阵的首次运算）。
     */
    SceneActor.prototype.onInstantiate = function (options) {
    };
    /**
     * 取消链接，继承请先`super.onUnLink()`。
     */
    SceneActor.prototype.onUnLink = function () {
        this._root.hiloNode.removeFromParent();
    };
    /**
     * 重新链接，继承请先`super.onReLink()`。
     */
    SceneActor.prototype.onReLink = function (parent) {
        if (!isSceneActor$1(parent)) {
            this._root.hiloNode.addTo(parent.game.hiloStage);
        }
    };
    /**
     * 获取自身的`Controller`实例，涉及到玩家系统，详见[Player](./player)。
     */
    SceneActor.prototype.getController = function () {
        return this._controller;
    };
    /**
     * 获取根组件的的包围盒(AABB)信息。
     * @param bounds 当前计算的包围盒信息，可用于节省开销
     * @param currentMatrix 当前计算的矩阵，可用于节省开销
     */
    SceneActor.prototype.getBounds = function (bounds, currentMatrix) {
        return this._root.getBounds(bounds, currentMatrix);
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    SceneActor.prototype.added = function () {
        if (this._inWorld) {
            return;
        }
        this._inWorld = true;
        this._linked = true;
        if (isLevel(this._parent)) {
            this._game.hiloStage.addChild(this._root.hiloNode);
        }
        this._components.forEach(function (component) {
            component.added();
        });
        try {
            this.onAdd(this._initOptions);
        }
        catch (error) {
            throwException(error, this);
        }
        if (!(this._initOptions && this._initOptions.__fromGlTF)) {
            this.instantiated();
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    SceneActor.prototype.instantiated = function () {
        this._root.updateMatrixWorld(true);
        try {
            this.onInstantiate(this._initOptions);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    SceneActor.prototype.destroy = function () {
        if (this._controller) {
            this._controller.dispossessActor();
        }
        if (this._parent && !isLevel(this._parent)) {
            this._parent.removeActor(this);
        }
        _super.prototype.destroy.call(this);
    };
    /**
     * 修改自身的父级实例，通常用于Actor的复用。
     * **注意修改了之后自身的渲染节点也会重新挂载！**
     */
    SceneActor.prototype.changeParent = function (parent) {
        var game = this._game;
        if (isLevel(parent) || isWorld(parent)) {
            if (isLevel(this._parent)) {
                return this;
            }
            this._parent.autoDestroyActor = false;
            this._parent.removeFromParent();
            game.hiloStage.addChild(this._root.hiloNode);
            this._parent = game.level;
            return this;
        }
        if (isLevel(this._parent)) {
            parent.addChild(this);
            return this;
        }
        this._parent.autoDestroyActor = false;
        this._parent.removeFromParent();
        parent.addChild(this);
        return this;
    };
    /**
     * 修改自身的朝向，直接代理到根组件的同名方法。
     */
    SceneActor.prototype.lookAt = function (target) {
        this._root.lookAt(target);
        return this;
    };
    /**
     * 进行一次预渲染，期间会处理Actor下所有Component的材质预编译、资源预提交等。
     */
    SceneActor.prototype.preRender = function () {
        this._components.forEach(function (c) {
            if (isSceneComponent(c)) {
                c.preRender();
            }
        });
    };
    SceneActor = __decorate([
        SClass({ className: 'SceneActor' })
    ], SceneActor);
    return SceneActor;
}(Actor));

/**
 * 判断一个实例是否为`PrimitiveComponent`。
 */
function isPrimitiveComponent(value) {
    return value.isPrimitiveComponent;
}
/**
 * 判断一个实例是否为`PrimitiveActor`。
 */
function isPrimitiveActor(value) {
    return isSceneActor$1(value) && isPrimitiveComponent(value.root);
}
/**
 * 图元Component类，是拥有图元的组件的基类。
 * 这个Component拥有将Mesh添加到World中的能力，基本等同于模型，但一般不直接使用，而是使用其派生的类。
 *
 * @template IStateTypes 初始化参数类型，必须继承自[IPrimitiveComponentState](../interfaces/iprimitivecomponentstate)。
 * @noInheritDoc
 */
var PrimitiveComponent = /** @class */ (function (_super) {
    __extends(PrimitiveComponent, _super);
    function PrimitiveComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isPrimitiveComponent = true;
        _this.needUpdateAndDestroy = false;
        _this.__multiPrimitive = false;
        return _this;
    }
    /**
     * 初始化，继承请先`super.onInit()`。
     */
    PrimitiveComponent.prototype.onInit = function (state) {
        _super.prototype.onInit.call(this, state);
        this.__multiPrimitive = state.__doNotUseMultiPrimitiveYourself && state.__doNotUseMultiPrimitiveYourself.length > 1;
        if (state.material && state.material.cloneForInst) {
            state.material = state.material.clone();
        }
        var defaultMesh = this._mesh = this.onCreateMesh(state);
        this._mesh.__forceUseParentWorldMatrix = true;
        if (this.__multiPrimitive) {
            this._list = [];
            this._table = {};
            var length_1 = state.__doNotUseMultiPrimitiveYourself.length;
            for (var index = 0; index < length_1; index += 1) {
                var _a = state.__doNotUseMultiPrimitiveYourself[index], geometry = _a.geometry, material = _a.material;
                var mesh = index === 0 ? defaultMesh : this.onCreateMesh({
                    geometry: geometry,
                    material: material.cloneForInst ? material.clone() : material
                });
                mesh.__forceUseParentWorldMatrix = false;
                this._list.push(mesh);
                this._table[material.name] = mesh;
                if (state.frustumTest !== undefined) {
                    mesh.frustumTest = state.frustumTest;
                }
                this._node.addChild(mesh);
            }
        }
        else {
            if (state.frustumTest !== undefined) {
                this._mesh.frustumTest = state.frustumTest;
            }
            this._node.addChild(this._mesh);
        }
        var root = this.getRoot();
        if (root) {
            root.hiloNode.addChild(this._node);
        }
    };
    Object.defineProperty(PrimitiveComponent.prototype, "material", {
        /**
         * 获取材质实例引用。
         */
        get: function () {
            return this._mesh.material;
        },
        /**
         * 设置材质。
         */
        set: function (material) {
            this._mesh.material = material;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 当GlTF模型数据中一个Mesh拥有多个Primitive时（对应Unity中一个GameObject拥有多个材质测场景），为了进行对应，一个PrimitiveComponent可能拥有多个Mesh。
     * 这种状况时，你可以通过`materialName`来修改一个具体的材质。**但不提供自行创建这种特殊组件的方式，谨慎使用！务必清楚多材质Mesh等价于多个Mesh！**
     */
    PrimitiveComponent.prototype.setMaterial = function (value, materialName) {
        if (!this.__multiPrimitive) {
            this._mesh.material = value;
            return this;
        }
        if (materialName && this._table[materialName]) {
            this._table[materialName].material = value;
        }
        return this;
    };
    /**
     * 当GlTF模型数据中一个Mesh拥有多个Primitive时（对应Unity中一个GameObject拥有多个材质测场景），为了进行对应，一个PrimitiveComponent可能拥有多个Mesh。
     * 这种状况时，你可以通过`materialName`来获取一个具体的材质。**但不提供自行创建这种特殊组件的方式，谨慎使用！务必清楚多材质Mesh等价于多个Mesh！**
     */
    PrimitiveComponent.prototype.getMaterial = function (materialName) {
        if (!materialName || !this.__multiPrimitive) {
            return this._mesh.material;
        }
        if (this._table[materialName]) {
            return this._table[materialName].material;
        }
        return null;
    };
    /**
     * 当GlTF模型数据中一个Mesh拥有多个Primitive时（对应Unity中一个GameObject拥有多个材质测场景），为了进行对应，一个PrimitiveComponent可能拥有多个Mesh。
     * 这种状况时，你可以通过此方法获取所有材质。**但不提供自行创建这种特殊组件的方式，谨慎使用！务必清楚多材质Mesh等价于多个Mesh！**
     */
    PrimitiveComponent.prototype.getMaterials = function () {
        return (!this.__multiPrimitive ? [this.material] : this._list.map(function (mesh) { return mesh.material; }));
    };
    Object.defineProperty(PrimitiveComponent.prototype, "geometry", {
        /**
         * 设置几何体实例引用。
         */
        get: function () {
            return this._mesh.geometry;
        },
        /**
         * 获取几何体实例引用。
         */
        set: function (geometry) {
            this._mesh.geometry = geometry;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 适用于多图元（材质）Mesh，详细基本等同于`setMaterial`方法。
     */
    PrimitiveComponent.prototype.setGeometry = function (value, materialName) {
        if (!this.__multiPrimitive) {
            this._mesh.geometry = value;
            return this;
        }
        if (materialName && this._table[materialName]) {
            this._table[materialName].geometry = value;
        }
        return this;
    };
    /**
     * 适用于多图元（材质）Mesh，详细基本等同于`getMaterial`方法。
     */
    PrimitiveComponent.prototype.getGeometry = function (materialName) {
        if (!materialName || !this.__multiPrimitive) {
            return this._mesh.geometry;
        }
        if (this._table[materialName]) {
            return this._table[materialName].geometry;
        }
        return null;
    };
    /**
     * 适用于多图元（材质）Mesh。
     */
    PrimitiveComponent.prototype.getSubMesh = function (materialName) {
        if (!materialName || !this.__multiPrimitive) {
            return this._mesh;
        }
        if (this._table[materialName]) {
            return this._table[materialName];
        }
        return null;
    };
    Object.defineProperty(PrimitiveComponent.prototype, "frustumTest", {
        /**
         * 是否需要视椎体裁剪。
         */
        get: function () {
            return this._mesh.frustumTest;
        },
        /**
         * 是否需要视椎体裁剪。
         */
        set: function (value) {
            this.setMeshProperty('frustumTest', value);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 进行一次预渲染，期间会处理材质预编译、资源预提交等。
     */
    PrimitiveComponent.prototype.preRender = function () {
        var renderer = this.getGame().renderer;
        if (this.__multiPrimitive) {
            renderer.renderMesh(this._mesh);
            return;
        }
        this._list.forEach(function (mesh) {
            renderer.renderMesh(mesh);
        });
    };
    PrimitiveComponent.prototype.setMeshProperty = function (name, value) {
        if (this.__multiPrimitive) {
            var length_2 = this._list.length;
            for (var index = 0; index < length_2; index += 1) {
                this._list[index][name] = value;
            }
            return;
        }
        this._mesh[name] = value;
    };
    PrimitiveComponent.prototype.onCreateMesh = function (state) {
        return null;
    };
    PrimitiveComponent = __decorate([
        SClass({ className: 'PrimitiveComponent' })
    ], PrimitiveComponent);
    return PrimitiveComponent;
}(SceneComponent));

/**
 * 判断一个实例是否为`StaticMeshComponent`。
 */
function isStaticMeshComponent(value) {
    return value.isStaticMeshComponent;
}
/**
 * 判断一个实例是否为`StaticMeshActor`。
 */
function isStaticMeshActor(value) {
    return isSceneActor(value) && isStaticMeshComponent(value.root);
}
/**
 * 静态Component类，承载纯粹静态的模型。
 *
 * @template IStateTypes 初始化参数类型，必须继承自[IStaticMeshComponentState](../interfaces/istaticmeshcomponentstate)。
 * @noInheritDoc
 */
var StaticMeshComponent = /** @class */ (function (_super) {
    __extends(StaticMeshComponent, _super);
    function StaticMeshComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isStaticMeshComponent = true;
        return _this;
    }
    StaticMeshComponent.prototype.onCreateMesh = function (state) {
        return new Mesh({
            geometry: state ? state.geometry : null,
            material: state ? state.material : null
        });
    };
    StaticMeshComponent = __decorate([
        SClass({ className: 'StaticMeshComponent' })
    ], StaticMeshComponent);
    return StaticMeshComponent;
}(PrimitiveComponent));

/**
 * 判断一个实例是否为`PBRMaterial`。
 */
function isPBRMaterial(value) {
    return value.isPBRMaterial;
}
var PBRMaterial = /** @class */ (function (_super) {
    __extends(PBRMaterial, _super);
    function PBRMaterial() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PBRMaterial;
}(Hilo3d$2.PBRMaterial));

/**
 * 判断一个实例是否为`AtlasManager`。
 */
function isAtlasManager(value) {
    return value.isAtlasManager;
}
function isPowerOfTwo$1(x) {
    return (Math.log(x) / Math.log(2)) % 1 === 0;
}
/**
 * 图集管理器。
 * 一般通过`AtlasLoader`加载自动生成。
 *
 * @noInheritDoc
 */
var AtlasManager = /** @class */ (function (_super) {
    __extends(AtlasManager, _super);
    /**
     * 构建一个图集。
     *
     * @param options 初始化参数。
     * @param updatable 是否是一个可更新的图集，若不是则不可调用`updateFrame`等方法。注意`updatable`的图集本身容器的宽高都必须为**2的幂！**比如512、1024、2048等等。
     */
    function AtlasManager(options, updatable) {
        if (updatable === void 0) { updatable = true; }
        var _this = _super.call(this) || this;
        _this.isAtlasManager = true;
        _this._AUTO_ID = 0;
        _this._area = 0;
        _this._needReBuild = false;
        /**
         * 纹理提交GPU后是否释放CPU内存
         */
        _this.isImageCanRelease = false;
        _this._frames = options.frames;
        _this._meta = options.meta;
        _this._canvases = {};
        _this._textures = {};
        _this._updatable = updatable;
        if (options.texture) {
            _this._image = options.texture.image;
            _this._texture = options.texture;
        }
        else if (options.image instanceof HTMLCanvasElement) {
            _this._image = options.image;
            _this._ctx = _this._image.getContext('2d');
        }
        else if (updatable) {
            if (Debug.devMode && !(isPowerOfTwo$1(_this._meta.size.w) && isPowerOfTwo$1(_this._meta.size.h))) {
                throw new Error("Atlas " + _this.name + " is updatable but it size is not power of two !");
            }
            _this._image = document.createElement('canvas');
            _this._image.width = _this._meta.size.w;
            _this._image.height = _this._meta.size.h;
            _this._ctx = _this._image.getContext('2d');
            _this._ctx.drawImage(options.image, 0, 0);
        }
        else {
            _this._image = options.image;
        }
        return _this;
    }
    AtlasManager_1 = AtlasManager;
    /**
     * 根据宽高创建一个空的图集，可自由申请或释放帧。
     */
    AtlasManager.CREATE_EMPTY = function (options) {
        var width = options.width, height = options.height;
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.fillStyle = 'rgba(255, 255, 255, 0)';
        context.fillRect(0, 0, width, height);
        return new AtlasManager_1({ image: canvas, frames: {}, meta: { size: { w: width, h: height } } }, true);
    };
    /**
     * 根据宽高和行数、列数来创建一个空的图集。
     * 这个图集将被行列分成若干个格子帧，开发者可以根据实际状况去使用`updateFrame`更新这些格子。
     * 自动生成的帧的名字为`${row}${col}`，比如第一行第一列为`'11'`。
     *
     * @param onDraw 初始化时的回调，可以用于一开始绘制图像
     */
    AtlasManager.CREATE_FROM_GRIDS = function (options, onDraw) {
        var width = options.width, height = options.height, rows = options.rows, cols = options.cols, space = options.space;
        space = space || 0;
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.fillStyle = 'rgba(255, 255, 255, 0)';
        context.fillRect(0, 0, width, height);
        var w = ~~(width / cols) - space;
        var h = ~~(height / rows) - space;
        var frames = {};
        for (var row = 0; row < rows; row += 1) {
            for (var col = 0; col < cols; col += 1) {
                var frameName = "" + row + col;
                var x = col * (w + space);
                var y = row * (h + space);
                frames[frameName] = {
                    frame: { x: x, y: y, w: w, h: h },
                    space: space
                };
            }
        }
        var atlas = new AtlasManager_1({ image: canvas, frames: frames, meta: { size: { w: width, h: height } } }, true);
        if (onDraw) {
            for (var row = 0; row < rows; row += 1) {
                for (var col = 0; col < cols; col += 1) {
                    var frameName = "" + row + col;
                    var _a = atlas.getFrame(frameName), x = _a.x, y = _a.y, w_1 = _a.w, h_1 = _a.h;
                    onDraw(atlas, context, { x: x, y: y, w: w_1, h: h_1, row: row, col: col }, frameName);
                }
            }
        }
        return atlas;
    };
    /**
     * 根据纹理和配置，来通过纹理创建一个不可修改的图集。通常用于精灵动画。
     * 这个图集将被行列分成若干个格子帧，每一帧的名字为`0`、`1`、`2`......
     */
    AtlasManager.CREATE_FROM_TEXTURE = function (texture, options) {
        var w = options.cellWidth;
        var h = options.cellHeight;
        var width = texture.origWidth, height = texture.origHeight;
        var spacing = options.spacing || 0;
        var framesPerLine = options.framesPerLine;
        var frameStart = options.frameStart, frameCount = options.frameCount;
        if (frameStart === undefined) {
            frameStart = 0;
        }
        if (frameCount === undefined) {
            frameCount = Infinity;
        }
        var frames = {};
        var i = frameStart;
        while (true) {
            var row = framesPerLine === 1 ? i : ~~(i / framesPerLine);
            var col = framesPerLine === 1 ? 0 : i % framesPerLine;
            var x = col * (w + spacing);
            var y = row * (h + spacing);
            if (i >= frameCount || (y + h + spacing >= height)) {
                break;
            }
            frames[i] = {
                frame: { x: x, y: y, w: w, h: h }
            };
            i += 1;
        }
        return new AtlasManager_1({ texture: texture, frames: frames, meta: { size: { w: width, h: height } } }, false);
    };
    Object.defineProperty(AtlasManager.prototype, "image", {
        /**
         * 获取整体图片数据。
         */
        get: function () {
            return this._image;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AtlasManager.prototype, "meta", {
        /**
         * 获取元信息。
         */
        get: function () {
            return this._meta;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AtlasManager.prototype, "frames", {
        /**
         * 获取帧集合。
         */
        get: function () {
            return this._frames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AtlasManager.prototype, "texture", {
        /**
         * 获取整体的纹理，也可以使用`getWholeTexture`。
         */
        get: function () {
            return this.getWholeTexture();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AtlasManager.prototype, "usage", {
        /**
         * 获取当前图集的使用率，仅在**动态图集**的状况下有效。
         */
        get: function () {
            var _a = this._meta.size, w = _a.w, h = _a.h;
            return this._area / (w * h);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取某一帧的数据。
     */
    AtlasManager.prototype.getFrame = function (frameName) {
        return this._frames[frameName].frame;
    };
    /**
     * @deprecated
     *
     * 请用`getUVMatrix`
     * 获取某一帧的uv。
     */
    AtlasManager.prototype.getUV = function (frameName) {
        throw new Error('`getUV` is deprecated, please use `getUVMatrix`!');
    };
    /**
     * 获取某一帧的uv变换矩阵。
     */
    AtlasManager.prototype.getUVMatrix = function (frameName) {
        var f = this._frames[frameName];
        if (!f) {
            throw new Error("Frame " + frameName + " is not existed!");
        }
        var uvMatrix = f.uvMatrix, frame = f.frame;
        if (!uvMatrix) {
            f.uvMatrix = this.buildUVMatrix(frame);
        }
        return f.uvMatrix;
    };
    AtlasManager.prototype.buildUVMatrix = function (frame) {
        var _a = this._meta.size, w = _a.w, h = _a.h;
        var matrix = new Matrix3();
        // flipY
        matrix.set(frame.w / w, 0, 0, 0, -frame.h / h, 0, frame.x / w, (frame.y + frame.h) / h, 1);
        return matrix;
    };
    /**
     * 获取某一帧的图片数据，**会创建独立的canvas，慎重使用！**。建议使用`getTexture`。
     */
    AtlasManager.prototype.getFrameImage = function (frameName) {
        if (!this._canvases[frameName]) {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            var _a = this._frames[frameName].frame, x = _a.x, y = _a.y, w = _a.w, h = _a.h;
            canvas.width = w;
            canvas.height = h;
            context.drawImage(this._image, x, y, w, h);
            this._canvases[frameName] = canvas;
        }
        return this._canvases[frameName];
    };
    /**
     * 获取某一帧的纹理数据，**会创建独立的canvas，慎重使用！**。建议使用`getWholeTexture`。
     */
    AtlasManager.prototype.getTexture = function (frameName, options) {
        if (!options && this._textures[frameName]) {
            return this._textures[frameName];
        }
        var frame = this.getFrame(frameName);
        var x = frame.x, y = frame.y, w = frame.w, h = frame.h;
        var image;
        if (this._image instanceof HTMLImageElement) {
            if (!this._tmpCanvas) {
                this._tmpCanvas = document.createElement('canvas');
                this._tmpCanvas.width = this._image.width;
                this._tmpCanvas.height = this._image.height;
            }
            var ctx = this._tmpCanvas.getContext('2d');
            ctx.drawImage(this._image, x, y, w, h, 0, 0, w, h);
            image = ctx.getImageData(0, 0, w, h);
        }
        else if (this._image instanceof HTMLCanvasElement) {
            var ctx = this._image.getContext('2d');
            image = ctx.getImageData(x, y, w, h);
        }
        else {
            Debug.warn("Image is 'ArrayBuffer', not support get a frame !");
        }
        if (options) {
            return new Texture(__assign({ image: image, isImageCanRelease: this.isImageCanRelease }, options));
        }
        this._textures[frameName] = new Texture({ image: image, isImageCanRelease: this.isImageCanRelease });
        return this._textures[frameName];
    };
    /**
     * 获取整体纹理数据，建议配合`getFrame`或`getUVMatrix`在shader中使用。
     */
    AtlasManager.prototype.getWholeTexture = function (options) {
        if (options) {
            if (this._texture) {
                this._texture.destroy();
            }
            return this._texture = new Texture(__assign({ image: this._image, isImageCanRelease: this.isImageCanRelease }, options));
        }
        if (!this._texture) {
            this._texture = new Texture({ image: this._image, isImageCanRelease: this.isImageCanRelease });
        }
        return this._texture;
    };
    /**
     * 更新某一frame，通过`onDraw`方法参数中的`context`和`region`来更新`canvas`画布上此帧所占据区域内的图像，并同步到GPU。
     */
    AtlasManager.prototype.updateFrame = function (frameName, onDraw) {
        if (!this._updatable) {
            throw new Error("Atlas " + this.name + " is not updatable !");
        }
        if (this._canvases[frameName]) {
            delete this._canvases[frameName];
        }
        if (this._textures[frameName]) {
            delete this._textures[frameName];
        }
        var _a = this.getFrame(frameName), x = _a.x, y = _a.y, w = _a.w, h = _a.h;
        onDraw(this._ctx, { x: x, y: y, w: w, h: h }, frameName);
        this.updateGlSubBuffer(x, y, w, h);
    };
    /**
     * 申请分配指定的`region`大小的一帧，其中`frameName`是你想要赋予的名字，若不传会自动生成。
     * 如果分配成功，则会通过`onDraw`的参数返回`context`、实际区域`region`和被分配的帧名`frameName`，你可以在这个方法中绘制。
     *
     * @returns [string] 若成功，将返回分配的`frame`的名字，否则返回`null`。
     */
    AtlasManager.prototype.allocateFrame = function (region, onDraw) {
        if (!this._updatable) {
            throw new Error("Atlas " + this.name + " is not updatable !");
        }
        var frameName = region.frameName;
        if (frameName && this._frames[frameName]) {
            throw new Error("Frame named " + frameName + " is not already existed !");
        }
        if (this._needReBuild) {
            this.rebuildFrames();
        }
        frameName = this.generateFrame(this._root, region);
        if (!frameName) {
            return null;
        }
        this._area += region.w * region.h;
        if (onDraw) {
            var _a = this.getFrame(frameName), x = _a.x, y = _a.y, w = _a.w, h = _a.h;
            onDraw(this._ctx, { x: x, y: y, w: w, h: h }, frameName);
            this.updateGlSubBuffer(x, y, w, h);
        }
        return frameName;
    };
    AtlasManager.prototype.generateFrame = function (rootFrame, region, bottom) {
        var w = region.w, h = region.h, _a = region.space, space = _a === void 0 ? 0 : _a, frameName = region.frameName;
        var size = this._meta.size;
        if (bottom === undefined) {
            bottom = this._meta.size.h;
        }
        if (!this._root) {
            return this._root = this.addFrame(0, 0, w, h, frameName);
        }
        var root = this._frames[rootFrame];
        var right = root.right, down = root.down, frame = root.frame;
        var x = frame.x + frame.w + space;
        var y = frame.y + frame.h + space;
        var aW = size.w - x;
        var aH = bottom - y;
        if (!right && !down && w <= aW && h <= frame.h) {
            return root.right = this.addFrame(x, frame.y, w, h, frameName, space);
        }
        if (!right && w <= aW && h <= frame.h) {
            return root.right = this.addFrame(x, frame.y, w, h, frameName, space);
        }
        if (!down && w <= (size.w - frame.x) && h <= aH) {
            return root.down = this.addFrame(frame.x, y, w, h, frameName, space);
        }
        if (right && (frameName = this.generateFrame(right, region, y))) {
            return frameName;
        }
        if (down && (frameName = this.generateFrame(down, region, bottom))) {
            return frameName;
        }
        return null;
    };
    AtlasManager.prototype.rebuildFrames = function () {
        var _this = this;
        var size = this._meta.size;
        if (!this._tmpCanvas) {
            var tmp = this._tmpCanvas = document.createElement('canvas');
            tmp.width = size.w;
            tmp.height = size.h;
        }
        var tmpCtx = this._tmpCanvas.getContext('2d');
        tmpCtx.drawImage(this._image, 0, 0);
        this._ctx.clearRect(0, 0, size.w, size.h);
        this._ctx.fillStyle = 'rgba(255, 255, 255, 0)';
        this._ctx.fillRect(0, 0, size.w, size.h);
        var frames = Object.assign({}, this._frames);
        this._frames = {};
        this._root = null;
        var keys = Object.keys(frames).sort(function (a, b) {
            return frames[b].frame.h - frames[a].frame.h;
        });
        keys.forEach(function (frameName) {
            var frame = frames[frameName];
            var _a = frame.frame, w = _a.w, h = _a.h;
            _this.generateFrame(_this._root, { w: w, h: h, frameName: frameName, space: frame.space });
            var _b = _this._frames[frameName].frame, x = _b.x, y = _b.y;
            var orig = frames[frameName].frame;
            _this._ctx.drawImage(_this._tmpCanvas, orig.x, orig.y, w, h, x, y, w, h);
        });
        this.updateGlSubBuffer(0, 0, size.w, size.h);
        this._needReBuild = false;
    };
    AtlasManager.prototype.addFrame = function (x, y, w, h, frameName, space) {
        frameName = frameName || "AUTO-" + this._AUTO_ID++;
        this._frames[frameName] = { frame: { x: x, y: y, w: w, h: h }, space: space };
        return frameName;
    };
    /**
     * 释放一帧的空间，将其标记为可分配状态。
     */
    AtlasManager.prototype.releaseFrame = function (frameName) {
        if (!this._updatable) {
            throw new Error("Atlas " + this.name + " is not updatable !");
        }
        var frame = this._frames[frameName];
        if (frame) {
            if (this._texture[frameName]) {
                this._texture.destroy();
            }
            if (this._canvases[frameName]) {
                delete this._canvases[frameName];
            }
            delete this._frames[frameName];
            this._area -= frame.frame.h * frame.frame.w;
            this._needReBuild = true;
        }
    };
    AtlasManager.prototype.updateGlSubBuffer = function (x, y, w, h) {
        if (!this._texture) {
            return;
        }
        this._texture.updateSubTexture(x, this._texture.flipY ? this._meta.size.h - y - h : y, this._ctx.getImageData(x, y, w, h));
    };
    /**
     * 完全销毁释放图集。
     */
    AtlasManager.prototype.destroy = function () {
        for (var key in this._textures) {
            this._textures[key].destroy();
        }
        if (this._texture) {
            this._texture.destroy();
        }
    };
    var AtlasManager_1;
    AtlasManager = AtlasManager_1 = __decorate([
        SClass({ className: 'AtlasManager' })
    ], AtlasManager);
    return AtlasManager;
}(SObject));

/**
 * 判断一个实例是否为`LazyTexture`。
 */
function isLazyTexture(value) {
    return value.isLazyTexture;
}
var LazyTexture = /** @class */ (function (_super) {
    __extends(LazyTexture, _super);
    function LazyTexture() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return LazyTexture;
}(Hilo3d$2.LazyTexture));

/**
 * @hidden
 */
var getDefaultParse = function (name) { return function (info, parser, node) {
    if (node) {
        node.gltfExtensions = node.gltfExtensions || {};
        node.gltfExtensions[name] = info;
        return node;
    }
}; };
/**
 * 模型解压缩扩展的配置实例。
 */
var AliAMCExtension = Hilo3d$2.AliAMCExtension;
/**
 * @hidden
 */
var SeinNodeExtension = {
    name: 'Sein_node',
    optionParsers: {},
    registerOptionParsers: function (type, parser) {
        SeinNodeExtension.optionParsers[type] = parser;
    },
    unregisterOptionParsers: function (type) {
        delete SeinNodeExtension.optionParsers[type];
    },
    parseOption: function (option, parser, info) {
        var type = option.type, value = option.value;
        if (type && SeinNodeExtension.optionParsers[type]) {
            return SeinNodeExtension.optionParsers[type](value, parser, info);
        }
        else {
            throw new Error("You must register parser for type '" + type + "' in Sein_node.initOptions !");
        }
    },
    parse: function (info, parser, node, options) {
        node.gltfExtensions = node.gltfExtensions || {};
        node.gltfExtensions[SeinNodeExtension.name] = info;
        if (!info.initOptions) {
            return node;
        }
        var initOptions = info.initOptions;
        Object.keys(initOptions).forEach(function (name) {
            initOptions[name] = SeinNodeExtension.parseOption(initOptions[name], parser, info);
        });
        return node;
    },
    instantiate: function (entity, info) {
        if (info.updateOnEverTick !== undefined) {
            entity.updateOnEverTick = info.updateOnEverTick;
        }
        if (info.neverTransform !== undefined) {
            entity.isStatic = info.neverTransform;
        }
        if (isSceneActor(entity)) {
            if (info.tag) {
                entity.tag = new SName(info.tag);
            }
            if (info.layers) {
                entity.layers.set(info.layers);
            }
            if (info.persistent !== undefined) {
                entity.persistent = info.persistent;
            }
            if (info.emitComponentsDestroy !== undefined) {
                entity.emitComponentsDestroy = info.emitComponentsDestroy;
            }
        }
    }
};
['Float', 'Int', 'String', 'Bool'].forEach(function (type) {
    SeinNodeExtension.registerOptionParsers(type, function (value) { return value; });
});
SeinNodeExtension.registerOptionParsers('Vec2', function (value) { return new Vector2().fromArray(value); });
SeinNodeExtension.registerOptionParsers('Vec3', function (value) { return new Vector3().fromArray(value); });
SeinNodeExtension.registerOptionParsers('Vec4', function (value) { return new Vector4().fromArray(value); });
SeinNodeExtension.registerOptionParsers('Mat4', function (value) { return new Matrix4().fromArray(value); });
SeinNodeExtension.registerOptionParsers('Quat', function (value) { return new Quaternion().fromArray(value); });
SeinNodeExtension.registerOptionParsers('Color', function (value) { return new Color().fromArray(value); });
SeinNodeExtension.registerOptionParsers('Tex2D', function (value, parser) { return parser.textures[value.index]; });
SeinNodeExtension.registerOptionParsers('TexCube', function (value, parser) { return parser.cubeTextures[value.index]; });
SeinNodeExtension.registerOptionParsers('Atlas', function (value, parser) { return parser.atlases[value.index]; });
SeinNodeExtension.registerOptionParsers('Mat', function (value, parser) { return parser.materials[value.index]; });
SeinNodeExtension.registerOptionParsers('Array', function (value, parser, info) {
    return value.map(function (v) { return SeinNodeExtension.parseOption(v, parser, info); });
});
SeinNodeExtension.registerOptionParsers('Object', function (value, parser, info) {
    var result = {};
    Object.keys(value).forEach(function (name) {
        result[name] = SeinNodeExtension.parseOption(value[name], parser, info);
    });
    return result;
});
/**
 * @hidden
 */
var SeinPhysicBodyExtension = {
    name: 'Sein_physicBody',
    instantiate: function (entity, info, game) {
        if (!isSceneActor(entity)) {
            Debug.warn("You could not add physicBody to a component: " + entity.name + ", ignore...");
            return;
        }
        var physicBody = info;
        if (!game.world.physicWorld) {
            Debug.warn("Model " + entity.name + " in gltf file has physicBody, but \"PhysicWorld\" is not found in current world, ignore...");
            return;
        }
        var body = entity.addComponent('rigidBody', RigidBodyComponent, {
            mass: physicBody.mass,
            friction: physicBody.friction,
            restitution: physicBody.restitution,
            unControl: physicBody.unControl,
            physicStatic: physicBody.physicStatic
        });
        if (info.sleeping) {
            entity.rigidBody.sleep();
        }
        physicBody.colliders.forEach(function (collider, index) {
            var name = "collider-" + (collider.name || (collider.type + index));
            switch (collider.type) {
                case 'BOX':
                    entity.addComponent(name, BoxColliderComponent, collider);
                    break;
                case 'SPHERE':
                    entity.addComponent(name, SphereColliderComponent, collider);
                    break;
            }
        });
        if (physicBody.colliders.length) {
            body.forceSync();
        }
    }
};
/**
 * @hidden
 */
var SeinAnimatorExtension = {
    name: 'Sein_animator',
    instantiate: function (entity) {
        if (!isSceneActor(entity)) {
            Debug.warn("You could not add animator to a component: " + entity.name + ", ignore...");
            return;
        }
    }
};
/**
 * @hidden
 */
var SeinRendererExtension = {
    name: 'Sein_renderer',
    parseOnLoad: function (info, parser) {
        parser['renderer'] = parser.json.extensions.Sein_renderer || {};
    },
    parseOnEnd: function (info, parser, model) {
        model['renderer'] = parser['renderer'];
        return model;
    },
    instantiate: function (entity, info, _, __, resource) {
        var root = isSceneActor(entity) ? entity.root : entity;
        if (!isStaticMeshComponent(root) && !isPrimitiveComponent(root)) {
            return;
        }
        root.getMaterials().forEach(function (material) {
            if (isStaticMeshComponent(root) && info.lightMap) {
                var matName = material.name;
                material = material.clone();
                root.setMaterial(material, matName);
                var _a = info.lightMap, lightMapIndex = _a.lightMapIndex, uvChannel = _a.uvChannel, uvRotation = _a.uvRotation, uvScale = _a.uvScale, uvOffset = _a.uvOffset;
                var texture = resource.textures[lightMapIndex];
                texture.uv = uvChannel;
                if (isPBRMaterial(material)) {
                    material.lightMap = texture;
                }
                else if (isRawShaderMaterial(material)) {
                    material.setUniform('u_lightMap', texture);
                }
                if (uvChannel === 0) {
                    material.uvMatrix = new Matrix3().fromRotationTranslationScale(uvRotation, uvOffset[0], uvOffset[1], uvScale[0], uvScale[1]);
                }
                else {
                    material.uvMatrix1 = new Matrix3().fromRotationTranslationScale(uvRotation, uvOffset[0], uvOffset[1], uvScale[0], uvScale[1]);
                }
            }
            material.receiveShadows = info.castShadows || false;
            material.castShadows = info.receiveShadows || false;
            material.gammaCorrection = info.gammaCorrection || false;
            var globalSetting = resource['renderer'];
            if (globalSetting) {
                material.gammaCorrection = globalSetting.gammaCorrection || false;
                material.useHDR = globalSetting.useHDR || false;
                material.exposure = globalSetting.exposure ? material.exposure : globalSetting.exposure;
            }
        });
    }
};
/**
 * @hidden
 */
var SeinAmbientLightExtension = {
    name: 'Sein_ambientLight',
    parseOnEnd: function (info, parser, model) {
        var color = info.color, intensity = info.intensity;
        var light = new Hilo3d$2.AmbientLight({
            name: 'gltf-ambientLight-extension',
            color: new Color(color[0], color[1], color[2]),
            amount: intensity
        });
        model['ambientLight'] = light;
        return model;
    }
};
/**
 * @hidden
 */
function getRelativePath(basePath, path) {
    if (/^(?:http|blob|data:|\/)/.test(path)) {
        return path;
    }
    var basePaths = basePath.replace(/\/[^/]*?$/, '').split('/');
    var paths = path.split('/');
    var i = 0;
    for (i = 0; i < paths.length; i += 1) {
        var p = paths[i];
        if (p === '..') {
            basePaths.pop();
        }
        else if (p !== '.') {
            break;
        }
    }
    return basePaths.join('/') + '/' + paths.slice(i).join('/');
}
/**
 * @hidden
 */
var SeinCubeTextureExtension = {
    name: 'Sein_cubeTexture',
    init: function (_, parser) {
        var game = parser.game;
        var actions = [];
        var extensions = parser.json.extensions || {};
        var source = extensions.Sein_cubeTexture || {};
        var textures = source.textures || [];
        var cubeTextures = [];
        parser.cubeTextures = cubeTextures;
        textures.forEach(function (tex, index) {
            var images = tex.images.map(function (imageIndex) {
                var uri = parser.getImageUri(imageIndex);
                uri = getRelativePath(parser.src, uri);
                return uri;
            });
            actions.push(Promise.resolve().then(function () { return new Promise(function (resolve, reject) {
                var format = /\.png$/.test(images[0]) ? Constants.RGBA : Constants.RGB;
                game.resource.getLoader('CubeTexture').load({
                    type: 'CubeTexture', url: '', images: {
                        right: images[0],
                        left: images[1],
                        top: images[2],
                        bottom: images[3],
                        front: images[4],
                        back: images[5]
                    },
                    name: '',
                    format: format,
                    internalFormat: format,
                    isImageCanRelease: tex.isImageCanRelease
                }, {
                    onLoading: function (_, progress) { },
                    onLoaded: function (entity) {
                        var cubeTex = entity.result;
                        var sampler = parser.json.samplers[tex.sampler];
                        cubeTextures[index] = cubeTex;
                        cubeTex.minFilter = sampler.minFilter || cubeTex.minFilter;
                        cubeTex.magFilter = sampler.magFilter || cubeTex.magFilter;
                        cubeTex.wrapS = sampler.wrapS || cubeTex.wrapS;
                        cubeTex.wrapT = sampler.wrapT || cubeTex.wrapT;
                        resolve();
                    },
                    onError: function (_, error) { return reject(error); }
                });
            }); }));
        });
        return Promise.all(actions);
    },
    parseOnEnd: function (info, parser, model) {
        model.cubeTextures = parser.cubeTextures;
        return model;
    }
};
/**
 * @hidden
 */
var SeinImageBasedLightingExtension = {
    name: 'Sein_imageBasedLighting',
    init: function (_, parser) {
        var game = parser.game;
        var extensions = parser.json.extensions || {};
        var iblSources = extensions.Sein_imageBasedLighting || {};
        var lights = iblSources.lights || [];
        var imageBasedLights = [];
        parser.imageBasedLights = imageBasedLights;
        lights.forEach(function (light, index) {
            imageBasedLights.push({
                diffuse: {
                    type: light.diffuse.type,
                    intensity: light.diffuse.intensity,
                    coefficients: new SphericalHarmonics3().fromArray(light.diffuse.coefficients),
                },
                specular: light.specular ? {
                    type: light.specular.type,
                    intensity: light.specular.intensity,
                    brdfLUTIndex: light.specular.brdfLUT.index,
                    brdfLUT: null,
                    cubeMap: null
                } : null
            });
            var specular = imageBasedLights[index].specular;
            if (!specular) {
                return;
            }
            specular.mapIndex = light.specular.map.index;
        });
    },
    parseOnLoad: function (info, parser) {
        parser.imageBasedLights.forEach(function (light) {
            if (!light.specular) {
                return;
            }
            light.specular.brdfLUT = parser.textures[light.specular.brdfLUTIndex];
            if (light.specular.type == '2D') {
                light.specular.map = parser.textures[light.specular.mapIndex];
            }
            else {
                light.specular.map = parser.cubeTextures[light.specular.mapIndex];
            }
        });
    },
    parseOnEnd: function (info, parser, model) {
        model.imageBasedLights = parser.imageBasedLights;
        return model;
    },
    parse: function (info, parser, entity) {
        // material extension
        var material = entity;
        var lIndex = info.light, type = info.type;
        var light = parser.imageBasedLights[lIndex];
        if (isPBRMaterial(material)) {
            // (material as any).isDiffuesEnvAndAmbientLightWorkTogether = true;
            if (type == 'ALL') {
                material.brdfLUT = light.specular.brdfLUT;
                material.specularEnvIntensity = light.specular.intensity;
                material.specularEnvMap = light.specular.map;
            }
            material.diffuseEnvIntensity = light.diffuse.intensity;
            if (light.diffuse.type == 'SH') {
                material.diffuseEnvSphereHarmonics3 = light.diffuse.coefficients;
            }
        }
        else if (isRawShaderMaterial(material)) {
            /**
             * @todo: support SeinCustomMaterial
             */
            if (type == 'ALL') {
                material.setUniform('u_brdfLUT', light.specular.brdfLUT);
                material.setUniform('u_specularEnvIntensity', light.specular.intensity);
                material.setUniform('u_specularEnvMap', light.specular.map);
            }
            material.setUniform('u_diffuseEnvIntensity', light.diffuse.intensity);
            if (light.diffuse.type == 'SH') {
                material.setUniform('u_diffuseEnvSphereHarmonics3', light.diffuse.coefficients);
            }
        }
        return material;
    }
};
/**
 * @hidden
 */
var SeinAtlasExtension = {
    name: 'Sein_atlas',
    init: function (_, parser) {
        var game = parser.game;
        var actions = [];
        var extensions = parser.json.extensions || {};
        var ex = extensions.Sein_atlas || {};
        var atlasesSource = ex.atlases || [];
        var atlases = [];
        parser.atlases = atlases;
        atlasesSource.forEach(function (atlas, index) {
            atlases.push(null);
            actions.push(Promise.resolve().then(function () { return new Promise(function (resolve, reject) {
                var source = atlas.meta.image.index;
                var uri = parser.getImageUri(source);
                var texture = new LazyTexture();
                texture.uv = undefined;
                texture.crossOrigin = true;
                texture.autoLoad = false;
                texture.resType = parser.getImageType(source);
                texture.src = uri;
                texture.name = atlas.name;
                texture.isImageCanRelease = atlas.isImageCanRelease;
                var OnTextureLoad = function (error) {
                    texture.off('load', OnTextureLoad);
                    texture.off('error', OnTextureLoad);
                    if (error) {
                        return reject(error);
                    }
                    atlases[index] = new AtlasManager({ texture: texture, frames: atlas.frames, meta: atlas.meta }, false);
                    atlases[index].name = new SName(atlas.name);
                    atlases[index].isImageCanRelease = atlas.isImageCanRelease;
                    resolve();
                };
                texture.on('load', function () { return OnTextureLoad(); });
                texture.on('error', function (error) { return OnTextureLoad(error); });
                texture.load(true);
            }); }));
        });
        return Promise.all(actions);
    },
    parseOnEnd: function (info, parser, model) {
        model.atlases = parser.atlases;
        return model;
    }
};
/**
 * @hidden
 *
 * 这里的扩展仅仅是全局用于加载材质脚本的。
 */
var SeinCustomMaterialExtension = {
    name: 'Sein_customMaterial',
    cache: {},
    init: function (_, parser) {
        var actions = [];
        var extensions = parser.json.extensions || {};
        var ex = extensions.Sein_customMaterial || {};
        var scripts = ex.scripts || [];
        parser.scripts = scripts;
        scripts.forEach(function (script, index) {
            var url = script.uri;
            if (SeinCustomMaterialExtension.cache[url]) {
                return;
            }
            SeinCustomMaterialExtension.cache[url] = true;
            url = getRelativePath(parser.src, url);
            actions.push(new Promise(function (resolve, reject) {
                var s = document.createElement('script');
                s.onload = function () { return resolve(); };
                s.onerror = function (error) { return reject(error); };
                s.src = url;
                document.head.append(s);
            }));
        });
        return Promise.all(actions);
    }
};
/**
 * @hidden
 */
var FakeHiloSprite = /** @class */ (function (_super) {
    __extends(FakeHiloSprite, _super);
    function FakeHiloSprite() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.className = 'FakeHiloSprite';
        _this.isFakeHiloSprite = true;
        return _this;
    }
    return FakeHiloSprite;
}(Hilo3d$2.Node));
/**
 * @hidden
 */
var SeinSpriteExtension = {
    name: 'Sein_sprite',
    init: function (_, parser) {
        var extensions = parser.json.extensions || {};
        var ex = extensions.Sein_sprite || {};
        parser.sprites = (ex.sprites || []).map(function (sprite) {
            var res = new FakeHiloSprite();
            res.sprite = sprite;
            return res;
        });
    },
    parseOnEnd: function (info, parser, model) {
        model['sprites'] = parser.sprites;
        parser.sprites.forEach(function (sp) {
            if (sp.sprite.material) {
                sp.material = parser.materials[sp.sprite.material.index];
            }
        });
        return model;
    },
    parse: function (info, parser, entity) {
        var node = entity;
        node.addChild(parser.sprites[info.index]);
        return node;
    }
};
/**
 * @hidden
 */
var SeinSkyboxExtension = {
    name: 'Sein_skybox',
    parse: function (info, parser, entity) {
        var camera = entity;
        var material = new SkyboxMaterial({
            type: info.type,
            uniforms: {
                u_color: { value: new Color().fromArray(info.color) },
                u_factor: { value: info.factor },
                u_texture: info.texture && { value: info.type === 'Panoramic' ? parser.textures[info.texture.index] : parser.cubeTextures[info.texture.index] },
                u_rotation: info.rotation !== undefined && { value: info.rotation },
                u_exposure: info.exposure !== undefined && { value: info.exposure },
                u_degrees: info.degrees !== undefined && { value: info.degrees },
            }
        });
        var globalSetting = parser.renderer;
        if (globalSetting) {
            material.gammaCorrection = globalSetting.gammaCorrection || false;
            material.useHDR = globalSetting.useHDR || false;
            material.exposure = globalSetting.exposure ? material.exposure : globalSetting.exposure;
        }
        camera.backgroundMat = material;
        return camera;
    }
};
/**
 * @hidden
 */
var SeinTextureImproveExtension = {
    name: 'Sein_textureImprove',
    parse: function (info, parser, texture) {
        texture.isImageCanRelease = info.isImageCanRelease;
        texture.anisotropic = info.anisotropic || texture.anisotropic;
        texture.type = info.textureType || texture.type;
        return texture;
    }
};
/**
 * @hidden
 */
function parse(info, parser, material, options) {
    if (options.isGlobalExtension) {
        return null;
    }
    var textures = parser.textures || [];
    var techniqueInfo = parser.techniques[info.technique];
    if (!techniqueInfo) {
        return null;
    }
    var programInfo = parser.programs[techniqueInfo.program];
    if (!programInfo) {
        return null;
    }
    var fragmentText = parser.shaders[programInfo.fragmentShader];
    var vertexText = parser.shaders[programInfo.vertexShader];
    var uniformsInfo = techniqueInfo.uniforms || {};
    var attributesInfo = techniqueInfo.attributes || {};
    var valuesInfo = info.values || {};
    var attributes = {};
    var uniforms = {};
    for (var uniformName in uniformsInfo) {
        var uniformDef = uniformsInfo[uniformName] || {};
        var uniformValue = valuesInfo[uniformName] !== undefined ? valuesInfo[uniformName] : uniformDef.value;
        var uniformObject = void 0;
        if (uniformValue !== undefined) {
            if (uniformDef.type === Constants.SAMPLER_2D) {
                var textureIndex = uniformValue.index || 0;
                uniformObject = { value: textures[textureIndex] };
            }
            else {
                uniformObject = { value: uniformValue };
            }
        }
        else if (uniformDef.semantic && Hilo3d$2.semantic[uniformDef.semantic]) {
            // const semanticFunc = Hilo3d.semantic[uniformDef.semantic];
            // const nodeIndex = uniformDef.node;
            // let node;
            // if (nodeIndex !== undefined) {
            //   uniformObject = {
            //     get(mesh, material, programInfo) {
            //       if (node === undefined) {
            //         node = parser.node.getChildByFn((node) => {
            //           return node.animationId === nodeIndex;
            //         }) || mesh;
            //       }
            //       return semanticFunc.get(node, material, programInfo);
            //     }
            //   };
            // } else {
            //   uniformObject = uniformDef.semantic;
            // }
            uniformObject = uniformDef.semantic;
        }
        else {
            uniformObject = Hilo3d$2.semantic.blankInfo;
        }
        uniforms[uniformName] = uniformObject;
    }
    for (var attributeName in attributesInfo) {
        var attributeValue = attributesInfo[attributeName] || {};
        if (attributeValue.semantic) {
            attributes[attributeName] = attributeValue.semantic;
        }
    }
    var shaderMaterial = new RawShaderMaterial({
        vs: vertexText,
        fs: fragmentText,
        attributes: attributes,
        uniforms: uniforms
    });
    return shaderMaterial;
}
Hilo3d$2.GLTFExtensions.KHR_techniques_webgl.parse = parse;

/**
 * 判断一个实例是否为`SkeletalMesh`。
 */
function isSkeletalMesh(value) {
    return value.isSkeletalMesh;
}
/**
 * 带有骨骼的曲面类。封装几何体`Geometry`和材质`Material`。
 */
var SkeletalMesh = /** @class */ (function (_super) {
    __extends(SkeletalMesh, _super);
    function SkeletalMesh() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isSkeletalMesh = true;
        return _this;
    }
    /**
     * 获取指定类型的材质。
     */
    SkeletalMesh.prototype.getMaterial = function () {
        return this.material;
    };
    /**
     * 克隆。
     */
    SkeletalMesh.prototype.clone = function (isChild) {
        return _super.prototype.clone.call(this, isChild);
    };
    return SkeletalMesh;
}(Hilo3d$2.SkinedMesh));

/**
 * 判断一个实例是否为`SkeletalMeshComponent`。
 */
function isSkeletalMeshComponent(value) {
    return value.isSkeletalMeshComponent;
}
/**
 * 判断一个实例是否为`SkeletalMeshActor`。
 */
function isSkeletalMeshActor(value) {
    return isSceneActor(value) && isSkeletalMeshComponent(value.root);
}
/**
 * 骨架Component类，是拥有骨架的图元组件。
 * 此Component在图元基础之上添加了骨骼动画的能力，拥有骨骼动画的模型实例化后即为此类的实例。
 *
 * @template IStateTypes 初始化参数类型，必须继承自[ISkeletalMeshComponentState](../interfaces/iskeletalmeshcomponentstate)。
 * @noInheritDoc
 */
var SkeletalMeshComponent = /** @class */ (function (_super) {
    __extends(SkeletalMeshComponent, _super);
    function SkeletalMeshComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isSkeletalMeshComponent = true;
        return _this;
    }
    Object.defineProperty(SkeletalMeshComponent.prototype, "skeleton", {
        /**
         * 获取骨架。
         */
        get: function () {
            return this._mesh.skeleton;
        },
        enumerable: false,
        configurable: true
    });
    SkeletalMeshComponent.prototype.onCreateMesh = function (state) {
        return new SkeletalMesh({
            geometry: state ? state.geometry : null,
            material: state ? state.material : null,
            skeleton: state ? state.skeleton : null
        });
    };
    /**
     * 将一个`SkeletalMeshComponent`的骨架赋予到本组件上，通常用于换装。
     */
    SkeletalMeshComponent.prototype.changeSkeleton = function (component) {
        if (this.__multiPrimitive) {
            this._list.forEach(function (m) {
                m.skeleton = component._mesh.skeleton;
            });
        }
        else {
            this._mesh.skeleton = component._mesh.skeleton;
        }
    };
    SkeletalMeshComponent.prototype.changeSkin = function (param) {
        var _this = this;
        if (isMesh(param)) {
            this._list = null;
            this._table = null;
            this.__multiPrimitive = false;
            this._mesh.geometry = param.geometry;
            this._mesh.material = param.material;
            this._node.children = [this._mesh];
            return;
        }
        if (param.length < 2) {
            throwException(new BreakGuardException(this, "meshes which is array must have more than two elements, if one, please use changeSkin(mesh)"), this);
            return;
        }
        var skeleton = this._mesh.skeleton;
        this._node.children = [];
        this._table = {};
        this._list = param.map(function (_a) {
            var geometry = _a.geometry, material = _a.material;
            var mesh = new SkeletalMesh({ geometry: geometry, material: material.cloneForInst ? material.clone() : material, skeleton: skeleton });
            _this._table[material.name] = mesh;
            _this._node.addChild(mesh);
            return mesh;
        });
        this._mesh = this._list[0];
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    SkeletalMeshComponent.prototype.cloneSkinningFromHilo = function (mesh, index) {
        var m = this._mesh;
        if (this.__multiPrimitive) {
            m = this._list[index];
            if (m.material) {
                delete this._table[m.material.name];
            }
        }
        m.skeleton = mesh.skeleton.clone(this.getRoot().hiloNode);
    };
    SkeletalMeshComponent = __decorate([
        SClass({ className: 'SkeletalMeshComponent' })
    ], SkeletalMeshComponent);
    return SkeletalMeshComponent;
}(PrimitiveComponent));

/**
 * [SkeletalMeshComponent](../skeletalmeshcomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var SkeletalMeshActor = /** @class */ (function (_super) {
    __extends(SkeletalMeshActor, _super);
    function SkeletalMeshActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SkeletalMeshActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', SkeletalMeshComponent, options);
    };
    SkeletalMeshActor = __decorate([
        SClass({ className: 'SkeletalMeshActor', classType: 'Primitive' })
    ], SkeletalMeshActor);
    return SkeletalMeshActor;
}(SceneActor));

/**
 * [StaticMeshComponent](../staticmeshcomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var StaticMeshActor = /** @class */ (function (_super) {
    __extends(StaticMeshActor, _super);
    function StaticMeshActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StaticMeshActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', StaticMeshComponent, options);
    };
    StaticMeshActor = __decorate([
        SClass({ className: 'StaticMeshActor' })
    ], StaticMeshActor);
    return StaticMeshActor;
}(SceneActor));

/**
 * [OrthographicCameraComponent](../orthographiccameracomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var OrthographicCameraActor = /** @class */ (function (_super) {
    __extends(OrthographicCameraActor, _super);
    function OrthographicCameraActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(OrthographicCameraActor.prototype, "camera", {
        get: function () {
            return this._root;
        },
        enumerable: false,
        configurable: true
    });
    OrthographicCameraActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', OrthographicCameraComponent, options);
    };
    OrthographicCameraActor = __decorate([
        SClass({ className: 'OrthographicCameraActor' })
    ], OrthographicCameraActor);
    return OrthographicCameraActor;
}(SceneActor));

/**
 * [PerspectiveCameraComponent](../perspectivecameracomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var PerspectiveCameraActor = /** @class */ (function (_super) {
    __extends(PerspectiveCameraActor, _super);
    function PerspectiveCameraActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PerspectiveCameraActor.prototype, "camera", {
        get: function () {
            return this._root;
        },
        enumerable: false,
        configurable: true
    });
    PerspectiveCameraActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', PerspectiveCameraComponent, options);
    };
    PerspectiveCameraActor = __decorate([
        SClass({ className: 'PerspectiveCameraActor' })
    ], PerspectiveCameraActor);
    return PerspectiveCameraActor;
}(SceneActor));

/**
 * 判断一个实例是否为`LightComponent`。
 */
function isLightComponent(value) {
    return value.isLightComponent;
}
/**
 * 判断一个实例是否为`AmbientLightActor`。
 */
function isLightActor(value) {
    return isSceneActor(value) && isLightComponent(value.root);
}
/**
 * 环境光组件。
 *
 * @noInheritDoc
 */
var LightComponent = /** @class */ (function (_super) {
    __extends(LightComponent, _super);
    function LightComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isLightComponent = true;
        _this.needUpdateAndDestroy = false;
        return _this;
    }
    LightComponent.prototype.onCreateLight = function (options) {
        throw new Error('Not Implement !');
    };
    /**
     * 初始化，继承请先`super.onInit()`。
     */
    LightComponent.prototype.onInit = function (options) {
        _super.prototype.onInit.call(this, options);
        this._light = this.onCreateLight(options);
        this._light.__forceUseParentWorldMatrix = true;
        this._node.addChild(this._light);
    };
    Object.defineProperty(LightComponent.prototype, "amount", {
        /**
         * 获取光照强度。
         */
        get: function () {
            return this._light.amount;
        },
        /**
         * 设置光照强度。
         */
        set: function (value) {
            this._light.amount = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightComponent.prototype, "color", {
        /**
         * 获取光照颜色。
         */
        get: function () {
            return this._light.color;
        },
        /**
         * 设置光照颜色。
         */
        set: function (value) {
            this._light.color.copy(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LightComponent.prototype, "shadow", {
        /**
         * 获取阴影参数。
         */
        get: function () {
            return this._light.shadow;
        },
        /**
         * 设置阴影参数。
         */
        set: function (value) {
            this._light.shadow = value;
        },
        enumerable: false,
        configurable: true
    });
    LightComponent = __decorate([
        SClass({ className: 'LightComponent' })
    ], LightComponent);
    return LightComponent;
}(SceneComponent));

/**
 * 判断一个实例是否为`AmbientLightComponent`。
 */
function isAmbientLightComponent(value) {
    return value.isAmbientLightComponent;
}
/**
 * 判断一个实例是否为`AmbientLightActor`。
 */
function isAmbientLightActor(value) {
    return isSceneActor(value) && isAmbientLightComponent(value.root);
}
/**
 * 环境光组件。
 *
 * @noInheritDoc
 */
var AmbientLightComponent = /** @class */ (function (_super) {
    __extends(AmbientLightComponent, _super);
    function AmbientLightComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isAmbientLightComponent = true;
        _this.needUpdateAndDestroy = false;
        return _this;
    }
    AmbientLightComponent.prototype.onCreateLight = function (options) {
        return new Hilo3d$2.AmbientLight(options);
    };
    AmbientLightComponent = __decorate([
        SClass({ className: 'AmbientLightComponent' })
    ], AmbientLightComponent);
    return AmbientLightComponent;
}(LightComponent));

/**
 * [AmbientLightComponent](../ambientlightcomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var AmbientLightActor = /** @class */ (function (_super) {
    __extends(AmbientLightActor, _super);
    function AmbientLightActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AmbientLightActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', AmbientLightComponent, options);
    };
    AmbientLightActor = __decorate([
        SClass({ className: 'AmbientLightActor' })
    ], AmbientLightActor);
    return AmbientLightActor;
}(SceneActor));

/**
 * 判断一个实例是否为`DirectionalLightComponent`。
 */
function isDirectionalLightComponent(value) {
    return value.isDirectionalLightComponent;
}
/**
 * 判断一个实例是否为`DirectionalLightActor`。
 */
function isDirectionalLightActor(value) {
    return isSceneActor(value) && isDirectionalLightComponent(value.root);
}
/**
 * 平行光组件。
 *
 * @noInheritDoc
 */
var DirectionalLightComponent = /** @class */ (function (_super) {
    __extends(DirectionalLightComponent, _super);
    function DirectionalLightComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isDirectionalLightComponent = true;
        _this.needUpdateAndDestroy = false;
        return _this;
    }
    DirectionalLightComponent.prototype.onCreateLight = function (options) {
        return new Hilo3d$2.DirectionalLight(options);
    };
    Object.defineProperty(DirectionalLightComponent.prototype, "direction", {
        /**
         * 获取光照方向。
         */
        get: function () {
            return this._light.direction;
        },
        /**
         * 设置光照方向。
         */
        set: function (value) {
            this._light.direction.copy(value);
        },
        enumerable: false,
        configurable: true
    });
    DirectionalLightComponent = __decorate([
        SClass({ className: 'DirectionalLightComponent' })
    ], DirectionalLightComponent);
    return DirectionalLightComponent;
}(LightComponent));

/**
 * [DirectionalLightComponent](../directionallightcomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var DirectionalLightActor = /** @class */ (function (_super) {
    __extends(DirectionalLightActor, _super);
    function DirectionalLightActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DirectionalLightActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', DirectionalLightComponent, options);
    };
    DirectionalLightActor = __decorate([
        SClass({ className: 'DirectionalLightActor' })
    ], DirectionalLightActor);
    return DirectionalLightActor;
}(SceneActor));

/**
 * 判断一个实例是否为`PointLightComponent`。
 */
function isPointLightComponent(value) {
    return value.isPointLightComponent;
}
/**
 * 判断一个实例是否为`PointLightActor`。
 */
function isPointLightActor(value) {
    return isSceneActor(value) && isPointLightComponent(value.root);
}
var PointLightComponent = /** @class */ (function (_super) {
    __extends(PointLightComponent, _super);
    function PointLightComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isPointLightComponent = true;
        _this.needUpdateAndDestroy = false;
        return _this;
    }
    PointLightComponent.prototype.onCreateLight = function (options) {
        return new Hilo3d$2.PointLight(options);
    };
    Object.defineProperty(PointLightComponent.prototype, "range", {
        /**
         * 获取光照范围。
         */
        get: function () {
            return this._light.range;
        },
        /**
         * 设置光照范围。
         */
        set: function (value) {
            this._light.range = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PointLightComponent.prototype, "constantAttenuation", {
        /**
         * 获取固定衰减系数。
         */
        get: function () {
            return this._light.constantAttenuation;
        },
        /**
         * 设置固定衰减系数。
         */
        set: function (value) {
            this._light.constantAttenuation = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PointLightComponent.prototype, "linearAttenuation", {
        /**
         * 获取线性衰减系数。
         */
        get: function () {
            return this._light.linearAttenuation;
        },
        /**
         * 设置线性衰减系数。
         */
        set: function (value) {
            this._light.linearAttenuation = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PointLightComponent.prototype, "quadraticAttenuation", {
        /**
         * 获取二次衰减系数。
         */
        get: function () {
            return this._light.quadraticAttenuation;
        },
        /**
         * 设置二次衰减系数。
         */
        set: function (value) {
            this._light.quadraticAttenuation = value;
        },
        enumerable: false,
        configurable: true
    });
    PointLightComponent = __decorate([
        SClass({ className: 'PointLightComponent' })
    ], PointLightComponent);
    return PointLightComponent;
}(LightComponent));

/**
 * [PointLightComponent](../pointlightcomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var PointLightActor = /** @class */ (function (_super) {
    __extends(PointLightActor, _super);
    function PointLightActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PointLightActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', PointLightComponent, options);
    };
    PointLightActor = __decorate([
        SClass({ className: 'PointLightActor' })
    ], PointLightActor);
    return PointLightActor;
}(SceneActor));

/**
 * 判断一个实例是否为`SpotLightComponent`。
 */
function isSpotLightComponent(value) {
    return value.isSpotLightComponent;
}
/**
 * 判断一个实例是否为`SpotLightActor`。
 */
function isSpotLightActor(value) {
    return isSceneActor(value) && isSpotLightComponent(value.root);
}
var SpotLightComponent = /** @class */ (function (_super) {
    __extends(SpotLightComponent, _super);
    function SpotLightComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isLightComponent = true;
        _this.isSpotLightComponent = true;
        _this.needUpdateAndDestroy = false;
        return _this;
    }
    SpotLightComponent.prototype.onCreateLight = function (options) {
        return new Hilo3d$2.SpotLight(options);
    };
    Object.defineProperty(SpotLightComponent.prototype, "direction", {
        /**
         * 获取光照方向。
         */
        get: function () {
            return this._light.direction;
        },
        /**
         * 设置光照方向。
         */
        set: function (value) {
            this._light.direction.copy(value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpotLightComponent.prototype, "range", {
        /**
         * 获取光照范围。
         */
        get: function () {
            return this._light.range;
        },
        /**
         * 设置光照范围。
         */
        set: function (value) {
            this._light.range = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpotLightComponent.prototype, "cutoff", {
        /**
         * 获取内裁剪范围。
         */
        get: function () {
            return this._light.cutoff;
        },
        /**
         * 设置内裁剪范围。
         */
        set: function (value) {
            this._light.cutoff = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpotLightComponent.prototype, "outerCutoff", {
        /**
         * 获取外裁剪范围。
         */
        get: function () {
            return this._light.outerCutoff;
        },
        /**
         * 设置外裁剪范围。
         */
        set: function (value) {
            this._light.outerCutoff = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpotLightComponent.prototype, "constantAttenuation", {
        /**
         * 获取固定衰减系数。
         */
        get: function () {
            return this._light.constantAttenuation;
        },
        /**
         * 设置固定衰减系数。
         */
        set: function (value) {
            this._light.constantAttenuation = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpotLightComponent.prototype, "linearAttenuation", {
        /**
         * 获取线性衰减系数。
         */
        get: function () {
            return this._light.linearAttenuation;
        },
        /**
         * 设置线性衰减系数。
         */
        set: function (value) {
            this._light.linearAttenuation = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpotLightComponent.prototype, "quadraticAttenuation", {
        /**
         * 获取二次衰减系数。
         */
        get: function () {
            return this._light.quadraticAttenuation;
        },
        /**
         * 设置二次衰减系数。
         */
        set: function (value) {
            this._light.quadraticAttenuation = value;
        },
        enumerable: false,
        configurable: true
    });
    SpotLightComponent = __decorate([
        SClass({ className: 'SpotLightComponent' })
    ], SpotLightComponent);
    return SpotLightComponent;
}(LightComponent));

/**
 * [SpotLightComponent](../spotlightcomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var SpotLightActor = /** @class */ (function (_super) {
    __extends(SpotLightActor, _super);
    function SpotLightActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SpotLightActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', SpotLightComponent, options);
    };
    SpotLightActor = __decorate([
        SClass({ className: 'SpotLightActor' })
    ], SpotLightActor);
    return SpotLightActor;
}(SceneActor));

/**
 * 判断一个实例是否为`Animation`。
 */
function isAnimation(value) {
    return value.isAnimation;
}
/**
 * @hidden
 */
function nop() { }
/**
 * 动画基类，作为动画组件的组成基本单元。
 * 一般不直接使用，而是使用各个派生类。
 *
 * @noInheritDoc
 */
var Animation = /** @class */ (function (_super) {
    __extends(Animation, _super);
    function Animation(initState) {
        var _this = _super.call(this) || this;
        _this.isAnimation = true;
        _this.animator = null;
        /**
         * 播放速度，具体交由每个动画自行实现。
         */
        _this.speed = 1;
        /**
         * 播放开始时的回调，一般不需要自己使用。
         */
        _this.handleStart = nop;
        /**
         * 播放结束后的回调，**作为终止行为，请在动画结束时自行调用！**。
         */
        _this.handleEnd = nop;
        /**
         * 播放暂停时的回调，一般不需要自己使用。。
         */
        _this.handlePause = nop;
        /**
         * 播放唤醒时的回调，一般不需要自己使用。。
         */
        _this.handleResume = nop;
        _this._initState = null;
        _this._paused = true;
        initState.speed = initState.speed || 1;
        _this.speed = initState.speed;
        _this._initState = initState;
        return _this;
    }
    Object.defineProperty(Animation.prototype, "parent", {
        /**
         * 获取自身的父级动画组件实例引用，一般不需要自己使用。
         */
        get: function () {
            return this.animator;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "actor", {
        /**
         * 获取自身的父级动画组件的Onwer实例引用。
         */
        get: function () {
            return this.animator.getOwner();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "fsm", {
        /**
         * 获取自身动画组件的状态机实例引用。
         */
        get: function () {
            return this.animator.fsm;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "currentTime", {
        /**
         * 获取当前播放时间。
         */
        get: function () {
            throw new Error('Not implemented !');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "duration", {
        /**
         * 获取当前播放总时长。
         */
        get: function () {
            throw new Error('Not implemented !');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "paused", {
        /**
         * 获取当前是否处于暂停状态。
         */
        get: function () {
            return this._paused;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取当前`Game`实例。
     *
     * @template IGameState 当前游戏状态管理器的类型。
     */
    Animation.prototype.getGame = function () {
        return this.actor.getGame();
    };
    /**
     * 获取当前`World`实例。
     *
     * @template IWorldState 当前世界状态管理器的类型。
     */
    Animation.prototype.getWorld = function () {
        return this.actor.getWorld();
    };
    /**
     * 获取当前`Level`实例。
     *
     * @template ILevelState 当前关卡状态管理器的类型。
     */
    Animation.prototype.getLevel = function () {
        return this.actor.getLevel();
    };
    /**
     * 生命周期，将在初始化时触发，你可以重写此方法来实现自定义动画。
     */
    Animation.prototype.onInit = function (initState) {
    };
    /**
     * 生命周期，将在`play`时触发，你可以重写此方法来实现自定义动画。
     *
     * @param loopCount 当前循环次数
     */
    Animation.prototype.onPlay = function (loopCount) {
    };
    /**
     * 生命周期，将在`pause`时触发，你可以重写此方法来实现自定义动画。
     */
    Animation.prototype.onPause = function () {
    };
    /**
     * 生命周期，将在`resume`时触发，你可以重写此方法来实现自定义动画。
     */
    Animation.prototype.onResume = function () {
    };
    /**
     * 生命周期，将在`stop`时触发，你可以重写此方法来实现自定义动画。
     */
    Animation.prototype.onStop = function () {
    };
    /**
     * 生命周期，将在每一帧`update`时触发，你可以重写此方法来实现自定义动画。
     */
    Animation.prototype.onUpdate = function (delta) {
    };
    /**
     * 生命周期，用于错误边界处理。将在游戏中大部分可预知错误发生时被调用（通常是生命周期中的非异步错误）。
     * 错误将会根据一定的路径向上传递，一直到`Engine`的层次，你可以在确保完美处理了问题后返回`true`来通知引擎不再向上传递。
     * 当然你也可以将自定义的一些错误加入错误边界机制中，详见[Exception](../../guide/exception)。
     */
    Animation.prototype.onError = function (error, details) {
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Animation.prototype.initialize = function () {
        try {
            this.onInit(this._initState);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Animation.prototype.play = function (loopCount) {
        this._paused = false;
        try {
            this.onPlay(loopCount);
            this.handleStart(this, this.actor);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Animation.prototype.pause = function () {
        this._paused = true;
        try {
            this.onPause();
            this.handlePause(this, this.actor);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Animation.prototype.resume = function () {
        this._paused = false;
        try {
            this.onResume();
            this.handleResume(this, this.actor);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Animation.prototype.stop = function () {
        this._paused = true;
        try {
            this.onStop();
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Animation.prototype.update = function (delta) {
        try {
            this.onUpdate(delta);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    Animation = __decorate([
        SClass({ className: 'Animation', classType: 'Animation' })
    ], Animation);
    return Animation;
}(SObject));

/**
 * 判断一个实例是否为`ModelAnimation`。
 */
function isModelAnimation(value) {
    return value.isModelAnimation;
}
/**
 * 模型动画类，用于存储模型动画。
 * 一般在模型实例化时已经自动生成，不需要自己初始化。
 *
 * @noInheritDoc
 */
var ModelAnimation = /** @class */ (function (_super) {
    __extends(ModelAnimation, _super);
    function ModelAnimation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isModelAnimation = true;
        _this._startTime = 0;
        _this._endTime = 0;
        _this._duration = 0;
        _this._currentEndHandler = function () { };
        return _this;
    }
    Object.defineProperty(ModelAnimation.prototype, "duration", {
        /**
         * 获取当前播放总时长。
         */
        get: function () {
            return this._duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ModelAnimation.prototype, "currentTime", {
        /**
         * 获取当前播放时间。
         */
        get: function () {
            return this._anim.currentTime;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ModelAnimation.prototype, "paused", {
        /**
         * 获取当前是否处于暂停状态。
         */
        get: function () {
            return this._anim.paused;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    ModelAnimation.prototype.onInit = function (initState) {
        var component = this.actor.findComponentByName(initState.componentName)
            || this.actor.root;
        var animation = component.hiloNode.anim;
        if (!animation) {
            throw new BreakGuardException(this, "Model of " + component.name + "->" + this.actor.name + " has no animations !");
        }
        var clip = animation.clips[initState.clipName];
        if (!clip) {
            throw new BreakGuardException(this, "Clip " + this.className + " is not existed in model of " + component.name + "->" + this.actor.name + " !");
        }
        this._anim = animation;
        this._clipName = initState.clipName;
        this._anim.loop = 0;
        var info = this._anim.getAnimStatesListTimeInfo(clip.animStatesList);
        this._duration = info.endTime - info.startTime;
    };
    /**
     * @hidden
     */
    ModelAnimation.prototype.onPlay = function (loopCount) {
        var _this = this;
        // this callback may be re-registered before it was removed, so we must use lambda function to avoid it
        this._currentEndHandler = function () { return _this.handleEnd(_this, _this.actor); };
        this._anim.on('end', this._currentEndHandler, true);
        this._anim.play(this._clipName);
    };
    /**
     * @hidden
     */
    ModelAnimation.prototype.onPause = function () {
        this._anim.off('end', this._currentEndHandler);
        this._anim.pause();
    };
    /**
     * @hidden
     */
    ModelAnimation.prototype.onResume = function () {
        this._anim.on('end', this._currentEndHandler, true);
        this._anim.resume();
    };
    /**
     * @hidden
     */
    ModelAnimation.prototype.onStop = function () {
        this._anim.off('end', this._currentEndHandler);
        this._currentEndHandler = function () { };
        this._anim.stop();
    };
    /**
     * @hidden
     */
    ModelAnimation.prototype.onUpdate = function (delta) {
        if (!this.paused) {
            this._anim.tick(delta);
        }
    };
    ModelAnimation = __decorate([
        SClass({ className: 'ModelAnimation' })
    ], ModelAnimation);
    return ModelAnimation;
}(Animation));

/**
 * 判断一个实例是否为`FSMState`。
 */
function isFSMState(value) {
    return value.isFSMState;
}
/**
 * 状态机的状态类，用于存储状态以及行为。
 *
 * @noInheritDoc
 */
var FSMState = /** @class */ (function (_super) {
    __extends(FSMState, _super);
    function FSMState(name, options, parent) {
        var _this = _super.call(this, name) || this;
        _this.isFSMState = true;
        _this._fsm = parent;
        _this.onEnter = options.onEnter;
        _this.onUpdate = options.onUpdate;
        _this.onExit = options.onExit;
        _this.actions = {};
        _this.next = {};
        return _this;
    }
    Object.defineProperty(FSMState.prototype, "fsm", {
        /**
         * 获取父级状态机。
         */
        get: function () {
            return this._fsm;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 进入此状态，将会触发对应回调。
     */
    FSMState.prototype.enter = function () {
        if (this.onEnter) {
            this.onEnter(this);
        }
    };
    /**
     * 每一帧更新，将会触发对应回调。
     */
    FSMState.prototype.update = function (delta) {
        if (this.onUpdate) {
            this.onUpdate(delta, this);
        }
    };
    /**
     * 退出此状态，将会触发对应回调。
     */
    FSMState.prototype.exit = function () {
        if (this.onExit) {
            this.onExit(this);
        }
    };
    FSMState = __decorate([
        SClass({ className: 'FSMState', classType: 'FSMState' })
    ], FSMState);
    return FSMState;
}(SObject));

/**
 * 判断一个实例是否为`FSMComponent`。
 */
function isFSMComponent(value) {
    return value.isFSMComponent;
}
function isArray(value) {
    return !!value.push;
}
/**
 * 有限状态机组件类，一种通用的游戏逻辑编程模型。
 * 默认拥有`enter`和`exit`两个状态。
 *
 * @noInheritDoc
 */
var FSMComponent = /** @class */ (function (_super) {
    __extends(FSMComponent, _super);
    /**
     * @hidden
     */
    function FSMComponent(name) {
        var _this = _super.call(this, name, null) || this;
        _this.isFSMComponent = true;
        /**
         * 退出一个状态时的回调。
         */
        _this.onExit = new Observable();
        _this._states = {};
        _this._current = 'enter';
        _this._default = null;
        _this.handleExit = function () {
            _this.dispatch('reset');
            if (_this.onExit) {
                _this.onExit.parent = _this;
                _this.onExit.notify(_this);
            }
        };
        _this.addState('enter');
        _this.addState('exit', { onEnter: _this.handleExit });
        _this.addTransition('reset', 'exit', 'enter');
        return _this;
    }
    Object.defineProperty(FSMComponent.prototype, "defaultState", {
        /**
         * 获取默认状态名称。
         */
        get: function () {
            return this._default;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FSMComponent.prototype, "current", {
        /**
         * 获取当前状态名称。
         */
        get: function () {
            return this._current;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FSMComponent.prototype, "currentState", {
        /**
         * 获取当前状态实例引用。
         */
        get: function () {
            return this._states[this._current];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FSMComponent.prototype, "parent", {
        /**
         * 获取父级实例引用。
         */
        get: function () {
            return this._parent || this._owner;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取当前状态实例引用。
     */
    FSMComponent.prototype.getCurrentState = function () {
        return this._states[this._current];
    };
    /**
     * 通过名字获取状态实例引用。
     */
    FSMComponent.prototype.getState = function (name) {
        return this._states[name];
    };
    /**
     * 添加一个实例。
     *
     * @param isDefault 是否为默认状态
     */
    FSMComponent.prototype.addState = function (name, options, isDefault) {
        if (options === void 0) { options = {}; }
        if (isDefault === void 0) { isDefault = false; }
        if (this._states[name]) {
            throw new MemberConflictException(this, 'State', name, this);
        }
        this._states[name] = new FSMState(name, options, this);
        if (isDefault) {
            this.setDefault(name);
        }
        return this;
    };
    /**
     * 修改默认状态。
     */
    FSMComponent.prototype.setDefault = function (name) {
        this._default = name;
        this.addTransition('enter', 'enter', name);
        return this;
    };
    /**
     * 判断是否拥有某个状态。
     */
    FSMComponent.prototype.has = function (name) {
        return !!this._states[name];
    };
    /**
     * 移除一个状态。
     */
    FSMComponent.prototype.removeState = function (name) {
        var state = this._states[name];
        if (!state) {
            return;
        }
        delete this._states[name];
        return this;
    };
    /**
     * 重置状态机到`enter`状态。
     */
    FSMComponent.prototype.reset = function () {
        this._current = 'enter';
        return this;
    };
    /**
     * 添加一个一对一或一对多的转换。
     */
    FSMComponent.prototype.addTransition = function (action, from, to) {
        var _this = this;
        var toState = this._states[to];
        if (!toState) {
            throwException(new MissingMemberException(this, 'State', to, this), this);
        }
        if (!isArray(from)) {
            from = [from];
        }
        from.forEach(function (fromName) {
            var fromState = _this._states[fromName];
            if (!fromState) {
                throwException(new MissingMemberException(_this, 'State', fromName, _this), _this);
            }
            if (fromState.next[to]) {
                throwException(new MemberConflictException(_this, 'State', fromName, _this), _this);
            }
            fromState.next[to] = action;
            fromState.actions[action] = to;
        });
        return this;
    };
    FSMComponent.prototype.removeTransition = function (from, to) {
        var _this = this;
        if (!isArray(from) && !isArray(to)) {
            this.removeOneTransition(from, to);
        }
        if (isArray(from) && !isArray(to)) {
            from.forEach(function (name) { return _this.removeOneTransition(name, to); });
        }
        if (isArray(to) && !isArray(from)) {
            to.forEach(function (name) { return _this.removeOneTransition(from, name); });
        }
        return this;
    };
    FSMComponent.prototype.removeOneTransition = function (from, to) {
        var fromState = this._states[from];
        if (!fromState || !fromState.next[to]) {
            return;
        }
        var action = fromState.next[to];
        delete fromState.next[to];
        delete fromState.actions[action];
        return this;
    };
    /**
     * 添加多对转换。
     */
    FSMComponent.prototype.addTransitions = function (options) {
        var _this = this;
        options.forEach(function (option) { return _this.addTransition(option.action, option.from, option.to); });
        return this;
    };
    /**
     * 移除多对转换。
     */
    FSMComponent.prototype.removeTransitions = function (options) {
        var _this = this;
        options.forEach(function (option) { return _this.removeTransition(option.from, option.to); });
        return this;
    };
    /**
     * 判断是否拥有某对转换。
     */
    FSMComponent.prototype.hasTransition = function (from, action) {
        var state = this._states[from];
        if (!state) {
            return false;
        }
        return !!state.actions[action];
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    FSMComponent.prototype.enter = function () {
        this.dispatch('enter');
    };
    /**
     * 每一帧更新，继承请先`super.onUpdate()`。
     */
    FSMComponent.prototype.onUpdate = function (delta) {
        if (!this._current) {
            return;
        }
        var state = this._states[this._current];
        if (state) {
            state.update(delta);
        }
    };
    /**
     * 执行某个动作`action`，触发转换。
     */
    FSMComponent.prototype.dispatch = function (action) {
        if (!this._current || !this._states[this._current]) {
            throwException(new Error("State \"" + this._current + "\" does not in this fsm now: \"" + this.name + "\"!"), this);
        }
        var currentState = this._states[this._current];
        currentState.exit();
        var nextName = currentState.actions[action];
        if (!nextName || !this._states[nextName]) {
            throwException(new Error("FromState \"" + this._current + "\" does not have action \"" + action + "\"!"), this);
        }
        this._current = nextName;
        this._states[nextName].enter();
        return this;
    };
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    FSMComponent.prototype.onDestroy = function () {
        this.reset();
    };
    FSMComponent = __decorate([
        SClass({ className: 'FSMComponent' })
    ], FSMComponent);
    return FSMComponent;
}(Component));

/**
 * 判断一个实例是否为`AnimatorComponent`。
 */
function isAnimatorComponent(value) {
    return value.isAnimatorComponent;
}
/**
 * 动画组件类，管理着一个Actor下的所有动画。
 * **当挂载到Actor后，你可以直接通过`actor.animator`来访问它。**
 *
 * @template IParameters 用于指定动画状态机参数的类型。
 * @noInheritDoc
 */
var AnimatorComponent = /** @class */ (function (_super) {
    __extends(AnimatorComponent, _super);
    function AnimatorComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isAnimatorComponent = true;
        _this._fsm = new FSMComponent('fsm');
        _this._loop = 0;
        _this._animations = {};
        _this._transitions = {};
        _this._parameters = {};
        _this.handleElementEnd = function (animation) {
            var from = animation.name.value;
            if (!_this._transitions[from]) {
                _this._fsm.dispatch('exit');
                return;
            }
            var _a = _this._transitions[from], conditions = _a.conditions, length = _a.length, array = _a.array;
            for (var index = 0; index < length; index += 1) {
                var to = array[index];
                if (conditions[to](_this._parameters)) {
                    _this._fsm.dispatch(to);
                    return;
                }
            }
            _this._fsm.dispatch('exit');
        };
        _this.handleEnd = function () {
            if (!_this._loop || _this._loop <= 0) {
                _this._event.trigger('End', { name: _this.current, animation: _this._currentAnimation, actor: _this._owner });
                _this._currentAnimation = null;
                return;
            }
            _this._event.trigger('Loop', { animation: _this._currentAnimation, name: _this._current, actor: _this._owner });
            _this._fsm.dispatch(_this._current);
            _this._loop -= 1;
        };
        return _this;
    }
    Object.defineProperty(AnimatorComponent.prototype, "event", {
        /**
         * AnimatorComponent的事件管理器。
         *
         * ```ts
         * EventManager<{
         *  Start: IAnimatorEvent;
         *  Pause: IAnimatorEvent;
         *  Resume: IAnimatorEvent;
         *  Loop: IAnimatorEvent;
         *  End: IAnimatorEvent;
         * }>
         * ```
         *
         * [IAnimatorEvent](../interfaces/ianimatorevent)
         */
        get: function () {
            return this._event;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorComponent.prototype, "current", {
        /**
         * 获取当前播放的动画名称。
         */
        get: function () {
            return this._current;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorComponent.prototype, "fsm", {
        /**
         * 获取状态机实例引用。
         */
        get: function () {
            return this._fsm;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorComponent.prototype, "parameters", {
        /**
         * 获取当前的状态机控制参数引用。
         */
        get: function () {
            return this._parameters;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AnimatorComponent.prototype, "animationNames", {
        get: function () {
            return Object.keys(this._fsm.getState('enter').next);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化，继承请先`super.onInit()`。
     */
    AnimatorComponent.prototype.onInit = function () {
        this._event.register('Start');
        this._event.register('Pause');
        this._event.register('Resume');
        this._event.register('Loop');
        this._event.register('End');
        this._fsm._parent = this;
        this._fsm.onExit.add(this.handleEnd);
    };
    /**
     * 添加到世界，继承请先`super.onAdd()`。
     */
    AnimatorComponent.prototype.onAdd = function (initState) {
        this.initFromComponent(initState.componentName);
        // fixme: hack for performance
        this._owner._animator = this;
    };
    /**
     * 修改状态参数的值。
     */
    AnimatorComponent.prototype.setParameter = function (key, value) {
        this._parameters[key] = value;
        return this;
    };
    /**
     * 获取状态参数的值。
     */
    AnimatorComponent.prototype.getParameter = function (key) {
        return this._parameters[key];
    };
    /**
     * 通过名字获取动画实例引用。
     */
    AnimatorComponent.prototype.getAnimation = function (name) {
        if (!this._animations[name]) {
            Debug.warn("Animation " + name + " is not existed in " + (this._owner && this._owner.name));
        }
        return this._animations[name];
    };
    /**
     * 通过组件名称添加其下的所有动画。
     */
    AnimatorComponent.prototype.initFromComponent = function (name) {
        var _this = this;
        if (name === void 0) { name = 'root'; }
        var component = this._owner.findComponentByName(name);
        if (!component.hiloNode.anim) {
            return;
        }
        var oldPrefix = this._owner.name.value + '@';
        var clips = component.hiloNode.anim.clips;
        Object.keys(clips).forEach(function (clipName) {
            _this.register(clipName.replace(oldPrefix, ''), new ModelAnimation({ componentName: name, clipName: clipName }));
        });
    };
    /**
     * 每一帧更新，继承请先`super.onUpdate()`。
     */
    AnimatorComponent.prototype.onUpdate = function (delta) {
        this._fsm.update(delta);
    };
    AnimatorComponent.prototype.onUnLink = function () {
        this.stop();
    };
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    AnimatorComponent.prototype.onDestroy = function () {
        if (this._currentAnimation && !this._currentAnimation.paused) {
            this._currentAnimation.pause();
        }
        if (this._owner.animator === this) {
            this._owner._animator = null;
        }
        this._fsm.reset();
        this._animations = {};
    };
    /**
     * 注册一个动画为一个名称，通过`isDefault`指定其是否为默认动画。
     */
    AnimatorComponent.prototype.register = function (name, animation, isDefault) {
        var _this = this;
        if (isDefault === void 0) { isDefault = false; }
        if (isDefault || !this._default) {
            this._default = name;
        }
        animation.name = new SName(name);
        animation.animator = this;
        animation.handleEnd = this.handleElementEnd;
        animation.handlePause = function () { return _this._event.trigger('Pause', { animation: animation, name: _this._current, actor: _this._owner }); };
        animation.handleResume = function () { return _this._event.trigger('Resume', { animation: animation, name: _this._current, actor: _this._owner }); };
        this._fsm.addState(name, {
            onEnter: function () {
                _this._currentAnimation = animation;
                animation.play(_this._loop);
            },
            onUpdate: function (delta) { return animation.update(delta); }
        });
        this.addTransition('enter', name, function () { return true; });
        this._fsm.addTransition('exit', name, 'exit');
        this._animations[name] = animation;
        animation.initialize();
        return this;
    };
    /**
     * 取消注册一个动画。
     */
    AnimatorComponent.prototype.unregister = function (name) {
        this._fsm.removeState(name);
        this._fsm.removeTransition('enter', name);
        if (this._animations[name]) {
            this._animations[name].destroy();
            delete this._animations[name];
        }
        return this;
    };
    /**
     * 设置默认的动画。
     */
    AnimatorComponent.prototype.setDefault = function (name) {
        this._default = name;
    };
    /**
     * 添加一个动画到另一个动画的链接。
     *
     * @param condition 通过当前状态参数决定此刻是否要执行这个转换，用于当一个动画拥有多个下一步的指向时。
     */
    AnimatorComponent.prototype.addTransition = function (from, to, condition) {
        this._fsm.addTransition(to, from, to);
        this._transitions[from] = this._transitions[from] || { conditions: {}, array: [], length: 0 };
        this._transitions[from].conditions[to] = condition || (function () { return true; });
        this._transitions[from].array.push(to);
        this._transitions[from].length += 1;
        return this;
    };
    /**
     * 修改一个动画到下一个动画的转换判定函数。
     */
    AnimatorComponent.prototype.setTransitionCondition = function (from, to, condition) {
        this._transitions[from].conditions[to] = condition;
        return this;
    };
    /**
     * 移除一个转换。
     */
    AnimatorComponent.prototype.removeTransition = function (from, to) {
        this._fsm.removeTransition(from, to);
        if (!this._transitions[from].conditions[to]) {
            return this;
        }
        delete this._transitions[from].conditions[to];
        var index = this._transitions[from].array.indexOf(to);
        this._transitions[from].array.splice(index, 1);
        this._transitions[from].length -= 1;
        return this;
    };
    /**
     * 清空所有动画。
     */
    AnimatorComponent.prototype.clear = function () {
        this.stop();
        this._fsm = new FSMComponent('fsm');
        return this;
    };
    /**
     * 判定一个动画是否已被注册。
     */
    AnimatorComponent.prototype.has = function (name) {
        return this._fsm.hasTransition('enter', name);
    };
    /**
     * 播放某个动画，不指定`name`将播放默认动画。`loop`用于指定循环次数。
     */
    AnimatorComponent.prototype.play = function (name, loop) {
        if (!this._fsm.getCurrentState().name.equalsTo('enter')) {
            this.stop();
        }
        name = name || this._default;
        if (!name) {
            return this;
        }
        this._loop = loop || 0;
        this._current = name;
        this._fsm.dispatch(name);
        this._event.trigger('Start', { animation: this._currentAnimation, name: this._current, actor: this._owner });
        return this;
    };
    /**
     * 暂停动画播放。
     */
    AnimatorComponent.prototype.pause = function () {
        this._currentAnimation.pause();
        return this;
    };
    /**
     * 唤醒动画播放。
     */
    AnimatorComponent.prototype.resume = function () {
        this._currentAnimation.resume();
        return this;
    };
    /**
     * 停止动画播放。
     */
    AnimatorComponent.prototype.stop = function () {
        if (this._currentAnimation && !this._currentAnimation.paused) {
            this._currentAnimation.stop();
        }
        this._loop = 0;
        this._fsm.reset();
        this.handleEnd();
        return this;
    };
    AnimatorComponent = __decorate([
        SClass({ className: 'AnimatorComponent' })
    ], AnimatorComponent);
    return AnimatorComponent;
}(Component));

/**
 * 判断一个实例是否为`MorphGeometry`。
 */
function isMorphGeometry(value) {
    return value.isMorphGeometry;
}
var MorphGeometry = /** @class */ (function (_super) {
    __extends(MorphGeometry, _super);
    function MorphGeometry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return MorphGeometry;
}(Hilo3d$2.MorphGeometry));

/**
 * 判断一个实例是否为`BSPComponent`。
 */
function isBSPComponent(value) {
    return value.isBSPComponent;
}
/**
 * 判断一个实例是否为`BSPActor`。
 */
function isBSPActor(value) {
    return isSceneActor(value) && isBSPComponent(value.root);
}
/**
 * 基础几何体基类，一般不直接使用，而是使用派生类。
 *
 * @noInheritDoc
 */
var BSPComponent = /** @class */ (function (_super) {
    __extends(BSPComponent, _super);
    function BSPComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isBSPComponent = true;
        _this.needUpdateAndDestroy = false;
        return _this;
    }
    /**
     * 初始化，继承请先`super.onInit()`。
     */
    BSPComponent.prototype.onInit = function (initState) {
        var state = this.convertState(initState);
        _super.prototype.onInit.call(this, state);
    };
    BSPComponent.prototype.convertState = function (initState) {
        return initState;
    };
    BSPComponent = __decorate([
        SClass({ className: 'BSPComponent' })
    ], BSPComponent);
    return BSPComponent;
}(StaticMeshComponent));

/**
 * 判断一个实例是否为`BSPMorphComponent`。
 */
function isBSPMorphComponent(value) {
    return value.isBSPMorphComponent;
}
/**
 * 判断一个实例是否为`BSPMorphActor`。
 */
function isBSPMorphActor(value) {
    return isSceneActor(value) && isBSPMorphComponent(value.root);
}
/**
 * 基础Morph几何体。
 *
 * @noInheritDoc
 */
var BSPMorphComponent = /** @class */ (function (_super) {
    __extends(BSPMorphComponent, _super);
    function BSPMorphComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isBSPMorphComponent = true;
        return _this;
    }
    Object.defineProperty(BSPMorphComponent.prototype, "geometry", {
        /**
         * 获取几何体。
         */
        get: function () {
            return this._mesh.geometry;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BSPMorphComponent.prototype, "targets", {
        /**
         * 设置targets。
         */
        get: function () {
            return this.geometry.targets;
        },
        /**
         * 获取targets。
         */
        set: function (value) {
            this.geometry.targets = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BSPMorphComponent.prototype, "weights", {
        /**
         * 获取权重。
         */
        get: function () {
            return this.geometry.weights;
        },
        /**
         * 设置权重。
         */
        set: function (value) {
            this.geometry.weights = value;
        },
        enumerable: false,
        configurable: true
    });
    BSPMorphComponent.prototype.convertState = function (initState) {
        var weights = initState.weights, targets = initState.targets, geometry = initState.geometry, others = __rest(initState, ["weights", "targets", "geometry"]);
        var result = others;
        var attrs = {};
        Object.keys(geometry).forEach(function (key) {
            if (geometry[key].isGeometryData) {
                attrs[key] = geometry[key];
            }
        });
        result.geometry = new MorphGeometry(attrs);
        if (geometry.isMorphGeometry) {
            result.geometry.targets = targets || geometry.targets;
            result.geometry.weights = weights || geometry.weights.slice();
        }
        else {
            result.geometry.weights = weights || [];
            result.geometry.targets = targets || {};
        }
        return result;
    };
    BSPMorphComponent = __decorate([
        SClass({ className: 'BSPMorphComponent' })
    ], BSPMorphComponent);
    return BSPMorphComponent;
}(BSPComponent));

/**
 * [BSPMorphComponent](../bspmorphcomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var BSPMorphActor = /** @class */ (function (_super) {
    __extends(BSPMorphActor, _super);
    function BSPMorphActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BSPMorphActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', BSPMorphComponent, options);
    };
    BSPMorphActor = __decorate([
        SClass({ className: 'BSPMorphActor' })
    ], BSPMorphActor);
    return BSPMorphActor;
}(SceneActor));

/**
 * 用于2D精灵的材质。
 *
 * @noInheritDoc
 */
var SpriteMaterial = /** @class */ (function (_super) {
    __extends(SpriteMaterial, _super);
    function SpriteMaterial(options) {
        var _this = _super.call(this, {
            side: Constants.FRONT_AND_BACK,
            alphaMode: 'BLEND',
            attributes: {
                a_position: 'POSITION',
                a_uv: 'TEXCOORD_0'
            },
            uniforms: __assign({ u_modelViewProjectionMatrix: 'SPRITEMODELVIEWPROJECTION', u_modelViewMatrix: 'MODELVIEW', u_fogInfo: 'FOGINFO', u_fogColor: 'FOGCOLOR' }, options.uniforms),
            vs: "\nprecision HILO_MAX_VERTEX_PRECISION float;\nattribute vec3 a_position;\nattribute vec2 a_uv;\nuniform mat4 u_modelViewProjectionMatrix;\nuniform mat3 u_uvMatrix;\n" + Shader.shaders['chunk/lightFog.vert'] + "\nvarying vec2 v_uv;\n\nvoid main() {\nvec4 pos = vec4(a_position, 1.0);\nv_uv = (u_uvMatrix * vec3(a_uv, 1.)).xy;\n" + Shader.shaders['chunk/lightFog_main.vert'] + "\n\ngl_Position = u_modelViewProjectionMatrix * pos;\n}\n",
            fs: "\nprecision HILO_MAX_FRAGMENT_PRECISION float;\nuniform sampler2D u_texture;\nuniform float u_opacity;\n" + Shader.shaders['chunk/fog.frag'] + "\nvarying vec2 v_uv;\n\nvoid main() {\nvec4 color = texture2D(u_texture, v_uv);\nfloat a = color.a;\n" + Shader.shaders['chunk/fog_main.frag'] + "\ncolor.a = a * u_opacity;\n\ngl_FragColor = color;\n}\n"
        }) || this;
        _this.isSpriteMaterial = true;
        return _this;
    }
    SpriteMaterial = __decorate([
        SMaterial({ className: 'SpriteMaterial' })
    ], SpriteMaterial);
    return SpriteMaterial;
}(RawShaderMaterial));

/**
 * 判断一个实例是否为`SpriteComponent`。
 */
function isSpriteComponent(value) {
    return value.isSpriteComponent;
}
/**
 * 判断一个实例是否为`SpriteActor`。
 */
function isSpriteActor(value) {
    return isSceneActor(value) && isSpriteComponent(value.root);
}
/**
 * 精灵组件类，是展示2D图元的基本组件。
 *
 * @noInheritDoc
 */
var SpriteComponent = /** @class */ (function (_super) {
    __extends(SpriteComponent, _super);
    function SpriteComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isSpriteComponent = true;
        _this._isBillboard = false;
        return _this;
    }
    Object.defineProperty(SpriteComponent.prototype, "isBillboard", {
        /**
         * 是否开启`Billboard`模式，若开启，则精灵始终面向摄像机。
         */
        get: function () {
            return this._isBillboard;
        },
        /**
         * 是否开启`Billboard`模式，若开启，则精灵始终面向摄像机。
         */
        set: function (value) {
            this._isBillboard = value;
            this.getMaterial().isBillboard = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteComponent.prototype, "currentFrame", {
        /**
         * 获取当前的帧名（图集模式）。
         */
        get: function () {
            return this._currentFrame;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化，继承请先`super.onInit()`。
     */
    SpriteComponent.prototype.onInit = function (state) {
        _super.prototype.onInit.call(this, state);
        var texture;
        var uvMatrix = new Matrix3();
        if (state.atlas) {
            texture = state.atlas.texture;
            this._atlas = state.atlas;
            uvMatrix.copy(this._atlas.getUVMatrix(state.frameName));
        }
        else {
            this._texture = texture = state.texture;
        }
        texture.width = texture.origWidth;
        texture.height = texture.origHeight;
        var opacity = state.opacity === undefined ? 1 : state.opacity;
        var geometry = new Hilo3d$2.PlaneGeometry({ width: state.width, height: state.height });
        var material = (state.material || new SpriteMaterial({
            uniforms: {
                u_texture: { value: texture },
                u_uvMatrix: { value: uvMatrix },
                u_opacity: { value: opacity }
            }
        }));
        if (state.material) {
            material.setUniform('u_texture', texture);
            material.setUniform('u_uvMatrix', uvMatrix);
            material.setUniform('u_opacity', opacity);
        }
        if (state.materialOptions) {
            Object.assign(material, state.materialOptions);
        }
        material.game = this.getGame();
        this._mesh = new Mesh({ geometry: geometry, material: material });
        this._mesh.__forceUseParentWorldMatrix = true;
        if (state.frustumTest !== undefined) {
            this._mesh.frustumTest = state.frustumTest;
        }
        this.isBillboard = state.isBillboard || false;
        this._node.addChild(this._mesh);
        var root = this.getRoot();
        if (root) {
            root.hiloNode.addChild(this._node);
        }
    };
    Object.defineProperty(SpriteComponent.prototype, "width", {
        /**
         * 获取精灵宽度。
         */
        get: function () {
            return this._initState.width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteComponent.prototype, "height", {
        /**
         * 获取精灵高度。
         */
        get: function () {
            return this._initState.height;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteComponent.prototype, "texture", {
        /**
         * 单纹理下模式下，直接获取纹理。
         */
        get: function () {
            return this._texture;
        },
        /**
         * 单纹理下模式下，直接设置纹理。
         */
        set: function (texture) {
            if (this._texture !== texture) {
                this._texture = texture;
                this._mesh.material.setUniform('u_texture', texture);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteComponent.prototype, "atlas", {
        /**
         * 获取当前图集。
         */
        get: function () {
            return this._atlas;
        },
        /**
         * 设置当前图集。
         */
        set: function (atlas) {
            if (this._atlas !== atlas) {
                this._atlas = atlas;
                this._mesh.material.setUniform('u_texture', atlas.getWholeTexture());
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteComponent.prototype, "frustumTest", {
        /**
         * 是否需要视椎体裁剪。
         */
        get: function () {
            return this._mesh.frustumTest;
        },
        /**
         * 是否需要视椎体裁剪。
         */
        set: function (frustumTest) {
            this._mesh.frustumTest = frustumTest;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteComponent.prototype, "material", {
        /**
         * 获取材质数据。
         */
        get: function () {
            return this._mesh.material;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取材质数据。
     */
    SpriteComponent.prototype.getMaterial = function () {
        return this._mesh.material;
    };
    /**
     * 仅当图集`atlas`模式下，设置要显示哪一帧。
     */
    SpriteComponent.prototype.setFrame = function (name) {
        this._mesh.material.setUniform('u_uvMatrix', this._atlas.getUVMatrix(name));
        this._currentFrame = name;
        return this;
    };
    /**
     * 进行一次预渲染，期间会处理材质预编译、资源预提交等。
     */
    SpriteComponent.prototype.preRender = function () {
        var renderer = this.getGame().renderer;
        renderer.renderMesh(this._mesh);
    };
    SpriteComponent = __decorate([
        SClass({ className: 'SpriteComponent' })
    ], SpriteComponent);
    return SpriteComponent;
}(SceneComponent));

/**
 * [SpriteComponent](../spritecomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var SpriteActor = /** @class */ (function (_super) {
    __extends(SpriteActor, _super);
    function SpriteActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SpriteActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', SpriteComponent, options);
    };
    SpriteActor = __decorate([
        SClass({ className: 'SpriteActor' })
    ], SpriteActor);
    return SpriteActor;
}(SceneActor));

/* tslint:disable */
/**
 * @hidden
 */
function generateActorOrComponentFromNode(node, parentActor, parent, isComponent, resource, world) {
    var child = node.children[0];
    var result = null;
    var root = null;
    var Class;
    var initOptions = { __fromGlTF: true, matrix: node.matrix };
    if (node.gltfExtensions.Sein_node && node.gltfExtensions.Sein_node.className) {
        var className = node.gltfExtensions.Sein_node.className;
        Class = MetaSClasses[className];
        if (!Class) {
            Debug.warn("No class named '" + className + "', no effect, you must use decorator 'SClass' to annotate your class before use it !");
        }
        else {
            Object.assign(initOptions, node.gltfExtensions.Sein_node.initOptions || {});
        }
    }
    if (!child) {
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || SceneComponent, initOptions, parent);
        }
        else {
            root = (result = world.addActor(node.name, Class || SceneActor, initOptions, parentActor, parent)).root;
        }
    }
    else if (child.isSkinedMesh) {
        var length_1 = node.children.length;
        var meshes = [];
        for (var index = 0; index < length_1; index += 1) {
            var mesh = node.children[index];
            if (!mesh.isSkinedMesh) {
                break;
            }
            meshes.push(mesh);
            node.childrenOffset += 1;
        }
        length_1 = meshes.length;
        var _a = child, geometry = _a.geometry, material = _a.material;
        Object.assign(initOptions, { __doNotUseMultiPrimitiveYourself: meshes, geometry: geometry, material: material });
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || SkeletalMeshComponent, initOptions, parent);
            parentActor.skeletalMeshComponents.push([root, meshes]);
        }
        else {
            root = (result = world.addActor(node.name, Class || SkeletalMeshActor, initOptions, parentActor, parent)).root;
            root.getOwner().skeletalMeshComponents = [[root, meshes]];
        }
    }
    else if (child.isMesh) {
        var length_2 = node.children.length;
        var meshes = [];
        for (var index = 0; index < length_2; index += 1) {
            var mesh = node.children[index];
            if (!mesh.isMesh) {
                break;
            }
            meshes.push(mesh);
            node.childrenOffset += 1;
        }
        length_2 = meshes.length;
        var _b = child, geometry = _b.geometry, material = _b.material;
        Object.assign(initOptions, { __doNotUseMultiPrimitiveYourself: meshes, geometry: geometry, material: material });
        if (geometry.isMorphGeometry) {
            if (isComponent) {
                root = result = parentActor.addComponent(node.name, Class || BSPMorphComponent, initOptions, parent);
            }
            else {
                root = (result = world.addActor(node.name, Class || BSPMorphActor, initOptions, parentActor, parent)).root;
            }
        }
        else {
            if (isComponent) {
                root = result = parentActor.addComponent(node.name, Class || StaticMeshComponent, initOptions, parent);
            }
            else {
                root = (result = world.addActor(node.name, Class || StaticMeshActor, initOptions, parentActor, parent)).root;
            }
        }
    }
    else if (child.isFakeHiloSprite) {
        var _c = child.sprite, width = _c.width, height = _c.height, isBillboard = _c.isBillboard, frustumTest = _c.frustumTest, atlas = _c.atlas;
        var material = child.material;
        var frameName = atlas.frameName, index = atlas.index;
        var atlasManager = resource['atlases'][index];
        Object.assign(initOptions, { width: width, height: height, isBillboard: isBillboard, frustumTest: frustumTest, frameName: frameName, atlas: atlasManager, material: material, materialOptions: { alphaMode: 'BLEND' } });
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || SpriteComponent, initOptions, parent);
        }
        else {
            root = (result = world.addActor(node.name, Class || SpriteActor, initOptions, parentActor, parent)).root;
        }
        node.childrenOffset += 1;
    }
    else if (child.isOrthographicCamera) {
        var _d = child, far = _d.far, near = _d.near, left = _d.left, right = _d.right, top_1 = _d.top, bottom = _d.bottom, backgroundMat = _d.backgroundMat;
        Object.assign(initOptions, { far: far, near: near, left: left, right: right, top: top_1, bottom: bottom, backgroundMat: backgroundMat });
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || OrthographicCameraComponent, initOptions, parent);
        }
        else {
            root = (result = world.addActor(node.name, Class || OrthographicCameraActor, initOptions, parentActor, parent)).root;
        }
        node.childrenOffset += 1;
    }
    else if (child.isPerspectiveCamera) {
        var _e = child, far = _e.far, near = _e.near, fov = _e.fov, aspect = _e.aspect, backgroundMat = _e.backgroundMat;
        Object.assign(initOptions, { far: far, near: near, fov: fov, aspect: aspect, backgroundMat: backgroundMat });
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || PerspectiveCameraComponent, initOptions, parent);
        }
        else {
            root = (result = world.addActor(node.name, Class || PerspectiveCameraActor, initOptions, parentActor, parent)).root;
        }
        node.childrenOffset += 1;
    }
    else if (child.isAmbientLight) {
        var _f = child, amount = _f.amount, color = _f.color, shadow = _f.shadow;
        Object.assign(initOptions, { amount: amount, color: color, shadow: shadow });
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || AmbientLightComponent, initOptions, parent);
        }
        else {
            root = (result = world.addActor(node.name, Class || AmbientLightActor, initOptions, parentActor, parent)).root;
        }
        node.childrenOffset += 1;
    }
    else if (child.isDirectionalLight) {
        var _g = child, amount = _g.amount, color = _g.color, shadow = _g.shadow, direction = _g.direction;
        Object.assign(initOptions, { amount: amount, color: color, shadow: shadow, direction: direction });
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || DirectionalLightComponent, initOptions, parent);
        }
        else {
            root = (result = world.addActor(node.name, Class || DirectionalLightActor, initOptions, parentActor, parent)).root;
        }
        node.childrenOffset += 1;
    }
    else if (child.isPointLight) {
        var _h = child, amount = _h.amount, color = _h.color, shadow = _h.shadow, range = _h.range, constantAttenuation = _h.constantAttenuation, linearAttenuation = _h.linearAttenuation, quadraticAttenuation = _h.quadraticAttenuation;
        Object.assign(initOptions, { amount: amount, color: color, shadow: shadow, range: range, constantAttenuation: constantAttenuation, linearAttenuation: linearAttenuation, quadraticAttenuation: quadraticAttenuation });
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || PointLightComponent, initOptions, parent);
        }
        else {
            root = (result = world.addActor(node.name, Class || PointLightActor, initOptions, parentActor, parent)).root;
        }
        node.childrenOffset += 1;
    }
    else if (child.isSpotLight) {
        var _j = child, amount = _j.amount, color = _j.color, shadow = _j.shadow, range = _j.range, constantAttenuation = _j.constantAttenuation, linearAttenuation = _j.linearAttenuation, quadraticAttenuation = _j.quadraticAttenuation, cutoff = _j.cutoff, outerCutoff = _j.outerCutoff, direction = _j.direction;
        Object.assign(initOptions, { amount: amount, color: color, shadow: shadow, range: range, constantAttenuation: constantAttenuation, linearAttenuation: linearAttenuation, quadraticAttenuation: quadraticAttenuation, cutoff: cutoff, outerCutoff: outerCutoff, direction: direction });
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || SpotLightComponent, initOptions, parent);
        }
        else {
            root = (result = world.addActor(node.name, Class || SpotLightActor, initOptions, parentActor, parent)).root;
        }
        node.childrenOffset += 1;
    }
    else {
        if (isComponent) {
            root = result = parentActor.addComponent(node.name, Class || SceneComponent, initOptions, parent);
        }
        else {
            root = (result = world.addActor(node.name, Class || SceneActor, initOptions, parentActor, parent)).root;
        }
    }
    root.cloneFromHiloNode(node);
    root.needReleaseGlRes = false;
    var animationId = root.hiloNode.animationId;
    if (isComponent && resource.anim && resource.anim.validAnimationIds[animationId]) {
        parentActor.animNameMap[animationId] = root.hiloNode;
        parentActor.animCount += 1;
    }
    return result;
}
/**
 * @hidden
 */
function convert(game, parent, children, actors, resource, forceAsComponent, className) {
    if (forceAsComponent === void 0) { forceAsComponent = false; }
    if (className === void 0) { className = null; }
    // if parent is null
    var isComponent = false;
    var parentNode = null;
    var parentSeinNode = null;
    if (parent) {
        if (isSceneActor$1(parent)) {
            parentNode = parent.root.hiloNode;
        }
        else {
            parentNode = parent.hiloNode;
            // parent is component, child must be component
            isComponent = true;
        }
    }
    if (parentNode && parentNode.gltfExtensions && parentNode.gltfExtensions.Sein_node) {
        parentSeinNode = parentNode.gltfExtensions.Sein_node;
    }
    else {
        parentSeinNode = {};
    }
    var length = children.length;
    var _loop_1 = function (i) {
        var child = children[i];
        child.gltfExtensions = child.gltfExtensions || {};
        child.childrenOffset = 0;
        var childSeinNode = void 0;
        var skipThisNode = false;
        if (child.gltfExtensions.Sein_node) {
            childSeinNode = child.gltfExtensions.Sein_node;
            skipThisNode = childSeinNode.skipThisNode;
        }
        if (forceAsComponent || className) {
            childSeinNode = childSeinNode || {
                selfType: exports.ESeinNodeType.Actor,
                childrenType: exports.ESeinNodeType.Component
            };
        }
        if (forceAsComponent) {
            childSeinNode.selfType = exports.ESeinNodeType.Component;
        }
        if (className) {
            childSeinNode.className = className;
        }
        // parent is actor, childrenType is component and selfType of child is component
        if (childSeinNode && childSeinNode.selfType === exports.ESeinNodeType.Actor) {
            isComponent = false;
        }
        else if (!isComponent
            && parentSeinNode.childrenType === exports.ESeinNodeType.Component
            && (!childSeinNode || childSeinNode.selfType !== exports.ESeinNodeType.Actor)) {
            isComponent = true;
        }
        else if (childSeinNode && childSeinNode.selfType === exports.ESeinNodeType.Component) {
            isComponent = true;
        }
        var result = parent;
        if (!skipThisNode) {
            result = generateActorOrComponentFromNode(child, (parent && !isSceneActor$1(parent)) ? parent.getOwner() : parent, (parent && isSceneActor$1(parent)) ? null : parent, isComponent, resource, game.world);
            if (isSceneActor$1(result)) {
                var actor = result;
                actor.animNameMap = {};
                actor.animCount = 0;
                actor.skeletalMeshComponents = actor.skeletalMeshComponents || [];
                var animationId = actor.root.hiloNode.animationId;
                if (resource.anim && resource.anim.validAnimationIds[animationId]) {
                    actor.animNameMap[animationId] = actor.root.hiloNode;
                    actor.animCount += 1;
                }
                actors.add(actor);
            }
            Object.keys(child.gltfExtensions).forEach(function (name) {
                // 避免循环依赖，临时解决方案
                var handler = Hilo3d$2.GLTFParser.extensionHandlers[name];
                if (handler && handler.instantiate) {
                    handler.instantiate(result, child.gltfExtensions[name], game, child, resource);
                }
            });
        }
        var offset = child.childrenOffset || 0;
        // Leaf node
        if (!child.children || child.children.length === offset) {
            return "continue";
        }
        // const grandson = child.children[offset];
        // if (child.children.length === offset + 1 && (!grandson.children || grandson.children.length === 0)) {
        //   console.log(child, child.jointName);
        //   continue;
        // }
        convert(game, result, child.children.slice(offset), actors, resource);
    };
    for (var i = 0; i < length; i += 1) {
        _loop_1(i);
    }
}
/* tslint:enable */
/**
 * @hidden
 */
function addActorsFromGlTF(game, entity, options) {
    var resource = entity.result;
    var node = resource.node;
    if (options && options.nodePath && options.nodePath.length !== 0) {
        node = resource.node.getChildByNamePath(options.nodePath);
        if (!node) {
            throw new Error("Resource \"" + entity.name + "\" in type \"GlTF\" dose not has node \"" + options.nodePath.toString() + "\" !");
        }
    }
    var children = null;
    var actors = new SArray();
    if (node !== resource.node) {
        children = [node];
    }
    else {
        children = node.children.slice();
        var al = resource['ambientLight'];
        if (al && !game.world.__gltfAmbientLightCreated) {
            var lNode = new Hilo3d$2.Node();
            lNode.name = al.name;
            lNode.addChild(al);
            children.push(lNode);
            game.world.__gltfAmbientLightCreated = true;
        }
    }
    if (options && options.name && children.length === 1) {
        var child = children[0];
        child.name = options.name;
    }
    convert(game, options && (options.parentActor || options.parentComponent), children, actors, resource, options && options.asComponent, options && (options.className || (options.Class && options.Class.CLASS_NAME.value)));
    actors.forEach(function (a) {
        var _a = a, animCount = _a.animCount, animNameMap = _a.animNameMap, skeletalMeshComponents = _a.skeletalMeshComponents;
        var length = skeletalMeshComponents.length;
        for (var i = 0; i < length; i += 1) {
            var _b = skeletalMeshComponents[i], component = _b[0], meshes = _b[1];
            var len = meshes.length;
            for (var index = 0; index < len; index += 1) {
                component.cloneSkinningFromHilo(meshes[index], index);
            }
        }
        delete a.animCount;
        delete a.animNameMap;
        delete a.skeletalMeshComponents;
        if (animCount > 0) {
            var hiloNode = a.root.hiloNode;
            hiloNode.anim = resource.anim.clone(null);
            hiloNode.anim.nodeNameMap = animNameMap;
            if (hiloNode.gltfExtensions.Sein_animator) {
                var _c = hiloNode.gltfExtensions.Sein_animator, modelAnimations = _c.modelAnimations, prefix = _c.prefix, prefixes = _c.prefixes;
                length = modelAnimations.length;
                if (length !== 0) {
                    var originClips = hiloNode.anim.clips;
                    var clips = hiloNode.anim.clips = {};
                    for (var index = 0; index < length; index += 1) {
                        var name_1 = modelAnimations[index];
                        var finalPrefix = prefixes ? (prefixes[index] || prefix) : prefix;
                        clips[name_1] = originClips[finalPrefix ? finalPrefix + "@" + name_1 : name_1];
                    }
                }
            }
            a.addComponent('animator', AnimatorComponent);
            if (hiloNode.gltfExtensions.Sein_animator) {
                var defaultAnimation = hiloNode.gltfExtensions.Sein_animator.defaultAnimation;
                if (defaultAnimation) {
                    a.animator.setDefault(defaultAnimation);
                }
            }
        }
        if (options.preRender) {
            a.preRender();
        }
        a.instantiated();
    });
    return actors;
}

/**
 * @hidden
 */
function materialCreator(name, metaData, json, parser) {
    if (!metaData || !metaData.extensions || !metaData.extensions['Sein_customMaterial']) {
        return;
    }
    var extensions = metaData.extensions, alphaMode = metaData.alphaMode, doubleSided = metaData.doubleSided;
    var _a = extensions['Sein_customMaterial'], className = _a.className, uniforms = _a.uniforms, cloneForInst = _a.cloneForInst, renderOrder = _a.renderOrder;
    var MaterialClass = MetaSMaterials[className];
    if (!MaterialClass) {
        if (parser.ignoreMaterialError) {
            Debug.warn("ShaderMaterial \"" + className + "\" is not existed, Please ensure your material is decorated with 'Sein.SMaterial' !");
            return;
        }
        else {
            throw new Error("ShaderMaterial \"" + className + "\" is not existed, Please ensure your material is decorated with 'Sein.SMaterial' !");
        }
    }
    var options = { uniforms: {}, doubleSided: doubleSided, alphaMode: alphaMode, renderOrder: renderOrder };
    if (uniforms) {
        for (var key in uniforms) {
            var _b = uniforms[key], type = _b.type, value = _b.value;
            var v = null;
            switch (type) {
                case Constants.SAMPLER_2D:
                    v = parser.textures[value.index];
                    break;
                case Constants.SAMPLER_CUBE:
                    v = parser.cubeTextures[value.index];
                    break;
                case Constants.FLOAT_VEC2:
                case Constants.INT_VEC2:
                    v = new Vector2();
                    v.fromArray(value);
                    break;
                case Constants.FLOAT_VEC3:
                case Constants.INT_VEC3:
                    v = new Vector3();
                    v.fromArray(value);
                    break;
                case Constants.FLOAT_VEC4:
                case Constants.INT_VEC4:
                    v = new Color();
                    v.fromArray(value);
                    break;
                case Constants.FLOAT_MAT3:
                    v = new Matrix3();
                    v.fromArray(value);
                    break;
                case Constants.FLOAT_MAT4:
                    v = new Matrix4();
                    v.fromArray(value);
                    break;
                default:
                    v = uniforms[key].value;
                    break;
            }
            options.uniforms[key] = { value: v };
        }
    }
    var material = new MaterialClass(options);
    if (cloneForInst !== undefined) {
        material.cloneForInst = cloneForInst;
    }
    material.initCommonOptions(options, true);
    var Sein_customMaterial = extensions.Sein_customMaterial, others = __rest(extensions, ["Sein_customMaterial"]);
    parser.parseExtensions(others, material, { isMaterial: true });
    return material;
}
/**
 * 判断一个实例是否为`GlTFLoader`。
 */
function isGlTFLoader(value) {
    return value.isGlTFLoader;
}
/**
 * GlTF加载器。
 *
 * @noInheritDoc
 */
var GlTFLoader = /** @class */ (function (_super) {
    __extends(GlTFLoader, _super);
    function GlTFLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._cache = {};
        _this._cacheNames = {};
        _this.isGlTFLoader = true;
        return _this;
    }
    /**
     * 注册GlTFLoader的扩展。
     */
    GlTFLoader.REGISTER_EXTENSION = function (hander) {
        if (!hander.parse) {
            hander.parse = getDefaultParse(hander.name);
        }
        else {
            var parse_1 = hander.parse;
            hander.parse = function (info, parser, entity, options) {
                getDefaultParse(hander.name);
                return parse_1(info, parser, entity, options);
            };
        }
        Hilo3d$2.GLTFParser.registerExtensionHandler(hander.name, hander);
    };
    /**
     * 取消注册GlTFLoader的扩展。
     */
    GlTFLoader.UNREGISTER_EXTENSION = function (hander) {
        Hilo3d$2.GLTFParser.unregisterExtensionHandler(hander.name);
    };
    /**
     * 获取GlTFLoader的扩展。
     */
    GlTFLoader.GET_EXTENSION_HANDLER = function (name) {
        return Hilo3d$2.GLTFParser.extensionHandlers[name];
    };
    GlTFLoader.prototype.load = function (entity, callbacks) {
        var _this = this;
        if (this._cache[entity.url]) {
            this._cacheNames[entity.url].push(entity.name);
            entity.result = this._cache[entity.url];
            callbacks.onLoaded(entity);
            return;
        }
        var loader = new Hilo3d$2.GLTFLoader();
        loader.game = this.game;
        loader.on('progress', function (event) {
            var _a = event.detail, loaded = _a.loaded, total = _a.total;
            if (total > 0) {
                callbacks.onLoading(entity, loaded / total);
            }
        });
        loader.load({
            src: entity.url,
            isProgressive: entity.isProgressive || false,
            customMaterialCreator: materialCreator,
            isLoadAllTextures: true,
            ignoreTextureError: entity.ignoreTextureError,
            game: this.game,
            ignoreMaterialError: entity.ignoreMaterialError || false,
            forceCreateNewBuffer: entity.forceCreateNewBuffer || false
        })
            .then(function (result) {
            entity.result = result;
            _this._cacheNames[entity.url] = _this._cacheNames[entity.url] || [];
            _this._cacheNames[entity.url][entity.name] = true;
            _this._cache[entity.url] = entity.result;
            callbacks.onLoaded(entity);
        })
            .catch(function (error) { return callbacks.onError(entity, error); });
    };
    /**
     * 将GlTF资源实例化为Actor或者Component。
     */
    GlTFLoader.prototype.instantiate = function (entity, options) {
        return addActorsFromGlTF(this.game, entity, options);
    };
    /**
     * 释放资源时将会调用，用于自定义释放逻辑。
     */
    GlTFLoader.prototype.release = function (entity) {
        var list = this._cacheNames[entity.url];
        if (!list) {
            return;
        }
        if (list.length > 1) {
            list.splice(list.indexOf(entity.name), 1);
            return;
        }
        delete this._cacheNames[entity.url];
        delete this._cache[entity.url];
        entity.result.node.destroy(this.game.renderer, true);
    };
    /**
     * 开发者无需关心。
     *
     * @hidden
     */
    GlTFLoader.clearCache = function () {
        Hilo3d$2.GLTFLoader.clearCache();
    };
    GlTFLoader.FORMATS = ['.gltf', '.glb'];
    GlTFLoader = __decorate([
        SClass({ className: 'GlTFLoader' })
    ], GlTFLoader);
    return GlTFLoader;
}(ResourceLoader));
GlTFLoader.REGISTER_EXTENSION(SeinCubeTextureExtension);
GlTFLoader.REGISTER_EXTENSION(SeinNodeExtension);
GlTFLoader.REGISTER_EXTENSION(SeinPhysicBodyExtension);
GlTFLoader.REGISTER_EXTENSION(SeinAnimatorExtension);
GlTFLoader.REGISTER_EXTENSION(SeinRendererExtension);
GlTFLoader.REGISTER_EXTENSION(SeinAmbientLightExtension);
GlTFLoader.REGISTER_EXTENSION(SeinImageBasedLightingExtension);
GlTFLoader.REGISTER_EXTENSION(SeinAtlasExtension);
GlTFLoader.REGISTER_EXTENSION(SeinSpriteExtension);
GlTFLoader.REGISTER_EXTENSION(SeinCustomMaterialExtension);
GlTFLoader.REGISTER_EXTENSION(SeinSkyboxExtension);
GlTFLoader.REGISTER_EXTENSION(SeinTextureImproveExtension);

/**
 * @hidden
 */
function getExt(url) {
    return '.' + url.split('.').pop();
}
/**
 * 判断一个实例是否为`ResourceManager`。
 */
function isResourceManager(value) {
    return value.isResourceManager;
}
/**
 * 资源管理器类。作为资源的集中管理容器，承担着引擎所有的资源加载器的注册、销毁，以及资源的添加、加载和释放。
 *
 * @template IDefaultLoaders 用于标注所有资源的名称以及对应的事件参数类型。
 * @noInheritDoc
 */
var ResourceManager = /** @class */ (function (_super) {
    __extends(ResourceManager, _super);
    /**
     * @hidden
     */
    function ResourceManager(game) {
        var _this = _super.call(this) || this;
        _this.isResourceManager = true;
        _this._onError = new Observable(_this);
        _this._onLoading = new Observable(_this);
        _this._onLoaded = new Observable(_this);
        _this._loaders = {};
        _this._loadersFormat = {};
        _this._queue = {};
        _this._store = {};
        _this._state = {
            totalCount: 0,
            loadedCount: 0,
            progress: 0,
            totalWeight: 0,
            loadDone: true,
            current: null
        };
        _this.handleLoadingOne = function (entity, progress) {
            // resource has been canceled
            if (!_this._queue[entity.name]) {
                return;
            }
            var weight = entity.weight, preProgress = entity.preProgress;
            entity.preProgress = progress;
            _this._state.current = entity;
            _this._state.progress += (weight * (progress - preProgress) / _this._state.totalWeight);
            _this.onLoading.notify(Object.assign({}, _this._state));
        };
        _this.handleLoadedOne = function (entity, error) {
            if (error === void 0) { error = null; }
            var weight = entity.weight, preProgress = entity.preProgress;
            var progress = 1;
            entity.preProgress = progress;
            _this._state.current = entity;
            _this._state.progress += (weight * (progress - preProgress) / _this._state.totalWeight);
            _this._state.loadedCount += 1;
            delete _this._queue[entity.name];
            if (!error) {
                _this._store[entity.name] = entity;
            }
            else {
                _this.onError.notify({ error: error, state: Object.assign({}, _this._state) });
            }
            _this.onLoading.notify(Object.assign(error ? { error: error } : {}, _this._state));
            if (_this._state.loadedCount === _this._state.totalCount) {
                _this.handleLoadDone();
            }
        };
        _this._game = game;
        return _this;
    }
    Object.defineProperty(ResourceManager.prototype, "loadDone", {
        /**
         * 此批资源是否加载完毕。
         */
        get: function () {
            return this._state.loadDone;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ResourceManager.prototype, "parent", {
        /**
         * 获取父级Game实例。
         */
        get: function () {
            return this._game;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ResourceManager.prototype, "onError", {
        /**
         * 此批资源加载错误时的可观察实例。
         */
        get: function () {
            return this._onError;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ResourceManager.prototype, "onLoading", {
        /**
         * 此批资源加载进度更新时的可观察实例。
         */
        get: function () {
            return this._onLoading;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ResourceManager.prototype, "onLoaded", {
        /**
         * 此批资源加载完毕时的可观察实例。
         */
        get: function () {
            return this._onLoaded;
        },
        enumerable: false,
        configurable: true
    });
    ResourceManager.prototype.getLoader = function (type) {
        return this._loaders[type];
    };
    /**
     * 获取一个指定格式的Loader。
     *
     * **指定格式需要在`ResourceLoader.EXTENSIONS`静态变量中定义！**
     */
    ResourceManager.prototype.getLoaderByFormat = function (format) {
        return this.getLoader(this._loadersFormat[format]);
    };
    ResourceManager.prototype.register = function (type, LoaderClass) {
        var _this = this;
        if (this._loaders[type]) {
            throw new MemberConflictException(this, 'Loader', type, this, 'You should unregister it at first !');
        }
        var loader = new LoaderClass();
        loader.game = this._game;
        this._loaders[type] = loader;
        (LoaderClass.FORMATS || []).forEach(function (format) {
            _this._loadersFormat[format] = type;
        });
        return this;
    };
    ResourceManager.prototype.unregister = function (type) {
        var _this = this;
        if (!this._loaders[type]) {
            return;
        }
        (this._loaders[type].constructor || []).FORMATS.forEach(function (format) {
            delete _this._loadersFormat[format];
        });
        delete this._loaders[type];
        return this;
    };
    ResourceManager.prototype.add = function (type, name, resource) {
        if (!this._loaders[type]) {
            throw new MissingMemberException(this, 'Loader', type, this, 'Register it before adding resource !');
        }
        if (this._store[name]) {
            return;
        }
        this._store[name] = { name: name, result: resource, type: type, url: '' };
        return this;
    };
    /**
     * 判断一个资源是否已经存在。
     */
    ResourceManager.prototype.has = function (name) {
        return !!this._store[name];
    };
    ResourceManager.prototype.get = function (name) {
        if (!this._store[name]) {
            Debug.warn("Resource " + name + " is not existed !");
            return null;
        }
        return this._store[name].result;
    };
    /**
     * 释放一个指定的资源。
     */
    ResourceManager.prototype.release = function (name) {
        var entity = this._store[name];
        if (!entity) {
            throw new MissingMemberException(this, 'Entity', name, this);
        }
        this._loaders[entity.type].release(entity);
        delete this._store[name];
        return this;
    };
    /**
     * 清除所有资源。
     */
    ResourceManager.prototype.clear = function () {
        for (var name_1 in this._store) {
            this.release(name_1);
        }
        return this;
    };
    /**
     * 取消特定资源加载。
     */
    ResourceManager.prototype.cancel = function (name) {
        if (!this._queue[name]) {
            return;
        }
        var entity = this._queue[name].entity;
        delete this._queue[name];
        this._loaders[entity.type].cancel(entity);
        this._state.loadedCount += 1;
        if (this._state.loadedCount === this._state.totalCount) {
            this.handleLoadDone();
        }
        return this;
    };
    /**
     * 取消当前所有资源加载。
     */
    ResourceManager.prototype.cancelAll = function () {
        for (var key in this._queue) {
            this.cancel(key);
        }
        return this;
    };
    ResourceManager.prototype.load = function (entity) {
        return __awaiter(this, void 0, void 0, function () {
            var type, loader, pending;
            var _this = this;
            return __generator(this, function (_a) {
                if (typeof entity.url === 'function') {
                    entity.url = entity.url(this._game);
                }
                type = entity.type || this._loadersFormat[getExt(entity.url)];
                if (!this._loaders[type]) {
                    throw new MissingMemberException(this, 'Loader', type, this, 'Register it before adding resource !');
                }
                if (this._store[entity.name]) {
                    return [2 /*return*/, this._store[entity.name]];
                }
                if (this._queue[entity.name]) {
                    return [2 /*return*/, this._queue[entity.name]];
                }
                loader = this._loaders[type];
                entity.type = type;
                entity.weight = entity.weight || 1;
                entity.preProgress = 0;
                entity.canceled = false;
                this._state.totalCount += 1;
                this._state.totalWeight += entity.weight;
                this._state.loadDone = false;
                pending = new Promise(function (resolve, reject) {
                    loader.load(entity, {
                        onLoading: _this.handleLoadingOne,
                        onLoaded: function () {
                            // resource has been canceled
                            if (!_this._queue[entity.name]) {
                                return;
                            }
                            _this.handleLoadedOne(entity);
                            resolve(entity.result);
                        },
                        onError: function (_, error) {
                            // resource has been canceled
                            if (!_this._queue[entity.name]) {
                                return;
                            }
                            var stack = error.stack;
                            error = new ResourceLoadException(entity.name, _this, error.message);
                            error.stack = stack;
                            _this.handleLoadedOne(entity, error);
                            reject(error);
                        }
                    });
                });
                this._queue[entity.name] = { pending: pending, entity: entity };
                return [2 /*return*/, this._queue[entity.name].pending];
            });
        });
    };
    ResourceManager.prototype.instantiate = function (resourceName, options) {
        var entity = this._store[resourceName];
        if (!entity) {
            throw new MissingMemberException(this, 'Entity', resourceName, this);
        }
        return this._loaders[entity.type].instantiate(entity, options || {});
    };
    ResourceManager.prototype.handleLoadDone = function () {
        GlTFLoader.clearCache();
        this._state.loadDone = true;
        this._state.progress = 1;
        var state = Object.assign({}, this._state);
        this._state.totalCount = 0;
        this._state.loadedCount = 0;
        this._state.totalWeight = 0;
        this._state.progress = 0;
        this._state.current = null;
        this.onLoaded.notify(state);
    };
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    ResourceManager.prototype.onDestroy = function () {
        if (!this._state.loadDone) {
            this.cancelAll();
        }
        this.clear();
        this._loaders = {};
    };
    ResourceManager = __decorate([
        SClass({ className: 'ResourceManager' })
    ], ResourceManager);
    return ResourceManager;
}(SObject));

/**
 * 判断一个实例是否为`ImageLoader`。
 */
function isImageLoader(value) {
    return value.isImageLoader;
}
/**
 * 图片加载器。
 *
 * @noInheritDoc
 */
var ImageLoader = /** @class */ (function (_super) {
    __extends(ImageLoader, _super);
    function ImageLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isImageLoader = true;
        return _this;
    }
    ImageLoader.prototype.load = function (entity, callbacks) {
        return __awaiter(this, void 0, void 0, function () {
            var image;
            return __generator(this, function (_a) {
                image = document.createElement('img');
                image.onload = function () {
                    image.onerror = null;
                    image.onabort = null;
                    image.onload = null;
                    if (entity.canceled) {
                        return;
                    }
                    entity.result = image;
                    callbacks.onLoaded(entity);
                };
                image.onerror = function () {
                    callbacks.onError(entity, new Error("Error when loading " + entity.url));
                };
                image.crossOrigin = (entity.crossOrigin || false) ? 'Anonymous' : '';
                image.src = entity.url;
                return [2 /*return*/];
            });
        });
    };
    ImageLoader = __decorate([
        SClass({ className: 'ImageLoader' })
    ], ImageLoader);
    return ImageLoader;
}(ResourceLoader));

/**
 * 判断一个实例是否为`TextureLoader`。
 */
function isTextureLoader(value) {
    return value.isTextureLoader;
}
/**
 * @hidden
 */
var loader = new Hilo3d$2.TextureLoader();
/**
 * @hidden
 */
var hdrLoader = new Hilo3d$2.HDRLoader;
/**
 * @hidden
 */
var ktxLoader = new Hilo3d$2.KTXLoader;
/**
 * 纹理加载器。
 *
 * @noInheritDoc
 */
var TextureLoader = /** @class */ (function (_super) {
    __extends(TextureLoader, _super);
    function TextureLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isTextureLoader = true;
        return _this;
    }
    TextureLoader.prototype.load = function (entity, callbacks) {
        var realLoader = (entity.hdr || /.hdr$/.test(entity.url)) ? hdrLoader : (entity.ktx || /.ktx$/.test(entity.url)) ? ktxLoader : loader;
        realLoader.load({
            src: entity.url,
            crossOrigin: entity.crossOrigin || false,
            uv: entity.uv || 0,
            flipY: entity.flipY,
            isImageCanRelease: entity.isImageCanRelease
        })
            .then(function (result) {
            entity.result = result;
            callbacks.onLoaded(entity);
        })
            .catch(function (error) { return callbacks.onError(entity, error); });
    };
    /**
     * 释放资源时将会调用，用于自定义释放逻辑。
     */
    TextureLoader.prototype.release = function (entity) {
        entity.result.destroy();
    };
    TextureLoader.EXTENSIONS = ['.png', '.jpg', '.bmp', '.hdr', '.ktx'];
    TextureLoader = __decorate([
        SClass({ className: 'TextureLoader' })
    ], TextureLoader);
    return TextureLoader;
}(ResourceLoader));

var axios = createCommonjsModule(function (module, exports) {
/* axios v0.18.1 | (c) 2019 by Matt Zabriskie */
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(commonjsGlobal, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	var bind = __webpack_require__(3);
	var Axios = __webpack_require__(5);
	var defaults = __webpack_require__(6);
	
	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);
	
	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);
	
	  // Copy context to instance
	  utils.extend(instance, context);
	
	  return instance;
	}
	
	// Create the default instance to be exported
	var axios = createInstance(defaults);
	
	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;
	
	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(utils.merge(defaults, instanceConfig));
	};
	
	// Expose Cancel & CancelToken
	axios.Cancel = __webpack_require__(22);
	axios.CancelToken = __webpack_require__(23);
	axios.isCancel = __webpack_require__(19);
	
	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(24);
	
	module.exports = axios;
	
	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {
	
	var bind = __webpack_require__(3);
	var isBuffer = __webpack_require__(4);
	
	/*global toString:true*/
	
	// utils is a library of generic helper functions non-specific to axios
	
	var toString = Object.prototype.toString;
	
	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}
	
	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}
	
	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}
	
	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}
	
	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}
	
	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}
	
	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}
	
	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}
	
	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}
	
	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}
	
	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}
	
	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}
	
	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}
	
	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}
	
	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}
	
	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 */
	function isStandardBrowserEnv() {
	  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
	    return false;
	  }
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined'
	  );
	}
	
	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }
	
	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }
	
	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}
	
	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }
	
	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}
	
	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}
	
	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isBuffer: isBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};


/***/ }),
/* 3 */
/***/ (function(module, exports) {
	
	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */
	
	module.exports = function isBuffer (obj) {
	  return obj != null && obj.constructor != null &&
	    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {
	
	var defaults = __webpack_require__(6);
	var utils = __webpack_require__(2);
	var InterceptorManager = __webpack_require__(16);
	var dispatchRequest = __webpack_require__(17);
	
	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}
	
	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }
	
	  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
	  config.method = config.method.toLowerCase();
	
	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);
	
	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });
	
	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }
	
	  return promise;
	};
	
	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});
	
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});
	
	module.exports = Axios;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	var normalizeHeaderName = __webpack_require__(7);
	
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};
	
	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}
	
	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(8);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(8);
	  }
	  return adapter;
	}
	
	var defaults = {
	  adapter: getDefaultAdapter(),
	
	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],
	
	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],
	
	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,
	
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	
	  maxContentLength: -1,
	
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};
	
	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};
	
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  defaults.headers[method] = {};
	});
	
	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});
	
	module.exports = defaults;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	
	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	var settle = __webpack_require__(9);
	var buildURL = __webpack_require__(12);
	var parseHeaders = __webpack_require__(13);
	var isURLSameOrigin = __webpack_require__(14);
	var createError = __webpack_require__(10);
	
	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;
	
	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }
	
	    var request = new XMLHttpRequest();
	
	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }
	
	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
	
	    // Set the request timeout in MS
	    request.timeout = config.timeout;
	
	    // Listen for ready state
	    request.onreadystatechange = function handleLoad() {
	      if (!request || request.readyState !== 4) {
	        return;
	      }
	
	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }
	
	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };
	
	      settle(resolve, reject, response);
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config, null, request));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
	        request));
	
	      // Clean up request
	      request = null;
	    };
	
	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(15);
	
	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
	          cookies.read(config.xsrfCookieName) :
	          undefined;
	
	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }
	
	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }
	
	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }
	
	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
	        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
	        if (config.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }
	
	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }
	
	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }
	
	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }
	
	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }
	
	    if (requestData === undefined) {
	      requestData = null;
	    }
	
	    // Send the request
	    request.send(requestData);
	  });
	};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {
	
	var createError = __webpack_require__(10);
	
	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response.request,
	      response
	    ));
	  }
	};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {
	
	var enhanceError = __webpack_require__(11);
	
	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, request, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, request, response);
	};


/***/ }),
/* 11 */
/***/ (function(module, exports) {
	
	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	module.exports = function enhanceError(error, config, code, request, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.request = request;
	  error.response = response;
	  return error;
	};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	
	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}
	
	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	
	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];
	
	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }
	
	      if (utils.isArray(val)) {
	        key = key + '[]';
	      } else {
	        val = [val];
	      }
	
	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });
	
	    serializedParams = parts.join('&');
	  }
	
	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }
	
	  return url;
	};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	
	// Headers whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	var ignoreDuplicateOf = [
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	];
	
	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;
	
	  if (!headers) { return parsed; }
	
	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));
	
	    if (key) {
	      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
	        return;
	      }
	      if (key === 'set-cookie') {
	        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
	      } else {
	        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	      }
	    }
	  });
	
	  return parsed;
	};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	
	module.exports = (
	  utils.isStandardBrowserEnv() ?
	
	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	  (function standardBrowserEnv() {
	    var msie = /(msie|trident)/i.test(navigator.userAgent);
	    var urlParsingNode = document.createElement('a');
	    var originURL;
	
	    /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	    function resolveURL(url) {
	      var href = url;
	
	      if (msie) {
	        // IE needs attribute set twice to normalize properties
	        urlParsingNode.setAttribute('href', href);
	        href = urlParsingNode.href;
	      }
	
	      urlParsingNode.setAttribute('href', href);
	
	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	      return {
	        href: urlParsingNode.href,
	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	        host: urlParsingNode.host,
	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	        hostname: urlParsingNode.hostname,
	        port: urlParsingNode.port,
	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	                  urlParsingNode.pathname :
	                  '/' + urlParsingNode.pathname
	      };
	    }
	
	    originURL = resolveURL(window.location.href);
	
	    /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	    return function isURLSameOrigin(requestURL) {
	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	      return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	    };
	  })() :
	
	  // Non standard browser envs (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return function isURLSameOrigin() {
	      return true;
	    };
	  })()
	);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	
	module.exports = (
	  utils.isStandardBrowserEnv() ?
	
	  // Standard browser envs support document.cookie
	  (function standardBrowserEnv() {
	    return {
	      write: function write(name, value, expires, path, domain, secure) {
	        var cookie = [];
	        cookie.push(name + '=' + encodeURIComponent(value));
	
	        if (utils.isNumber(expires)) {
	          cookie.push('expires=' + new Date(expires).toGMTString());
	        }
	
	        if (utils.isString(path)) {
	          cookie.push('path=' + path);
	        }
	
	        if (utils.isString(domain)) {
	          cookie.push('domain=' + domain);
	        }
	
	        if (secure === true) {
	          cookie.push('secure');
	        }
	
	        document.cookie = cookie.join('; ');
	      },
	
	      read: function read(name) {
	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	        return (match ? decodeURIComponent(match[3]) : null);
	      },
	
	      remove: function remove(name) {
	        this.write(name, '', Date.now() - 86400000);
	      }
	    };
	  })() :
	
	  // Non standard browser env (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return {
	      write: function write() {},
	      read: function read() { return null; },
	      remove: function remove() {}
	    };
	  })()
	);


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	
	function InterceptorManager() {
	  this.handlers = [];
	}
	
	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};
	
	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};
	
	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};
	
	module.exports = InterceptorManager;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	var transformData = __webpack_require__(18);
	var isCancel = __webpack_require__(19);
	var defaults = __webpack_require__(6);
	var isAbsoluteURL = __webpack_require__(20);
	var combineURLs = __webpack_require__(21);
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}
	
	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);
	
	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }
	
	  // Ensure headers exist
	  config.headers = config.headers || {};
	
	  // Transform request data
	  config.data = transformData(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );
	
	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers || {}
	  );
	
	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );
	
	  var adapter = config.adapter || defaults.adapter;
	
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);
	
	    // Transform response data
	    response.data = transformData(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );
	
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);
	
	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }
	
	    return Promise.reject(reason);
	  });
	};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {
	
	var utils = __webpack_require__(2);
	
	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });
	
	  return data;
	};


/***/ }),
/* 19 */
/***/ (function(module, exports) {
	
	module.exports = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};


/***/ }),
/* 20 */
/***/ (function(module, exports) {
	
	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};


/***/ }),
/* 21 */
/***/ (function(module, exports) {
	
	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	};


/***/ }),
/* 22 */
/***/ (function(module, exports) {
	
	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}
	
	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};
	
	Cancel.prototype.__CANCEL__ = true;
	
	module.exports = Cancel;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {
	
	var Cancel = __webpack_require__(22);
	
	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }
	
	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });
	
	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }
	
	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}
	
	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};
	
	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};
	
	module.exports = CancelToken;


/***/ }),
/* 24 */
/***/ (function(module, exports) {
	
	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};


/***/ })
/******/ ])
});

});

/**
 * @File   : HTTP.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 2018/9/27 下午11:23:59
 * @Description:
 */
/**
 * 提供基本的HTTP请求能力。
 */
var HTTP = /** @class */ (function () {
    function HTTP() {
    }
    HTTP.get = axios.get;
    HTTP.post = axios.post;
    HTTP.delete = axios.delete;
    HTTP.put = axios.put;
    HTTP.patch = axios.patch;
    HTTP.request = axios.request;
    return HTTP;
}());

/**
 * 判断一个实例是否为`AtlasLoader`。
 */
function isAtlasLoader(value) {
    return value.isAtlasLoader;
}
/**
 * @hidden
 */
function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
}
/**
 * @hidden
 */
function isAbsolute(url) {
    return url[0] === '/' || /^(http|https):\/\//.test(url);
}
/**
 * 图集加载器。
 *
 * @noInheritDoc
 */
var AtlasLoader = /** @class */ (function (_super) {
    __extends(AtlasLoader, _super);
    function AtlasLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isAtlasLoader = true;
        return _this;
    }
    AtlasLoader.prototype.load = function (entity, callbacks) {
        return __awaiter(this, void 0, void 0, function () {
            var meta_1, url, fileName, image_1, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, HTTP.get(entity.url)];
                    case 1:
                        meta_1 = (_a.sent()).data;
                        if (!meta_1) {
                            throw new Error("Load resource error: " + entity.name);
                        }
                        callbacks.onLoading(entity, .1);
                        url = meta_1.meta.image;
                        if (!isAbsolute(url) && !isBase64(url)) {
                            fileName = entity.url.split('/').pop();
                            url = "" + entity.url.replace(fileName, '') + meta_1.meta.image;
                        }
                        image_1 = document.createElement('img');
                        image_1.onload = function () {
                            image_1.onerror = null;
                            image_1.onabort = null;
                            image_1.onload = null;
                            if (entity.canceled) {
                                return;
                            }
                            entity.result = new AtlasManager({
                                image: image_1,
                                frames: meta_1.frames,
                                meta: meta_1.meta
                            }, entity.updatable || false);
                            callbacks.onLoaded(entity);
                        };
                        image_1.onerror = function () {
                            callbacks.onError(entity, new Error("Error when loading " + entity.name));
                        };
                        image_1.crossOrigin = (entity.crossOrigin || false) ? 'Anonymous' : '';
                        image_1.src = url;
                        return [3 /*break*/, 3];
                    case 2:
                        error_1 = _a.sent();
                        callbacks.onError(entity, error_1);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * **尚未实现**。
     */
    AtlasLoader.prototype.instantiate = function (entity, options) {
        throw new Error('Not implemented !');
    };
    /**
     * 释放资源时将会调用，用于自定义释放逻辑。
     */
    AtlasLoader.prototype.release = function (entity) {
        entity.result.destroy();
    };
    AtlasLoader.EXTENSIONS = ['.atlas'];
    AtlasLoader = __decorate([
        SClass({ className: 'AtlasLoader' })
    ], AtlasLoader);
    return AtlasLoader;
}(ResourceLoader));

/**
 * 判断一个实例是否为`EventTrigger`。
 */
function isEventTrigger(value) {
    return value.isEventTrigger;
}
/**
 * 事件触发器类。触发器用于在事件管理器[EventManager](../eventmanager)注册事件时，添加特殊的自动分发功能。
 * 你可以继承此基类来派生自己的触发器，之后触发器便会自动得完成一些特殊事件的分发工作，比如HID（用户输入）。
 * 详细例子请看[CustomTrigger](../../example/event/custom-trigger)。
 *
 * @template TEvent 此触发器对应的事件参数类型。
 * @noInheritDoc
 */
var EventTrigger = /** @class */ (function (_super) {
    __extends(EventTrigger, _super);
    /**
     * 一般不需要自己调用。
     */
    function EventTrigger(type, eventManager, objHasGame) {
        if (objHasGame === void 0) { objHasGame = null; }
        var _this = _super.call(this) || this;
        _this.isEventTrigger = true;
        /**
         * 此触发器是否要在每一次事件触发时立即分发，如果不，怎会先缓存之后在每一帧更新之前统一分发。
         */
        _this.autoFlush = true;
        _this._type = null;
        _this._eventManager = null;
        _this._paused = true;
        _this._objHasGame = null;
        /**
         * **不要自己调用！！**
         *
         * @hidden
         */
        _this.trigger = function (event) {
            try {
                _this.onTrigger(event);
            }
            catch (error) {
                throwException(error, _this);
            }
            return _this;
        };
        _this._type = new SName(type);
        _this._eventManager = eventManager;
        _this._objHasGame = objHasGame;
        return _this;
    }
    Object.defineProperty(EventTrigger.prototype, "paused", {
        /**
         * 该触发器是否已暂停触发。
         */
        get: function () {
            return this._paused;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EventTrigger.prototype, "parent", {
        /**
         * 获取自身的父级实例引用，一般不需要自己使用。
         */
        get: function () {
            return this._eventManager;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 获取游戏实例引用。
     */
    EventTrigger.prototype.getGame = function () {
        return this._objHasGame.getGame();
    };
    /**
     * 生命周期，触发器开始运作时调用，你可以在这里初始化你的触发器。
     * 比如`window.addEventListener(eventName, this.trigger);`。
     */
    EventTrigger.prototype.onBegin = function () {
    };
    /**
     * 生命周期，触发器停止运作时调用，你可以在这里释放你的触发器。
     */
    EventTrigger.prototype.onPause = function () {
    };
    /**
     * 生命周期，触发器被触发前调用，你可以在这里。
     * 注意别忘了调用`super.onTrigger`来保证默认行为。
     */
    EventTrigger.prototype.onTrigger = function (event) {
        this._eventManager.trigger(this._type.value, event, this.autoFlush);
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    EventTrigger.prototype.begin = function () {
        this._paused = false;
        try {
            this.onBegin();
        }
        catch (error) {
            throwException(error, this);
        }
        return this;
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    EventTrigger.prototype.pause = function () {
        this._paused = true;
        try {
            this.onPause();
        }
        catch (error) {
            throwException(error, this);
        }
        return this;
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    EventTrigger.prototype.destroy = function () {
        this.pause();
    };
    EventTrigger = __decorate([
        SClass({ className: 'EventTrigger', classType: 'EventTrigger' })
    ], EventTrigger);
    return EventTrigger;
}(SObject));

/**
 * @hidden
 */
function createKeyboardTrigger(className, eventName) {
    var KeyBoardEventTrigger = /** @class */ (function (_super) {
        __extends(KeyBoardEventTrigger, _super);
        function KeyBoardEventTrigger() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isKeyBoardEventTrigger = true;
            _this.autoFlush = false;
            return _this;
        }
        KeyBoardEventTrigger.prototype.onBegin = function () {
            window.addEventListener(eventName, this.trigger);
        };
        KeyBoardEventTrigger.prototype.onTrigger = function (event) {
            if (className !== 'KeyDownTrigger') {
                event.preventDefault();
            }
            event.stopPropagation();
            _super.prototype.onTrigger.call(this, event);
        };
        KeyBoardEventTrigger.prototype.onPause = function () {
            window.removeEventListener(eventName, this.trigger);
        };
        KeyBoardEventTrigger = __decorate([
            SClass({ className: className })
        ], KeyBoardEventTrigger);
        return KeyBoardEventTrigger;
    }(EventTrigger));
    return KeyBoardEventTrigger;
}
var KeyDownTrigger = createKeyboardTrigger('KeyDownTrigger', 'keydown');
var KeyPressTrigger = createKeyboardTrigger('KeyPressTrigger', 'keypress');
var KeyUpTrigger = createKeyboardTrigger('KeyUpTrigger', 'keyup');

/**
 * @hidden
 */
function createTouchTrigger(className, eventName) {
    var TouchEventTrigger = /** @class */ (function (_super) {
        __extends(TouchEventTrigger, _super);
        function TouchEventTrigger() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isTouchEventTrigger = true;
            _this.autoFlush = false;
            return _this;
        }
        TouchEventTrigger.prototype.onBegin = function () {
            this.getGame().canvas.addEventListener(eventName, this.trigger);
        };
        TouchEventTrigger.prototype.onTrigger = function (event) {
            event.preventDefault();
            event.stopPropagation();
            _super.prototype.onTrigger.call(this, event);
        };
        TouchEventTrigger.prototype.onPause = function () {
            this.getGame().canvas.removeEventListener(eventName, this.trigger);
        };
        TouchEventTrigger = __decorate([
            SClass({ className: className })
        ], TouchEventTrigger);
        return TouchEventTrigger;
    }(EventTrigger));
    return TouchEventTrigger;
}
var TouchStartTrigger = createTouchTrigger('TouchStartTrigger', 'touchstart');
var TouchEndTrigger = createTouchTrigger('TouchEndTrigger', 'touchend');
var TouchMoveTrigger = createTouchTrigger('TouchMoveTrigger', 'touchmove');
var TouchCancelTrigger = createTouchTrigger('TouchCancelTrigger', 'touchcancel');

/**
 * @hidden
 */
function createMouseTrigger(className, eventName) {
    var MouseEventTrigger = /** @class */ (function (_super) {
        __extends(MouseEventTrigger, _super);
        function MouseEventTrigger() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isMouseEventTrigger = true;
            _this.autoFlush = false;
            return _this;
        }
        MouseEventTrigger.prototype.onBegin = function () {
            this.getGame().canvas.addEventListener(eventName, this.trigger);
        };
        MouseEventTrigger.prototype.onTrigger = function (event) {
            event.preventDefault();
            event.stopPropagation();
            _super.prototype.onTrigger.call(this, event);
        };
        MouseEventTrigger.prototype.onPause = function () {
            this.getGame().canvas.removeEventListener(eventName, this.trigger);
        };
        MouseEventTrigger = __decorate([
            SClass({ className: className })
        ], MouseEventTrigger);
        return MouseEventTrigger;
    }(EventTrigger));
    return MouseEventTrigger;
}
var MouseClickTrigger = createMouseTrigger('MouseClickTrigger', 'click');
var MouseDownTrigger = createMouseTrigger('MouseDownTrigger', 'mousedown');
var MouseUpTrigger = createMouseTrigger('MouseUpTrigger', 'mouseup');
var MouseEnterTrigger = createMouseTrigger('MouseEnterTrigger', 'mouseenter');
var MouseLeaveTrigger = createMouseTrigger('MouseLeaveTrigger', 'mouseleave');
var MouseMoveTrigger = createMouseTrigger('MouseMoveTrigger', 'mousemove');
var MouseOutTrigger = createMouseTrigger('MouseOutTrigger', 'mouseout');
var MouseOverTrigger = createMouseTrigger('MouseOverTrigger', 'mouseover');
var MouseWheelTrigger = createMouseTrigger('MouseWheelTrigger', 'mousewheel');
var WheelTrigger = createMouseTrigger('WheelTrigger', 'wheel');
var ContextMenuTrigger = createMouseTrigger('ContextMenuTrigger', 'contextmenu');

/**
 * 窗口大小改变时的触发器。
 *
 * @noInheritDoc
 */
var WindowResizeTrigger = /** @class */ (function (_super) {
    __extends(WindowResizeTrigger, _super);
    function WindowResizeTrigger() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isMouseEventTrigger = true;
        _this.autoFlush = false;
        return _this;
    }
    WindowResizeTrigger.prototype.onBegin = function () {
        window.addEventListener('resize', this.trigger);
    };
    WindowResizeTrigger.prototype.onPause = function () {
        window.removeEventListener('resize', this.trigger);
    };
    WindowResizeTrigger = __decorate([
        SClass({ className: 'WindowResizeTrigger' })
    ], WindowResizeTrigger);
    return WindowResizeTrigger;
}(EventTrigger));

/**
 * 判断一个实例是否为`Player`。
 */
function isPlayer(value) {
    return value.isPlayer;
}
/**
 * 玩家类，用于管理玩家的逻辑。
 * 一般不直接用于控制实例，而是使用其在`World`中的代理`PlayerControllerActor`。
 * 可以对齐进行继承扩展，来达到一种自顶向下的设计理念，详见[Player](../../guide/player)。
 *
 * @noInheritDoc
 */
var Player = /** @class */ (function (_super) {
    __extends(Player, _super);
    function Player(name, game) {
        var _this = _super.call(this, name) || this;
        _this.isPlayer = true;
        _this._game = game;
        return _this;
    }
    Object.defineProperty(Player.prototype, "parent", {
        /**
         * 父级为Game。
         */
        get: function () {
            return this._game;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Player.prototype, "controller", {
        /**
         * 直接获取无类型的控制器实例引用，建议使用`getController`替代。
         */
        get: function () {
            return this._controller;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Player.prototype, "state", {
        /**
         * 直接获取无类型的状态实例引用，建议使用`getState`替代。
         */
        get: function () {
            return this._controller.state;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 生命周期，在实例创建后触发。
     */
    Player.prototype.onInit = function () {
    };
    /**
     * 生命周期，在实例获取到控制器的所有权时触发。
     */
    Player.prototype.onSwitchController = function (controller) {
    };
    /**
     * 生命周期，在实例释放控制器的所有权时触发。
     */
    Player.prototype.onReleaseController = function (controller) {
    };
    /**
     * 生命周期，在每一帧更新时触发。
     */
    Player.prototype.onUpdate = function (delta) {
    };
    /**
     * 生命周期，用于错误边界处理。将在Game中大部分可预知错误发生时被调用（通常是生命周期中的非异步错误）。
     * 错误将会根据一定的路径向上传递，一直到`Engine`的层次，你可以在确保完美处理了问题后返回`true`来通知引擎不再向上传递。
     * 当然你也可以将自定义的一些错误加入错误边界机制中，详见[Exception](../../guide/exception)。
     */
    Player.prototype.onError = function (error, details) {
    };
    /**
     * 切换自身在World中代理的Controller。
     */
    Player.prototype.switchController = function (controller) {
        if (controller.player) {
            throw new BreakGuardException(this, "Controller " + controller.name + " already owned by player " + controller.parent.name + " !");
        }
        this._controller = controller;
        controller._player = this;
        try {
            this.onSwitchController(controller);
        }
        catch (error) {
            throwException(error, this);
        }
        return this;
    };
    /**
     * 释放当前自身在World中代理的Controller。
     */
    Player.prototype.releaseController = function () {
        try {
            this.onReleaseController(this._controller);
        }
        catch (error) {
            throwException(error, this);
        }
        if (this._controller) {
            this._controller._player = null;
        }
        this._controller = null;
        return this;
    };
    /**
     * 获取当前自身在World中代理的Controller。
     */
    Player.prototype.getController = function () {
        return this._controller;
    };
    /**
     * 获取当前自身在World中代理的Controller的状态。
     */
    Player.prototype.getState = function () {
        return this._controller.getState();
    };
    /**
     * 获取当前`Game`实例。
     *
     * @template IGameState 当前游戏状态管理器的类型。
     */
    Player.prototype.getGame = function () {
        return this._game;
    };
    /**
     * 获取当前`World`实例。
     *
     * @template IWorldState 当前世界状态管理器的类型。
     */
    Player.prototype.getWorld = function () {
        return this._game.world;
    };
    /**
     * 获取当前`Level`实例。
     *
     * @template ILevelState 当前关卡状态管理器的类型。
     */
    Player.prototype.getLevel = function () {
        return this._game.level;
    };
    /**
     * 仅在初始化了物理引擎之后，用于获取当前物理世界`PhysicWorld`实例。
     * 如何使用物理引擎请见**Guide**和**Demo**。
     */
    Player.prototype.getPhysicWorld = function () {
        return this._game.world.physicWorld;
    };
    /**
     * **不要自行调用！**
     *
     * @hidden
     */
    Player.prototype.update = function (delta) {
        try {
            this.onUpdate(delta);
        }
        catch (error) {
            throwException(error, this);
        }
    };
    /**
     * **不要自行调用！**
     *
     * @hidden
     */
    Player.prototype.destroy = function () {
        if (this._controller) {
            this._controller._player = null;
        }
        this._controller = null;
        this._game = null;
        _super.prototype.destroy.call(this);
    };
    Player = __decorate([
        SClass({ className: 'Player' })
    ], Player);
    return Player;
}(SObject));

/**
 * 判断一个实例是否为`InfoActor`。
 */
function isInfoActor(value) {
    return value.isInfoActor;
}
/**
 * 信息管理Actor基类。单纯的书记官，不放入场景内，仅仅作为信息的记录者。
 * 一般不直接使用，而是使用其派生类。
 *
 * @template IOptionTypes 初始化参数类型，一般交由由继承的类定义实现多态。
 * @template TRootComponent 根组件类型。
 *
 * @noInheritDoc
 */
var InfoActor = /** @class */ (function (_super) {
    __extends(InfoActor, _super);
    function InfoActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isInfoActor = true;
        /**
         * 更新优先级，只可在派生时指定，不可在初始化后的运行时修改！
         */
        _this.updatePriority = InfoActor_1.UPDATE_PRIORITY.Others;
        return _this;
    }
    InfoActor_1 = InfoActor;
    var InfoActor_1;
    /**
     * 默认的更新优先级。
     *
     * @member System 约定占用1000 ~ 2000
     * @member GameMode 约定占用2000 ~ 3000
     * @member LevelScript 约定占用3000 ~ 4000
     * @member State 约定占用4000 ~ 5000
     * @member Others 其他，默认直接追加到最后
     */
    InfoActor.UPDATE_PRIORITY = {
        System: 1000,
        GameMode: 2000,
        LevelScript: 3000,
        State: 4000,
        Others: -1
    };
    InfoActor = InfoActor_1 = __decorate([
        SClass({ className: 'InfoActor' })
    ], InfoActor);
    return InfoActor;
}(Actor));

/**
 * 判断一个实例是否为`StateActor`。
 */
function isStateActor(value) {
    return value.isStateActor;
}
/**
 * 状态管理Actor类。记录一些状态，比如`Game`所用的`GameState`、`World`所用的`WorldState`。
 *
 * @template IOptionTypes 初始化参数类型，一般交由由继承的类定义实现多态。
 *
 * @noInheritDoc
 */
var StateActor = /** @class */ (function (_super) {
    __extends(StateActor, _super);
    function StateActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isStateActor = true;
        _this.updatePriority = InfoActor.UPDATE_PRIORITY.State;
        return _this;
    }
    /**
     * 自定义复制接口，你可以定制改写它。
     */
    StateActor.prototype.copy = function (state) {
        if (!state) {
            return;
        }
        return this;
    };
    StateActor = __decorate([
        SClass({ className: 'StateActor' })
    ], StateActor);
    return StateActor;
}(InfoActor));

/**
 * 判断一个实例是否为`SystemActor`。
 */
function isSystemActor(value) {
    return value.isSystemActor;
}
/**
 * 系统Actor基类，派生一些系统类，比如物理引擎管理、声音系统等全局规则型Actor，它们在更新队列的最先端。
 *
 * @template IOptionTypes 初始化参数类型，一般交由由继承的类定义实现多态。
 *
 * @noInheritDoc
 */
var SystemActor = /** @class */ (function (_super) {
    __extends(SystemActor, _super);
    function SystemActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isSystemActor = true;
        _this.updatePriority = InfoActor.UPDATE_PRIORITY.System;
        return _this;
    }
    SystemActor = __decorate([
        SClass({ className: 'SystemActor' })
    ], SystemActor);
    return SystemActor;
}(InfoActor));

/**
 * 物理系统Actor，负责更新物理世界。
 *
 * @hidden
 * @noInheritDoc
 */
var PhysicSystemActor = /** @class */ (function (_super) {
    __extends(PhysicSystemActor, _super);
    function PhysicSystemActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isPhysicSystemActor = true;
        return _this;
    }
    PhysicSystemActor.prototype.onUpdate = function (delta) {
        var world = this.getWorld();
        if (world && world.physicWorld) {
            world.physicWorld.update(delta);
        }
    };
    PhysicSystemActor = __decorate([
        SClass({ className: 'PhysicSystemActor' })
    ], PhysicSystemActor);
    return PhysicSystemActor;
}(SystemActor));

/**
 * 判断一个实例是否为`CubeTextureLoader`。
 */
function isCubeTextureLoader(value) {
    return value.isCubeTextureLoader;
}
/**
 * @hidden
 */
var loader$1 = new Hilo3d$2.CubeTextureLoader();
/**
 * 纹理加载器。
 *
 * @noInheritDoc
 */
var CubeTextureLoader = /** @class */ (function (_super) {
    __extends(CubeTextureLoader, _super);
    function CubeTextureLoader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isCubeTextureLoader = true;
        return _this;
    }
    CubeTextureLoader.prototype.load = function (entity, callbacks) {
        var url = entity.url, images = entity.images;
        var baseUrl = (!url || url[url.length - 1] === '/') ? entity.url : entity.url + '/';
        loader$1.load({
            left: baseUrl + images.left,
            right: baseUrl + images.right,
            front: baseUrl + images.front,
            back: baseUrl + images.back,
            top: baseUrl + images.top,
            bottom: baseUrl + images.bottom,
            crossOrigin: entity.crossOrigin || false,
            uv: entity.uv || 0,
            flipY: entity.flipY,
            format: entity.format || Constants.RGB,
            internalFormat: entity.internalFormat || Constants.RGB,
            isImageCanRelease: entity.isImageCanRelease
        })
            .then(function (result) {
            entity.result = result;
            callbacks.onLoaded(entity);
        })
            .catch(function (error) { return callbacks.onError(entity, error); });
    };
    /**
     * 释放资源时将会调用，用于自定义释放逻辑。
     */
    CubeTextureLoader.prototype.release = function (entity) {
        entity.result.destroy();
    };
    CubeTextureLoader = __decorate([
        SClass({ className: 'CubeTextureLoader' })
    ], CubeTextureLoader);
    return CubeTextureLoader;
}(ResourceLoader));

/**
 * 判断一个实例是否为`Game`。
 */
function isGame(value) {
    return value.isGame;
}
/**
 * 游戏类，整个Game逻辑中实际的顶层类，将作为一个单例存在于整个Game中，通常使用`getGame`获取。
 *
 * @template IState Game的状态Actor类型，用于存储整个Game的全局状态。
 * @noInheritDoc
 */
var Game = /** @class */ (function (_super) {
    __extends(Game, _super);
    /**
     * @param StateClass 游戏全局状态实例的类
     * @param initState 游戏全局状态实例的初始值，若存在，将在初始化时从它clone
     */
    function Game(name, options, StateClass, initState) {
        if (StateClass === void 0) { StateClass = StateActor; }
        if (initState === void 0) { initState = null; }
        var _this = _super.call(this, name) || this;
        _this.isGame = true;
        /**
         * 当前的一些设备信息。
         */
        _this.deviceInfo = {
            touchable: !!(window && ('ontouchstart' in window))
        };
        _this._engine = null;
        _this._resource = null;
        _this._event = null;
        _this._hid = null;
        _this._worldsMeta = {};
        _this._defaultWorldName = null;
        _this._world = null;
        _this._actors = new SArray();
        _this._actorsForUpdate = new SArray();
        _this._actorsNeedUpdate = false;
        _this._actorsPriorities = [];
        _this._actorsPriorityCount = {};
        _this._players = new SMap();
        _this._defaultPlayer = null;
        _this._paused = true;
        _this._hiloStage = null;
        _this._initState = initState;
        _this._hiloStage = new Hilo3d$2.Stage(options);
        _this._hiloStage.needCallChildUpdate = false;
        _this._resource = new ResourceManager(_this);
        _this._event = new EventManager(_this);
        _this._hid = new EventManager(_this);
        _this._state = _this.addActor('game-state', StateClass);
        _this._state.copy(_this._initState);
        _this.canvas.style.width = '';
        _this.canvas.style.height = '';
        _this.initEvents();
        _this.initLoaders(options);
        _this.initSystems();
        try {
            _this.onInit();
        }
        catch (error) {
            throwException(error, _this);
        }
        _this._event.trigger('GameDidInit', { game: _this });
        return _this;
    }
    Object.defineProperty(Game.prototype, "state", {
        /**
         * Game状态Actor实例引用。
         */
        get: function () {
            return this._state;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "event", {
        /**
         * Game全局事件管理器实例引用。
         * 默认事件列表见[IGlobalDefaultEvents](../interfaces/iglobaldefaultevents`)。
         */
        get: function () {
            return this._event;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "hid", {
        /**
         * Game全局HID管理器全局实例引用。
         * 这实际上是一个特化过的事件管理器，默认事件列表见[IGlobalHIDDefaultEvents](../interfaces/iglobalhiddefaultevents`)。
         */
        get: function () {
            return this._hid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "fps", {
        /**
         * 当前Game锁帧帧率。
         */
        get: function () {
            return this._engine.options.fps;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "paused", {
        /**
         * 当前游戏是否处于暂停状态。
         */
        get: function () {
            return this._paused;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "parent", {
        /**
         * Game的父级引擎实例引用。
         */
        get: function () {
            return this._engine;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "game", {
        /**
         * @hidden
         */
        get: function () {
            return this;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "world", {
        /**
         * 当前`World`实例引用。一般不直接使用，而是用`actor.getWorld()`或`component.getWorld`，提供更好的泛型类型推断。
         */
        get: function () {
            return this._world;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "level", {
        /**
         * 当前`Level`实例引用。一般不直接使用，而是用`actor.getLevel()`或`component.getLevel`，提供更好的泛型类型推断。
         */
        get: function () {
            return this._world.level;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "players", {
        /**
         * 当前的玩家列表，要结合玩家系统，详见[Player](./player)。
         */
        get: function () {
            return this._players;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "actors", {
        /**
         * 当前`Game`实例下的所有Actor列表，注意列表中的`Actor`必须为`InfoActor`，单纯负责逻辑而没有`transform`。
         * 如果你需要实际上可视的Actor的列表，请参考`world.actors`。
         */
        get: function () {
            return this._actors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "resource", {
        /**
         * Game的全局资源管理器实例引用，用于加载和管理所有的Game资源。
         */
        get: function () {
            return this._resource;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "ticker", {
        /**
         * Game的全局Ticker，来自`Engine`类，所有Game共用。
         */
        get: function () {
            return this._engine.ticker;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "canvas", {
        /**
         * 当前的`canvas`实例引用。
         */
        get: function () {
            return this._hiloStage.canvas;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "screenWidth", {
        /**
         * 当前视口的实际像素宽度。
         */
        get: function () {
            return this.canvas.offsetWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "screenHeight", {
        /**
         * 当前视口的实际像素高度。
         */
        get: function () {
            return this.canvas.offsetHeight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "bound", {
        /**
         * 当前视口的实际边界属性。
         */
        get: function () {
            return this.canvas.getBoundingClientRect();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "screenAspect", {
        /**
         * 当前视口实际的纵横比。
         */
        get: function () {
            var _a = this.canvas, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight;
            return offsetWidth / offsetHeight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "env", {
        /**
         * 当前运行环境，一般为`development`或`production`。
         */
        get: function () {
            return Debug.env;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "devMode", {
        /**
         * `env`不为`production`时，判定为开发环境。
         */
        get: function () {
            return Debug.devMode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "renderer", {
        /**
         * @hidden
         */
        get: function () {
            return this._hiloStage.renderer;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Game.prototype, "hiloStage", {
        /**
         * @hidden
         */
        get: function () {
            return this._hiloStage;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    Game.prototype.getGame = function () {
        return this;
    };
    /**
     * 获取全局事件管理器引用。
     */
    Game.prototype.getEvent = function () {
        return this._event;
    };
    /**
     * 获取全局HID管理器引用。
     */
    Game.prototype.getHID = function () {
        return this._hid;
    };
    /**
     * 获取全局资源管理器引用。
     */
    Game.prototype.getResource = function () {
        return this._resource;
    };
    /**
     * 设定特定渲染配置。
     */
    Game.prototype.setOption = function (key, value) {
        this._hiloStage.renderer[key] = value;
        this._initState[key] = value;
    };
    /**
     * 获取特定渲染配置。
     */
    Game.prototype.getOption = function (key) {
        return this._initState[key];
    };
    /**
     * 生命周期，在Game初始化时被触发。
     * 大部分Game生命周期都有其对应的全局方法，建议在`game.event`中去监听使用。
     */
    Game.prototype.onInit = function () {
    };
    /**
     * 生命周期，在Game被添加到引擎成功后被触发。
     * 大部分Game生命周期都有其对应的全局方法，建议在`game.event`中去监听使用。
     */
    Game.prototype.onAdd = function () {
    };
    /**
     * 生命周期，在Game启动后被处罚。
     * 大部分Game生命周期都有其对应的全局方法，建议在`game.event`中去监听使用。
     */
    Game.prototype.onStart = function () {
    };
    /**
     * 生命周期，在Game被暂停前触发。
     * 大部分Game生命周期都有其对应的全局方法，建议在`game.event`中去监听使用。
     */
    Game.prototype.onPause = function () {
    };
    /**
     * 生命周期，在Game被唤醒后触发。
     * 大部分Game生命周期都有其对应的全局方法，建议在`game.event`中去监听使用。
     */
    Game.prototype.onResume = function () {
    };
    /**
     * 生命周期，用于错误边界处理。将在Game中大部分可预知错误发生时被调用（通常是生命周期中的非异步错误）。
     * 错误将会根据一定的路径向上传递，一直到`Engine`的层次，你可以在确保完美处理了问题后返回`true`来通知引擎不再向上传递。
     * 当然你也可以将自定义的一些错误加入错误边界机制中，详见[Exception](../../guide/exception)。
     */
    Game.prototype.onError = function (error, details) {
    };
    /**
     * 生命周期，在Game每一帧更新时被触发。
     * 大部分Game生命周期都有其对应的全局方法，建议在`game.event`中去监听使用。
     */
    Game.prototype.onUpdate = function (delta) {
    };
    /**
     * 生命周期，在Game销毁时被触发。
     * 大部分Game生命周期都有其对应的全局方法，建议在`game.event`中去监听使用。
     */
    Game.prototype.onDestroy = function () {
    };
    /**
     * 向Game类添加一个`World`。
     *
     * @param GameMode 承载World逻辑的Actor，需继承自`GameModeActor`，此World所有的Level都将共有这一个GameMode。
     * @param PersistentLevelScript World至少有一个默认的Level，在添加World时必须指定一个入口Level。
     * @param isDefault 此World是否是游戏默认的World，在游戏开始前至少有一个默认的World。
     */
    Game.prototype.addWorld = function (name, GameMode, PersistentLevelScript, isDefault) {
        if (isDefault === void 0) { isDefault = false; }
        this._worldsMeta[name] = {
            GameMode: GameMode,
            levels: {
                persistent: {
                    Script: PersistentLevelScript
                }
            }
        };
        if (isDefault || Object.keys(this._worldsMeta).length < 2) {
            this._defaultWorldName = name;
        }
        return this;
    };
    /**
     * 从Game类中移除一个`World`。
     *
     * 注意不能移除当前正在运作的World。
     */
    Game.prototype.removeWorld = function (name) {
        if (this._world.name.equalsTo(name)) {
            throw new BreakGuardException(this, "World " + name + " is running could not be removed !");
        }
        this._world.destroy();
        delete this._worldsMeta[name];
        return this;
    };
    /**
     * 切换当前正在运行的`World`。
     *
     * @param initState 如果需要，指定初始化状态，将会被clone，传`null`则没有效果。
     * @param needInheritActors 是否需要从上一个World继承Actors。
     */
    Game.prototype.switchWorld = function (name, initState, needInheritActors) {
        if (initState === void 0) { initState = null; }
        if (needInheritActors === void 0) { needInheritActors = false; }
        return __awaiter(this, void 0, void 0, function () {
            var inheritActors, oldWorld, _a, GameMode, levels;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this._worldsMeta[name]) {
                            throw new MissingMemberException(this, 'World', name, this);
                        }
                        oldWorld = this._world;
                        // todo: inherit actors from pre world
                        if (oldWorld) {
                            inheritActors = oldWorld.destroy(!needInheritActors);
                        }
                        _a = this._worldsMeta[name], GameMode = _a.GameMode, levels = _a.levels;
                        this._world = new World(name, GameMode, levels, this);
                        return [4 /*yield*/, this._world.init(initState)];
                    case 1:
                        _b.sent();
                        if (!(inheritActors && needInheritActors)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._world.switchLevel('persistent', null, inheritActors)];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.switchLevel('persistent')];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * 向指定World添加一个`Level`。
     *
     * @param Script 承载Level逻辑的Actor，需继承自`LevelScriptActor`。
     */
    Game.prototype.addLevel = function (worldName, levelName, Script) {
        if (!this._worldsMeta[worldName]) {
            throw new MissingMemberException(this, 'World', worldName, this);
        }
        if (this._worldsMeta[worldName].levels[levelName]) {
            throw new MemberConflictException(this, "Level of world " + worldName, levelName, this);
        }
        this._worldsMeta[worldName].levels[levelName] = { Script: Script };
        return this;
    };
    /**
     * 从指定World中移除一个`Level`。
     */
    Game.prototype.removeLevel = function (worldName, levelName) {
        if (!this._worldsMeta[worldName]) {
            return;
        }
        if (this._world.name.equalsTo(worldName) && this.level.name.equalsTo(levelName)) {
            throw new BreakGuardException(this, "Level " + worldName + " in world " + this._world.name + " is running could not be removed !");
        }
        delete this._worldsMeta[worldName].levels[levelName];
        return this;
    };
    /**
     * 切换当前World中运行的`Level`。
     * 注意Level之间的actors是会默认进入继承逻辑的。
     */
    Game.prototype.switchLevel = function (name, initState) {
        if (initState === void 0) { initState = null; }
        return this._world.switchLevel(name, initState);
    };
    /**
     * 通过指定的InfoActor类`ActorClass`和初始化参数`initOptions`，向Game中添加一个actor。
     * 注意继承自`SceneActor`或根组件为`SceneComponent`的Actor应当被添加到`World`中，而不是`Game`中。
     */
    Game.prototype.addActor = function (name, ActorClass, initOptions) {
        var actor = new ActorClass(name, this, initOptions);
        if (this.devMode) {
            try {
                actor.verifyAdding(initOptions);
            }
            catch (error) {
                throwException(error, actor);
                return;
            }
        }
        actor.initialized();
        var updatePriority = actor.updatePriority;
        var priorities = this._actorsPriorities;
        var priorityCount = this._actorsPriorityCount;
        var count = priorityCount[updatePriority];
        if (updatePriority === InfoActor.UPDATE_PRIORITY.Others) {
            this._actors.add(actor);
        }
        else {
            var length_1 = priorities.length;
            var index = 0;
            for (var i = 0; i < length_1; i += 1) {
                var p = priorities[i];
                if (updatePriority < p) {
                    break;
                }
                index += priorityCount[p];
            }
            if (count === undefined) {
                count = 0;
                priorities.push(updatePriority);
                /**
                 * @todo: change to insert sorting?
                 */
                priorities.sort();
            }
            priorityCount[updatePriority] = count + 1;
            this._actors.insert(index, actor);
        }
        actor._parent = this;
        actor.added();
        this._actorsNeedUpdate = true;
        return actor;
    };
    /**
     * 从Game中移除一个actor。
     */
    Game.prototype.removeActor = function (actor) {
        actor.destroy();
        actor._parent = null;
        this._actors.remove(actor);
        var updatePriority = actor.updatePriority;
        var priorities = this._actorsPriorities;
        var priorityCount = this._actorsPriorityCount;
        var count = priorityCount[updatePriority];
        if (updatePriority !== InfoActor.UPDATE_PRIORITY.Others) {
            count -= 1;
        }
        if (count === 0) {
            delete priorityCount[count];
            priorities.splice(priorities.indexOf(updatePriority), 1);
        }
        this._actorsNeedUpdate = true;
        return this;
    };
    /**
     * 通过指定的玩家类`PlayerClass`，向Game中创建一个Player。
     * 要结合玩家系统，详见[Player](./player)。
     */
    Game.prototype.createPlayer = function (name, PlayerClass, isDefault) {
        if (isDefault === void 0) { isDefault = false; }
        if (PlayerClass) {
            this._players.set(name, new PlayerClass(name, this));
        }
        else {
            this._players.set(name, new Player(name, this));
        }
        if (isDefault || this._players.empty) {
            this._defaultPlayer = name;
        }
        return this._players.get(name);
    };
    /**
     * 获取一个指定的Player实例引用。
     */
    Game.prototype.getPlayer = function (name) {
        if (!name && this._defaultPlayer) {
            name = this._defaultPlayer;
        }
        return this._players.get(name);
    };
    /**
     * 移除一个指定的Player。
     */
    Game.prototype.removePlayer = function (name) {
        var player = this._players.remove(name);
        player.releaseController();
        return this;
    };
    /**
     * 清空Player列表。
     */
    Game.prototype.clearPlayers = function () {
        this._players.forEach(function (player) {
            player.releaseController();
        });
        this._players.clear();
        return this;
    };
    Game.prototype.initLoaders = function (options) {
        this._resource.register('GlTF', GlTFLoader);
        this._resource.register('Image', ImageLoader);
        this._resource.register('Texture', TextureLoader);
        this._resource.register('CubeTexture', CubeTextureLoader);
        this._resource.register('Atlas', AtlasLoader);
        if (options.amcMemPages) {
            GlTFLoader.GET_EXTENSION_HANDLER('ALI_amc_mesh_compression').memPages = options.amcMemPages;
        }
    };
    Game.prototype.initEvents = function () {
        var _this = this;
        this._hid.register('MouseClick', MouseClickTrigger);
        this._hid.register('MouseDown', MouseDownTrigger);
        this._hid.register('MouseEnter', MouseEnterTrigger);
        this._hid.register('MouseLeave', MouseLeaveTrigger);
        this._hid.register('MouseMove', MouseMoveTrigger);
        this._hid.register('MouseOut', MouseOutTrigger);
        this._hid.register('MouseOver', MouseOverTrigger);
        this._hid.register('MouseUp', MouseUpTrigger);
        this._hid.register('MouseWheel', MouseWheelTrigger);
        this._hid.register('Wheel', WheelTrigger);
        this._hid.register('ContextMenu', ContextMenuTrigger);
        this._hid.register('KeyDown', KeyDownTrigger);
        this._hid.register('KeyUp', KeyUpTrigger);
        this._hid.register('KeyPress', KeyPressTrigger);
        this._hid.register('TouchStart', TouchStartTrigger);
        this._hid.register('TouchEnd', TouchEndTrigger);
        this._hid.register('TouchMove', TouchMoveTrigger);
        this._hid.register('TouchCancel', TouchCancelTrigger);
        this._event.register('Resize', WindowResizeTrigger);
        this._event.register('GameDidInit');
        this._event.register('GameDidStart');
        this._event.register('GameWillPause');
        this._event.register('GameDidResume');
        this._event.register('GameWillDestroy');
        this._event.register('WorldDidInit');
        this._event.register('WorldDidCreatePlayers');
        this._event.register('WorldWillDestroy');
        this._event.register('LevelDidInit');
        this._event.register('LevelWillPreload');
        this._event.register('LevelIsPreloading');
        this._event.register('LevelDidPreload');
        this._event.register('LevelDidCreateActors');
        this._event.register('LevelWillDestroy');
        this._event.register('WebglContextLost');
        this._event.register('WebglContextRestored');
        this._event.register('MainRendererWillStart');
        this._event.register('MainRendererIsCleared');
        this._event.register('MainRendererIsFinished');
        this._hiloStage.renderer.on('webglContextLost', function () { return _this._event.trigger('WebglContextLost'); });
        this._hiloStage.renderer.on('webglContextRestored', function () { return _this._event.trigger('WebglContextRestored'); });
        this._hiloStage.renderer.on('beforeRenderScene', function () { return _this._event.trigger('MainRendererIsCleared'); });
        this.event.add('Resize', function () { return _this.resize(); });
    };
    Game.prototype.initSystems = function () {
        this.game.addActor('physicSystem', PhysicSystemActor);
    };
    /**
     * 重置画布容器尺寸。
     */
    Game.prototype.resize = function (bound) {
        var _this = this;
        bound = bound || this.bound;
        var width = bound.width, height = bound.height;
        var _a = this._hiloStage, pixelRatio = _a.pixelRatio, renderer = _a.renderer;
        this._hiloStage.width = width;
        this._hiloStage.height = height;
        renderer.resize(width * pixelRatio, height * pixelRatio, true);
        if (this.world) {
            setTimeout(function () { return _this.world.resizeMainCamera(); }, 0);
        }
        return this;
    };
    /**
     * 启动这个游戏。
     */
    Game.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._defaultWorldName) {
                            throw new UnmetRequireException(this, 'A default world must be specified !');
                        }
                        this.resize();
                        return [4 /*yield*/, this.switchWorld(this._defaultWorldName)];
                    case 1:
                        _a.sent();
                        // destroyed
                        if (!this._engine) {
                            return [2 /*return*/, this];
                        }
                        this._engine.startGame(this);
                        this._paused = false;
                        this._event.trigger('GameDidStart', { game: this });
                        return [2 /*return*/, this];
                }
            });
        });
    };
    /**
     * 暂停这个游戏。
     */
    Game.prototype.pause = function () {
        if (this._paused) {
            return;
        }
        this._event.trigger('GameWillPause', { game: this });
        this._engine.pauseGame(this);
        this._paused = true;
        return this;
    };
    /**
     * 唤醒这个游戏。
     */
    Game.prototype.resume = function () {
        if (!this._paused) {
            return;
        }
        this._engine.resumeGame(this);
        this._paused = false;
        this._event.trigger('GameDidResume', { game: this });
        return this;
    };
    /**
     * 销毁这个游戏。
     */
    Game.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this._paused = true;
        this._event.trigger('GameWillDestroy', { game: this });
        this._engine.destroyGame(this);
        this._engine = null;
        this._hid.destroy();
        this._event.destroy();
        this._world.destroy();
        this.removeActor(this._state);
        this._actors.forEach(function (actor) { return actor.destroy(); });
        this._actors.clear();
        this._hiloStage.destroy();
        this._resource.destroy();
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    Game.prototype.update = function (delta) {
        this._hid.flushAll();
        this._event.flushAll();
        try {
            this.onUpdate(delta);
        }
        catch (error) {
            throwException(error, this);
        }
        if (this._actorsNeedUpdate) {
            this._actorsForUpdate.copy(this._actors);
            this._actorsNeedUpdate = false;
        }
        this._actorsForUpdate.forEach(function (actor) { return actor.update(delta); });
        this._players.forEach(function (player) { return player.update(delta); });
        if (this.world) {
            this.world.update(delta);
        }
    };
    Game = __decorate([
        SClass({ className: 'Game', classType: 'Game' })
    ], Game);
    return Game;
}(SObject));

/**
 * 判断一个实例是否为`GameModeActor`。
 */
function isGameModeActor(value) {
    return value.isGameModeActor;
}
/**
 * 游戏玩法逻辑Actor类。此类承载着一个`World`的整体玩法逻辑，适用于其下的所有`Level`。
 *
 * @template IWorldState 世界状态参数类型。
 *
 * @noInheritDoc
 */
var GameModeActor = /** @class */ (function (_super) {
    __extends(GameModeActor, _super);
    function GameModeActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isGameModeActor = true;
        _this.updatePriority = InfoActor.UPDATE_PRIORITY.GameMode;
        return _this;
    }
    Object.defineProperty(GameModeActor.prototype, "parent", {
        /**
         * 此实例的父级实际指向`Game`。
         */
        get: function () {
            return this._game;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GameModeActor.prototype, "state", {
        /**
         * 获取当前`World`的状态。
         */
        get: function () {
            return this.getWorld().state;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 一个特殊的生命周期，在`onAdd`之后触发，只有在此生命周期内，你可以**执行阻塞的异步逻辑**。
     * 这个生命周期一般用于用户登录、获取异步状态等逻辑，谨慎使用！
     */
    GameModeActor.prototype.onLogin = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    /**
     * 生命周期，在`onLogin`之后触发。
     * 用于创建游戏玩家`Player`，默认会创建一个名为`'player'`的玩家。
     */
    GameModeActor.prototype.onCreatePlayers = function () {
        this._game.createPlayer('player', null, true);
    };
    /**
     * 生命周期，在`onDestroy`之后触发。
     * 用于销毁玩家，默认不执行销毁，即保留玩家。
     */
    GameModeActor.prototype.onDestroyPlayers = function () {
    };
    /**
     * 指定一个状态类，在此类所从属的`World`实例化时，会由其生成默认的`WorldState`实例。
     */
    GameModeActor.WorldStateClass = StateActor;
    GameModeActor = __decorate([
        SClass({ className: 'GameModeActor' })
    ], GameModeActor);
    return GameModeActor;
}(InfoActor));

/**
 * 判断一个实例是否为`LevelScriptActor`。
 */
function isLevelScriptActor(value) {
    return value.isLevelScriptActor;
}
/**
 * 游戏关卡逻辑Actor类。此类承载着一个`Level`的具体逻辑。
 *
 * @template ILevelState 关卡状态参数类型。
 *
 * @noInheritDoc
 */
var LevelScriptActor = /** @class */ (function (_super) {
    __extends(LevelScriptActor, _super);
    function LevelScriptActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isLevelScriptActor = true;
        _this.updatePriority = InfoActor.UPDATE_PRIORITY.LevelScript;
        return _this;
    }
    Object.defineProperty(LevelScriptActor.prototype, "parent", {
        /**
         * 此实例的父级实际指向`World`。
         */
        get: function () {
            return this._game.world;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LevelScriptActor.prototype, "state", {
        /**
         * 获取当前`Level`的状态。
         */
        get: function () {
            return this.getLevel().state;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 一个特殊的生命周期，在`onAdd`之后触发，只有在此生命周期内，你可以**执行阻塞的异步逻辑**。
     * 这个生命周期一般用于用户登录、获取异步状态等逻辑，谨慎使用！
     */
    LevelScriptActor.prototype.onLogin = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    /**
     * 生命周期，在`onLogin`之后触发。
     * 这个生命周期用于关卡资源初始化，你也可以在这里直接创建一些Actor用于加载动画等。
     */
    LevelScriptActor.prototype.onPreload = function () {
    };
    /**
     * 生命周期，在`onPreload`之后、每一次资源加载进度更新时触发。
     * 你可以在这里更新你的家在进度。
     */
    LevelScriptActor.prototype.onLoading = function (state) {
    };
    /**
     * 生命周期，在`onLoading`结束之后触发。
     * 到了这个生命周期，所有的资源已经加载完毕就位，你可以执行实际上场景的创建了。
     */
    LevelScriptActor.prototype.onCreate = function () {
    };
    /**
     * 指定一个状态类，在此类所从属的`Level`实例化时，会由其生成默认的`LevelState`实例。
     */
    LevelScriptActor.LevelStateClass = StateActor;
    LevelScriptActor = __decorate([
        SClass({ className: 'LevelScriptActor' })
    ], LevelScriptActor);
    return LevelScriptActor;
}(InfoActor));

/**
 * 判断一个实例是否为`Timer`。
 */
function isTimerActor(value) {
    return value.isTimerActor;
}
/**
 * 定时器。
 *
 * @noInheritDoc
 */
var TimerActor = /** @class */ (function (_super) {
    __extends(TimerActor, _super);
    function TimerActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isTimerActor = true;
        _this._state = {
            times: 0,
            timeStep: 0,
            current: 0
        };
        _this._delta = 0;
        _this._paused = false;
        _this._stopped = false;
        return _this;
    }
    Object.defineProperty(TimerActor.prototype, "event", {
        /**
         * Timer的事件管理器。
         *
         * ```ts
         * EventManager<{
         *  Start: ITimerState;
         *  Pause: ITimerState;
         *  Resume: ITimerState;
         *  Step: ITimerState;
         *  End: ITimerState;
         * }>
         * ```
         *
         * [ITimerState](../interfaces/itimerstate)
         */
        get: function () {
            return this._root.event;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 初始化，继承请先`super.onInit()`。
     */
    TimerActor.prototype.onInit = function () {
        this.event.register('Start');
        this.event.register('Pause');
        this.event.register('Resume');
        this.event.register('Step');
        this.event.register('End');
    };
    /**
     * 每帧更新，继承请先`super.onUpdate()`。
     */
    TimerActor.prototype.onUpdate = function (delta) {
        if (this._stopped) {
            this._delta = 0;
            return;
        }
        if (this._delta < this._state.timeStep) {
            this._delta += delta;
            return;
        }
        this._delta = 0;
        if (this._state.current === this._state.times) {
            this.stop();
            return;
        }
        this._state.current += 1;
        this.event.trigger('Step', this._state);
    };
    /**
     * 启动Timer。
     *
     * @param times 此次倒计时总步数。
     * @param timeStep 此次倒计每次步长。
     */
    TimerActor.prototype.start = function (times, timeStep) {
        this._state.times = times;
        this._state.timeStep = timeStep;
        this._state.current = 0;
        this.event.trigger('Start', this._state);
        this._paused = false;
        this._stopped = false;
        return this;
    };
    /**
     * 暂停Timer。
     */
    TimerActor.prototype.pause = function () {
        if (this._paused || this._stopped) {
            return;
        }
        this._paused = true;
        this.event.trigger('Pause', this._state);
        return this;
    };
    /**
     * 唤醒Timer。
     */
    TimerActor.prototype.resume = function () {
        if (this._stopped || !this._paused) {
            return;
        }
        this._delta = 0;
        this.event.trigger('Resume', this._state);
        this._paused = false;
        return this;
    };
    /**
     * 停止Timer。
     */
    TimerActor.prototype.stop = function () {
        this._stopped = true;
        this.event.trigger('End', this._state);
        return this;
    };
    TimerActor = __decorate([
        SClass({ className: 'Timer', classType: 'Timer' })
    ], TimerActor);
    return TimerActor;
}(InfoActor));

/**
 * Sein.js封装的用于存储`SObject`实例的特殊Set容器。
 * 通过实例的`uuid`表征唯一性。
 *
 * @template T 存储的实例的类型。
 */
var SSet = /** @class */ (function (_super) {
    __extends(SSet, _super);
    function SSet() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._table = {};
        return _this;
    }
    /**
     * 添加一个实例到SArray中。
     */
    SSet.prototype.add = function (item) {
        if (this._table[item.uuid]) {
            return;
        }
        this.addItem(item);
        this._table[item.uuid] = item;
        return this;
    };
    /**
     * 从容器中移除一个实例。
     */
    SSet.prototype.remove = function (item) {
        if (!this._table[item.uuid]) {
            return;
        }
        this.removeItem(item);
        delete this._table[item.uuid];
        return this;
    };
    /**
     * 清空所有存储的实例。
     */
    SSet.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this._table = {};
        return this;
    };
    /**
     * 从一个基本的数组实例初始化SIterable。
     */
    SSet.prototype.fromArray = function (array) {
        this.clear();
        var length = array.length;
        for (var index = 0; index < length; index += 1) {
            this.add(array[index]);
        }
        return this;
    };
    return SSet;
}(SIterable));

/**
 * 判断一个实例是否为`TypeConflictException`。
 */
function isTypeConflictException(value) {
    return value.isTypeConflictException;
}
/**
 * 类型冲突异常。
 *
 * @noInheritDoc
 */
var TypeConflictException = /** @class */ (function (_super) {
    __extends(TypeConflictException, _super);
    /**
     * 构建异常。
     *
     * @param member 成员实例。
     * @param requireType 需求的类型。
     * @param object 触发异常的实例。
     * @param message 追加信息。
     */
    function TypeConflictException(member, requireType, object, message) {
        if (message === void 0) { message = ''; }
        var _this = _super.call(this, 'TypeConflict', object, "Type of \"" + member.name + "\" is \"" + member.classType + "\", but type \"" + requireType + "\" is required. \"" + parent.name + "\". " + message) || this;
        _this.isTypeConflictException = true;
        return _this;
    }
    return TypeConflictException;
}(BaseException));

/**
 * 判断一个实例是否为`ControllerActor`。
 */
function isControllerActor(value) {
    return value.isControllerActor;
}
/**
 * 控制器类，作为`World`中棋子SceneActor的抽象逻辑控制代理。
 * 一般不直接使用，而是使用其派生类`PlayerControllerActor`和`AIControllerActor`。
 * 和玩家系统有关，详见[Player](./player)。
 *
 * @template IState 指定状态的类型。
 * @template IActor 指定允许控制的Actor的类型。
 * @noInheritDoc
 */
var ControllerActor = /** @class */ (function (_super) {
    __extends(ControllerActor, _super);
    function ControllerActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isControllerActor = true;
        _this._follow = false;
        return _this;
    }
    Object.defineProperty(ControllerActor.prototype, "actor", {
        /**
         * 获取当前控制的actor。
         */
        get: function () {
            return this._actor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ControllerActor.prototype, "state", {
        /**
         * 获取当前关联的状态。
         */
        get: function () {
            return this._state;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 生命周期，将在获得了一个actor的控制权时呗触发。
     */
    ControllerActor.prototype.onPossesActor = function (actor) {
    };
    /**
     * 生命周期，将在失去了一个actor的控制权时呗触发。
     */
    ControllerActor.prototype.onDisPossesActor = function (actor) {
    };
    /**
     * 控制一个actor。
     */
    ControllerActor.prototype.possessActor = function (actor) {
        if (this._actor) {
            throw new BreakGuardException(this, "Controller " + this.name + " already has actor " + this.actor.name + " !");
        }
        if (actor._controller) {
            throw new BreakGuardException(this, "Actor " + actor.name + " already controlled by controller " + actor.getController().name + " !");
        }
        this._actor = actor;
        this._actor._controller = this;
        try {
            this.onPossesActor(actor);
        }
        catch (error) {
            throwException(error, this);
        }
        return this;
    };
    /**
     * 解除一个actor的控制。
     *
     * @param transferTo 如果存在，将当前控制的actor的控制权移交。
     */
    ControllerActor.prototype.dispossessActor = function (transferTo) {
        try {
            this.onDisPossesActor(this._actor);
        }
        catch (error) {
            throwException(error, this);
        }
        if (this._actor) {
            this._actor.controller = null;
        }
        this._actor = null;
        if (transferTo) {
            transferTo.possessActor(this);
        }
        return this;
    };
    /**
     * 获取当前控制的actor，可用于类型推断。
     */
    ControllerActor.prototype.getActor = function () {
        return this._actor;
    };
    ControllerActor.prototype.switchState = function (state) {
        if (state.controller) {
            state.controller._state = null;
        }
        this._state = state;
        state._controller = this;
        return this;
    };
    /**
     * 获取当前关联的状态，可用于类型推断。
     */
    ControllerActor.prototype.getState = function () {
        return this._state;
    };
    /**
     * 跟随actor，由于ControllerActor自身也是`SceneActor`，所以其自己也有`transform`。
     * 你可以给其添加一个摄像机组件来达成一些有意思的玩法。
     */
    ControllerActor.prototype.followActor = function () {
        this._follow = true;
        return this;
    };
    /**
     * 取消跟随`Actor`。
     */
    ControllerActor.prototype.unFollowActor = function () {
        this._follow = false;
        return this;
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    ControllerActor.prototype.added = function () {
        _super.prototype.added.call(this);
        var initState = this._initOptions;
        if (initState.state) {
            this.switchState(initState.state);
        }
        if (initState.actor) {
            this.possessActor(initState.actor);
        }
        this._follow = !!initState.followActor;
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    ControllerActor.prototype.update = function (delta) {
        _super.prototype.update.call(this, delta);
        if (this._follow && this._actor) {
            this.transform.matrix.copy(this._actor.transform.matrix);
        }
    };
    ControllerActor = __decorate([
        SClass({ className: 'ControllerActor', classType: 'Controller' })
    ], ControllerActor);
    return ControllerActor;
}(SceneActor));

/**
 * 判断一个实例是否为`PlayerControllerActor`。
 */
function isPlayerControllerActor(value) {
    return value.isPlayerControllerActor;
}
/**
 * 玩家控制器类，区别于AI控制器，和玩家系统有关，详见[Player](./player)。
 *
 * @template IState 指定状态的类型。
 * @template IActor 指定允许控制的Actor的类型。
 * @noInheritDoc
 */
var PlayerControllerActor = /** @class */ (function (_super) {
    __extends(PlayerControllerActor, _super);
    function PlayerControllerActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isPlayerControllerActor = true;
        _this.persistent = true;
        return _this;
    }
    Object.defineProperty(PlayerControllerActor.prototype, "player", {
        /**
         * 获取当前拥有自身的玩家。
         */
        get: function () {
            return this._player;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 设置当前拥有自身的玩家。
     */
    PlayerControllerActor.prototype.setPlayer = function (player) {
        player.switchController(this);
        return this;
    };
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    PlayerControllerActor.prototype.onDestroy = function () {
        if (this._player) {
            this._player.releaseController();
        }
        _super.prototype.onDestroy.call(this);
    };
    PlayerControllerActor = __decorate([
        SClass({ className: 'PlayerControllerActor' })
    ], PlayerControllerActor);
    return PlayerControllerActor;
}(ControllerActor));

/**
 * 判断一个实例是否为`PlayerStateActor`。
 */
function isPlayerStateActor(value) {
    return value.isPlayerStateActor;
}
/**
 * 用户状态类，可被`ControllerActor`关联。
 * 和玩家系统有关，详见[Player](./player)。
 *
 * @template IOptionTypes 初始化参数类型。
 * @noInheritDoc
 */
var PlayerStateActor = /** @class */ (function (_super) {
    __extends(PlayerStateActor, _super);
    function PlayerStateActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isPlayerStateActor = true;
        return _this;
    }
    /**
     * 获取当前关联的Controller。
     */
    PlayerStateActor.prototype.getController = function () {
        return this._controller;
    };
    PlayerStateActor = __decorate([
        SClass({ className: 'PlayerStateActor' })
    ], PlayerStateActor);
    return PlayerStateActor;
}(StateActor));

/**
 * 判断一个实例是否为`AIControllerActor`。
 */
function isAIControllerActor(value) {
    return value.isAIControllerActor;
}
/**
 * AI控制器类，区别于玩家控制器，完全由代码逻辑控制。
 * 和玩家系统有关，详见[Player](./player)。
 *
 * @template IState 指定状态的类型。
 * @template IActor 指定允许控制的Actor的类型。
 * @noInheritDoc
 */
var AIControllerActor = /** @class */ (function (_super) {
    __extends(AIControllerActor, _super);
    function AIControllerActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isAIControllerActor = true;
        return _this;
        // todo: 添加默认行为树
    }
    AIControllerActor = __decorate([
        SClass({ className: 'AIControllerActor' })
    ], AIControllerActor);
    return AIControllerActor;
}(ControllerActor));

/**
 * 判断一个实例是否为`Fog`。
 */
function isFog(value) {
    return value.isFog;
}
var Fog = /** @class */ (function (_super) {
    __extends(Fog, _super);
    function Fog() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Fog;
}(Hilo3d$2.Fog));

/**
 * 判断一个实例是否为`FrameBuffer`。
 */
function isFrameBuffer(value) {
    return value.isFramebuffer;
}
/**
 * FrameBuffer。可以作为渲染的目标对象。
 */
var FrameBuffer = /** @class */ (function (_super) {
    __extends(FrameBuffer, _super);
    function FrameBuffer(game, options) {
        return _super.call(this, game.renderer, options) || this;
    }
    return FrameBuffer;
}(Hilo3d$2.Framebuffer));

/**
 * 判断一个实例是否为`RenderSystemActor`。
 */
function isRenderSystemActor(value) {
    return value.isRenderSystemActor;
}
/**
 * 渲染系统，可以用于精确控制整个渲染流程，达到需要多个PASS的渲染的效果（例如镜面、后处理等等）。
 *
 * 实例请见[进阶渲染](../../example/render/advance)。
 */
var RenderSystemActor = /** @class */ (function (_super) {
    __extends(RenderSystemActor, _super);
    function RenderSystemActor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isRenderSystemActor = true;
        _this.handlePreRender = function () { return _this.onPreRender(_this._initOptions); };
        _this.handlePostClear = function () { return _this.onPostClear(_this._initOptions); };
        _this.handlePostRender = function () { return _this.onPostRender(_this._initOptions); };
        return _this;
    }
    /**
     * 初始化，继承请先调用`super.onInit`。
     */
    RenderSystemActor.prototype.onInit = function (initOptions) {
        this.bindEvents();
    };
    /**
     * 取消链接，将会暂时让功能失效，继承请先调用`super.onUnLink`。
     */
    RenderSystemActor.prototype.onUnLink = function () {
        this.unBindEvents();
    };
    /**
     * 取消链接，将会让功能恢复，继承请先调用`super.onReLink`。
     */
    RenderSystemActor.prototype.onReLink = function () {
        this.bindEvents();
    };
    /**
     * 在整个世界中的所有物体被默认渲染前触发。
     * **注意不要在这里切换主相机！**
     */
    RenderSystemActor.prototype.onPreRender = function (initOptions) {
    };
    /**
     * 在整个画面被`Clear`后触发。
     * 如果想默认渲染到`Renderer`内置的`Frame`或者插入一些类似于手机相机的画面等，可以在这里完成。
     * **注意不要在这里修改任何图层！也不要在这里切换主相机！**
     */
    RenderSystemActor.prototype.onPostClear = function (initOptions) {
    };
    /**
     * 在整个所有的模型被默认渲染到屏幕后触发。
     * **注意不要在这里切换主相机！**
     */
    RenderSystemActor.prototype.onPostRender = function (initOptions) {
    };
    /**
     * 销毁逻辑，继承请先调用`super.onDestroy`。
     */
    RenderSystemActor.prototype.onDestroy = function () {
        this.unBindEvents();
    };
    RenderSystemActor.prototype.bindEvents = function () {
        var game = this.getGame();
        game.event.add('MainRendererWillStart', this.handlePreRender);
        game.event.add('MainRendererIsCleared', this.handlePostClear);
        game.event.add('MainRendererIsFinished', this.handlePostRender);
    };
    RenderSystemActor.prototype.unBindEvents = function () {
        var game = this.getGame();
        game.event.remove('MainRendererWillStart', this.handlePreRender);
        game.event.remove('MainRendererIsCleared', this.handlePostClear);
        game.event.remove('MainRendererIsFinished', this.handlePostRender);
    };
    RenderSystemActor = __decorate([
        SClass({ className: 'RenderSystemActor' })
    ], RenderSystemActor);
    return RenderSystemActor;
}(SystemActor));

var VertexArrayObject = /** @class */ (function (_super) {
    __extends(VertexArrayObject, _super);
    function VertexArrayObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return VertexArrayObject;
}(Hilo3d$2.VertexArrayObject));

var Program = /** @class */ (function (_super) {
    __extends(Program, _super);
    function Program() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Program;
}(Hilo3d$2.Program));

/**
 * @File   : GLCapabilities.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 6/10/2019, 10:40:17 PM
 * @Description:
 */
var GLCapabilities = Hilo3d$2.capabilities;

/**
 * @File   : GLExtensions.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 6/10/2019, 10:40:59 PM
 * @Description:
 */
var GLExtensions = Hilo3d$2.extensions;

var Buffer = /** @class */ (function (_super) {
    __extends(Buffer, _super);
    function Buffer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Buffer;
}(Hilo3d$2.Buffer));

/**
 * 判断一个实例是否为`BSPBoxComponent`。
 */
function isBSPBoxComponent(value) {
    return value.isBSPBoxComponent;
}
/**
 * 判断一个实例是否为`BSPBoxActor`。
 */
function isBSPBoxActor(value) {
    return isSceneActor(value) && isBSPBoxComponent(value.root);
}
/**
 * 基础立方体。
 *
 * @noInheritDoc
 */
var BSPBoxComponent = /** @class */ (function (_super) {
    __extends(BSPBoxComponent, _super);
    function BSPBoxComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isBSPBoxComponent = true;
        return _this;
    }
    BSPBoxComponent.prototype.convertState = function (initState) {
        var width = initState.width, height = initState.height, depth = initState.depth, widthSegments = initState.widthSegments, heightSegments = initState.heightSegments, depthSegments = initState.depthSegments, others = __rest(initState, ["width", "height", "depth", "widthSegments", "heightSegments", "depthSegments"]);
        var result = others;
        result.geometry = new BoxGeometry(initState);
        return result;
    };
    BSPBoxComponent = __decorate([
        SClass({ className: 'BSPBoxComponent' })
    ], BSPBoxComponent);
    return BSPBoxComponent;
}(BSPComponent));

/**
 * 判断一个实例是否为`PlaneGeometry`。
 */
function isPlaneGeometry(value) {
    return value.isPlaneGeometry;
}
var PlaneGeometry = /** @class */ (function (_super) {
    __extends(PlaneGeometry, _super);
    function PlaneGeometry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PlaneGeometry;
}(Hilo3d$2.PlaneGeometry));

/**
 * 判断一个实例是否为`BSPPlaneComponent`。
 */
function isBSPPlaneComponent(value) {
    return value.isBSPPlaneComponent;
}
/**
 * 判断一个实例是否为`BSPPlaneActor`。
 */
function isBSPPlaneActor(value) {
    return isSceneActor(value) && isBSPPlaneComponent(value.root);
}
/**
 * 基础平面。
 *
 * @noInheritDoc
 */
var BSPPlaneComponent = /** @class */ (function (_super) {
    __extends(BSPPlaneComponent, _super);
    function BSPPlaneComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isBSPPlaneComponent = true;
        return _this;
    }
    BSPPlaneComponent.prototype.convertState = function (initState) {
        var width = initState.width, height = initState.height, widthSegments = initState.widthSegments, heightSegments = initState.heightSegments, others = __rest(initState, ["width", "height", "widthSegments", "heightSegments"]);
        var result = others;
        result.geometry = new PlaneGeometry(initState);
        return result;
    };
    BSPPlaneComponent = __decorate([
        SClass({ className: 'BSPPlaneComponent' })
    ], BSPPlaneComponent);
    return BSPPlaneComponent;
}(BSPComponent));

/**
 * 判断一个实例是否为`BSPSphereComponent`。
 */
function isBSPSphereComponent(value) {
    return value.isBSPSphereComponent;
}
/**
 * 判断一个实例是否为`BSPSphereActor`。
 */
function isBSPSphereActor(value) {
    return isSceneActor(value) && isBSPSphereComponent(value.root);
}
/**
 * 基础球体。
 *
 * @noInheritDoc
 */
var BSPSphereComponent = /** @class */ (function (_super) {
    __extends(BSPSphereComponent, _super);
    function BSPSphereComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isBSPSphereComponent = true;
        return _this;
    }
    BSPSphereComponent.prototype.convertState = function (initState) {
        var radius = initState.radius, widthSegments = initState.widthSegments, heightSegments = initState.heightSegments, others = __rest(initState, ["radius", "widthSegments", "heightSegments"]);
        var result = others;
        result.geometry = new SphereGeometry(initState);
        return result;
    };
    BSPSphereComponent = __decorate([
        SClass({ className: 'BSPSphereComponent' })
    ], BSPSphereComponent);
    return BSPSphereComponent;
}(BSPComponent));

/**
 * 判断一个实例是否为`Geometry`。
 */
function isGeometry(value) {
    return value.isGeometry;
}
var Geometry = /** @class */ (function (_super) {
    __extends(Geometry, _super);
    function Geometry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Geometry;
}(Hilo3d$2.Geometry));

/**
 * 判断一个实例是否为`GeometryData`。
 */
function isGeometryData(value) {
    return value.isGeometryData;
}
var GeometryData = /** @class */ (function (_super) {
    __extends(GeometryData, _super);
    function GeometryData(data, size, params) {
        return _super.call(this, data, size, params) || this;
    }
    return GeometryData;
}(Hilo3d$2.GeometryData));

/**
 * 判断一个实例是否为`CylinderGeometry`。
 */
function isCylinderGeometry(value) {
    return value.isCylinderGeometry;
}
/**
 * 圆柱几何体。
 *
 * @noInheritDoc
 */
var CylinderGeometry = /** @class */ (function (_super) {
    __extends(CylinderGeometry, _super);
    function CylinderGeometry(params) {
        var _this = _super.call(this, params) || this;
        _this.isCylinderGeometry = true;
        _this.className = 'CylinderGeometry';
        _this._options = {
            radiusTop: 1,
            radiusBottom: 1,
            height: 1,
            radialSegments: 8,
            heightSegments: 1,
            openEnded: false,
            thetaStart: 0,
            thetaLength: Math.PI * 2
        };
        Object.assign(_this._options, params);
        _this.build();
        return _this;
    }
    /* tslint:disable */
    CylinderGeometry.prototype.build = function () {
        var _a = this._options, radiusTop = _a.radiusTop, radiusBottom = _a.radiusBottom, height = _a.height, radialSegments = _a.radialSegments, heightSegments = _a.heightSegments, openEnded = _a.openEnded, thetaStart = _a.thetaStart, thetaLength = _a.thetaLength;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var index = 0;
        var indexArray = [];
        var halfHeight = height / 2;
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0) {
                generateCap(true);
            }
            if (radiusBottom > 0) {
                generateCap(false);
            }
        }
        this.vertices = new GeometryData(new Float32Array(vertices), 3, null);
        this.indices = new GeometryData(new Uint16Array(indices), 1, null);
        this.uvs = new GeometryData(new Float32Array(uvs), 2, null);
        this.normals = new GeometryData(new Float32Array(normals), 3, null);
        function generateTorso() {
            var x;
            var y;
            var normal = new Vector3();
            var vertex = new Vector3();
            // this will be used to calculate the normal
            var slope = (radiusBottom - radiusTop) / height;
            // generate vertices, normals and uvs
            for (y = 0; y <= heightSegments; y++) {
                var indexRow = [];
                var v = y / heightSegments;
                // calculate the radius of the current row
                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);
                    // vertex
                    vertex.x = radius * sinTheta;
                    vertex.y = -v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // normal
                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    // uv
                    uvs.push(u, 1 - v);
                    // save index of vertex in respective row
                    indexRow.push(index++);
                }
                // now save vertices of the row in our index array
                indexArray.push(indexRow);
            }
            // generate indices
            for (x = 0; x < radialSegments; x++) {
                for (y = 0; y < heightSegments; y++) {
                    // we use the index array to access the correct indices
                    var a = indexArray[y][x];
                    var b = indexArray[y + 1][x];
                    var c = indexArray[y + 1][x + 1];
                    var d = indexArray[y][x + 1];
                    // faces
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
        }
        function generateCap(top) {
            var x;
            var centerIndexStart;
            var centerIndexEnd;
            var uv = new Vector2();
            var vertex = new Vector3();
            var radius = (top === true) ? radiusTop : radiusBottom;
            var sign = (top === true) ? 1 : -1;
            // save the index of the first center vertex
            centerIndexStart = index;
            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment
            for (x = 1; x <= radialSegments; x++) {
                // vertex
                vertices.push(0, halfHeight * sign, 0);
                // normal
                normals.push(0, sign, 0);
                // uv
                uvs.push(0.5, 0.5);
                // increase index
                index++;
            }
            // save the index of the last center vertex
            centerIndexEnd = index;
            // now we generate the surrounding vertices, normals and uvs
            for (x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;
                var cosTheta = Math.cos(theta);
                var sinTheta = Math.sin(theta);
                // vertex
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                // normal
                normals.push(0, sign, 0);
                // uv
                uv.x = (cosTheta * 0.5) + 0.5;
                uv.y = (sinTheta * 0.5 * sign) + 0.5;
                uvs.push(uv.x, uv.y);
                // increase index
                index++;
            }
            // generate indices
            for (x = 0; x < radialSegments; x++) {
                var c = centerIndexStart + x;
                var i = centerIndexEnd + x;
                if (top === true) {
                    // face top
                    indices.push(i, i + 1, c);
                }
                else {
                    // face bottom
                    indices.push(i + 1, i, c);
                }
            }
        }
    };
    return CylinderGeometry;
}(Geometry));

/**
 * 判断一个实例是否为`BSPCylinderComponent`。
 */
function isBSPCylinderComponent(value) {
    return value.isBSPCylinderComponent;
}
/**
 * 判断一个实例是否为`BSPCylinderActor`。
 */
function isBSPCylinderActor(value) {
    return isSceneActor(value) && isBSPCylinderComponent(value.root);
}
/**
 * 基础圆柱体。
 *
 * @noInheritDoc
 */
var BSPCylinderComponent = /** @class */ (function (_super) {
    __extends(BSPCylinderComponent, _super);
    function BSPCylinderComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isBSPCylinderComponent = true;
        return _this;
    }
    BSPCylinderComponent.prototype.convertState = function (initState) {
        var radiusTop = initState.radiusTop, radiusBottom = initState.radiusBottom, height = initState.height, radialSegments = initState.radialSegments, heightSegments = initState.heightSegments, openEnded = initState.openEnded, thetaStart = initState.thetaStart, thetaLength = initState.thetaLength, others = __rest(initState, ["radiusTop", "radiusBottom", "height", "radialSegments", "heightSegments", "openEnded", "thetaStart", "thetaLength"]);
        var result = others;
        result.geometry = new CylinderGeometry(initState);
        return result;
    };
    BSPCylinderComponent = __decorate([
        SClass({ className: 'BSPCylinderComponent' })
    ], BSPCylinderComponent);
    return BSPCylinderComponent;
}(BSPComponent));

/**
 * [BSPBoxComponent](../bspboxcomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var BSPBoxActor = /** @class */ (function (_super) {
    __extends(BSPBoxActor, _super);
    function BSPBoxActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BSPBoxActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', BSPBoxComponent, options);
    };
    BSPBoxActor = __decorate([
        SClass({ className: 'BSPBoxActor' })
    ], BSPBoxActor);
    return BSPBoxActor;
}(SceneActor));

/**
 * [BSPCylinderComponent](../bspcylindercomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var BSPCylinderActor = /** @class */ (function (_super) {
    __extends(BSPCylinderActor, _super);
    function BSPCylinderActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BSPCylinderActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', BSPCylinderComponent, options);
    };
    BSPCylinderActor = __decorate([
        SClass({ className: 'BSPCylinderActor' })
    ], BSPCylinderActor);
    return BSPCylinderActor;
}(SceneActor));

/**
 * [BSPPlaneComponent](../bspplanecomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var BSPPlaneActor = /** @class */ (function (_super) {
    __extends(BSPPlaneActor, _super);
    function BSPPlaneActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BSPPlaneActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', BSPPlaneComponent, options);
    };
    BSPPlaneActor = __decorate([
        SClass({ className: 'BSPPlaneActor' })
    ], BSPPlaneActor);
    return BSPPlaneActor;
}(SceneActor));

/**
 * [BSPSphereComponent](../bspspherecomponent)的一个包装容器。
 *
 * @noInheritDoc
 */
var BSPSphereActor = /** @class */ (function (_super) {
    __extends(BSPSphereActor, _super);
    function BSPSphereActor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BSPSphereActor.prototype.onCreateRoot = function (options) {
        return this.addComponent('root', BSPSphereComponent, options);
    };
    BSPSphereActor = __decorate([
        SClass({ className: 'BSPSphereActor' })
    ], BSPSphereActor);
    return BSPSphereActor;
}(SceneActor));

/**
 * 判断一个实例是否为`CubeTexture`。
 */
function isCubeTexture(value) {
    return value.isCubeTexture;
}
var CubeTexture = /** @class */ (function (_super) {
    __extends(CubeTexture, _super);
    function CubeTexture() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CubeTexture;
}(Hilo3d$2.CubeTexture));

/**
 * 判断一个实例是否为`DataTexture`。
 */
function isDataTexture(value) {
    return value.isDataTexture;
}
var DataTexture = /** @class */ (function (_super) {
    __extends(DataTexture, _super);
    function DataTexture() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DataTexture;
}(Hilo3d$2.DataTexture));

/**
 * 判断一个实例是否为`DynamicTexture`。
 */
function isDynamicTexture(value) {
    return value.isDynamicTexture;
}
/**
 * 动态纹理类。
 *
 * @template IDynamicTextureOptions 动态纹理的初始化参数类型。
 * @noInheritDoc
 */
var DynamicTexture = /** @class */ (function (_super) {
    __extends(DynamicTexture, _super);
    function DynamicTexture(options) {
        var _this = _super.call(this, options) || this;
        _this.isDynamicTexture = true;
        _this.image = _this._canvas = document.createElement('canvas');
        _this._canvas.width = options.width;
        _this._canvas.height = options.height;
        _this._context = _this._canvas.getContext('2d');
        var needUpdate = _this.onInit(_this._context, options);
        _this.needUpdate = needUpdate === false ? false : true;
        return _this;
    }
    Object.defineProperty(DynamicTexture.prototype, "context", {
        get: function () {
            return this._context;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 纹理初始化时调用的函数，你可以在这里通过canvas初始化绘制你的贴图。
     * 通过返回值来决定是否要更新buffer，返回`false`不更新，默认更新。
     */
    DynamicTexture.prototype.onInit = function (context, initOptions) {
        return false;
    };
    /**
     * 纹理在每次被绘制时调用的函数，你可以在这里通过canvas绘制你的纹理。
     * 通过返回值来决定是否要更新buffer，返回`false`不更新，默认更新。
     */
    DynamicTexture.prototype.onDraw = function (context) {
        return false;
    };
    /**
     * 触发绘制回调。
     */
    DynamicTexture.prototype.draw = function () {
        var needUpdate = this.onDraw(this._context);
        this.needUpdate = needUpdate === false ? false : true;
    };
    return DynamicTexture;
}(Texture));

/**
 * 判断一个实例是否为`Material`。
 */
function isMaterial(value) {
    return value.isMaterial;
}
/**
 * **材质基类，不要直接使用！想自定义请使用`RawShaderMaterial`**
 */
var Material = /** @class */ (function (_super) {
    __extends(Material, _super);
    function Material() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Material;
}(Hilo3d$2.Material));
Hilo3d$2.Material.prototype.getUniform = function getUniform(key) {
    /* tslint:disable-next-line */
    var self = this;
    return {
        get value() {
            return self[key];
        },
        set value(v) {
            self.setUniform(key, v);
        }
    };
};
Hilo3d$2.Material.prototype.setUniform = function setUniform(key, value) {
    this[key] = value;
    return this;
};
Hilo3d$2.Material.prototype.changeUniform = function changeUniform(key, handler) {
    this[key] = handler(this[key]);
    return this;
};

var _this = undefined;
/**
 * 判断一个实例是否为`BasicMaterial`。
 */
function isBasicMaterial(value) {
    return value.isBasicMaterial;
}
var BasicMaterial = /** @class */ (function (_super) {
    __extends(BasicMaterial, _super);
    function BasicMaterial() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return BasicMaterial;
}(Hilo3d$2.BasicMaterial));
/**
 * @hidden
 */
function GlTFBasicMaterial(_a) {
    var uniforms = _a.uniforms, options = _a.options, opts = __rest(_a, ["uniforms", "options"]);
    var lt = uniforms.lightType.value;
    var lightType = lt === 0 ? 'NONE' : lt === 1 ? 'PHONE' : lt === 2 ? 'BLINN-PHONE' : 'LAMBERT';
    return new BasicMaterial(__assign({ lightType: lightType, diffuse: (uniforms.u_diffuseMap || uniforms.u_diffuse || {}).value, ambient: (uniforms.u_ambientMap || {}).value, specular: (uniforms.u_specularMap || uniforms.u_specular || {}).value, normalMap: (uniforms.u_normalMap || {}).value, normalMapScale: (uniforms.u_normalMapScale || {}).value, emission: (uniforms.u_emissionMap || uniforms.u_emission || {}).value, shininess: (uniforms.u_shininess || {}).value, reflectivity: (uniforms.u_reflectivity || {}).value, refractivity: (uniforms.u_refractivity || {}).value, refractRatio: (uniforms.u_refractRatio || {}).value }, opts));
}
/**
 * @hidden
 */
BasicMaterial.prototype.initCommonOptions = function (options) {
    if (options.alphaMode) {
        switch (options.alphaMode) {
            case 'BLEND':
                _this.transparent = true;
                _this.blend = true;
                break;
            case 'MASK':
                if ('alphaCutoff' in options) {
                    _this.alphaCutoff = options.alphaCutoff;
                }
                else {
                    _this.alphaCutoff = 0.5;
                }
                break;
            case 'OPAQUE':
            default:
                _this.ignoreTranparent = true;
                break;
        }
    }
    if (options.doubleSided) {
        _this.side = Constants.FRONT_AND_BACK;
    }
};
/**
 * @hidden
 */
BasicMaterial.CLASS_NAME = new SName('BasicMaterial');
/**
 * @hidden
 */
MetaSMaterials['BasicMaterial'] = GlTFBasicMaterial;

function isGeometryMaterial(value) {
    return value.isGeometryMaterial;
}
var GeometryMaterial = /** @class */ (function (_super) {
    __extends(GeometryMaterial, _super);
    function GeometryMaterial() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GeometryMaterial;
}(Hilo3d$2.GeometryMaterial));

/**
 * 判断一个实例是否为`ShaderChunk`。
 */
function isShaderChunk(value) {
    return value.isShaderChuck;
}
/**
 * Shader材质块类，可用于shader复用，快速拼接效果。
 * 详细使用间[Material](../../guide/material)。
 *
 * @template IOptions 初始化参数类型。
 * @noInheritDoc
 */
var ShaderChunk = /** @class */ (function () {
    /**
     * 构造器。
     *
     * @param isMain 此chuck是否做为材质的最终输出。
     */
    function ShaderChunk(name, options, isMain) {
        if (isMain === void 0) { isMain = false; }
        this.name = name;
        this.isMain = isMain;
        this.isShaderChuck = true;
        /**
         * 顶点着色器函数入口名称，若指定并使用了`MixChunkChuck`，则会在最后的shader中调用。
         */
        this.vsEntryName = '';
        /**
         * 片段着色器主函数入口名称，若指定并使用了`MixChunkChuck`，则会在最后的shader中调用。
         */
        this.fsEntryName = '';
        /**
         * 此chuck主函数是否拥有顶点着色器的输出。
         */
        this.hasVsOut = false;
        /**
         * 此chuck主函数是否拥有片段着色器的输出。
         */
        this.hasFsOut = false;
        this.requiredAttributes = [];
        this.requiredUniforms = [];
        this.attributes = {};
        this.uniforms = {};
        this.defines = '';
        this.vs = { header: '', main: '' };
        this.fs = { header: '', main: '' };
        this.onInit(name, options);
    }
    /**
     * 生命周期，将在chuck初始化的时候被调用。
     */
    ShaderChunk.prototype.onInit = function (name, options) {
    };
    return ShaderChunk;
}());

/**
 * @hidden
 */
var defines = [
    Hilo3d$2.Shader.shaders['chunk/baseDefine.glsl'],
    '#define HILO_HAS_NORMAL 1',
    '#define HILO_HAS_TEXCOORD0 1',
    '#define HILO_HAS_TEXCOORD1 1'
].join('\n');
/**
 * @hidden
 */
var attributes = {
    a_position: 'POSITION',
    a_normal: 'NORMAL',
    a_tangent: 'TANGENT',
    a_texcoord0: 'TEXCOORD_0',
    a_texcoord1: 'TEXCOORD_1',
    a_color: 'COLOR_0',
    a_skinIndices: 'SKININDICES',
    a_skinWeights: 'SKINWEIGHTS'
};
['POSITION', 'NORMAL', 'TANGENT'].forEach(function (name) {
    var camelName = name.slice(0, 1) + name.slice(1).toLowerCase();
    for (var i = 0; i < 8; i += 1) {
        attributes['a_morph' + camelName + i] = ('MORPH' + name + i);
    }
});
/**
 * @hidden
 */
var uniforms = {
    u_normalMatrix: 'MODELVIEWINVERSETRANSPOSE',
    u_modelViewMatrix: 'MODELVIEW',
    u_modelViewProjectionMatrix: 'MODELVIEWPROJECTION',
    u_logDepth: 'LOGDEPTH',
    // light
    u_ambientLightsColor: 'AMBIENTLIGHTSCOLOR',
    u_directionalLightsColor: 'DIRECTIONALLIGHTSCOLOR',
    u_directionalLightsInfo: 'DIRECTIONALLIGHTSINFO',
    u_directionalLightsShadowMap: 'DIRECTIONALLIGHTSSHADOWMAP',
    u_directionalLightsShadowMapSize: 'DIRECTIONALLIGHTSSHADOWMAPSIZE',
    u_directionalLightsShadowBias: 'DIRECTIONALLIGHTSSHADOWBIAS',
    u_directionalLightSpaceMatrix: 'DIRECTIONALLIGHTSPACEMATRIX',
    u_pointLightsPos: 'POINTLIGHTSPOS',
    u_pointLightsColor: 'POINTLIGHTSCOLOR',
    u_pointLightsInfo: 'POINTLIGHTSINFO',
    u_pointLightsShadowBias: 'POINTLIGHTSSHADOWBIAS',
    u_pointLightsShadowMap: 'POINTLIGHTSSHADOWMAP',
    u_pointLightSpaceMatrix: 'POINTLIGHTSPACEMATRIX',
    u_pointLightCamera: 'POINTLIGHTCAMERA',
    u_spotLightsPos: 'SPOTLIGHTSPOS',
    u_spotLightsDir: 'SPOTLIGHTSDIR',
    u_spotLightsColor: 'SPOTLIGHTSCOLOR',
    u_spotLightsCutoffs: 'SPOTLIGHTSCUTOFFS',
    u_spotLightsInfo: 'SPOTLIGHTSINFO',
    u_spotLightsShadowMap: 'SPOTLIGHTSSHADOWMAP',
    u_spotLightsShadowMapSize: 'SPOTLIGHTSSHADOWMAPSIZE',
    u_spotLightsShadowBias: 'SPOTLIGHTSSHADOWBIAS',
    u_spotLightSpaceMatrix: 'SPOTLIGHTSPACEMATRIX',
    u_areaLightsPos: 'AREALIGHTSPOS',
    u_areaLightsColor: 'AREALIGHTSCOLOR',
    u_areaLightsWidth: 'AREALIGHTSWIDTH',
    u_areaLightsHeight: 'AREALIGHTSHEIGHT',
    u_areaLightsLtcTexture1: 'AREALIGHTSLTCTEXTURE1',
    u_areaLightsLtcTexture2: 'AREALIGHTSLTCTEXTURE2',
    // joint
    u_jointMat: 'JOINTMATRIX',
    u_jointMatTexture: 'JOINTMATRIXTEXTURE',
    u_jointMatTextureSize: 'JOINTMATRIXTEXTURESIZE',
    // quantization
    u_positionDecodeMat: 'POSITIONDECODEMAT',
    u_normalDecodeMat: 'NORMALDECODEMAT',
    u_uvDecodeMat: 'UVDECODEMAT',
    u_uv1DecodeMat: 'UV1DECODEMAT',
    // morph
    u_morphWeights: 'MORPHWEIGHTS',
    u_normalMapScale: 'NORMALMAPSCALE',
    u_emission: 'EMISSION',
    u_transparency: 'TRANSPARENCY',
    // uv matrix
    u_uvMatrix: 'UVMATRIX_0',
    u_uvMatrix1: 'UVMATRIX_1',
    // other info
    u_fogColor: 'FOGCOLOR',
    u_fogInfo: 'FOGINFO',
    u_alphaCutoff: 'ALPHACUTOFF',
    u_exposure: 'EXPOSURE',
    u_gammaFactor: 'GAMMAFACTOR'
};
/**
 * @hidden
 */
var vs = {
    header: [
        Hilo3d$2.Shader.shaders['chunk/extensions.vert'],
        Hilo3d$2.Shader.shaders['chunk/precision.vert'],
        'attribute vec3 a_position;',
        'uniform mat4 u_modelViewProjectionMatrix;',
        Hilo3d$2.Shader.shaders['chunk/unQuantize.vert'],
        Hilo3d$2.Shader.shaders['chunk/joint.vert'],
        Hilo3d$2.Shader.shaders['chunk/uv.vert'],
        Hilo3d$2.Shader.shaders['chunk/normal.vert'],
        Hilo3d$2.Shader.shaders['chunk/lightFog.vert'],
        Hilo3d$2.Shader.shaders['chunk/morph.vert'],
        Hilo3d$2.Shader.shaders['chunk/color.vert'],
        Hilo3d$2.Shader.shaders['chunk/logDepth.vert']
    ].join('\n'),
    main: ''
};
/**
 * @hidden
 */
var fs = {
    header: [
        Hilo3d$2.Shader.shaders['chunk/extensions.frag'],
        Hilo3d$2.Shader.shaders['chunk/precision.frag'],
        Hilo3d$2.Shader.shaders['./chunk/color.frag'],
        Hilo3d$2.Shader.shaders['./chunk/uv.frag'],
        Hilo3d$2.Shader.shaders['./chunk/normal.frag'],
        Hilo3d$2.Shader.shaders['./chunk/lightFog.frag'],
        Hilo3d$2.Shader.shaders['./chunk/light.frag'],
        Hilo3d$2.Shader.shaders['./chunk/transparency.frag'],
        Hilo3d$2.Shader.shaders['./chunk/fog.frag'],
        Hilo3d$2.Shader.shaders['./chunk/logDepth.frag']
    ].join('\n'),
    main: ''
};
/**
 * 基础材质定义，用于指定一些基础的材质变量。
 * `ShaderMaterial`就在`RawShaderMaterial`基础上用到了这个chuck。
 *
 * @noInheritDoc
 */
var BasicDefinitionChunk = /** @class */ (function (_super) {
    __extends(BasicDefinitionChunk, _super);
    function BasicDefinitionChunk() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BasicDefinitionChunk.prototype.onInit = function () {
        this.attributes = attributes;
        this.uniforms = uniforms;
        this.defines = defines;
        this.vs = vs;
        this.fs = fs;
    };
    return BasicDefinitionChunk;
}(ShaderChunk));

/**
 * 判断一个实例是否为`ShaderMaterial`。
 */
function isShaderMaterial(value) {
    return value.isShaderMaterial;
}
/**
 * 自定义材质类，在`RawShaderMaterial`基础上增加了基本的`attributes`和`uniforms`定义。
 * 基础的定义请见[BasicDefinitionChunk](../basicdefinitionchunk)
 *
 * @noInheritDoc
 */
var ShaderMaterial = /** @class */ (function (_super) {
    __extends(ShaderMaterial, _super);
    function ShaderMaterial(options) {
        var _this = _super.call(this) || this;
        _this.isShaderMaterial = true;
        options.chunks = options.chunks || [];
        options.chunks.splice(0, 0, new BasicDefinitionChunk('basicDefinition'));
        _this.init(options);
        return _this;
    }
    ShaderMaterial = __decorate([
        SMaterial({ className: 'ShaderMaterial' })
    ], ShaderMaterial);
    return ShaderMaterial;
}(RawShaderMaterial));

/**
 * @hidden
 */
var requiredAttributes = [
    'a_position',
    'a_normal',
    'a_texcoord0'
];
/**
 * @hidden
 */
var requiredUniforms = [
    'u_normalMatrix',
    'u_viewVector'
];
/**
 * @hidden
 */
var uniforms$1 = {
    u_fresnelC: { value: 1 },
    u_fresnelP: { value: 1 },
    u_fresnelColor: { value: new Color(1, 1, 1, 1) }
};
/**
 * @hidden
 */
var vs$1 = {
    header: "\nuniform vec3 u_viewVector;\nuniform float u_fresnelC;\nuniform float u_fresnelP;\n\nvarying vec2 v_fresnelUv;\nvarying float v_fresnelIntensity;\n",
    main: "\nvoid fresnelEffect() {\nvec3 v_normal = normalize(u_normalMatrix * a_normal);\nvec3 v_view = normalize(u_normalMatrix * u_viewVector);\n\nv_fresnelIntensity = pow(u_fresnelC - dot(v_normal, v_view), u_fresnelP);\nv_fresnelUv = a_texcoord0;\n}  \n"
};
/**
 * @hidden
 */
var fs$1 = {
    header: "\nuniform vec4 u_fresnelColor;\n\nvarying float v_fresnelIntensity;\nvarying vec2 v_fresnelUv;\n",
    main: "\nvec4 fresnelEffect() {\nvec4 glow = u_fresnelColor * v_fresnelIntensity;\n\nreturn glow;\n}  \n"
};
/**
 * 菲涅尔效应chuck。
 *
 * @noInheritDoc
 */
var FresnelEffectChuck = /** @class */ (function (_super) {
    __extends(FresnelEffectChuck, _super);
    function FresnelEffectChuck() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vsEntryName = 'fresnelEffect';
        _this.fsEntryName = 'fresnelEffect';
        _this.hasVsOut = false;
        _this.hasFsOut = true;
        return _this;
    }
    FresnelEffectChuck.prototype.onInit = function () {
        this.requiredAttributes = requiredAttributes;
        this.requiredUniforms = requiredUniforms;
        this.uniforms = uniforms$1;
        this.vs = vs$1;
        this.fs = fs$1;
    };
    return FresnelEffectChuck;
}(ShaderChunk));

/**
 * 混合多个chuck的chuck，可以作为一个材质最终的输出。
 *
 * @noInheritDoc
 */
var MixChunksChunk = /** @class */ (function (_super) {
    __extends(MixChunksChunk, _super);
    function MixChunksChunk() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasVsOut = true;
        _this.hasFsOut = true;
        return _this;
    }
    MixChunksChunk.prototype.onInit = function (name, options) {
        var chunks = options.chunks, _a = options.vsWeights, vsWeights = _a === void 0 ? {} : _a, _b = options.fsWeights, fsWeights = _b === void 0 ? {} : _b;
        var vsRes = [];
        var fsRes = [];
        if (name) {
            this.vsEntryName = this.fsEntryName = name;
        }
        else {
            this.vsEntryName = this.fsEntryName = 'mixChunks';
        }
        this.vs.main = this.fs.main = "vec4 " + this.vsEntryName + "() {\n";
        var length = options.chunks.length;
        for (var index = 0; index < length; index += 1) {
            var chuck = chunks[index];
            if (chuck.vsEntryName) {
                if (chuck.hasVsOut) {
                    var weight = vsWeights[chuck.name] || 0;
                    var weightName = "u_" + chuck.vsEntryName + "VsWeight";
                    var resName = chuck.vsEntryName + "Res";
                    vsRes.push(resName);
                    this.vs.main += "vec4 " + resName + " = " + chuck.vsEntryName + "() * " + weightName + ";\n";
                    this.uniforms[weightName] = { value: weight };
                    this.vs.header += "uniform float " + weightName + ";\n";
                }
                else {
                    this.vs.main += chuck.vsEntryName + "();\n";
                }
            }
            if (chuck.fsEntryName) {
                if (chuck.hasFsOut) {
                    var weight = fsWeights[chuck.name] || 0;
                    var weightName = "u_" + chuck.fsEntryName + "FsWeight";
                    var resName = chuck.fsEntryName + "Res";
                    fsRes.push(resName);
                    this.fs.main += "vec4 " + resName + " = " + chuck.fsEntryName + "() * " + weightName + ";\n";
                    this.uniforms[weightName] = { value: weight };
                    this.fs.header += "uniform float " + weightName + ";\n";
                }
                else {
                    this.fs.main += chuck.fsEntryName + "();\n";
                }
            }
        }
        this.vs.main += 'return ' + vsRes.join(' + ') + ';\n}';
        this.fs.main += 'return ' + fsRes.join(' + ') + ';\n}';
    };
    return MixChunksChunk;
}(ShaderChunk));

/**
 * @File   : index.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 11/21/2018, 11:33:39 AM
 * @Description:
 */
var shaderChunks = {
    BasicDefinitionChunk: BasicDefinitionChunk,
    FresnelEffectChuck: FresnelEffectChuck,
    MixChunksChunk: MixChunksChunk
};

/**
 * @File   : Semantic.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 4/2/2019, 8:24:52 PM
 * @Description:
 */
var S = Hilo3d$2.semantic;
S.register = function (semantic, object) {
    if (S[semantic]) {
        throw new Error("Sematic " + semantic + " has already existed !");
    }
    S[semantic] = object;
};
S.get = function (semantic) {
    return S[semantic];
};
S.unregister = function (semantic) {
    if (S[semantic]) {
        delete S[semantic];
    }
};
var Semantic = S;
var SpriteMVP = {
    _mvp: new Matrix4(),
    get: function (mesh, material) {
        var mainCamera = material.game.world.mainCamera;
        var mvp = SpriteMVP._mvp;
        mvp.copy(mesh.worldMatrix);
        if (material.isBillboard) {
            mvp.fromRotationTranslationScale(mainCamera.quaternion, mvp.getTranslation(), mvp.getScaling());
        }
        mvp.premultiply(mainCamera.viewProjectionMatrix);
        return mvp.elements;
    }
};
Semantic.register('SPRITEMODELVIEWPROJECTION', SpriteMVP);

/**
 * 骨架类。
 */
var Skeleton = /** @class */ (function (_super) {
    __extends(Skeleton, _super);
    function Skeleton() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Skeleton;
}(Hilo3d$2.Skeleton));

/**
 * 判断一个实例是否为`SpriteAnimation`。
 */
function isSpriteAnimation(value) {
    return value.isSpriteAnimation;
}
/**
 * 2D精灵动画类，用于管理2D精灵动画的播放。根据初始化参数的不同，拥有两种模式。
 * 一种是基于帧序列的，指定单元尺寸和空隙以及帧数队列来进行播放。
 * 另一种是基于图集Atlas的，指定帧名队列来进行播放。
 *
 *
 * @noInheritDoc
 */
var SpriteAnimation = /** @class */ (function (_super) {
    __extends(SpriteAnimation, _super);
    function SpriteAnimation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isSpriteAnimation = true;
        _this._paused = true;
        _this._delta = 0;
        _this.handleElementEnd = function () {
            _this.handleEnd(_this, _this.actor);
        };
        return _this;
    }
    Object.defineProperty(SpriteAnimation.prototype, "duration", {
        /**
         * 获取当前播放总时长。
         */
        get: function () {
            return this._length * 1000 / (this._fps || this.parent.getGame().fps);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimation.prototype, "frameCount", {
        /**
         * 获取当前播放总帧数。
         */
        get: function () {
            return this._length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimation.prototype, "currentFrame", {
        /**
         * 获取当前播放帧。
         */
        get: function () {
            return this._current;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpriteAnimation.prototype, "currentTime", {
        /**
         * 获取当前播放时间。
         */
        get: function () {
            return this._current * 1000 / (this._fps || this.parent.getGame().fps);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    SpriteAnimation.prototype.onInit = function (initState) {
        var component = this._component = this.actor.findComponentByName(initState.componentName || 'root');
        if (!component.isSpriteComponent) {
            throw new TypeConflictException(component, 'SpriteComponent', this);
        }
        this._fps = initState.fps;
        var atlas = this._atlas = initState.atlas || component.atlas;
        this._frames = initState.frameNames;
        if (!initState.frameNames) {
            this._frames = Object.keys(atlas.frames);
        }
        this._length = this._frames.length;
    };
    /**
     * @hidden
     */
    SpriteAnimation.prototype.onPlay = function (loopCount) {
        this._current = 0;
        this._delta = 0;
        this._paused = false;
        this._component.atlas = this._atlas;
    };
    /**
     * @hidden
     */
    SpriteAnimation.prototype.onPause = function () {
        this._paused = true;
    };
    /**
     * @hidden
     */
    SpriteAnimation.prototype.onResume = function () {
        this._paused = false;
        this._delta = 0;
        this._component.atlas = this._atlas;
    };
    /**
     * @hidden
     */
    SpriteAnimation.prototype.onStop = function () {
        this._current = 0;
        this._paused = true;
    };
    /**
     * @hidden
     */
    SpriteAnimation.prototype.onUpdate = function (delta) {
        if (this._paused) {
            return;
        }
        var fps = this._fps || this.parent.getGame().fps;
        if (this._delta < 1000 / fps) {
            this._delta += delta;
            return;
        }
        else {
            this._delta = 0;
        }
        this._component.setFrame(this._frames[this._current]);
        this._current += 1;
        if (this._current === this._length) {
            this.stop();
            this.handleElementEnd();
        }
    };
    SpriteAnimation = __decorate([
        SClass({ className: 'SpriteAnimation' })
    ], SpriteAnimation);
    return SpriteAnimation;
}(Animation));

/**
 * 判断一个实例是否为`TweenAnimation`。
 */
function isTweenAnimation(value) {
    return value.isTweenAnimation;
}
/**
 * 模型动画类，用于存储模型动画。
 * 一般在模型实例化时已经自动生成，不需要自己初始化。
 *
 * @noInheritDoc
 */
var TweenAnimation = /** @class */ (function (_super) {
    __extends(TweenAnimation, _super);
    function TweenAnimation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isTweenAnimation = true;
        _this.handleElementPause = function () {
            _this.pause();
        };
        _this.handleElementResume = function () {
            _this.resume();
        };
        _this.handleComplete = function () {
            _this.handleEnd(_this, _this.actor);
        };
        return _this;
    }
    Object.defineProperty(TweenAnimation.prototype, "currentTime", {
        /**
         * 获取当前播放时间。
         */
        get: function () {
            return this._tween.time;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TweenAnimation.prototype, "duration", {
        /**
         * 获取当前播放总时长。
         */
        get: function () {
            return this._tween.duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TweenAnimation.prototype, "paused", {
        /**
         * 获取当前是否处于暂停状态。
         */
        get: function () {
            return this._tween.paused;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    TweenAnimation.prototype.onInit = function (_a) {
        var create = _a.create;
        this._tween = create(this.handleComplete);
        this._tween.stop();
        this.getGame().event.add('GameWillPause', this.handleElementPause);
        this.getGame().event.add('GameDidResume', this.handleElementResume);
    };
    /**
     * @hidden
     */
    TweenAnimation.prototype.onPlay = function (loopCount) {
        this._tween.start();
    };
    /**
     * @hidden
     */
    TweenAnimation.prototype.onPause = function () {
        this._tween.pause();
    };
    /**
     * @hidden
     */
    TweenAnimation.prototype.onResume = function () {
        this._tween.resume();
    };
    /**
     * @hidden
     */
    TweenAnimation.prototype.onStop = function () {
        this._tween.stop();
    };
    /**
     * @hidden
     */
    TweenAnimation.prototype.onDestroy = function () {
        this.stop();
        this.getGame().event.remove('GameWillPause', this.handleElementPause);
        this.getGame().event.remove('GameDidResume', this.handleElementResume);
    };
    TweenAnimation = __decorate([
        SClass({ className: 'TweenAnimation' })
    ], TweenAnimation);
    return TweenAnimation;
}(Animation));

/**
 * 判断一个实例是否为`CombineAnimation`。
 */
function isCombineAnimation(value) {
    return value.isCombineAnimation;
}
/**
 * 组合动画类，可以并行播放多个动画，结束以最后一个结束的为准。
 *
 * @noInheritDoc
 */
var CombineAnimation = /** @class */ (function (_super) {
    __extends(CombineAnimation, _super);
    function CombineAnimation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isCombineAnimation = true;
        _this._count = 0;
        _this._length = 0;
        _this.handleElementEnd = function () {
            _this._count += 1;
            if (_this._count === _this._length) {
                _this.handleEnd(_this, _this.actor);
            }
        };
        return _this;
    }
    /**
     * @hidden
     */
    CombineAnimation.prototype.onInit = function (options) {
        this._animations = options.animations;
        this._length = this._animations.length;
        for (var index = 0; index < this._length; index += 1) {
            var animation = this._animations[index];
            animation.handleEnd = this.handleElementEnd;
            animation.animator = this.animator;
            animation.initialize();
        }
    };
    /**
     * @hidden
     */
    CombineAnimation.prototype.onPlay = function (loopCount) {
        this._count = 0;
        for (var index = 0; index < this._length; index += 1) {
            this._animations[index].play(loopCount);
        }
    };
    /**
     * @hidden
     */
    CombineAnimation.prototype.onPause = function () {
        for (var index = 0; index < this._length; index += 1) {
            this._animations[index].pause();
        }
    };
    /**
     * @hidden
     */
    CombineAnimation.prototype.onResume = function () {
        for (var index = 0; index < this._length; index += 1) {
            this._animations[index].resume();
        }
    };
    /**
     * @hidden
     */
    CombineAnimation.prototype.onStop = function () {
        for (var index = 0; index < this._length; index += 1) {
            this._animations[index].stop();
        }
    };
    /**
     * @hidden
     */
    CombineAnimation.prototype.onUpdate = function (delta) {
        for (var index = 0; index < this._length; index += 1) {
            this._animations[index].onUpdate(delta);
        }
    };
    /**
     * @hidden
     */
    CombineAnimation.prototype.onDestroy = function () {
        for (var index = 0; index < this._length; index += 1) {
            this._animations[index].destroy();
        }
    };
    CombineAnimation = __decorate([
        SClass({ className: 'CombineAnimation' })
    ], CombineAnimation);
    return CombineAnimation;
}(Animation));

/**
 * @hidden
 */
function bfs(parent, func) {
    var children = parent.findComponentsByClass(ChildActorComponent);
    var length = children.length;
    var tmp = [];
    for (var i = 0; i < length; i += 1) {
        var actor = children[i].actor;
        if (func(actor)) {
            return;
        }
        Array.prototype.push.apply(tmp, actor.findComponentsByClass(ChildActorComponent));
        if (i === length - 1) {
            children = tmp;
            length = children.length;
            i = 0;
            tmp = [];
        }
    }
}
/**
 * 迭代`parent`下的所有`actors`。
 *
 * @param func 迭代回调函数，若返回`true`，则立即停止迭代，用于性能优化。
 */
function iterateActors(parent, func) {
    if (isActor(parent)) {
        bfs(parent, func);
        return;
    }
    parent.actors.forEach(func);
}
/**
 * 迭代`parent`下的所有名字为`name`的`actors`。
 *
 * @param func 迭代回调函数，若返回`true`，则立即停止迭代，用于性能优化。
 */
function iterateActorsByName(parent, name, func) {
    iterateActors(parent, function (actor) {
        if (!actor.name.equalsTo(name)) {
            return false;
        }
        return func(actor);
    });
}
/**
 * 迭代`parent`下的所有标签为`tag`的`actors`。
 *
 * @param func 迭代回调函数，若返回`true`，则立即停止迭代，用于性能优化。
 */
function iterateActorsByTag(parent, tag, func) {
    iterateActors(parent, function (actor) {
        if (!actor.tag.equalsTo(tag)) {
            return false;
        }
        return func(actor);
    });
}
/**
 * **暂时没用。**
 * 迭代`parent`下的所有类的类型为`classType`的`actors`。
 *
 * @param func 迭代回调函数，若返回`true`，则立即停止迭代，用于性能优化。
 */
function iterateActorsByClassType(parent, classType, func) {
    iterateActors(parent, function (actor) {
        if (!actor.classType.equalsTo(classType)) {
            return false;
        }
        return func(actor);
    });
}
/**
 * 迭代`parent`下的所有类型为`Class`的`actors`。
 *
 * @param func 迭代回调函数，若返回`true`，则立即停止迭代，用于性能优化。
 */
function iterateActorsByClass(parent, Class, func) {
    iterateActors(parent, function (actor) {
        if (!actor.className.equalsTo(Class.CLASS_NAME)) {
            return false;
        }
        return func(actor);
    });
}

/**
 * 基于cannon.js的物理世界类，完成了CANNON到Sein.js的物理引擎的桥接。
 * **一般情况下你并不需要直接操作这个实例，而是使用刚体和碰撞体组件！**
 * CANNON的工程（魔改过的）请见这里：[https://github.com/dtysky/cannon.js](https://github.com/dtysky/cannon.js)，可以使用`npm i cannon-dtysky`获取。
 * 详细使用请见[Physic](../../guide/physic)。
 *
 * @noInheritDoc
 */
var CannonPhysicWorld = /** @class */ (function (_super) {
    __extends(CannonPhysicWorld, _super);
    /**
     * 构造器。
     *
     * @param Cannon CANNON模块引用`Cannon`。
     * @param gravity 世界重力。
     * @param iterations 迭代次数。
     */
    function CannonPhysicWorld(Cannon, gravity, iterations) {
        if (gravity === void 0) { gravity = new Vector3(0, -9.81, 0); }
        if (iterations === void 0) { iterations = 10; }
        var _this = _super.call(this, 'SeinCannonPhysicWorld') || this;
        _this.isPhysicWorld = true;
        _this.isCannonPhysicWorld = true;
        _this._fixedTimeStep = 1 / 60;
        _this._physicsMaterials = [];
        if (!Cannon) {
            throw new UnmetRequireException(_this, 'The newest version Cannonjs is required ! Goto "https://github.com/dtysky/cannon.js/tree/master/build" get it !');
        }
        _this.CANNON = Cannon;
        _this._world = new _this.CANNON.World();
        _this._world.broadphase = new _this.CANNON.NaiveBroadphase();
        _this._world.solver.iterations = iterations;
        _this._world.gravity.set(gravity.x, gravity.y, gravity.z);
        _this._ray = new _this.CANNON.Ray();
        _this._rayResult = new _this.CANNON.RaycastResult();
        return _this;
    }
    Object.defineProperty(CannonPhysicWorld.prototype, "timeStep", {
        /**
         * 获取固定步长（秒）。
         */
        get: function () {
            return this._fixedTimeStep;
        },
        /**
         * 设置固定步长（秒）。
         */
        set: function (value) {
            this._fixedTimeStep = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CannonPhysicWorld.prototype, "gravity", {
        /**
         * 获取重力。
         */
        get: function () {
            var _a = this._world.gravity, x = _a.x, y = _a.y, z = _a.z;
            return new Vector3(x, y, z);
        },
        /**
         * 设置重力。
         */
        set: function (gravity) {
            this._world.gravity.set(gravity.x, gravity.y, gravity.z);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 启用高级碰撞事件，这可以让你拥有对碰撞更细致的控制，但会有一些性能损耗。
     */
    CannonPhysicWorld.prototype.initContactEvents = function () {
        this._world.addEventListener('beginContact', function (args) {
            if (!args.bodyA || !args.bodyB) {
                return;
            }
            if (args.bodyA.component.valid) {
                args.bodyA.component.handleBodyEnter(args.bodyA.component, args.bodyB.component);
            }
            if (args.bodyB.component.valid) {
                args.bodyB.component.handleBodyEnter(args.bodyB.component, args.bodyA.component);
            }
        });
        this._world.addEventListener('endContact', function (args) {
            if (!args.bodyA || !args.bodyB) {
                return;
            }
            if (args.bodyA.component.valid) {
                args.bodyA.component.handleBodyLeave(args.bodyA.component, args.bodyB.component);
            }
            if (args.bodyB.component.valid) {
                args.bodyB.component.handleBodyLeave(args.bodyB.component, args.bodyA.component);
            }
        });
        this._world.addEventListener('beginShapeContact', function (args) {
            if (!args.bodyA || !args.bodyB) {
                return;
            }
            if (args.bodyA.component.valid) {
                args.bodyA.component.handleColliderEnter(args.bodyA.component, args.bodyB.component, args.shapeA.component, args.shapeB.component);
            }
            if (args.bodyB.component.valid) {
                args.bodyB.component.handleColliderEnter(args.bodyB.component, args.bodyA.component, args.shapeB.component, args.shapeA.component);
            }
        });
        this._world.addEventListener('endShapeContact', function (args) {
            if (!args.bodyA || !args.bodyB) {
                return;
            }
            if (args.bodyA.component.valid) {
                args.bodyA.component.handleColliderLeave(args.bodyA.component, args.bodyB.component, args.shapeA.component, args.shapeB.component);
            }
            if (args.bodyB.component.valid) {
                args.bodyB.component.handleColliderLeave(args.bodyB.component, args.bodyA.component, args.shapeB.component, args.shapeA.component);
            }
        });
    };
    /**
     * 设置重力。
     */
    CannonPhysicWorld.prototype.setGravity = function (gravity) {
        this._world.gravity.x = gravity.x;
        this._world.gravity.y = gravity.y;
        this._world.gravity.z = gravity.z;
        return this;
    };
    /**
     * **不要自己调用！！**
     *
     * @hidden
     */
    CannonPhysicWorld.prototype.update = function (delta, components) {
        if (delta === void 0) { delta = 0; }
        this._world.step(this._fixedTimeStep, delta, 3);
    };
    /**
     * 添加脉冲力。
     */
    CannonPhysicWorld.prototype.applyImpulse = function (component, force, contactPoint) {
        var worldPoint = new this.CANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
        var impulse = new this.CANNON.Vec3(force.x, force.y, force.z);
        component.rigidBody.applyImpulse(impulse, worldPoint);
    };
    /**
     * 添加力。
     */
    CannonPhysicWorld.prototype.applyForce = function (component, force, contactPoint) {
        var worldPoint = new this.CANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
        var impulse = new this.CANNON.Vec3(force.x, force.y, force.z);
        component.rigidBody.applyForce(impulse, worldPoint);
    };
    /**
     * 拾取操作。
     */
    CannonPhysicWorld.prototype.pick = function (from, to, onPick, origOptions) {
        var _this = this;
        if (origOptions === void 0) { origOptions = {}; }
        var options = __assign({}, origOptions);
        this._ray.from.copy(from);
        this._ray.to.copy(to);
        this._ray.checkCollisionResponse = options.checkCollisionResponse === true ? true : false;
        switch (options.mode) {
            case exports.EPickMode.All:
                options.mode = this.CANNON.Ray.ALL;
                break;
            case exports.EPickMode.Any:
                options.mode = this.CANNON.Ray.ANY;
                break;
            case exports.EPickMode.Closest:
                options.mode = this.CANNON.Ray.CLOSEST;
            default:
                options.mode = this.CANNON.Ray.CLOSEST;
                break;
        }
        options.skipBackfaces = options.skipBackfaces === false ? false : true;
        options.result = this._rayResult;
        var result = [];
        options.callback = function () {
            var _a = _this._rayResult, body = _a.body, shape = _a.shape, distance = _a.distance, hitPointWorld = _a.hitPointWorld;
            if (!body.component.valid) {
                return;
            }
            result.push({ rigidBody: body.component, collider: shape.component, actor: body.component.getOwner(), distance: distance, point: new Vector3(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z) });
        };
        if (options.bodies) {
            options.bodies = options.bodies.map(function (body) { return body.rigidBody; });
        }
        var hit = this._ray.intersectWorld(this._world, options);
        if (hit) {
            if (options.mode === exports.EPickMode.CLOSEST) {
                var _a = this._rayResult, body = _a.body, shape = _a.shape, distance = _a.distance, hitPointWorld = _a.hitPointWorld;
                result.push({ rigidBody: body.component, collider: shape.component, actor: body.component.getOwner(), distance: distance, point: new Vector3(hitPointWorld.x, hitPointWorld.y, hitPointWorld.z) });
            }
            onPick(result);
        }
        return hit;
    };
    /**
     * 创建一个刚体。
     */
    CannonPhysicWorld.prototype.createRigidBody = function (component, options) {
        var material = this.addMaterial("mat-" + component.uuid, options.friction, options.restitution);
        var bodyCreationObject = {
            mass: options.mass,
            material: material
        };
        for (var key in options.nativeOptions) {
            bodyCreationObject[key] = options.nativeOptions[key];
        }
        var rigidBody = new this.CANNON.Body(bodyCreationObject);
        rigidBody.component = component;
        var _a = component.getCurrentTransform(), position = _a[0], rotation = _a[1], scale = _a[2];
        this.setBodyTransform(rigidBody, position, rotation, scale);
        rigidBody.updateMassProperties();
        rigidBody.updateBoundingRadius();
        if (Debug.devMode) {
            this.checkNest(component);
        }
        this._world.addBody(rigidBody);
        return rigidBody;
    };
    /**
     * 暂时使得刚体失去效应，可以用`enableRigidBody`恢复。
     */
    CannonPhysicWorld.prototype.disableRigidBody = function (component) {
        this._world.remove(component.rigidBody);
    };
    /**
     * 使得一个暂时失去效应的刚体恢复。
     */
    CannonPhysicWorld.prototype.enableRigidBody = function (component) {
        this._world.add(component.rigidBody);
    };
    /**
     * 在开发环境下，检测是否有物理嵌套。
     */
    CannonPhysicWorld.prototype.checkNest = function (component) {
        var actor = component.getOwner();
        var parent = actor.parent;
        while (parent) {
            if (parent.rigidBody) {
                Debug.warn('You should never have a parent and child "none isTrigger and 0 mass" rigidBody together', actor, parent);
                break;
            }
            parent = parent.parent;
        }
        bfs(actor, function (child) {
            if (child.rigidBody) {
                Debug.warn('You should never have a parent and child "none isTrigger and 0 mass" rigidBody together', actor, child);
                return false;
            }
            return true;
        });
    };
    /**
     * 初始化基本事件。
     */
    CannonPhysicWorld.prototype.initEvents = function (component) {
        this._world.addEventListener('preStep', component.handleBeforeStep);
        this._world.addEventListener('postStep', component.handleAfterStep);
        component.rigidBody.addEventListener('collide', component.handleCollision);
    };
    /**
     * 移除一个刚体。
     */
    CannonPhysicWorld.prototype.removeRigidBody = function (component) {
        this._world.removeEventListener('preStep', component.handleBeforeStep);
        this._world.removeEventListener('postStep', component.handleAfterStep);
        component.rigidBody.removeEventListener('collision', component.handleCollision);
        this._world.remove(component.rigidBody);
    };
    /**
     * 清空物理世界。
     */
    CannonPhysicWorld.prototype.clear = function () {
        this._world._listeners.preStep = [];
        this._world._listeners.postStep = [];
        this._world.bodies = [];
    };
    CannonPhysicWorld.prototype.createJoint = function (rigidBody, component, params) {
        var type = params.type, options = params.options;
        var actor = options.actor, data = __rest(options, ["actor"]);
        var mainBody = rigidBody.rigidBody;
        var connectedBody = actor.rigidBody.rigidBody;
        var constraint;
        switch (type) {
            case exports.EJointType.Hinge:
                constraint = new this.CANNON.HingeConstraint(mainBody, connectedBody, data);
                break;
            case exports.EJointType.Distance:
                constraint = new this.CANNON.DistanceConstraint(mainBody, connectedBody, data.distance, data.maxForce);
                break;
            case exports.EJointType.Spring:
                constraint = new this.CANNON.Spring(mainBody, connectedBody, data);
                break;
            case exports.EJointType.Lock:
                constraint = new this.CANNON.LockConstraint(mainBody, connectedBody, data);
                break;
            case exports.EJointType.PointToPoint:
            default:
                constraint = new this.CANNON.PointToPointConstraint(mainBody, data.pivotA, connectedBody, data.pivotB, data.maxForce);
                break;
        }
        constraint.collideConnected = !!data.collideConnected;
        constraint.wakeUpBodies = !!data.wakeUpBodies;
        constraint.component = constraint;
        //don't add spring as constraint, as it is not one.
        if (type !== exports.EJointType.Spring) {
            this._world.addConstraint(constraint);
        }
        else {
            rigidBody.event.add('AfterStep', component.applyForce);
        }
        return constraint;
    };
    CannonPhysicWorld.prototype.removeJoint = function (rigidBody, component) {
        if (component.type !== exports.EJointType.Spring) {
            this._world.removeConstraint(component.joint);
        }
        else {
            rigidBody.event.remove('AfterStep', component.applyForce);
        }
    };
    CannonPhysicWorld.prototype.enableJoint = function (component) {
        component.joint.enable();
    };
    CannonPhysicWorld.prototype.disableJoint = function (component) {
        component.joint.disable();
    };
    CannonPhysicWorld.prototype.addMaterial = function (name, friction, restitution) {
        var index;
        var mat;
        for (index = 0; index < this._physicsMaterials.length; index += 1) {
            mat = this._physicsMaterials[index];
            if (mat.friction === friction && mat.restitution === restitution) {
                return mat;
            }
        }
        var currentMat = new this.CANNON.Material(name);
        currentMat.friction = friction;
        currentMat.restitution = restitution;
        this._physicsMaterials.push(currentMat);
        return currentMat;
    };
    /**
     * 创建碰撞体。
     */
    CannonPhysicWorld.prototype.createCollider = function (bodyComp, colliderComp, params) {
        var _a, _b;
        var shape;
        switch (params.type) {
            case exports.EColliderType.Sphere:
                shape = new this.CANNON.Sphere(params.options.radius);
                break;
            case exports.EColliderType.Cylinder:
                shape = new this.CANNON.Cylinder(params.options.radiusTop, params.options.radiusBottom, params.options.height, params.options.numSegments);
                break;
            case exports.EColliderType.Box:
                shape = new this.CANNON.Box(new this.CANNON.Vec3(params.options.size[0] / 2, params.options.size[1] / 2, params.options.size[2] / 2));
                break;
            case exports.EColliderType.Plane:
                Debug.warn('Attention, PlaneCollider might not behave as you expect. Consider using BoxCollider instead');
                shape = new this.CANNON.Plane();
                break;
        }
        var _c = params.options, offset = _c.offset, quaternion = _c.quaternion, isTrigger = _c.isTrigger;
        var rigidBody = bodyComp.rigidBody;
        offset = offset || [0, 0, 0];
        quaternion = quaternion || [0, 0, 0, 1];
        isTrigger = isTrigger || false;
        rigidBody.addShape(shape, new ((_a = this.CANNON.Vec3).bind.apply(_a, __spreadArrays([void 0], offset)))(), new ((_b = this.CANNON.Quaternion).bind.apply(_b, __spreadArrays([void 0], quaternion)))());
        shape.collisionResponse = !isTrigger;
        shape.component = colliderComp;
        return shape;
    };
    /**
     * 移除碰撞体。
     */
    CannonPhysicWorld.prototype.removeCollider = function (rigidBodyComp, colliderComp) {
        var rigidBody = rigidBodyComp.rigidBody;
        var collider = colliderComp.collider;
        var index = rigidBody.shapes.indexOf(collider);
        rigidBody.shapes.splice(index, 1);
        rigidBody.shapeOffsets.splice(index, 1);
        rigidBody.shapeOrientations.splice(index, 1);
    };
    // private _createHeightmap(object: IPhysicsEnabledObject, pointDepth?: number) {
    //   const pos = <FloatArray>(object.getVerticesData(VertexBuffer.PositionKind));
    //   let transform = object.computeWorldMatrix(true);
    //   // convert rawVerts to object space
    //   const temp = new Array<number>();
    //   const index: number;
    //   for (index = 0; index < pos.length; index += 3) {
    //     Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(temp, index);
    //   }
    //   pos = temp;
    //   const matrix = new Array<Array<any>>();
    //   //For now pointDepth will not be used and will be automatically calculated.
    //   //Future reference - try and find the best place to add a reference to the pointDepth constiable.
    //   const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);
    //   let boundingInfo = object.getBoundingInfo();
    //   const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);
    //   const minY = boundingInfo.boundingBox.extendSizeWorld.z;
    //   const elementSize = dim * 2 / arraySize;
    //   for (const i = 0; i < pos.length; i = i + 3) {
    //     const x = Math.round((pos[i + 0]) / elementSize + arraySize / 2);
    //     const z = Math.round(((pos[i + 1]) / elementSize - arraySize / 2) * -1);
    //     const y = -pos[i + 2] + minY;
    //     if (!matrix[x]) {
    //       matrix[x] = [];
    //     }
    //     if (!matrix[x][z]) {
    //       matrix[x][z] = y;
    //     }
    //     matrix[x][z] = Math.max(y, matrix[x][z]);
    //   }
    //   for (const x = 0; x <= arraySize; ++x) {
    //     if (!matrix[x]) {
    //       const loc = 1;
    //       while (!matrix[(x + loc) % arraySize]) {
    //         loc++;
    //       }
    //       matrix[x] = matrix[(x + loc) % arraySize].slice();
    //       //console.log("missing x", x);
    //     }
    //     for (const z = 0; z <= arraySize; ++z) {
    //       if (!matrix[x][z]) {
    //         const loc = 1;
    //         const newValue;
    //         while (newValue === undefined) {
    //           newValue = matrix[x][(z + loc++) % arraySize];
    //         }
    //         matrix[x][z] = newValue;
    //       }
    //     }
    //   }
    //   const shape = new this.CANNON.Heightfield(matrix, {
    //     elementSize: elementSize
    //   });
    //   //For future reference, needed for body transformation
    //   shape.minY = minY;
    //   return shape;
    // }
    /**
     * 设置某个刚体的父级Actor的`transform`。
     */
    CannonPhysicWorld.prototype.setRootTransform = function (component) {
        var transform = component.getOwner().transform;
        var _a = component.rigidBody, position = _a.position, quaternion = _a.quaternion;
        transform.setPosition(position.x, position.y, position.z);
        transform.setQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
    };
    /**
     * 设置某个刚体的`transform`。
     */
    CannonPhysicWorld.prototype.setRigidBodyTransform = function (component, newPosition, newRotation, 
    // only for sphere, box, cylinder
    newScale) {
        this.setBodyTransform(component.rigidBody, newPosition, newRotation, newScale);
    };
    CannonPhysicWorld.prototype.setBodyTransform = function (body, newPosition, newRotation, newScale) {
        var _this = this;
        if (newPosition) {
            body.position.copy(newPosition);
        }
        if (newRotation) {
            body.quaternion.copy(newRotation);
        }
        if (newScale && body.shapes) {
            body.shapes.forEach(function (collider, index) {
                _this.setColliderScale(collider.component, body.component, newScale, index);
            });
        }
    };
    CannonPhysicWorld.prototype.setColliderTransform = function (component, 
    // note: position and rotation not working in current time
    newPosition, newRotation, 
    // only for sphere, box, capsule
    newScale) {
        if (!component) {
            return;
        }
        var collider = component.collider;
        var rigidBody = component.getOwner().rigidBody;
        var index = rigidBody.rigidBody.shapes.indexOf(collider);
        if (newScale) {
            this.setColliderScale(component, rigidBody, newScale, index);
        }
        // if want to change qrientation, change the shapeOrientations and rigidBody.updateBoundingRadius
        rigidBody.needUpdateCollider = true;
    };
    CannonPhysicWorld.prototype.setColliderScale = function (component, rigidBodyComp, newScale, index) {
        var collider = component.collider;
        var options = component.initState;
        // todo: better scale for multiple collider
        switch (component.type) {
            case exports.EColliderType.Box:
                collider.halfExtents.set(options.size[0] / 2 * newScale.x, options.size[1] / 2 * newScale.y, options.size[2] / 2 * newScale.z);
                break;
            case exports.EColliderType.Sphere:
                collider.radius = options.radius * newScale.x;
                break;
        }
        if (component.type !== exports.EColliderType.Sphere) {
            collider.updateConvexPolyhedronRepresentation();
        }
        var offset = options.offset;
        if (offset[0] !== 0 || offset[1] !== 0 || offset[2] !== 0) {
            var off = rigidBodyComp.rigidBody.shapeOffsets[index];
            off.x = offset[0] * newScale.x;
            off.y = offset[1] * newScale.y;
            off.z = -offset[2] * newScale.z;
        }
    };
    /**
     * 强制更新包围盒。
     */
    CannonPhysicWorld.prototype.updateBounding = function (component) {
        component.rigidBody.updateMassProperties();
        component.rigidBody.updateBoundingRadius();
    };
    /**
     * 设置线速度。
     */
    CannonPhysicWorld.prototype.setLinearVelocity = function (component, velocity) {
        component.rigidBody.velocity.copy(velocity);
    };
    /**
     * 设置角速度。
     */
    CannonPhysicWorld.prototype.setAngularVelocity = function (component, velocity) {
        component.rigidBody.angularVelocity.copy(velocity);
    };
    /**
     * 获取线速度。
     */
    CannonPhysicWorld.prototype.getLinearVelocity = function (component) {
        var v = component.rigidBody.velocity;
        if (!v) {
            return null;
        }
        return new Vector3(v.x, v.y, v.z);
    };
    /**
     * 获取角速度。
     */
    CannonPhysicWorld.prototype.getAngularVelocity = function (component) {
        var v = component.rigidBody.angularVelocity;
        if (!v) {
            return null;
        }
        return new Vector3(v.x, v.y, v.z);
    };
    /**
     * 设置重力。
     */
    CannonPhysicWorld.prototype.setBodyMass = function (component, mass) {
        component.rigidBody.mass = mass;
        if (!component.physicStatic && mass > 0) {
            this.setBodyType(component, exports.ERigidBodyType.Dynamic);
        }
        component.rigidBody.updateMassProperties();
    };
    /**
     * 获取重力。
     */
    CannonPhysicWorld.prototype.getBodyMass = function (component) {
        return component.rigidBody.mass;
    };
    /**
     * 设置filterGroup，一个32bits的整数，用于给刚体分组。
     */
    CannonPhysicWorld.prototype.setFilterGroup = function (component, group) {
        component.rigidBody.collisionFilterGroup = group;
    };
    /**
     * 获取filterGroup。
     */
    CannonPhysicWorld.prototype.getFilterGroup = function (component) {
        return component.rigidBody.collisionFilterGroup;
    };
    /**
     * 设置filterMask，一个32bits的整数，用于给分组后的刚体设置碰撞对象范围。
     */
    CannonPhysicWorld.prototype.setFilterMask = function (component, mask) {
        component.rigidBody.collisionFilterMask = mask;
    };
    /**
     * 获取filterMask。
     */
    CannonPhysicWorld.prototype.getFilterMask = function (component) {
        return component.rigidBody.collisionFilterMask;
    };
    /**
     * 设置刚体摩擦力。
     */
    CannonPhysicWorld.prototype.getBodyFriction = function (component) {
        return component.rigidBody.material.friction;
    };
    /**
     * 获取刚体摩擦力。
     */
    CannonPhysicWorld.prototype.setBodyFriction = function (component, friction) {
        component.rigidBody.material.friction = friction;
    };
    /**
     * 获取刚体弹性系数。
     */
    CannonPhysicWorld.prototype.getBodyRestitution = function (component) {
        return component.rigidBody.material.restitution;
    };
    /**
     * 设置刚体弹性系数。
     */
    CannonPhysicWorld.prototype.setBodyRestitution = function (component, restitution) {
        component.rigidBody.material.restitution = restitution;
    };
    /**
     * 使刚体进入睡眠状态，不会触发任何碰撞事件，但可以正确响应拾取操作。
     */
    CannonPhysicWorld.prototype.sleepBody = function (component) {
        component.rigidBody.sleep();
    };
    /**
     * 唤醒刚体。
     */
    CannonPhysicWorld.prototype.wakeUpBody = function (component) {
        component.rigidBody.wakeUp();
    };
    /**
     * 设置刚体类型。
     */
    CannonPhysicWorld.prototype.setBodyType = function (component, type) {
        component.rigidBody.type = type;
    };
    /**
     * 设置碰撞体为触发器。
     */
    CannonPhysicWorld.prototype.setColliderIsTrigger = function (component, isTrigger) {
        component.collider.collisionResponse = !isTrigger;
    };
    /**
     * 获取碰撞体是否为触发器。
     */
    CannonPhysicWorld.prototype.getColliderIsTrigger = function (component) {
        return !component.collider.collisionResponse;
    };
    CannonPhysicWorld = __decorate([
        SClass({ className: 'CannonPhysicWorld', classType: 'PhysicWorld' })
    ], CannonPhysicWorld);
    return CannonPhysicWorld;
}(SObject));

/**
 * 判断一个实例是否为`CylinderColliderComponent`。
 */
function isCylinderColliderComponent(value) {
    return value.isCylinderColliderComponent;
}
/**
 * 圆柱碰撞体，不太常用。
 *
 * @noInheritDoc
 */
var CylinderColliderComponent = /** @class */ (function (_super) {
    __extends(CylinderColliderComponent, _super);
    function CylinderColliderComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isCylinderColliderComponent = true;
        _this._type = exports.EColliderType.Cylinder;
        return _this;
    }
    CylinderColliderComponent.prototype.getDefaultOptions = function () {
        return null;
    };
    CylinderColliderComponent = __decorate([
        SClass({ className: 'CylinderColliderComponent', classType: 'Collider' })
    ], CylinderColliderComponent);
    return CylinderColliderComponent;
}(ColliderComponent));

/**
 * 判断一个实例是否为`PlaneColliderComponent`。
 */
function isPlaneColliderComponent(value) {
    return value.isPlaneColliderComponent;
}
/**
 * 平面碰撞体，不建议使用。
 *
 * @noInheritDoc
 */
var PlaneColliderComponent = /** @class */ (function (_super) {
    __extends(PlaneColliderComponent, _super);
    function PlaneColliderComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isPlaneColliderComponent = true;
        _this._type = exports.EColliderType.Plane;
        return _this;
    }
    PlaneColliderComponent.prototype.getDefaultOptions = function () {
        return null;
    };
    PlaneColliderComponent = __decorate([
        SClass({ className: 'PlaneColliderComponent', classType: 'Collider' })
    ], PlaneColliderComponent);
    return PlaneColliderComponent;
}(ColliderComponent));

/**
 * 判断一个实例是否为`JointComponent`。
 */
function isJointComponent(value) {
    return value.isJointComponent;
}
/**
 * 铰链组件基类。一般不自己使用，而是交由继承的类实现多态。
 *
 * @template IStateTypes 初始化参数类型，一般交由由继承的类定义实现多态。
 * @noInheritDoc
 */
var JointComponent = /** @class */ (function (_super) {
    __extends(JointComponent, _super);
    function JointComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isJointComponent = true;
        _this._type = exports.EJointType.PointToPoint;
        return _this;
    }
    Object.defineProperty(JointComponent.prototype, "joint", {
        /**
         * 获取物理世界的铰链，不要自己操作。
         *
         * @hidden
         */
        get: function () {
            return this._joint;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(JointComponent.prototype, "type", {
        /**
         * 获取铰链类型。
         */
        get: function () {
            return this._type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(JointComponent.prototype, "initState", {
        /**
         * 获取初始化参数实例引用。
         */
        get: function () {
            return this._initState;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 开发环境下，验证可添加性。
     */
    JointComponent.prototype.verifyAdding = function (initState) {
        var rigidBody = this._owner.rigidBody;
        if (!rigidBody || !initState.actor.rigidBody) {
            throw new BreakGuardException(this, 'RigidBodyComponent must be added to self or other actor before adding JointComponent !');
        }
    };
    /**
     * 添加到世界，继承请先`super.onAdd()`。
     */
    JointComponent.prototype.onAdd = function (initState) {
        var rigidBody = this._owner.rigidBody;
        var options = this._initState = initState;
        this._joint = this.getPhysicWorld().createJoint(rigidBody, this, { type: this._type, options: options });
    };
    /**
     * 禁用关节。
     */
    JointComponent.prototype.disable = function () {
        this.getPhysicWorld().disableJoint(this);
    };
    /**
     * 启用关节。
     */
    JointComponent.prototype.enable = function () {
        this.getPhysicWorld().enableJoint(this);
    };
    // public updateEquations() {
    // }
    /**
     * 销毁，继承请先`super.onDestroy()`。
     */
    JointComponent.prototype.onDestroy = function () {
        var _this = this;
        var physicWorld = this.getPhysicWorld();
        setTimeout(function () {
            if (_this._owner && _this._owner.rigidBody) {
                physicWorld.removeJoint(_this._owner.rigidBody, _this);
            }
        }, 0);
    };
    JointComponent = __decorate([
        SClass({ className: 'JointComponent' })
    ], JointComponent);
    return JointComponent;
}(Component));

/**
 * 判断一个实例是否为`PointToPointJointComponent`。
 */
function isPointToPointJointComponent(value) {
    return value.isPointToPointJointComponent;
}
/**
 * 点对点约束关节。
 *
 * @noInheritDoc
 */
var PointToPointJointComponent = /** @class */ (function (_super) {
    __extends(PointToPointJointComponent, _super);
    function PointToPointJointComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isPointToPointJointComponent = true;
        _this._type = exports.EJointType.PointToPoint;
        return _this;
    }
    PointToPointJointComponent = __decorate([
        SClass({ className: 'PointToPointJointComponent', classType: 'Collider' })
    ], PointToPointJointComponent);
    return PointToPointJointComponent;
}(JointComponent));

/**
 * 判断一个实例是否为`DistanceJointComponent`。
 */
function isDistanceJointComponent(value) {
    return value.isDistanceJointComponent;
}
/**
 * 距离约束关节。
 *
 * @noInheritDoc
 */
var DistanceJointComponent = /** @class */ (function (_super) {
    __extends(DistanceJointComponent, _super);
    function DistanceJointComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isDistanceJointComponent = true;
        _this._type = exports.EJointType.Distance;
        return _this;
    }
    DistanceJointComponent = __decorate([
        SClass({ className: 'DistanceJointComponent', classType: 'Collider' })
    ], DistanceJointComponent);
    return DistanceJointComponent;
}(JointComponent));

/**
 * 判断一个实例是否为`HingeJointComponent`。
 */
function isHingeJointComponent(value) {
    return value.isHingeJointComponent;
}
/**
 * 铰链关节。
 *
 * @noInheritDoc
 */
var HingeJointComponent = /** @class */ (function (_super) {
    __extends(HingeJointComponent, _super);
    function HingeJointComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isHingeJointComponent = true;
        _this._type = exports.EJointType.Hinge;
        return _this;
    }
    HingeJointComponent = __decorate([
        SClass({ className: 'HingeJointComponent', classType: 'Collider' })
    ], HingeJointComponent);
    return HingeJointComponent;
}(JointComponent));

/**
 * 判断一个实例是否为`LockJointComponent`。
 */
function isLockJointComponent(value) {
    return value.isLockJointComponent;
}
/**
 * 锁定约束关节。
 *
 * @noInheritDoc
 */
var LockJointComponent = /** @class */ (function (_super) {
    __extends(LockJointComponent, _super);
    function LockJointComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isLockJointComponent = true;
        _this._type = exports.EJointType.Lock;
        return _this;
    }
    LockJointComponent = __decorate([
        SClass({ className: 'LockJointComponent', classType: 'Collider' })
    ], LockJointComponent);
    return LockJointComponent;
}(JointComponent));

/**
 * 判断一个实例是否为`SpringJointComponent`。
 */
function isSpringJointComponent(value) {
    return value.isSpringJointComponent;
}
/**
 * 弹簧关节。
 *
 * @noInheritDoc
 */
var SpringJointComponent = /** @class */ (function (_super) {
    __extends(SpringJointComponent, _super);
    function SpringJointComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isSpringJointComponent = true;
        _this._type = exports.EJointType.Spring;
        /**
         * **不要自己使用！**应用弹簧力。
         */
        _this.applyForce = function () {
            _this._joint.applyForce;
        };
        return _this;
    }
    SpringJointComponent = __decorate([
        SClass({ className: 'SpringJointComponent', classType: 'Collider' })
    ], SpringJointComponent);
    return SpringJointComponent;
}(JointComponent));

/**
 * 判断一个实例是否为`PhysicPicker`。
 */
function isPhysicPicker(value) {
    return value.isPhysicPicker;
}
/**
 * 物理拾取器，用于拾取已经挂载了刚体和碰撞体的Actor。
 *
 * @noInheritDoc
 */
var PhysicPicker = /** @class */ (function (_super) {
    __extends(PhysicPicker, _super);
    function PhysicPicker(game) {
        var _this = _super.call(this) || this;
        _this.isPhysicPicker = true;
        _this._active = false;
        _this._tmpTo = new Vector3();
        _this._tmpFrom = new Vector3();
        _this.handleMouse = function (event) {
            var _a = _this._game.bound, left = _a.left, top = _a.top;
            _this._tmpX = event.clientX - left;
            _this._tmpY = event.clientY - top;
            _this.pick(_this._tmpX, _this._tmpY);
        };
        _this.handleTouch = function (event) {
            var touch = event.changedTouches[0];
            if (!touch) {
                return;
            }
            var _a = _this._game.bound, left = _a.left, top = _a.top;
            _this._tmpX = touch.clientX - left;
            _this._tmpY = touch.clientY - top;
            _this.pick(_this._tmpX, _this._tmpY);
        };
        _this.onPick = function (results) {
            if (_this._options.filter) {
                results = _this._options.filter(results);
            }
            results.forEach(function (result) {
                result.rigidBody.handlePick(result);
            });
        };
        _this._game = game;
        return _this;
    }
    Object.defineProperty(PhysicPicker.prototype, "options", {
        /**
         * 获取当前配置，你可以随时修改它。
         */
        get: function () {
            return this._options;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * 开启拾取功能，你可以通过选项来设定不同模式。
     */
    PhysicPicker.prototype.enablePicking = function (options) {
        if (!this._game.world.physicWorld) {
            throw new UnmetRequireException(this, 'Physic world is required for enable physic picking !');
        }
        if (this._active) {
            return;
        }
        this._options = options || {};
        this._options.type = this._options.type || 'down';
        this._active = true;
        if (this._options.type === 'up') {
            this._game.hid.add('MouseUp', this.handleMouse);
            this._game.hid.add('TouchEnd', this.handleTouch);
        }
        else if (this._options.type === 'down') {
            this._game.hid.add('MouseDown', this.handleMouse);
            this._game.hid.add('TouchStart', this.handleTouch);
        }
    };
    /**
     * 关闭拾取功能。
     */
    PhysicPicker.prototype.disablePicking = function () {
        if (!this._game.world.physicWorld) {
            throw new UnmetRequireException(this, 'Physic world is required for enable physic picking !');
        }
        if (this._options.type === 'up') {
            this._game.hid.remove('MouseUp', this.handleMouse);
            this._game.hid.remove('TouchEnd', this.handleTouch);
        }
        else if (this._options.type === 'down') {
            this._game.hid.remove('MouseDown', this.handleMouse);
            this._game.hid.remove('TouchStart', this.handleTouch);
        }
    };
    /**
     * 通过屏幕空间的`x`和`y`触发一次拾取。
     * 这通常用于开发者想自定义拾取模式的时候，即`options.type === 'custom'`。
     */
    PhysicPicker.prototype.pick = function (x, y) {
        var _a = this._game, screenWidth = _a.screenWidth, screenHeight = _a.screenHeight;
        var physicWorld = this._game.world.physicWorld;
        var camera = this._game.world.mainCamera;
        if (!camera) {
            Debug.warn('Can not pick, world has no camera now !');
            return;
        }
        camera.generateRay(x, y, screenWidth, screenHeight, this._tmpFrom, this._tmpTo, this._options.rayLength);
        physicWorld.pick(this._tmpFrom, this._tmpTo, this.onPick, this._options);
    };
    PhysicPicker = __decorate([
        SClass({ className: 'PhysicPicker' })
    ], PhysicPicker);
    return PhysicPicker;
}(SObject));

/**
 * 通过筛选函数`filter`查找`parent`下的首个`actor`。
 *
 * @param filter 筛选函数，若返回`true`。
 */
function findActorByFilter(parent, filter) {
    var result = null;
    iterateActors(parent, function (actor) {
        if (filter(actor)) {
            result = actor;
            return true;
        }
        return false;
    });
    return result;
}
/**
 * 通过删选函数`filter`查找`parent`下的所有`actor`。
 *
 * @param filter 筛选函数。
 * @param stopFinding 停止测试函数，若返回`true`，则立即查找，用于性能优化。
 */
function findActorsByFilter(parent, filter, stopFinding) {
    var result = [];
    iterateActors(parent, function (actor) {
        if (filter(actor)) {
            result.push(actor);
        }
        if (stopFinding && stopFinding(actor, result)) {
            return true;
        }
    });
    return result;
}
/**
 * 通过名字`name`查找`parent`下的首个`actor`。
 */
function findActorByName(parent, name) {
    return findActorByFilter(parent, function (actor) { return actor.name.equalsTo(name); });
}
/**
 * 通过名字路径`namePath`查找`parent`下的首个`actor`。
 */
function findActorByNamePath(p, namePath) {
    var length = namePath.length;
    var parent;
    if (isGame(p)) {
        parent = p.actors.findByName(namePath[0]);
    }
    else if (isWorld(p)) {
        parent = p.actors.findByName(namePath[0]);
    }
    else {
        parent = p;
    }
    if (!parent) {
        return null;
    }
    if (length === 1) {
        return parent;
    }
    namePath.splice(0, 1);
    length -= 1;
    if (length === 0) {
        return null;
    }
    var current = parent;
    var name;
    for (var index = 0; index < length; index += 1) {
        name = namePath[index];
        bfs(current, function (actor) {
            if (actor.name.equalsTo(name)) {
                current = actor;
                return true;
            }
            current = null;
            return false;
        });
        if (!current) {
            return null;
        }
    }
    if (current === parent) {
        return null;
    }
    return current;
}
/**
 * 通过名称`name`查找`parent`下的所有`actor`。
 *
 * @param stopFinding 停止测试函数，若返回`true`，则立即查找，用于性能优化。
 */
function findActorsByName(parent, name, stopFinding) {
    return findActorsByFilter(parent, function (actor) { return actor.name.equalsTo(name); }, stopFinding);
}
/**
 * 通过标签`tag`查找`parent`下的首个`actor`。
 */
function findActorByTag(parent, tag) {
    return findActorByFilter(parent, function (actor) { return actor.tag.equalsTo(tag); });
}
/**
 * 通过标签`tag`查找`parent`下的所有`actor`。
 *
 * @param stopFinding 停止测试函数，若返回`true`，则立即查找，用于性能优化。
 */
function findActorsByTag(parent, tag, stopFinding) {
    return findActorsByFilter(parent, function (actor) { return actor.tag.equalsTo(tag); }, stopFinding);
}
/**
 * 通过位移ID`uuid`查找`parent`下的首个`actor`。
 */
function findActorByUUID(parent, uuid) {
    return findActorByFilter(parent, function (actor) { return actor.uuid === uuid; });
}
/**
 * 通过类的类型`className`查找`parent`下的首个`actor`。
 */
function findActorByClassName(parent, className) {
    return findActorByFilter(parent, function (actor) { return actor.className.equalsTo(className); });
}
/**
 * 通过类的类型`className`查找`parent`下的所有`actor`。
 *
 * @param stopFinding 停止测试函数，若返回`true`，则立即查找，用于性能优化。
 */
function findActorsByClassName(parent, className, stopFinding) {
    return findActorsByFilter(parent, function (actor) { return actor.className.equalsTo(className); }, stopFinding);
}
/**
 * 通过类型`Class`查找`parent`下的首个`actor`。
 */
function findActorByClass(parent, Class) {
    return findActorByFilter(parent, function (actor) { return actor.className.equalsTo(Class.CLASS_NAME); });
}
/**
 * 通过类型`Class`查找`parent`下的所有`actor`。
 *
 * @param stopFinding 停止测试函数，若返回`true`，则立即查找，用于性能优化。
 */
function findActorsByClass(parent, Class, stopFinding) {
    return findActorsByFilter(parent, function (actor) { return actor.className.equalsTo(Class.CLASS_NAME); }, stopFinding);
}

/**
 * @File   : ContextSupports.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 12/10/2019, 1:13:06 PM
 * @Description:
 */
var ContextSupportsClass = /** @class */ (function () {
    function ContextSupportsClass() {
    }
    Object.defineProperty(ContextSupportsClass.prototype, "isWebGLSupport", {
        get: function () {
            return Hilo3d$2.WebGLSupport.get();
        },
        enumerable: false,
        configurable: true
    });
    return ContextSupportsClass;
}());
var ContextSupports = new ContextSupportsClass();

/**
 * @File   : index.ts
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 2018-7-28 13:54:12
 * @Description:
 */
var version = '1.5.10';
var author = 'Tianyu Dai <dtysky@outlook.com>';
/* tslint:disable-line */
console.log("Sein.js verison: " + version);
if (typeof window !== 'undefined' && !window['Sein']) {
    window['Sein'] = module.exports;
}

exports.AIControllerActor = AIControllerActor;
exports.Actor = Actor;
exports.AliAMCExtension = AliAMCExtension;
exports.AmbientLightActor = AmbientLightActor;
exports.AmbientLightComponent = AmbientLightComponent;
exports.Animation = Animation;
exports.AnimatorComponent = AnimatorComponent;
exports.AtlasLoader = AtlasLoader;
exports.AtlasManager = AtlasManager;
exports.BSPBoxActor = BSPBoxActor;
exports.BSPBoxComponent = BSPBoxComponent;
exports.BSPComponent = BSPComponent;
exports.BSPCylinderActor = BSPCylinderActor;
exports.BSPCylinderComponent = BSPCylinderComponent;
exports.BSPMorphActor = BSPMorphActor;
exports.BSPMorphComponent = BSPMorphComponent;
exports.BSPPlaneActor = BSPPlaneActor;
exports.BSPPlaneComponent = BSPPlaneComponent;
exports.BSPSphereActor = BSPSphereActor;
exports.BSPSphereComponent = BSPSphereComponent;
exports.BaseException = BaseException;
exports.BasicMaterial = BasicMaterial;
exports.BoxColliderComponent = BoxColliderComponent;
exports.BoxGeometry = BoxGeometry;
exports.BreakGuardException = BreakGuardException;
exports.Buffer = Buffer;
exports.CameraComponent = CameraComponent;
exports.CannonPhysicWorld = CannonPhysicWorld;
exports.ChildActorComponent = ChildActorComponent;
exports.ColliderComponent = ColliderComponent;
exports.Color = Color;
exports.CombineAnimation = CombineAnimation;
exports.Component = Component;
exports.Constants = Constants;
exports.ContextMenuTrigger = ContextMenuTrigger;
exports.ContextSupports = ContextSupports;
exports.ControllerActor = ControllerActor;
exports.CubeTexture = CubeTexture;
exports.CubeTextureLoader = CubeTextureLoader;
exports.CylinderColliderComponent = CylinderColliderComponent;
exports.CylinderGeometry = CylinderGeometry;
exports.DEG2RAD = DEG2RAD;
exports.DataTexture = DataTexture;
exports.Debug = Debug;
exports.DirectionalLightActor = DirectionalLightActor;
exports.DirectionalLightComponent = DirectionalLightComponent;
exports.DistanceJointComponent = DistanceJointComponent;
exports.DynamicTexture = DynamicTexture;
exports.Engine = Engine;
exports.Euler = Euler;
exports.EventManager = EventManager;
exports.EventTrigger = EventTrigger;
exports.FSMComponent = FSMComponent;
exports.FSMState = FSMState;
exports.Fog = Fog;
exports.FrameBuffer = FrameBuffer;
exports.GLCapabilities = GLCapabilities;
exports.GLExtensions = GLExtensions;
exports.Game = Game;
exports.GameModeActor = GameModeActor;
exports.Geometry = Geometry;
exports.GeometryData = GeometryData;
exports.GeometryMaterial = GeometryMaterial;
exports.GlTFLoader = GlTFLoader;
exports.HTTP = HTTP;
exports.HingeJointComponent = HingeJointComponent;
exports.ImageLoader = ImageLoader;
exports.InfoActor = InfoActor;
exports.JointComponent = JointComponent;
exports.KeyDownTrigger = KeyDownTrigger;
exports.KeyPressTrigger = KeyPressTrigger;
exports.KeyUpTrigger = KeyUpTrigger;
exports.Layers = Layers;
exports.LazyTexture = LazyTexture;
exports.Level = Level;
exports.LevelScriptActor = LevelScriptActor;
exports.LightComponent = LightComponent;
exports.LockJointComponent = LockJointComponent;
exports.Material = Material;
exports.Matrix3 = Matrix3;
exports.Matrix4 = Matrix4;
exports.MemberConflictException = MemberConflictException;
exports.Mesh = Mesh;
exports.MetaSClasses = MetaSClasses;
exports.MetaSMaterials = MetaSMaterials;
exports.MissingMemberException = MissingMemberException;
exports.ModelAnimation = ModelAnimation;
exports.MorphGeometry = MorphGeometry;
exports.MouseClickTrigger = MouseClickTrigger;
exports.MouseDownTrigger = MouseDownTrigger;
exports.MouseEnterTrigger = MouseEnterTrigger;
exports.MouseLeaveTrigger = MouseLeaveTrigger;
exports.MouseMoveTrigger = MouseMoveTrigger;
exports.MouseOutTrigger = MouseOutTrigger;
exports.MouseOverTrigger = MouseOverTrigger;
exports.MouseUpTrigger = MouseUpTrigger;
exports.MouseWheelTrigger = MouseWheelTrigger;
exports.Observable = Observable;
exports.OrthographicCameraActor = OrthographicCameraActor;
exports.OrthographicCameraComponent = OrthographicCameraComponent;
exports.PBRMaterial = PBRMaterial;
exports.PerspectiveCameraActor = PerspectiveCameraActor;
exports.PerspectiveCameraComponent = PerspectiveCameraComponent;
exports.PhysicPicker = PhysicPicker;
exports.PlaneColliderComponent = PlaneColliderComponent;
exports.PlaneGeometry = PlaneGeometry;
exports.Player = Player;
exports.PlayerControllerActor = PlayerControllerActor;
exports.PlayerStateActor = PlayerStateActor;
exports.PointLightActor = PointLightActor;
exports.PointLightComponent = PointLightComponent;
exports.PointToPointJointComponent = PointToPointJointComponent;
exports.PrimitiveComponent = PrimitiveComponent;
exports.Program = Program;
exports.Quaternion = Quaternion;
exports.RAD2DEG = RAD2DEG;
exports.RawShaderMaterial = RawShaderMaterial;
exports.RenderSystemActor = RenderSystemActor;
exports.ResourceLoadException = ResourceLoadException;
exports.ResourceLoader = ResourceLoader;
exports.ResourceManager = ResourceManager;
exports.RigidBodyComponent = RigidBodyComponent;
exports.SArray = SArray;
exports.SClass = SClass;
exports.SIterable = SIterable;
exports.SMap = SMap;
exports.SMaterial = SMaterial;
exports.SName = SName;
exports.SObject = SObject;
exports.SSet = SSet;
exports.SceneActor = SceneActor;
exports.SceneComponent = SceneComponent;
exports.Semantic = Semantic;
exports.Shader = Shader;
exports.ShaderChunk = ShaderChunk;
exports.ShaderMaterial = ShaderMaterial;
exports.SkeletalMesh = SkeletalMesh;
exports.SkeletalMeshActor = SkeletalMeshActor;
exports.SkeletalMeshComponent = SkeletalMeshComponent;
exports.Skeleton = Skeleton;
exports.SkyboxMaterial = SkyboxMaterial;
exports.SphereColliderComponent = SphereColliderComponent;
exports.SphereGeometry = SphereGeometry;
exports.Spherical = Spherical;
exports.SphericalHarmonics3 = SphericalHarmonics3;
exports.SpotLightActor = SpotLightActor;
exports.SpotLightComponent = SpotLightComponent;
exports.SpringJointComponent = SpringJointComponent;
exports.SpriteActor = SpriteActor;
exports.SpriteAnimation = SpriteAnimation;
exports.SpriteComponent = SpriteComponent;
exports.StateActor = StateActor;
exports.StaticMeshActor = StaticMeshActor;
exports.StaticMeshComponent = StaticMeshComponent;
exports.SystemActor = SystemActor;
exports.Texture = Texture;
exports.TextureLoader = TextureLoader;
exports.Ticker = Ticker;
exports.TimerActor = TimerActor;
exports.TouchCancelTrigger = TouchCancelTrigger;
exports.TouchEndTrigger = TouchEndTrigger;
exports.TouchMoveTrigger = TouchMoveTrigger;
exports.TouchStartTrigger = TouchStartTrigger;
exports.Tween = Tween;
exports.TweenAnimation = TweenAnimation;
exports.TypeConflictException = TypeConflictException;
exports.UnmetRequireException = UnmetRequireException;
exports.Vector2 = Vector2;
exports.Vector3 = Vector3;
exports.Vector4 = Vector4;
exports.VertexArrayObject = VertexArrayObject;
exports.WheelTrigger = WheelTrigger;
exports.WindowResizeTrigger = WindowResizeTrigger;
exports.World = World;
exports.author = author;
exports.bfs = bfs;
exports.clamp = clamp;
exports.degToRad = degToRad;
exports.deprecated = deprecated;
exports.findActorByClass = findActorByClass;
exports.findActorByClassName = findActorByClassName;
exports.findActorByFilter = findActorByFilter;
exports.findActorByName = findActorByName;
exports.findActorByNamePath = findActorByNamePath;
exports.findActorByTag = findActorByTag;
exports.findActorByUUID = findActorByUUID;
exports.findActorsByClass = findActorsByClass;
exports.findActorsByClassName = findActorsByClassName;
exports.findActorsByFilter = findActorsByFilter;
exports.findActorsByName = findActorsByName;
exports.findActorsByTag = findActorsByTag;
exports.inspectable = inspectable;
exports.isAIControllerActor = isAIControllerActor;
exports.isActor = isActor;
exports.isAmbientLightActor = isAmbientLightActor;
exports.isAmbientLightComponent = isAmbientLightComponent;
exports.isAnimation = isAnimation;
exports.isAnimatorComponent = isAnimatorComponent;
exports.isAtlasLoader = isAtlasLoader;
exports.isAtlasManager = isAtlasManager;
exports.isBSPActor = isBSPActor;
exports.isBSPBoxActor = isBSPBoxActor;
exports.isBSPBoxComponent = isBSPBoxComponent;
exports.isBSPComponent = isBSPComponent;
exports.isBSPCylinderActor = isBSPCylinderActor;
exports.isBSPCylinderComponent = isBSPCylinderComponent;
exports.isBSPMorphActor = isBSPMorphActor;
exports.isBSPMorphComponent = isBSPMorphComponent;
exports.isBSPPlaneActor = isBSPPlaneActor;
exports.isBSPPlaneComponent = isBSPPlaneComponent;
exports.isBSPSphereActor = isBSPSphereActor;
exports.isBSPSphereComponent = isBSPSphereComponent;
exports.isBaseException = isBaseException;
exports.isBasicMaterial = isBasicMaterial;
exports.isBoxColliderComponent = isBoxColliderComponent;
exports.isBoxGeometry = isBoxGeometry;
exports.isBreakGuardException = isBreakGuardException;
exports.isCameraActor = isCameraActor;
exports.isColliderComponent = isColliderComponent;
exports.isColor = isColor;
exports.isCombineAnimation = isCombineAnimation;
exports.isComponent = isComponent;
exports.isControllerActor = isControllerActor;
exports.isCubeTexture = isCubeTexture;
exports.isCubeTextureLoader = isCubeTextureLoader;
exports.isCylinderColliderComponent = isCylinderColliderComponent;
exports.isCylinderGeometry = isCylinderGeometry;
exports.isDataTexture = isDataTexture;
exports.isDirectionalLightActor = isDirectionalLightActor;
exports.isDirectionalLightComponent = isDirectionalLightComponent;
exports.isDistanceJointComponent = isDistanceJointComponent;
exports.isDynamicTexture = isDynamicTexture;
exports.isEngine = isEngine;
exports.isEuler = isEuler;
exports.isEventManager = isEventManager;
exports.isEventTrigger = isEventTrigger;
exports.isFSMComponent = isFSMComponent;
exports.isFSMState = isFSMState;
exports.isFog = isFog;
exports.isFrameBuffer = isFrameBuffer;
exports.isGame = isGame;
exports.isGameModeActor = isGameModeActor;
exports.isGeometry = isGeometry;
exports.isGeometryData = isGeometryData;
exports.isGeometryMaterial = isGeometryMaterial;
exports.isGlTFLoader = isGlTFLoader;
exports.isHingeJointComponent = isHingeJointComponent;
exports.isImageLoader = isImageLoader;
exports.isInfoActor = isInfoActor;
exports.isJointComponent = isJointComponent;
exports.isLayers = isLayers;
exports.isLazyTexture = isLazyTexture;
exports.isLevel = isLevel;
exports.isLevelScriptActor = isLevelScriptActor;
exports.isLightActor = isLightActor;
exports.isLightComponent = isLightComponent;
exports.isLockJointComponent = isLockJointComponent;
exports.isMaterial = isMaterial;
exports.isMatrix3 = isMatrix3;
exports.isMatrix4 = isMatrix4;
exports.isMemberConflictException = isMemberConflictException;
exports.isMesh = isMesh;
exports.isMissingMemberException = isMissingMemberException;
exports.isModelAnimation = isModelAnimation;
exports.isMorphGeometry = isMorphGeometry;
exports.isObservable = isObservable;
exports.isOrthographicCameraActor = isOrthographicCameraActor;
exports.isOrthographicCameraComponent = isOrthographicCameraComponent;
exports.isPBRMaterial = isPBRMaterial;
exports.isPerspectiveCameraActor = isPerspectiveCameraActor;
exports.isPerspectiveCameraComponent = isPerspectiveCameraComponent;
exports.isPhysicPicker = isPhysicPicker;
exports.isPlaneColliderComponent = isPlaneColliderComponent;
exports.isPlaneGeometry = isPlaneGeometry;
exports.isPlayer = isPlayer;
exports.isPlayerControllerActor = isPlayerControllerActor;
exports.isPlayerStateActor = isPlayerStateActor;
exports.isPointLightActor = isPointLightActor;
exports.isPointLightComponent = isPointLightComponent;
exports.isPointToPointJointComponent = isPointToPointJointComponent;
exports.isPowerOfTwo = isPowerOfTwo;
exports.isPrimitiveActor = isPrimitiveActor;
exports.isPrimitiveComponent = isPrimitiveComponent;
exports.isQuaternion = isQuaternion;
exports.isRawShaderMaterial = isRawShaderMaterial;
exports.isRenderSystemActor = isRenderSystemActor;
exports.isResourceLoadException = isResourceLoadException;
exports.isResourceLoader = isResourceLoader;
exports.isResourceManager = isResourceManager;
exports.isRigidBodyComponent = isRigidBodyComponent;
exports.isSName = isSName;
exports.isSObject = isSObject;
exports.isSceneActor = isSceneActor$1;
exports.isSceneComponent = isSceneComponent;
exports.isShaderChunk = isShaderChunk;
exports.isShaderMaterial = isShaderMaterial;
exports.isSkeletalMesh = isSkeletalMesh;
exports.isSkeletalMeshActor = isSkeletalMeshActor;
exports.isSkeletalMeshComponent = isSkeletalMeshComponent;
exports.isSkyboxMaterial = isSkyboxMaterial;
exports.isSphereColliderComponent = isSphereColliderComponent;
exports.isSphereGeometry = isSphereGeometry;
exports.isSpherical = isSpherical;
exports.isSphericalHarmonics3 = isSphericalHarmonics3;
exports.isSpotLightActor = isSpotLightActor;
exports.isSpotLightComponent = isSpotLightComponent;
exports.isSpringJointComponent = isSpringJointComponent;
exports.isSpriteActor = isSpriteActor;
exports.isSpriteAnimation = isSpriteAnimation;
exports.isSpriteComponent = isSpriteComponent;
exports.isStateActor = isStateActor;
exports.isStaticMeshActor = isStaticMeshActor;
exports.isStaticMeshComponent = isStaticMeshComponent;
exports.isSystemActor = isSystemActor;
exports.isTexture = isTexture;
exports.isTextureLoader = isTextureLoader;
exports.isTicker = isTicker;
exports.isTimerActor = isTimerActor;
exports.isTweenAnimation = isTweenAnimation;
exports.isTypeConflictException = isTypeConflictException;
exports.isUnmetRequireException = isUnmetRequireException;
exports.isVector2 = isVector2;
exports.isVector3 = isVector3;
exports.isVector4 = isVector4;
exports.isWorld = isWorld;
exports.iterateActors = iterateActors;
exports.iterateActorsByClass = iterateActorsByClass;
exports.iterateActorsByClassType = iterateActorsByClassType;
exports.iterateActorsByName = iterateActorsByName;
exports.iterateActorsByTag = iterateActorsByTag;
exports.nearestPowerOfTwo = nearestPowerOfTwo;
exports.nextPowerOfTwo = nextPowerOfTwo;
exports.radToDeg = radToDeg;
exports.serialize = serialize;
exports.shaderChunks = shaderChunks;
exports.throwException = throwException;
exports.version = version;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../_process@0.11.10@process/browser.js */ "./node_modules/_process@0.11.10@process/browser.js"), __webpack_require__(/*! ./../../_webpack@4.43.0@webpack/buildin/global.js */ "./node_modules/_webpack@4.43.0@webpack/buildin/global.js")))

/***/ }),

/***/ "./webpack-platform-plugin/alias/wx-mini-game.js":
/*!*******************************************************!*\
  !*** ./webpack-platform-plugin/alias/wx-mini-game.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @File   : wx-mini-game.js
 * @Author : dtysky (dtysky@outlook.com)
 * @Date   : 6/4/2020, 1:20:39 PM
 * @Description:
 */
const Sein = __webpack_require__(/*! seinjs-orig */ "./node_modules/_seinjs@1.5.10@seinjs/lib/seinjs.js");

wx.Sein = Sein;

module.exports = wx.Sein;


/***/ })

}]);